function gen_sil_test_frame(subsystem_name)

	% construct the path to the siltest directory for copying source files.
	siltestdir = which('gen_sil_test_frame');
	siltestdir = strrep(siltestdir,'\gen_sil_test_frame.m','');
	siltestdir = strrep(siltestdir,'\','/');
    
    tlSystems = get_tlsubsystems(subsystem_name);
    if isempty(tlSystems)
        s = regexprep(subsystem_name,'\n',' ');
        fprintf('Error: The subsystem "%s" contains no TargetLink subsystems.\n',s);
        return;
    elseif length(tlSystems) > 1
        modelname=tlSystems{1}(1:findstr(tlSystems{1},'/')-1);
        fprintf(['Error: The model "%s" contains more than one TargetLink subsystem.\n'...
            '       This script is only configured for one subsystem\n'],modelname);
        return;
    end
    
    info=tl_get_subsystem_info(tlSystems{1});
    modelname=info.model;
    tlsubsystem=info.tlSubsystemName;
    
	logopt_str_list={'log according to block data',...
		'log signal histories',...
		'log min/max-values',...
		'do not log anything'};
    
	logopt_n=tl_get(modelname,'logopt.globalloggingmode');
	logopt_str=logopt_str_list{logopt_n};

	if ~strcmp(logopt_str,'do not log anything')

		% Note: This is very important because we manipulate the LOG_VAR
		% macros so we first require that there is no logging and then 
		% we build it in ourselves.

		errordlg(['Incorrect Simulation frame option:' 10 10 ...
			'    Global logging option: ' logopt_str 10 10 ...
			'It must be set to ''do not log anything'' for SiL testing.'],...
			'dlgname','on')

	else

		cleancode_opt = tl_get(modelname,'codeopt.cleancode');
		if cleancode_opt
			tl_set(modelname,'codeopt.cleancode',0);
		end

		% change it to 'log signal histories'
		tl_set(modelname,'logopt.globalloggingmode',2);
		% and generate the code with LOG_VAR macros
		tl_generate_code('SimMode','TL_CODE_HOST');
        if ds_error_check, return; end
        
		filenames = get_generated_files(tlsubsystem);
        
		% move each generated file to a .siltest file.
		for i=1:length(filenames),
			evalin('base',['!move ' filenames{i} ' ' filenames{i} '.siltest']);
			fprintf('!move %s %s.siltest\n', filenames{i}, filenames{i});
		end
		% Also move the simulation frame file.
		evalin('base',['!move TLSim\' tlsubsystem '_frm.h TLSim\' tlsubsystem '_frm.h.siltest']);
		fprintf('!move TLSim\\%s_frm.h TLSim\\%s_frm.h.siltest\n', tlsubsystem, tlsubsystem);

		% Create the testFrame definitions in the silframe source files.
		ConstructTestFrameFromDD(tlsubsystem)

		% then change back to the original options
		tl_set(modelname,'logopt.globalloggingmode',logopt_n);

		% generate the code with original options
		tl_generate_code('SimMode','TL_CODE_HOST');
        if ds_error_check, return; end

		% move each generated file back from a .siltest file.
		for i=1:length(filenames),
			evalin('base',['!move ' filenames{i} '.siltest ' filenames{i}]);
			fprintf('!move %s.siltest %s\n', filenames{i}, filenames{i});
		end

		% Move the simulation frame file back.
		evalin('base',['!move TLSim\' tlsubsystem '_frm.h.siltest TLSim\' tlsubsystem '_frm.h']);
		fprintf('!move TLSim\\%s_frm.h.siltest TLSim\\%s_frm.h\n', tlsubsystem, tlsubsystem);
        
		copyfile([siltestdir '/custom_src/siltest_sf_frame.c'],'TLSim');
		copyfile([siltestdir '/custom_src/siltest_pcf_frame.c'],'TLSim');
		copyfile([siltestdir '/custom_src/siltest_common.h'],'TLSim');

        add_modelname_define(['TLSim/' tlsubsystem '_sf.c'], modelname);
		include_file_at_end_of_source(['TLSim/' tlsubsystem '_sf.c'], 'siltest_sf_frame.c');
		include_file_at_end_of_source(['TLSim/' tlsubsystem '_pcf.c'], 'siltest_pcf_frame.c');

		tl_compile_host;
        if ds_error_check, return; end

		% rebuild the sfunction using the modified source files in the siltest directory.
		build_sil_sf(tlsubsystem,modelname,siltestdir);

		% set the clean code option back to what it was at the start.
		if cleancode_opt
			tl_set(modelname,'codeopt.cleancode',1);
		end

		% set the simulation mode to Software in the Loop.
		tl_set_sim_mode('SimMode','TL_CODE_HOST');
	end

%-------------------------------------------------------------------------------
% Function get_generated_files
%
% Get the list of generated files from the host pc build.
%-------------------------------------------------------------------------------
function [filenames] = get_generated_files(tlsubsystem)

    filenames=[];
    
   % Get the list of all modules which have been generated by TL in current subsystem
   hSubsystem = dsdd('GetAttribute', ['//DD0/Subsystems/' tlsubsystem], 'hDDObject');
   hModuleList = dsdd('GetChildren', hSubsystem, 'ObjectKind', 'Module');
   iFilename=1;
   for hModule = hModuleList,
	  [hModuleInfo, error] = dsdd('GetModuleInfo', hModule);
	  if error,
		 continue;
	  end
	  % NOTE: find function cannot be used for module, since dependencies object
	  % are also of the FileInfo kind
	  hFileInfoList = dsdd('Find', hModuleInfo, 'ObjectKind', 'FileInfo',...
		 'Property', {'Name', 'FileType', 'Value', 'GeneratedFile'});
	  for hFileInfo = hFileInfoList,
		 [moduleName, error] = dsdd('GetFileName', hFileInfo);
		 if ~error,
			% delete file only if it resides in current directory
			% required by UlrichK, 2003-10-24

			[shortName,relativeName] = ds_find_file(moduleName);

			if strcmp(shortName, relativeName),
				filenames{iFilename} = moduleName;
				iFilename = iFilename + 1;
			end
		 end
	  end
   end

%-------------------------------------------------------------------------------
% Function include_file_at_end_of_source
%
% Open a source file and at the end add a #include to 'include_filename'
%-------------------------------------------------------------------------------
function include_file_at_end_of_source(src_filename, include_filename)

	if exist(src_filename) == 2

		[fid,msg] = fopen(src_filename,'rt');
		fileContent = setstr(fread(fid))';
		fclose(fid);

		[fid,msg] = fopen(src_filename,'wt');
		fwrite(fid,fileContent);
		fprintf(fid, ['\n'...
			'/* include the custom sil test frame. */\n'...
			'#include "' include_filename '"\n'...
			]);
		fclose(fid); 
	else
		ds_error_msg([src_filename ' doesn''t exist.']);
	end
    

%-------------------------------------------------------------------------------
% Function add_modelname_define(src_filename, modelname)
%
% Open the source file and a define for the model name
%-------------------------------------------------------------------------------
function add_modelname_define(src_filename, modelname)

	if exist(src_filename) == 2
		[fid,msg] = fopen(src_filename,'rt');
		fileContent = setstr(fread(fid))';
		fclose(fid);
		[fid,msg] = fopen(src_filename,'wt');
		fwrite(fid,fileContent);
		fprintf(fid, ['\n'...
			'/* Define for the model name required by the sil test frame. */\n'...
            'static const char szTLModelName[] = "' modelname '";\n'...            
			]);
		fclose(fid);
	else
		ds_error_msg([src_filename ' doesn''t exist.']);
	end
    
%-------------------------------------------------------------------------------
% Function build_sil_sf
%
% Build a modified sfunction and TL dll for the subsystem.
%-------------------------------------------------------------------------------
function build_sil_sf(subsystem_name,modelname,siltestdir)
% FUNCTION BUILD_SIL_SF
% builds the SIL sfunction without recreating the code

	build_sfunction_dll(subsystem_name,modelname,siltestdir);
	build_model_dll(modelname);

%-------------------------------------------------------------------------------
% Function build_sfunction_dll
%
% Build the sfunction DLL.
%-------------------------------------------------------------------------------
function build_sfunction_dll(subsystem_name,modelname,siltestdir)

    fprintf('Building a modified SIL sfunction using the files in srd_sil\n');

    tl_simfile_dir=[];
    
    % Get the TargetLink version information.
    config = tl_config(6);
    if strcmp(config.Version,'2.0.6') || strcmp(config.Version,'2.0.7')
        tl_simfile_dir='/TLSimFiles_v2.0.6/HostPC';
    elseif strcmp(config.Version,'2.1.6')
        tl_simfile_dir='/TLSimFiles_v2.1.6/HostPC';
    else
		ds_error_msg('gen_sil_test_frame: needs configuring for this version of TargetLink.');
    end
    
    mex('-g', '-V5', '-D__LCC__', '-DTL_SIM_SFCN', '-DLOG_VARS',...
		 ['-D__' upper(subsystem_name) '_SF__'],...
		 ['-I' getenv('DSPACE_ROOT') '\matlab\tl\SrcFiles\i86\lcc\include'],...
		 ['-I' siltestdir tl_simfile_dir],...
		 ['-I' getenv('DSPACE_ROOT') '\matlab\tl\SimFiles\Generic'],...
		 ['.\TLSim\' subsystem_name '_sf.c'],...
		 [siltestdir tl_simfile_dir '/tl_hostframe.c'])
         
%-------------------------------------------------------------------------------
% Function build_model_dll
%
% Build the TL model DLL.
%-------------------------------------------------------------------------------
function build_model_dll(modelname)

    fprintf('Building the SIL model DLL:\n');
	evalin('base', ...
		['!dsmake -f ' getenv('DSPACE_ROOT') '\matlab\tl\SimFiles\HostPC\LCC\makefile.mk '...
			'APP=' modelname ' TARGET=HostPC_LCC']);


%-------------------------------------------------------------------------------
% Function i_CheckDDObject
%-------------------------------------------------------------------------------
function [ddObjectAttributes, ok] = i_CheckDDObject(ddObject, objectKind)

% check if variable subsystemObject specifies valid DDObject
[ddObjectAttributes, errCode] = dsdd('GetAttributes', ddObject);
if errCode ~= 0 | ~strcmpi(ddObjectAttributes.objectKind, objectKind),
   ok = 0;
   ddObjectAttributes = [];
else
   ok = 1;
end
% path is not member of the Attributes structure, must be retrieved separately
ddObjectAttributes.path = dsdd('GetAttribute', ddObject, 'path');


%-------------------------------------------------------------------------------
% Function i_GetLogData
%-------------------------------------------------------------------------------
function logData = i_GetLogData(hModuleObjectList, ddSubsystemObject, options)

	% init values
	logData         = [];
	hLogObjectList  = [];
	logObjectStruct = [];
	bIsPointer      = 0;

	% Collect all log objects belonging to the current TL subsystem
	% NOTE: the log objects are put in a strcuture array.
	% Each element of this structure corresponds with one
	% function instance !
	% From the functions objects which represents an inline code, take only this one
	% which are root functions
	hRootFcnList = i_GetRootFunctionHandles(ddSubsystemObject.hDDObject);
	k = 0;
	for i = 1:length(hModuleObjectList),
    
	   % get all child objects of the object kind: function
	   hFunctionObjectList = dsdd('GetChildren',hModuleObjectList(i),...
		   'ObjectKind','Function');
     
	   % iterate through all functions
	   for j = 1:length(hFunctionObjectList),
		  bInlinedCode = dsdd('GetInlinedCode', hFunctionObjectList(j));
		  if bInlinedCode & isempty(find(hRootFcnList == hFunctionObjectList(j)))
			 continue;
		  end
      
		  % iterate through all InstancaData and collect the logObjects
		  instanceNumber                           = 1;
		  functionObjectName                       = dsdd('GetAttribute', hFunctionObjectList(j), 'name');
		  [bFcnInstanceExist, hInstanceDataObject] = dsdd('Exist', 'InstanceData','Parent',hFunctionObjectList(j));

		  while bFcnInstanceExist,
			 % Get the log variables object
			 [hLogVariablesObject, errCode] = dsdd('GetLogVariables', hInstanceDataObject);
			 if errCode == 0,
				 % OK, LogVariables object exist, get its child object
				 k = k + 1;
				 logObjectStruct(k).hLogObjectList  = dsdd('GetChildren', hLogVariablesObject,...
						 'ObjectKind', 'LogVariable');
				 if instanceNumber == 1,
					logObjectStruct(k).fcnInstanceName = functionObjectName;     
				 else
					logObjectStruct(k).fcnInstanceName = sprintf('%s(#%d)',functionObjectName, instanceNumber);     
				 end
				 hLogObjectList = [hLogObjectList logObjectStruct(k).hLogObjectList];
			 end
			 instanceNumber                           = instanceNumber + 1;
			 instanceObjectName                       = sprintf('InstanceData(#%d)',instanceNumber);
			 [bFcnInstanceExist, hInstanceDataObject] = dsdd('Exist', instanceObjectName,'Parent',hFunctionObjectList(j));
		  end % while bFcnInstanceExist
	   end % end j = 1:length(ddModuleObjectChildList) 
	end

	% Prepare the information contained in the LogVariableObject to the form needed 
	% by the frm header generator: logData must be a vector of structure with following
	% fields: logObjectName, baseType and channels (variable width)

	% for The Bool base type special handling is needed, on same platform this type
	% may be represent as single bit
	hBaseTypes   = dsdd('GetBaseTypes', ddSubsystemObject.hDDObject);
	numberOfBits = dsdd('GetBoolNumberOfBits', hBaseTypes);
	if ~isempty(numberOfBits) & numberOfBits == 1,
	   % ok, for bool data type only one bit is used.
	   % in the log structure used UInt8 for these logvariables
	   boolBaseType = 'UInt8';
	else
	   boolBaseType = 'Bool';
	end
	for i=1:length(hLogObjectList),
   
	   % Get the variable associated with current log object 
	   [hVariableRef, errCode]    = dsdd('GetVariableRefTarget', hLogObjectList(i));
	   if dsdd_check_msg(errCode), return; end

	   % Get the base type of the variable to be logged
	   [hType, errCode]    = dsdd('GetTypeTarget', hVariableRef);
	   if dsdd_check_msg(errCode), return; end
	   [baseType, errCode] = dsdd('GetBaseType', hType);
	   if dsdd_check_msg(errCode), return; end
   
	   if strcmpi(baseType, 'pointer'),
		  bIsPointer = 1;
      
		  % get the pointer destintation type; note: only simple pointer are supported now !
		  [hType, errCode] = dsdd('GetPointerDestTypeTarget', hType);
		  if dsdd_check_msg(errCode), return; end
		  [baseType, errCode] = dsdd('GetBaseType', hType);
		  if dsdd_check_msg(errCode), return; end
      
		  if strcmpi(baseType, 'pointer'),
			 varPath = dsdd('GetAttribute', hVariableRef, 'path');
			 ds_error_msg({...
				'Internal errCode. Please contact dSPACE technical support.',...
				'Multiple pointers are not supported.'},...
				'MessageType', 'Error',...
				'ShowDialog',  'no',...
				'MessageNumber', 90101);
			 return;
		  end
	   end % end strcmpi(baseType, 'pointer')
   
	   % special handling needed if basetype if Bitfield or Bool
	   if strcmp(baseType, 'Bitfield'),
		  baseType = 'UInt8';
	   end
	   if strcmp(baseType, 'Bool')
		  baseType = boolBaseType;
		end
	   logData(i).baseType = baseType;
      
	   % channels - WAS MIT MATRIZEN UND WENN TYPE AUCH SCHON WIDTH HAT ?
	   % For pointer variable, check if the pointer destination is set.
	   % is yes obtain the width from the pointer destination
	   if bIsPointer
		  hPointerDest = [];
		  indices      = dsdd('GetAutoRenamePropertyIndices', hVariableRef, 'PointerDest');
		  if length(indices) == 1,
			 [hPointerDest,errCode] = dsdd('GetPointerDestTarget',hVariableRef, indices);  % only one pointer destination allowed !
		  end
	   end
	   if bIsPointer & ~isempty(hPointerDest),
		  [width, errCode] = dsdd('GetWidth', hPointerDest);
	   else
		  [width, errCode] = dsdd('GetWidth', hVariableRef);
	   end
	   if dsdd_check_msg(errCode), return; end
	   if isempty(width),
		  logData(i).channels = 1;
	   else
		  logData(i).channels = width;
	   end
      
	   % logObjectName
	   [logVariableName, errCode] = dsdd('GetLogObjectName', hLogObjectList(i));
	   if ~errCode,
		  logData(i).logObjectName = logVariableName;
	   else
		  logData(i).logObjectName = dsdd('GetAttribute', hVariableRef, 'name');
	   end

		% SRD: I want this as well.
	  logData(i).varPath = dsdd('GetAttribute', hVariableRef, 'path');
	  hScalingRef = dsdd('GetScalingTarget',hVariableRef); 
	  logData(i).LSB=dsdd('GetLSB', hScalingRef);
	  logData(i).Offset=dsdd('GetOffset', hScalingRef);
	  logData(i).ConversionType=dsdd('GetConversionType', hScalingRef);
  	end


%-------------------------------------------------------------------------------
% Extract useful info from the DD file and dump to a file.
%-------------------------------------------------------------------------------
function ConstructTestFrameFromDD(subsystem_name)

	tlSystems{1}=subsystem_name;

	[ddSubsystemObject, ok] = i_CheckDDObject(['//DD0/Subsystems/' tlSystems{1}],'Subsystem');

	hModuleObjectList = dsdd('GetChildren', ddSubsystemObject.hDDObject,...
		'ObjectKind','Module');
	numberOfModules = length(hModuleObjectList);
	if numberOfModules == 0,
	   disp('numberOfModules == 0');
	   return;
	end

	subsystem_id = dsdd('GetSubsystemInfoSubsystemID', ddSubsystemObject.hDDObject);
    
	tstamp=clock;

	cal_macros_fid=fopen('TLSim/calibration_macros_sf.c','w');
	fprintf(cal_macros_fid,'/* Generated on %g-%g-%g at %g:%g:%g */\n\n',...
		tstamp(3),tstamp(2),tstamp(1),tstamp(4),tstamp(5),tstamp(6));

	cal_list_fid=fopen('TLSim/calibration_list_pcf.c','w');
	fprintf(cal_list_fid,'/* Generated on %g-%g-%g at %g:%g:%g */\n\n',...
		tstamp(3),tstamp(2),tstamp(1),tstamp(4),tstamp(5),tstamp(6));

	meas_list_fid=fopen('TLSim/measurement_list_pcf.c','w');
	fprintf(meas_list_fid,'/* Generated on %g-%g-%g at %g:%g:%g */\n\n',...
		tstamp(3),tstamp(2),tstamp(1),tstamp(4),tstamp(5),tstamp(6));

	% *****
	% Modules are the c and h files
	% *****
    nCal=0;
    calData=[];
    
	for i=1:numberOfModules,
        
        path = dsdd('GetAttribute', hModuleObjectList(i), 'path');
        filename = dsdd('GetAttribute', hModuleObjectList(i), 'name');
        hVarObjectList = dsdd('GetChildren','Variables','Parent',path,'objectKind','Variable');
        
        for k=1:length(hVarObjectList)
            
            hClass = dsdd('GetClassTarget',hVarObjectList(k));
            className = dsdd('GetAttribute',hClass,'name');
            varName = dsdd('GetAttribute',hVarObjectList(k),'name');

           % Get the base type of the variable to be logged
           [hType, errCode]    = dsdd('GetTypeTarget', hVarObjectList(k));
           if dsdd_check_msg(errCode), return; end
           [baseType, errCode] = dsdd('GetBaseType', hType);
           if dsdd_check_msg(errCode), return; end

           [width, errCode]    = dsdd('GetWidth', hVarObjectList(k));
           if dsdd_check_msg(errCode), return; end
       
			hScalingRef = dsdd('GetScalingTarget',hVarObjectList(k)); 
			LSB=dsdd('GetLSB', hScalingRef);
			offset=dsdd('GetOffset', hScalingRef);
			conversionType=dsdd('GetConversionType', hScalingRef);
      
            if isCalibrateable(className)
                nCal = nCal + 1;
                calData(nCal).name=varName;

				if isempty(width)
					ndims=1;
					dimx=1;
					dimy=1;
					objtype='eScalar';
					array_subscript='';
				else
					dims=size(width);
					if dims(2)==1
						ndims=1;
						dimx=width(1);
						dimy=1;
						objtype='eArray1D';
						array_subscript='[]';
					else
						ndims=2;
						dimx=width(1);
						dimy=width(2);
						objtype='eArray2D';
						array_subscript='[][]';
					end
				end
                calData(nCal).array_subscript=array_subscript;
                calData(nCal).objtype=objtype;
                calData(nCal).ndims=ndims;
                calData(nCal).dimx=dimx;
                calData(nCal).dimy=dimy;
                calData(nCal).filename=filename;
                calData(nCal).classname=className;
                calData(nCal).basetype=baseType;
                calData(nCal).LSB=LSB;
                calData(nCal).offset=offset;
                calData(nCal).convtype=conversionType;
            end
        end
    end

	fprintf(cal_list_fid,'/* Extern declarations for the calibration items. */\n');

    % extern decs first:
	for i=1:length(calData),
		fprintf(cal_list_fid,'extern %s %s %s%s;\n',calData(i).classname,calData(i).basetype,calData(i).name,calData(i).array_subscript);

		if strcmp(calData(i).objtype,'eArray1D')
			fprintf(cal_macros_fid,'UPDATE_CAL_ARRAY1D(%s)\n',calData(i).name);
		elseif strcmp(calData(i).objtype,'eArray2D')
			fprintf(cal_macros_fid,'UPDATE_CAL_ARRAY2D(%s)\n',calData(i).name);
		else
			fprintf(cal_macros_fid,'UPDATE_CAL_SCALAR(%s)\n',calData(i).name);
		end
    end

	fprintf(cal_list_fid,'\n/* CalibrationList structure for accessing items. */\n');
	fprintf(cal_list_fid,'silStruct_t CalibrationList[] =\n{\n');
        
	for i=1:length(calData),
		fprintf(cal_list_fid,'\t{"%s", e%s, %s, %g, %g, %g, %g, %g, NULL, (void*)&(%s)},\n',calData(i).name,...
            calData(i).basetype,calData(i).objtype,calData(i).ndims,calData(i).dimx,calData(i).dimy,calData(i).LSB,calData(i).offset,calData(i).name);
    end
	fprintf(cal_list_fid,'};\n\nsize_t CalibrationListLength = sizeof(CalibrationList) / sizeof(CalibrationList[0]);\n\n');

	logData = i_GetLogData(hModuleObjectList, ddSubsystemObject, []);
	if tl_error_check, 
		disp('tl_error');
		return; 
	end

	assignin('base','logData',logData);

	fprintf(meas_list_fid,'/* MeasurementList structure for accessing items. */\n');
	fprintf(meas_list_fid,'\nsilStruct_t MeasurementList[] =\n{\n');
	for i=1:length(logData),

		% logData(i).logObjectName
		% logData(i).channels
		dims=size(logData(i).channels);
		if dims(2)==1
			ndims=1;
			dimx=logData(i).channels(1);
			dimy=1;
			if dimx == 1
				objtype='eScalar';
			else
				objtype='eArray1D';
			end
		else
			ndims=2;
			dimx=logData(i).channels(1);
			dimy=logData(i).channels(2);
			objtype='eArray2D';
		end

        logData(i).objtype=objtype;
        logData(i).ndims=ndims;
        logData(i).dimx=dimx;
        logData(i).dimy=dimy;

		if strcmp(logData(i).objtype,'eScalar')

			fprintf(meas_list_fid,'\t{"%s", e%s, %s, %g, %g, %g, %g, %g, &(log_struct_%s.flags.%s), (void*)&(log_struct_%s.%s)},\n',logData(i).logObjectName(2:end),...
				logData(i).baseType,logData(i).objtype,logData(i).ndims,logData(i).dimx,logData(i).dimy,logData(i).LSB,logData(i).Offset,subsystem_id,logData(i).logObjectName,subsystem_id,logData(i).logObjectName);

		elseif strcmp(logData(i).objtype,'eArray1D')

			for k=1:logData(i).dimx,
				fprintf(meas_list_fid,'\t{"%s[%g]", e%s, eScalar, 1, 1, 1, %g, %g, &(log_struct_%s.flags.%s), (void*)&(log_struct_%s.%s[%g])},\n',logData(i).logObjectName(2:end),...
					k-1,logData(i).baseType,logData(i).LSB,logData(i).Offset,subsystem_id,logData(i).logObjectName,subsystem_id,logData(i).logObjectName,k-1);
			end

		end
	end

	fprintf(meas_list_fid,'};\n\nsize_t MeasurementListLength = sizeof(MeasurementList) / sizeof(MeasurementList[0]);\n\n');

	fclose(cal_macros_fid);
	fclose(cal_list_fid);
	fclose(meas_list_fid);

function [iscal] = isCalibrateable(className)
    if isequal(className,'CAL') | isequal(className,'PROD_CAL') | isequal(className,'DEV_CAL') |...
        isequal(className,'LOOKUP_AXIS')
        iscal=1;
    else
        iscal=0;
    end
    
%-------------------------------------------------------------------------------
% Function i_GetRootFunctionHandles
%-------------------------------------------------------------------------------
function hRootFcnList = i_GetRootFunctionHandles(hSubsystem)

	% init values
	hRootFcnList = [];

	[hRootFunctions, errCode] = dsdd('GetRootFunctions', hSubsystem);
	if dsdd_check_msg(errCode), return; end
	rootFcnNames              = dsdd('GetPropertyNames', hRootFunctions);
	for i=1:length(rootFcnNames),
	   [hRootFcn,errCode]  = dsdd('GetFunctionRefTarget', hSubsystem,rootFcnNames{i});
	   if dsdd_check_msg(errCode), return; end
	   hRootFcnList(end+1) = hRootFcn;
	end
