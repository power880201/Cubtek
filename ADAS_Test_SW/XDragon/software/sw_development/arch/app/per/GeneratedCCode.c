#include "GeneratedCCode.h"
#ifndef GH_a459_288_4165_b98_ae7f9e666a
#error "The generated header code is not compatible with the generated source code."
#endif /* GH_a459_288_4165_b98_ae7f9e666a */

#include <stdlib.h>
#include <stddef.h>
#include <assert.h>
#include <math.h>
#include <string.h>
#include <time.h>

#ifndef __cplusplus
#include <stdbool.h>
#endif /* __cplusplus */
#ifndef DISABLE_MEMORY_PROFILING
#include <stdio.h>
#include <stdlib.h>
#endif /* DISABLE_MEMORY_PROFILING */
#ifdef DISABLE_MEMORY_PROFILING
#include "resourceProfile.h"
#ifndef GC__27941_05_47_820_c1244a649f2
#error "The resource profile is not compatible with the generated source."
#endif /* GC__27941_05_47_820_c1244a649f2 */
#else /* DISABLE_MEMORY_PROFILING */
#define RC_int32_t_1D_13 3
#define RC_StaticList_27 14
#define RC_TrackWithMeasurements 232
#define RC_TrackWithMeasurements_1D_15 15
#define RC_CASpace 2492
#define RC_int32_t_1D_0 1
#define RC_int32_t_1D_1 2682
#define RC_Object 18763
#define RC_float64_t_1D_0 2
#define RC_MatrixData 11860
#define RC_float64_t_1D_5 11977
#define RC_PositiveDefiniteMatrix_7 571
#define RC_MatrixData_2 1309
#define RC_float64_t_1D_25 1313
#define RC_LinearAlgebra 2
#define RC_Gaussian_5 562
#define RC_Existence 370
#define RC_ExistenceSpace 1539
#define RC_MatrixData_3 1722
#define RC_float64_t_1D_1 1737
#define RC_StaticListFactory 379
#define RC_UniformRandomGenerator 535
#define RC_Random 537
#define RC_int32_t_1D_56 540
#define RC_StaticList_15 381
#define RC_SampleProbabilityPair_2 766
#define RC_SampleProbabilityPair_2_1D_2 382
#define RC_Obstacle 353
#define RC_Object_1 7405
#define RC_StaticList_12 2
#define RC_float64_t_1D_3 94
#define RC_RadarSpace_1D_15 3
#define RC_RadarSpace 46
#define RC_MatrixData_4 77
#define RC_StaticList_4 2
#define RC_Obstacle_1D_40 3
#define RC_StaticList_6 17
#define RC_float64_t_1D_4 7306
#define RC_MobilEyeSpace_1D_40 18
#define RC_MobilEyeSpace 7172
#define RC_MatrixData_5 7183
#define RC_StaticList_9 17
#define RC_FrontRadarObjectSpace 7171
#define RC_FrontRadarObjectSpace_1D_40 18
#define RC_Measure_2 2
#define RC_Measure_3 2
#define RC_Tracking 2
#define RC_SensorProperties 3
#define RC_FrontRadarNearParameters 9
#define RC_FrontRadarFarParameters 6
#define RC_MobilEyeParameters 92
#define RC_Vector2D_1D_10 174
#define RC_FrontRadarObjectParameters 92
#define RC_EgoMotionFilter 3
#define RC_float64_t_1D_2 33
#define RC_PositiveDefiniteMatrix_4 5
#define RC_CTRAErrorSpace 27
#define RC_MatrixData_8 31
#define RC_MatrixData_6 11
#define RC_CTRASpace 142
#define RC_MatrixData_9 154
#define RC_float64_t_1D_6 192
#define RC_CTRAModel 4
#define RC_PositiveDefiniteMatrix 16
#define RC_VelocitySpace 67
#define RC_VelocityMeasurementModel 4
#define RC_PositiveDefiniteMatrix_1 16
#define RC_YawRateSpace 67
#define RC_YawRateMeasurementModel 4
#define RC_Gaussian_4 13
#define RC_PositiveDefiniteMatrix_6 22
#define RC_float64_t_1D_36 47
#define RC_MatrixData_11 43
#define RC_StaticListEnumerator_15 5
#define RC_SquareMatrix_6 7
#define RC_Matrix_7 2
#define RC_float64_t_1D_12 11
#define RC_MatrixData_12 9
#define RC_Matrix_8 6
#define RC_MatrixData_10 19
#define RC_Gaussian 6
#define RC_Matrix_9 6
#define RC_Gaussian_1 6
#define RC_StaticListFactory_1 158
#define RC_StatIPDATrackColleFactoProvi 20
#define RC_StaticListFactory_2 21
#define RC_StaticListFactory_3 21
#define RC_StaticAssociatioTableFactory 21
#define RC_StaticListFactory_4 21
#define RC_StaticListFactory_5 21
#define RC_StaticList_23 4
#define RC_Gaussian_5_1D_15 5
#define RC_StaticList_20 12
#define RC_Gaussian_2 201
#define RC_Gaussian_2_1D_15 13
#define RC_StaticList_16 4
#define RC_Matrix_11 81
#define RC_Matrix_11_1D_15 5
#define RC_StaticList_26 8
#define RC_Existence_1D_15 9
#define RC_StaticList_22 4
#define RC_MarginalizedEvaluable 76
#define RC_MarginalizedEvaluable_1D_15 5
#define RC_PositiveDefiniteMatrix_2 5
#define RC_CAErrorSpace 27
#define RC_MatrixData_13 11
#define RC_float64_t_1D_9 14
#define RC_CAModel 4
#define RC_PersistenceModel 2
#define RC_MobilEyeDetectionModel 78
#define RC_EgoMotionCompensation 2
#define RC_SquareMatrix_7 7
#define RC_Matrix_12 2
#define RC_float64_t_1D_15 11
#define RC_MatrixData_14 9
#define RC_TwoPointDistribution 8
#define RC_Type 2
#define RC_MobilEyeMeasurementModel 2
#define RC_PositiveDefiniteMatrix_3 209
#define RC_MatrixData_15 642
#define RC_float64_t_1D_16 646
#define RC_float64_t_1D_20 98
#define RC_MatrixData_16 88
#define RC_SquareMatrix_3 5
#define RC_MatrixData_18 8
#define RC_float64_t_1D_200 11
#define RC_StaticList_7 8
#define RC_MobilEyeSpace_1D_50 9
#define RC_SampleSet 78
#define RC_StaticList_13 87
#define RC_SampleProbabilityPair 4401
#define RC_SampleProbabilityPair_1D_50 88
#define RC_StaticListEnumerator_3 4
#define RC_StaticListEnumerator_8 6
#define RC_ProbabilityGate 2
#define RC_SquaredMahalanobisDistance 3
#define RC_IMetric 1
#define RC_MultipleLocalNearestNeighbor 10
#define RC_IEnumerable 1
#define RC_IEnumerable_1 1
#define RC_IEnumerable_2 1
#define RC_IAssociationAlgorithm 1
#define RC_MeasurementAssociation 4
#define RC_StaticListEnumerator_12 4
#define RC_StaticListEnumerator_2 5
#define RC_AssociationTable 11
#define RC_float64_t_2D_15_40 12
#define RC_StaticListEnumerator_14 4
#define RC_MatrixData_7 5
#define RC_int32_t_1D_4 2
#define RC_int32_t_1D_40 242
#define RC_IAssociationTable 1
#define RC_StaticList_5 14
#define RC_StaticList_1D_15 15
#define RC_StaticList 241
#define RC_StaticListEnumerator 4
#define RC_IEvaluable 1
#define RC_IEvaluable_1 1
#define RC_IEvaluable_2 1
#define RC_IPDA 4
#define RC_CardinalitySpace 5
#define RC_StaticList_1 4
#define RC_float64_t_1D_40 5
#define RC_MeasurementSetLikelihood 10
#define RC_StaticList_18 13
#define RC_TruePositivesHypothesis 576
#define RC_TruePositivesHypothesi_1D_41 14
#define RC_StaticList_8 584
#define RC_MobilEyeSpace_1D_1 585
#define RC_GaussianMixture 2
#define RC_IListFactory 1
#define RC_StaticList_24 5
#define RC_Gaussian_5_1D_41 6
#define RC_StaticList_2 9
#define RC_float64_t_1D_41 10
#define RC_StaticListEnumerator_10 4
#define RC_StaticListEnumerator_4 4
#define RC_Space 1
#define RC_MatrixData_17 8
#define RC_StaticListEnumerator_1 4
#define RC_InverseMobilEyeMeasuremModel 2
#define RC_MatrixData_2_1D_1 1
#define RC_MatrixData_1D_0 1
#define RC_StaticList_21 12
#define RC_Gaussian_3 201
#define RC_Gaussian_3_1D_15 13
#define RC_StaticList_17 4
#define RC_Matrix_13 81
#define RC_Matrix_13_1D_15 5
#define RC_StaticList_25 4
#define RC_MarginalizedEvaluable_1 76
#define RC_MarginalizeEvaluable_1_1D_15 5
#define RC_FrontRadarObjectMeasureModel 2
#define RC_PositiveDefiniteMatrix_5 209
#define RC_FrontRadarObjectDetectiModel 78
#define RC_StaticList_3 79
#define RC_SquareMatrix_5 5
#define RC_MatrixData_19 8
#define RC_float64_t_1D_250 11
#define RC_StaticList_10 8
#define RC_FrontRadarObjectSpace_1D_50 9
#define RC_SampleSet_1 78
#define RC_StaticList_14 87
#define RC_SampleProbabilityPair_1 4401
#define RC_SampleProbabilitPair_1_1D_50 88
#define RC_StaticListEnumerator_6 4
#define RC_StaticListEnumerator_9 6
#define RC_ProbabilityGate_1 2
#define RC_SquaredMahalanobisDistance_1 3
#define RC_IMetric_1 1
#define RC_IEnumerable_3 1
#define RC_IEnumerable_4 1
#define RC_MeasurementAssociation_1 4
#define RC_StaticListEnumerator_13 4
#define RC_StaticListEnumerator_5 5
#define RC_MatrixData_1 5
#define RC_int32_t_1D_5 2
#define RC_IEvaluable_3 1
#define RC_IPDA_1 4
#define RC_StaticList_19 13
#define RC_TruePositivesHypothesis_1 576
#define RC_TruePositiveHypothes_1_1D_41 14
#define RC_StaticList_11 584
#define RC_FrontRadarObjectSpace_1D_1 585
#define RC_StaticListEnumerator_11 4
#define RC_StaticListEnumerator_7 4
#define RC_InveCartMeasModeWithVectVelo 2
#endif /* DISABLE_MEMORY_PROFILING */

struct M_int32_t_1D_13
{
	int32_t CurrentCount;
	struct int32_t_1D_13 *Next[RC_int32_t_1D_13];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct int32_t_1D_13 Elements[RC_int32_t_1D_13];
};

struct M_StaticList_27
{
	int32_t CurrentCount;
	struct StaticList_27 *Next[RC_StaticList_27];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_27 Elements[RC_StaticList_27];
};

struct M_TrackWithMeasurements
{
	int32_t CurrentCount;
	struct TrackWithMeasurements *Next[RC_TrackWithMeasurements];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct TrackWithMeasurements Elements[RC_TrackWithMeasurements];
};

struct M_TrackWithMeasurements_1D_15
{
	int32_t CurrentCount;
	struct TrackWithMeasurements_1D_15 *Next[RC_TrackWithMeasurements_1D_15];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct TrackWithMeasurements_1D_15 Elements[RC_TrackWithMeasurements_1D_15];
};

struct M_CASpace
{
	int32_t CurrentCount;
	struct CASpace *Next[RC_CASpace];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct CASpace Elements[RC_CASpace];
};

struct M_int32_t_1D_0
{
	int32_t CurrentCount;
	struct int32_t_1D_0 *Next[RC_int32_t_1D_0];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct int32_t_1D_0 Elements[RC_int32_t_1D_0];
};

struct M_int32_t_1D_1
{
	int32_t CurrentCount;
	struct int32_t_1D_1 *Next[RC_int32_t_1D_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct int32_t_1D_1 Elements[RC_int32_t_1D_1];
};

struct M_Object
{
	int32_t CurrentCount;
	struct Object *Next[RC_Object];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Object Elements[RC_Object];
};

struct M_float64_t_1D_0
{
	int32_t CurrentCount;
	struct float64_t_1D_0 *Next[RC_float64_t_1D_0];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_1D_0 Elements[RC_float64_t_1D_0];
};

struct M_MatrixData
{
	int32_t CurrentCount;
	struct MatrixData *Next[RC_MatrixData];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData Elements[RC_MatrixData];
};

struct M_float64_t_1D_5
{
	int32_t CurrentCount;
	struct float64_t_1D_5 *Next[RC_float64_t_1D_5];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_1D_5 Elements[RC_float64_t_1D_5];
};

struct M_PositiveDefiniteMatrix_7
{
	int32_t CurrentCount;
	struct PositiveDefiniteMatrix_7 *Next[RC_PositiveDefiniteMatrix_7];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct PositiveDefiniteMatrix_7 Elements[RC_PositiveDefiniteMatrix_7];
};

struct M_MatrixData_2
{
	int32_t CurrentCount;
	struct MatrixData_2 *Next[RC_MatrixData_2];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_2 Elements[RC_MatrixData_2];
};

struct M_float64_t_1D_25
{
	int32_t CurrentCount;
	struct float64_t_1D_25 *Next[RC_float64_t_1D_25];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_1D_25 Elements[RC_float64_t_1D_25];
};

struct M_LinearAlgebra
{
	int32_t CurrentCount;
	struct LinearAlgebra *Next[RC_LinearAlgebra];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct LinearAlgebra Elements[RC_LinearAlgebra];
};

struct M_Gaussian_5
{
	int32_t CurrentCount;
	struct Gaussian_5 *Next[RC_Gaussian_5];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Gaussian_5 Elements[RC_Gaussian_5];
};

struct M_Existence
{
	int32_t CurrentCount;
	struct Existence *Next[RC_Existence];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Existence Elements[RC_Existence];
};

struct M_ExistenceSpace
{
	int32_t CurrentCount;
	struct ExistenceSpace *Next[RC_ExistenceSpace];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct ExistenceSpace Elements[RC_ExistenceSpace];
};

struct M_MatrixData_3
{
	int32_t CurrentCount;
	struct MatrixData_3 *Next[RC_MatrixData_3];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_3 Elements[RC_MatrixData_3];
};

struct M_float64_t_1D_1
{
	int32_t CurrentCount;
	struct float64_t_1D_1 *Next[RC_float64_t_1D_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_1D_1 Elements[RC_float64_t_1D_1];
};

struct M_StaticListFactory
{
	int32_t CurrentCount;
	struct StaticListFactory *Next[RC_StaticListFactory];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListFactory Elements[RC_StaticListFactory];
};

struct M_UniformRandomGenerator
{
	int32_t CurrentCount;
	struct UniformRandomGenerator *Next[RC_UniformRandomGenerator];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct UniformRandomGenerator Elements[RC_UniformRandomGenerator];
};

struct M_Random
{
	int32_t CurrentCount;
	struct Random *Next[RC_Random];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Random Elements[RC_Random];
};

struct M_int32_t_1D_56
{
	int32_t CurrentCount;
	struct int32_t_1D_56 *Next[RC_int32_t_1D_56];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct int32_t_1D_56 Elements[RC_int32_t_1D_56];
};

struct M_StaticList_15
{
	int32_t CurrentCount;
	struct StaticList_15 *Next[RC_StaticList_15];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_15 Elements[RC_StaticList_15];
};

struct M_SampleProbabilityPair_2
{
	int32_t CurrentCount;
	struct SampleProbabilityPair_2 *Next[RC_SampleProbabilityPair_2];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct SampleProbabilityPair_2 Elements[RC_SampleProbabilityPair_2];
};

struct M_SampleProbabilityPair_2_1D_2
{
	int32_t CurrentCount;
	struct SampleProbabilityPair_2_1D_2 *Next[RC_SampleProbabilityPair_2_1D_2];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct SampleProbabilityPair_2_1D_2 Elements[RC_SampleProbabilityPair_2_1D_2];
};

struct M_Obstacle
{
	int32_t CurrentCount;
	struct Obstacle *Next[RC_Obstacle];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Obstacle Elements[RC_Obstacle];
};

struct M_Object_1
{
	int32_t CurrentCount;
	struct Object_1 *Next[RC_Object_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Object_1 Elements[RC_Object_1];
};

struct M_StaticList_12
{
	int32_t CurrentCount;
	struct StaticList_12 *Next[RC_StaticList_12];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_12 Elements[RC_StaticList_12];
};

struct M_float64_t_1D_3
{
	int32_t CurrentCount;
	struct float64_t_1D_3 *Next[RC_float64_t_1D_3];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_1D_3 Elements[RC_float64_t_1D_3];
};

struct M_RadarSpace_1D_15
{
	int32_t CurrentCount;
	struct RadarSpace_1D_15 *Next[RC_RadarSpace_1D_15];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct RadarSpace_1D_15 Elements[RC_RadarSpace_1D_15];
};

struct M_RadarSpace
{
	int32_t CurrentCount;
	struct RadarSpace *Next[RC_RadarSpace];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct RadarSpace Elements[RC_RadarSpace];
};

struct M_MatrixData_4
{
	int32_t CurrentCount;
	struct MatrixData_4 *Next[RC_MatrixData_4];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_4 Elements[RC_MatrixData_4];
};

struct M_StaticList_4
{
	int32_t CurrentCount;
	struct StaticList_4 *Next[RC_StaticList_4];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_4 Elements[RC_StaticList_4];
};

struct M_Obstacle_1D_40
{
	int32_t CurrentCount;
	struct Obstacle_1D_40 *Next[RC_Obstacle_1D_40];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Obstacle_1D_40 Elements[RC_Obstacle_1D_40];
};

struct M_StaticList_6
{
	int32_t CurrentCount;
	struct StaticList_6 *Next[RC_StaticList_6];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_6 Elements[RC_StaticList_6];
};

struct M_float64_t_1D_4
{
	int32_t CurrentCount;
	struct float64_t_1D_4 *Next[RC_float64_t_1D_4];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_1D_4 Elements[RC_float64_t_1D_4];
};

struct M_MobilEyeSpace_1D_40
{
	int32_t CurrentCount;
	struct MobilEyeSpace_1D_40 *Next[RC_MobilEyeSpace_1D_40];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MobilEyeSpace_1D_40 Elements[RC_MobilEyeSpace_1D_40];
};

struct M_MobilEyeSpace
{
	int32_t CurrentCount;
	struct MobilEyeSpace *Next[RC_MobilEyeSpace];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MobilEyeSpace Elements[RC_MobilEyeSpace];
};

struct M_MatrixData_5
{
	int32_t CurrentCount;
	struct MatrixData_5 *Next[RC_MatrixData_5];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_5 Elements[RC_MatrixData_5];
};

struct M_StaticList_9
{
	int32_t CurrentCount;
	struct StaticList_9 *Next[RC_StaticList_9];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_9 Elements[RC_StaticList_9];
};

struct M_FrontRadarObjectSpace
{
	int32_t CurrentCount;
	struct FrontRadarObjectSpace *Next[RC_FrontRadarObjectSpace];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct FrontRadarObjectSpace Elements[RC_FrontRadarObjectSpace];
};

struct M_FrontRadarObjectSpace_1D_40
{
	int32_t CurrentCount;
	struct FrontRadarObjectSpace_1D_40 *Next[RC_FrontRadarObjectSpace_1D_40];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct FrontRadarObjectSpace_1D_40 Elements[RC_FrontRadarObjectSpace_1D_40];
};

struct M_Measure_2
{
	int32_t CurrentCount;
	struct Measure_2 *Next[RC_Measure_2];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Measure_2 Elements[RC_Measure_2];
};

struct M_Measure_3
{
	int32_t CurrentCount;
	struct Measure_3 *Next[RC_Measure_3];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Measure_3 Elements[RC_Measure_3];
};

struct M_Tracking
{
	int32_t CurrentCount;
	struct Tracking *Next[RC_Tracking];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Tracking Elements[RC_Tracking];
};

struct M_SensorProperties
{
	int32_t CurrentCount;
	struct SensorProperties *Next[RC_SensorProperties];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct SensorProperties Elements[RC_SensorProperties];
};

struct M_FrontRadarNearParameters
{
	int32_t CurrentCount;
	struct FrontRadarNearParameters *Next[RC_FrontRadarNearParameters];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct FrontRadarNearParameters Elements[RC_FrontRadarNearParameters];
};

struct M_FrontRadarFarParameters
{
	int32_t CurrentCount;
	struct FrontRadarFarParameters *Next[RC_FrontRadarFarParameters];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct FrontRadarFarParameters Elements[RC_FrontRadarFarParameters];
};

struct M_MobilEyeParameters
{
	int32_t CurrentCount;
	struct MobilEyeParameters *Next[RC_MobilEyeParameters];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MobilEyeParameters Elements[RC_MobilEyeParameters];
};

struct M_Vector2D_1D_10
{
	int32_t CurrentCount;
	struct Vector2D_1D_10 *Next[RC_Vector2D_1D_10];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Vector2D_1D_10 Elements[RC_Vector2D_1D_10];
};

struct M_FrontRadarObjectParameters
{
	int32_t CurrentCount;
	struct FrontRadarObjectParameters *Next[RC_FrontRadarObjectParameters];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct FrontRadarObjectParameters Elements[RC_FrontRadarObjectParameters];
};

struct M_EgoMotionFilter
{
	int32_t CurrentCount;
	struct EgoMotionFilter *Next[RC_EgoMotionFilter];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct EgoMotionFilter Elements[RC_EgoMotionFilter];
};

struct M_float64_t_1D_2
{
	int32_t CurrentCount;
	struct float64_t_1D_2 *Next[RC_float64_t_1D_2];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_1D_2 Elements[RC_float64_t_1D_2];
};

struct M_PositiveDefiniteMatrix_4
{
	int32_t CurrentCount;
	struct PositiveDefiniteMatrix_4 *Next[RC_PositiveDefiniteMatrix_4];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct PositiveDefiniteMatrix_4 Elements[RC_PositiveDefiniteMatrix_4];
};

struct M_CTRAErrorSpace
{
	int32_t CurrentCount;
	struct CTRAErrorSpace *Next[RC_CTRAErrorSpace];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct CTRAErrorSpace Elements[RC_CTRAErrorSpace];
};

struct M_MatrixData_8
{
	int32_t CurrentCount;
	struct MatrixData_8 *Next[RC_MatrixData_8];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_8 Elements[RC_MatrixData_8];
};

struct M_MatrixData_6
{
	int32_t CurrentCount;
	struct MatrixData_6 *Next[RC_MatrixData_6];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_6 Elements[RC_MatrixData_6];
};

struct M_CTRASpace
{
	int32_t CurrentCount;
	struct CTRASpace *Next[RC_CTRASpace];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct CTRASpace Elements[RC_CTRASpace];
};

struct M_MatrixData_9
{
	int32_t CurrentCount;
	struct MatrixData_9 *Next[RC_MatrixData_9];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_9 Elements[RC_MatrixData_9];
};

struct M_float64_t_1D_6
{
	int32_t CurrentCount;
	struct float64_t_1D_6 *Next[RC_float64_t_1D_6];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_1D_6 Elements[RC_float64_t_1D_6];
};

struct M_CTRAModel
{
	int32_t CurrentCount;
	struct CTRAModel *Next[RC_CTRAModel];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct CTRAModel Elements[RC_CTRAModel];
};

struct M_PositiveDefiniteMatrix
{
	int32_t CurrentCount;
	struct PositiveDefiniteMatrix *Next[RC_PositiveDefiniteMatrix];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct PositiveDefiniteMatrix Elements[RC_PositiveDefiniteMatrix];
};

struct M_VelocitySpace
{
	int32_t CurrentCount;
	struct VelocitySpace *Next[RC_VelocitySpace];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct VelocitySpace Elements[RC_VelocitySpace];
};

struct M_VelocityMeasurementModel
{
	int32_t CurrentCount;
	struct VelocityMeasurementModel *Next[RC_VelocityMeasurementModel];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct VelocityMeasurementModel Elements[RC_VelocityMeasurementModel];
};

struct M_PositiveDefiniteMatrix_1
{
	int32_t CurrentCount;
	struct PositiveDefiniteMatrix_1 *Next[RC_PositiveDefiniteMatrix_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct PositiveDefiniteMatrix_1 Elements[RC_PositiveDefiniteMatrix_1];
};

struct M_YawRateSpace
{
	int32_t CurrentCount;
	struct YawRateSpace *Next[RC_YawRateSpace];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct YawRateSpace Elements[RC_YawRateSpace];
};

struct M_YawRateMeasurementModel
{
	int32_t CurrentCount;
	struct YawRateMeasurementModel *Next[RC_YawRateMeasurementModel];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct YawRateMeasurementModel Elements[RC_YawRateMeasurementModel];
};

struct M_Gaussian_4
{
	int32_t CurrentCount;
	struct Gaussian_4 *Next[RC_Gaussian_4];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Gaussian_4 Elements[RC_Gaussian_4];
};

struct M_PositiveDefiniteMatrix_6
{
	int32_t CurrentCount;
	struct PositiveDefiniteMatrix_6 *Next[RC_PositiveDefiniteMatrix_6];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct PositiveDefiniteMatrix_6 Elements[RC_PositiveDefiniteMatrix_6];
};

struct M_float64_t_1D_36
{
	int32_t CurrentCount;
	struct float64_t_1D_36 *Next[RC_float64_t_1D_36];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_1D_36 Elements[RC_float64_t_1D_36];
};

struct M_MatrixData_11
{
	int32_t CurrentCount;
	struct MatrixData_11 *Next[RC_MatrixData_11];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_11 Elements[RC_MatrixData_11];
};

struct M_StaticListEnumerator_15
{
	int32_t CurrentCount;
	struct StaticListEnumerator_15 *Next[RC_StaticListEnumerator_15];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListEnumerator_15 Elements[RC_StaticListEnumerator_15];
};

struct M_SquareMatrix_6
{
	int32_t CurrentCount;
	struct SquareMatrix_6 *Next[RC_SquareMatrix_6];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct SquareMatrix_6 Elements[RC_SquareMatrix_6];
};

struct M_Matrix_7
{
	int32_t CurrentCount;
	struct Matrix_7 *Next[RC_Matrix_7];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Matrix_7 Elements[RC_Matrix_7];
};

struct M_float64_t_1D_12
{
	int32_t CurrentCount;
	struct float64_t_1D_12 *Next[RC_float64_t_1D_12];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_1D_12 Elements[RC_float64_t_1D_12];
};

struct M_MatrixData_12
{
	int32_t CurrentCount;
	struct MatrixData_12 *Next[RC_MatrixData_12];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_12 Elements[RC_MatrixData_12];
};

struct M_Matrix_8
{
	int32_t CurrentCount;
	struct Matrix_8 *Next[RC_Matrix_8];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Matrix_8 Elements[RC_Matrix_8];
};

struct M_MatrixData_10
{
	int32_t CurrentCount;
	struct MatrixData_10 *Next[RC_MatrixData_10];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_10 Elements[RC_MatrixData_10];
};

struct M_Gaussian
{
	int32_t CurrentCount;
	struct Gaussian *Next[RC_Gaussian];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Gaussian Elements[RC_Gaussian];
};

struct M_Matrix_9
{
	int32_t CurrentCount;
	struct Matrix_9 *Next[RC_Matrix_9];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Matrix_9 Elements[RC_Matrix_9];
};

struct M_Gaussian_1
{
	int32_t CurrentCount;
	struct Gaussian_1 *Next[RC_Gaussian_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Gaussian_1 Elements[RC_Gaussian_1];
};

struct M_StaticListFactory_1
{
	int32_t CurrentCount;
	struct StaticListFactory_1 *Next[RC_StaticListFactory_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListFactory_1 Elements[RC_StaticListFactory_1];
};

struct M_StatiIPDATrackColleFactoProvi
{
	int32_t CurrentCount;
	struct StatiIPDATrackColleFactorProvid *Next[RC_StatIPDATrackColleFactoProvi];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StatiIPDATrackColleFactorProvid Elements[RC_StatIPDATrackColleFactoProvi];
};

struct M_StaticListFactory_2
{
	int32_t CurrentCount;
	struct StaticListFactory_2 *Next[RC_StaticListFactory_2];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListFactory_2 Elements[RC_StaticListFactory_2];
};

struct M_StaticListFactory_3
{
	int32_t CurrentCount;
	struct StaticListFactory_3 *Next[RC_StaticListFactory_3];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListFactory_3 Elements[RC_StaticListFactory_3];
};

struct M_StaticAssociationTableFactory
{
	int32_t CurrentCount;
	struct StaticAssociationTableFactory *Next[RC_StaticAssociatioTableFactory];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticAssociationTableFactory Elements[RC_StaticAssociatioTableFactory];
};

struct M_StaticListFactory_4
{
	int32_t CurrentCount;
	struct StaticListFactory_4 *Next[RC_StaticListFactory_4];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListFactory_4 Elements[RC_StaticListFactory_4];
};

struct M_StaticListFactory_5
{
	int32_t CurrentCount;
	struct StaticListFactory_5 *Next[RC_StaticListFactory_5];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListFactory_5 Elements[RC_StaticListFactory_5];
};

struct M_StaticList_23
{
	int32_t CurrentCount;
	struct StaticList_23 *Next[RC_StaticList_23];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_23 Elements[RC_StaticList_23];
};

struct M_Gaussian_5_1D_15
{
	int32_t CurrentCount;
	struct Gaussian_5_1D_15 *Next[RC_Gaussian_5_1D_15];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Gaussian_5_1D_15 Elements[RC_Gaussian_5_1D_15];
};

struct M_StaticList_20
{
	int32_t CurrentCount;
	struct StaticList_20 *Next[RC_StaticList_20];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_20 Elements[RC_StaticList_20];
};

struct M_Gaussian_2
{
	int32_t CurrentCount;
	struct Gaussian_2 *Next[RC_Gaussian_2];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Gaussian_2 Elements[RC_Gaussian_2];
};

struct M_Gaussian_2_1D_15
{
	int32_t CurrentCount;
	struct Gaussian_2_1D_15 *Next[RC_Gaussian_2_1D_15];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Gaussian_2_1D_15 Elements[RC_Gaussian_2_1D_15];
};

struct M_StaticList_16
{
	int32_t CurrentCount;
	struct StaticList_16 *Next[RC_StaticList_16];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_16 Elements[RC_StaticList_16];
};

struct M_Matrix_11
{
	int32_t CurrentCount;
	struct Matrix_11 *Next[RC_Matrix_11];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Matrix_11 Elements[RC_Matrix_11];
};

struct M_Matrix_11_1D_15
{
	int32_t CurrentCount;
	struct Matrix_11_1D_15 *Next[RC_Matrix_11_1D_15];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Matrix_11_1D_15 Elements[RC_Matrix_11_1D_15];
};

struct M_StaticList_26
{
	int32_t CurrentCount;
	struct StaticList_26 *Next[RC_StaticList_26];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_26 Elements[RC_StaticList_26];
};

struct M_Existence_1D_15
{
	int32_t CurrentCount;
	struct Existence_1D_15 *Next[RC_Existence_1D_15];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Existence_1D_15 Elements[RC_Existence_1D_15];
};

struct M_StaticList_22
{
	int32_t CurrentCount;
	struct StaticList_22 *Next[RC_StaticList_22];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_22 Elements[RC_StaticList_22];
};

struct M_MarginalizedEvaluable
{
	int32_t CurrentCount;
	struct MarginalizedEvaluable *Next[RC_MarginalizedEvaluable];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MarginalizedEvaluable Elements[RC_MarginalizedEvaluable];
};

struct M_MarginalizedEvaluable_1D_15
{
	int32_t CurrentCount;
	struct MarginalizedEvaluable_1D_15 *Next[RC_MarginalizedEvaluable_1D_15];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MarginalizedEvaluable_1D_15 Elements[RC_MarginalizedEvaluable_1D_15];
};

struct M_PositiveDefiniteMatrix_2
{
	int32_t CurrentCount;
	struct PositiveDefiniteMatrix_2 *Next[RC_PositiveDefiniteMatrix_2];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct PositiveDefiniteMatrix_2 Elements[RC_PositiveDefiniteMatrix_2];
};

struct M_CAErrorSpace
{
	int32_t CurrentCount;
	struct CAErrorSpace *Next[RC_CAErrorSpace];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct CAErrorSpace Elements[RC_CAErrorSpace];
};

struct M_MatrixData_13
{
	int32_t CurrentCount;
	struct MatrixData_13 *Next[RC_MatrixData_13];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_13 Elements[RC_MatrixData_13];
};

struct M_float64_t_1D_9
{
	int32_t CurrentCount;
	struct float64_t_1D_9 *Next[RC_float64_t_1D_9];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_1D_9 Elements[RC_float64_t_1D_9];
};

struct M_CAModel
{
	int32_t CurrentCount;
	struct CAModel *Next[RC_CAModel];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct CAModel Elements[RC_CAModel];
};

struct M_PersistenceModel
{
	int32_t CurrentCount;
	struct PersistenceModel *Next[RC_PersistenceModel];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct PersistenceModel Elements[RC_PersistenceModel];
};

struct M_MobilEyeDetectionModel
{
	int32_t CurrentCount;
	struct MobilEyeDetectionModel *Next[RC_MobilEyeDetectionModel];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MobilEyeDetectionModel Elements[RC_MobilEyeDetectionModel];
};

struct M_EgoMotionCompensation
{
	int32_t CurrentCount;
	struct EgoMotionCompensation *Next[RC_EgoMotionCompensation];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct EgoMotionCompensation Elements[RC_EgoMotionCompensation];
};

struct M_SquareMatrix_7
{
	int32_t CurrentCount;
	struct SquareMatrix_7 *Next[RC_SquareMatrix_7];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct SquareMatrix_7 Elements[RC_SquareMatrix_7];
};

struct M_Matrix_12
{
	int32_t CurrentCount;
	struct Matrix_12 *Next[RC_Matrix_12];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Matrix_12 Elements[RC_Matrix_12];
};

struct M_float64_t_1D_15
{
	int32_t CurrentCount;
	struct float64_t_1D_15 *Next[RC_float64_t_1D_15];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_1D_15 Elements[RC_float64_t_1D_15];
};

struct M_MatrixData_14
{
	int32_t CurrentCount;
	struct MatrixData_14 *Next[RC_MatrixData_14];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_14 Elements[RC_MatrixData_14];
};

struct M_TwoPointDistribution
{
	int32_t CurrentCount;
	struct TwoPointDistribution *Next[RC_TwoPointDistribution];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct TwoPointDistribution Elements[RC_TwoPointDistribution];
};

struct M_Type
{
	int32_t CurrentCount;
	struct Type *Next[RC_Type];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Type Elements[RC_Type];
};

struct M_MobilEyeMeasurementModel
{
	int32_t CurrentCount;
	struct MobilEyeMeasurementModel *Next[RC_MobilEyeMeasurementModel];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MobilEyeMeasurementModel Elements[RC_MobilEyeMeasurementModel];
};

struct M_PositiveDefiniteMatrix_3
{
	int32_t CurrentCount;
	struct PositiveDefiniteMatrix_3 *Next[RC_PositiveDefiniteMatrix_3];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct PositiveDefiniteMatrix_3 Elements[RC_PositiveDefiniteMatrix_3];
};

struct M_MatrixData_15
{
	int32_t CurrentCount;
	struct MatrixData_15 *Next[RC_MatrixData_15];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_15 Elements[RC_MatrixData_15];
};

struct M_float64_t_1D_16
{
	int32_t CurrentCount;
	struct float64_t_1D_16 *Next[RC_float64_t_1D_16];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_1D_16 Elements[RC_float64_t_1D_16];
};

struct M_float64_t_1D_20
{
	int32_t CurrentCount;
	struct float64_t_1D_20 *Next[RC_float64_t_1D_20];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_1D_20 Elements[RC_float64_t_1D_20];
};

struct M_MatrixData_16
{
	int32_t CurrentCount;
	struct MatrixData_16 *Next[RC_MatrixData_16];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_16 Elements[RC_MatrixData_16];
};

struct M_SquareMatrix_3
{
	int32_t CurrentCount;
	struct SquareMatrix_3 *Next[RC_SquareMatrix_3];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct SquareMatrix_3 Elements[RC_SquareMatrix_3];
};

struct M_MatrixData_18
{
	int32_t CurrentCount;
	struct MatrixData_18 *Next[RC_MatrixData_18];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_18 Elements[RC_MatrixData_18];
};

struct M_float64_t_1D_200
{
	int32_t CurrentCount;
	struct float64_t_1D_200 *Next[RC_float64_t_1D_200];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_1D_200 Elements[RC_float64_t_1D_200];
};

struct M_StaticList_7
{
	int32_t CurrentCount;
	struct StaticList_7 *Next[RC_StaticList_7];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_7 Elements[RC_StaticList_7];
};

struct M_MobilEyeSpace_1D_50
{
	int32_t CurrentCount;
	struct MobilEyeSpace_1D_50 *Next[RC_MobilEyeSpace_1D_50];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MobilEyeSpace_1D_50 Elements[RC_MobilEyeSpace_1D_50];
};

struct M_SampleSet
{
	int32_t CurrentCount;
	struct SampleSet *Next[RC_SampleSet];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct SampleSet Elements[RC_SampleSet];
};

struct M_StaticList_13
{
	int32_t CurrentCount;
	struct StaticList_13 *Next[RC_StaticList_13];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_13 Elements[RC_StaticList_13];
};

struct M_SampleProbabilityPair
{
	int32_t CurrentCount;
	struct SampleProbabilityPair *Next[RC_SampleProbabilityPair];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct SampleProbabilityPair Elements[RC_SampleProbabilityPair];
};

struct M_SampleProbabilityPair_1D_50
{
	int32_t CurrentCount;
	struct SampleProbabilityPair_1D_50 *Next[RC_SampleProbabilityPair_1D_50];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct SampleProbabilityPair_1D_50 Elements[RC_SampleProbabilityPair_1D_50];
};

struct M_StaticListEnumerator_3
{
	int32_t CurrentCount;
	struct StaticListEnumerator_3 *Next[RC_StaticListEnumerator_3];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListEnumerator_3 Elements[RC_StaticListEnumerator_3];
};

struct M_StaticListEnumerator_8
{
	int32_t CurrentCount;
	struct StaticListEnumerator_8 *Next[RC_StaticListEnumerator_8];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListEnumerator_8 Elements[RC_StaticListEnumerator_8];
};

struct M_ProbabilityGate
{
	int32_t CurrentCount;
	struct ProbabilityGate *Next[RC_ProbabilityGate];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct ProbabilityGate Elements[RC_ProbabilityGate];
};

struct M_SquaredMahalanobisDistance
{
	int32_t CurrentCount;
	struct SquaredMahalanobisDistance *Next[RC_SquaredMahalanobisDistance];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct SquaredMahalanobisDistance Elements[RC_SquaredMahalanobisDistance];
};

struct M_IMetric
{
	int32_t CurrentCount;
	struct IMetric *Next[RC_IMetric];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct IMetric Elements[RC_IMetric];
};

struct M_MultipleLocalNearestNeighbor
{
	int32_t CurrentCount;
	struct MultipleLocalNearestNeighbor *Next[RC_MultipleLocalNearestNeighbor];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MultipleLocalNearestNeighbor Elements[RC_MultipleLocalNearestNeighbor];
};

struct M_IEnumerable
{
	int32_t CurrentCount;
	struct IEnumerable *Next[RC_IEnumerable];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct IEnumerable Elements[RC_IEnumerable];
};

struct M_IEnumerable_1
{
	int32_t CurrentCount;
	struct IEnumerable_1 *Next[RC_IEnumerable_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct IEnumerable_1 Elements[RC_IEnumerable_1];
};

struct M_IEnumerable_2
{
	int32_t CurrentCount;
	struct IEnumerable_2 *Next[RC_IEnumerable_2];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct IEnumerable_2 Elements[RC_IEnumerable_2];
};

struct M_IAssociationAlgorithm
{
	int32_t CurrentCount;
	struct IAssociationAlgorithm *Next[RC_IAssociationAlgorithm];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct IAssociationAlgorithm Elements[RC_IAssociationAlgorithm];
};

struct M_MeasurementAssociation
{
	int32_t CurrentCount;
	struct MeasurementAssociation *Next[RC_MeasurementAssociation];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MeasurementAssociation Elements[RC_MeasurementAssociation];
};

struct M_StaticListEnumerator_12
{
	int32_t CurrentCount;
	struct StaticListEnumerator_12 *Next[RC_StaticListEnumerator_12];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListEnumerator_12 Elements[RC_StaticListEnumerator_12];
};

struct M_StaticListEnumerator_2
{
	int32_t CurrentCount;
	struct StaticListEnumerator_2 *Next[RC_StaticListEnumerator_2];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListEnumerator_2 Elements[RC_StaticListEnumerator_2];
};

struct M_AssociationTable
{
	int32_t CurrentCount;
	struct AssociationTable *Next[RC_AssociationTable];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct AssociationTable Elements[RC_AssociationTable];
};

struct M_float64_t_2D_15_40
{
	int32_t CurrentCount;
	struct float64_t_2D_15_40 *Next[RC_float64_t_2D_15_40];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_2D_15_40 Elements[RC_float64_t_2D_15_40];
};

struct M_StaticListEnumerator_14
{
	int32_t CurrentCount;
	struct StaticListEnumerator_14 *Next[RC_StaticListEnumerator_14];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListEnumerator_14 Elements[RC_StaticListEnumerator_14];
};

struct M_MatrixData_7
{
	int32_t CurrentCount;
	struct MatrixData_7 *Next[RC_MatrixData_7];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_7 Elements[RC_MatrixData_7];
};

struct M_int32_t_1D_4
{
	int32_t CurrentCount;
	struct int32_t_1D_4 *Next[RC_int32_t_1D_4];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct int32_t_1D_4 Elements[RC_int32_t_1D_4];
};

struct M_int32_t_1D_40
{
	int32_t CurrentCount;
	struct int32_t_1D_40 *Next[RC_int32_t_1D_40];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct int32_t_1D_40 Elements[RC_int32_t_1D_40];
};

struct M_IAssociationTable
{
	int32_t CurrentCount;
	struct IAssociationTable *Next[RC_IAssociationTable];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct IAssociationTable Elements[RC_IAssociationTable];
};

struct M_StaticList_5
{
	int32_t CurrentCount;
	struct StaticList_5 *Next[RC_StaticList_5];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_5 Elements[RC_StaticList_5];
};

struct M_StaticList_1D_15
{
	int32_t CurrentCount;
	struct StaticList_1D_15 *Next[RC_StaticList_1D_15];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_1D_15 Elements[RC_StaticList_1D_15];
};

struct M_StaticList
{
	int32_t CurrentCount;
	struct StaticList *Next[RC_StaticList];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList Elements[RC_StaticList];
};

struct M_StaticListEnumerator
{
	int32_t CurrentCount;
	struct StaticListEnumerator *Next[RC_StaticListEnumerator];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListEnumerator Elements[RC_StaticListEnumerator];
};

struct M_IEvaluable
{
	int32_t CurrentCount;
	struct IEvaluable *Next[RC_IEvaluable];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct IEvaluable Elements[RC_IEvaluable];
};

struct M_IEvaluable_1
{
	int32_t CurrentCount;
	struct IEvaluable_1 *Next[RC_IEvaluable_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct IEvaluable_1 Elements[RC_IEvaluable_1];
};

struct M_IEvaluable_2
{
	int32_t CurrentCount;
	struct IEvaluable_2 *Next[RC_IEvaluable_2];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct IEvaluable_2 Elements[RC_IEvaluable_2];
};

struct M_IPDA
{
	int32_t CurrentCount;
	struct IPDA *Next[RC_IPDA];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct IPDA Elements[RC_IPDA];
};

struct M_CardinalitySpace
{
	int32_t CurrentCount;
	struct CardinalitySpace *Next[RC_CardinalitySpace];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct CardinalitySpace Elements[RC_CardinalitySpace];
};

struct M_StaticList_1
{
	int32_t CurrentCount;
	struct StaticList_1 *Next[RC_StaticList_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_1 Elements[RC_StaticList_1];
};

struct M_float64_t_1D_40
{
	int32_t CurrentCount;
	struct float64_t_1D_40 *Next[RC_float64_t_1D_40];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_1D_40 Elements[RC_float64_t_1D_40];
};

struct M_MeasurementSetLikelihood
{
	int32_t CurrentCount;
	struct MeasurementSetLikelihood *Next[RC_MeasurementSetLikelihood];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MeasurementSetLikelihood Elements[RC_MeasurementSetLikelihood];
};

struct M_StaticList_18
{
	int32_t CurrentCount;
	struct StaticList_18 *Next[RC_StaticList_18];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_18 Elements[RC_StaticList_18];
};

struct M_TruePositivesHypothesis
{
	int32_t CurrentCount;
	struct TruePositivesHypothesis *Next[RC_TruePositivesHypothesis];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct TruePositivesHypothesis Elements[RC_TruePositivesHypothesis];
};

struct M_TruePositivesHypothesis_1D_41
{
	int32_t CurrentCount;
	struct TruePositivesHypothesis_1D_41 *Next[RC_TruePositivesHypothesi_1D_41];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct TruePositivesHypothesis_1D_41 Elements[RC_TruePositivesHypothesi_1D_41];
};

struct M_StaticList_8
{
	int32_t CurrentCount;
	struct StaticList_8 *Next[RC_StaticList_8];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_8 Elements[RC_StaticList_8];
};

struct M_MobilEyeSpace_1D_1
{
	int32_t CurrentCount;
	struct MobilEyeSpace_1D_1 *Next[RC_MobilEyeSpace_1D_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MobilEyeSpace_1D_1 Elements[RC_MobilEyeSpace_1D_1];
};

struct M_GaussianMixture
{
	int32_t CurrentCount;
	struct GaussianMixture *Next[RC_GaussianMixture];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct GaussianMixture Elements[RC_GaussianMixture];
};

struct M_IListFactory
{
	int32_t CurrentCount;
	struct IListFactory *Next[RC_IListFactory];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct IListFactory Elements[RC_IListFactory];
};

struct M_StaticList_24
{
	int32_t CurrentCount;
	struct StaticList_24 *Next[RC_StaticList_24];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_24 Elements[RC_StaticList_24];
};

struct M_Gaussian_5_1D_41
{
	int32_t CurrentCount;
	struct Gaussian_5_1D_41 *Next[RC_Gaussian_5_1D_41];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Gaussian_5_1D_41 Elements[RC_Gaussian_5_1D_41];
};

struct M_StaticList_2
{
	int32_t CurrentCount;
	struct StaticList_2 *Next[RC_StaticList_2];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_2 Elements[RC_StaticList_2];
};

struct M_float64_t_1D_41
{
	int32_t CurrentCount;
	struct float64_t_1D_41 *Next[RC_float64_t_1D_41];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_1D_41 Elements[RC_float64_t_1D_41];
};

struct M_StaticListEnumerator_10
{
	int32_t CurrentCount;
	struct StaticListEnumerator_10 *Next[RC_StaticListEnumerator_10];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListEnumerator_10 Elements[RC_StaticListEnumerator_10];
};

struct M_StaticListEnumerator_4
{
	int32_t CurrentCount;
	struct StaticListEnumerator_4 *Next[RC_StaticListEnumerator_4];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListEnumerator_4 Elements[RC_StaticListEnumerator_4];
};

struct M_Space
{
	int32_t CurrentCount;
	struct Space *Next[RC_Space];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Space Elements[RC_Space];
};

struct M_MatrixData_17
{
	int32_t CurrentCount;
	struct MatrixData_17 *Next[RC_MatrixData_17];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_17 Elements[RC_MatrixData_17];
};

struct M_StaticListEnumerator_1
{
	int32_t CurrentCount;
	struct StaticListEnumerator_1 *Next[RC_StaticListEnumerator_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListEnumerator_1 Elements[RC_StaticListEnumerator_1];
};

struct M_InverseMobilEyeMeasuremeModel
{
	int32_t CurrentCount;
	struct InverseMobilEyeMeasurementModel *Next[RC_InverseMobilEyeMeasuremModel];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct InverseMobilEyeMeasurementModel Elements[RC_InverseMobilEyeMeasuremModel];
};

struct M_MatrixData_2_1D_1
{
	int32_t CurrentCount;
	struct MatrixData_2_1D_1 *Next[RC_MatrixData_2_1D_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_2_1D_1 Elements[RC_MatrixData_2_1D_1];
};

struct M_MatrixData_1D_0
{
	int32_t CurrentCount;
	struct MatrixData_1D_0 *Next[RC_MatrixData_1D_0];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_1D_0 Elements[RC_MatrixData_1D_0];
};

struct M_StaticList_21
{
	int32_t CurrentCount;
	struct StaticList_21 *Next[RC_StaticList_21];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_21 Elements[RC_StaticList_21];
};

struct M_Gaussian_3
{
	int32_t CurrentCount;
	struct Gaussian_3 *Next[RC_Gaussian_3];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Gaussian_3 Elements[RC_Gaussian_3];
};

struct M_Gaussian_3_1D_15
{
	int32_t CurrentCount;
	struct Gaussian_3_1D_15 *Next[RC_Gaussian_3_1D_15];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Gaussian_3_1D_15 Elements[RC_Gaussian_3_1D_15];
};

struct M_StaticList_17
{
	int32_t CurrentCount;
	struct StaticList_17 *Next[RC_StaticList_17];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_17 Elements[RC_StaticList_17];
};

struct M_Matrix_13
{
	int32_t CurrentCount;
	struct Matrix_13 *Next[RC_Matrix_13];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Matrix_13 Elements[RC_Matrix_13];
};

struct M_Matrix_13_1D_15
{
	int32_t CurrentCount;
	struct Matrix_13_1D_15 *Next[RC_Matrix_13_1D_15];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct Matrix_13_1D_15 Elements[RC_Matrix_13_1D_15];
};

struct M_StaticList_25
{
	int32_t CurrentCount;
	struct StaticList_25 *Next[RC_StaticList_25];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_25 Elements[RC_StaticList_25];
};

struct M_MarginalizedEvaluable_1
{
	int32_t CurrentCount;
	struct MarginalizedEvaluable_1 *Next[RC_MarginalizedEvaluable_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MarginalizedEvaluable_1 Elements[RC_MarginalizedEvaluable_1];
};

struct M_MarginalizedEvaluable_1_1D_15
{
	int32_t CurrentCount;
	struct MarginalizedEvaluable_1_1D_15 *Next[RC_MarginalizeEvaluable_1_1D_15];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MarginalizedEvaluable_1_1D_15 Elements[RC_MarginalizeEvaluable_1_1D_15];
};

struct M_FrontRadarObjectMeasuremModel
{
	int32_t CurrentCount;
	struct FrontRadarObjectMeasuremenModel *Next[RC_FrontRadarObjectMeasureModel];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct FrontRadarObjectMeasuremenModel Elements[RC_FrontRadarObjectMeasureModel];
};

struct M_PositiveDefiniteMatrix_5
{
	int32_t CurrentCount;
	struct PositiveDefiniteMatrix_5 *Next[RC_PositiveDefiniteMatrix_5];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct PositiveDefiniteMatrix_5 Elements[RC_PositiveDefiniteMatrix_5];
};

struct M_FrontRadarObjectDetectioModel
{
	int32_t CurrentCount;
	struct FrontRadarObjectDetectionModel *Next[RC_FrontRadarObjectDetectiModel];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct FrontRadarObjectDetectionModel Elements[RC_FrontRadarObjectDetectiModel];
};

struct M_StaticList_3
{
	int32_t CurrentCount;
	struct StaticList_3 *Next[RC_StaticList_3];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_3 Elements[RC_StaticList_3];
};

struct M_SquareMatrix_5
{
	int32_t CurrentCount;
	struct SquareMatrix_5 *Next[RC_SquareMatrix_5];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct SquareMatrix_5 Elements[RC_SquareMatrix_5];
};

struct M_MatrixData_19
{
	int32_t CurrentCount;
	struct MatrixData_19 *Next[RC_MatrixData_19];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_19 Elements[RC_MatrixData_19];
};

struct M_float64_t_1D_250
{
	int32_t CurrentCount;
	struct float64_t_1D_250 *Next[RC_float64_t_1D_250];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct float64_t_1D_250 Elements[RC_float64_t_1D_250];
};

struct M_StaticList_10
{
	int32_t CurrentCount;
	struct StaticList_10 *Next[RC_StaticList_10];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_10 Elements[RC_StaticList_10];
};

struct M_FrontRadarObjectSpace_1D_50
{
	int32_t CurrentCount;
	struct FrontRadarObjectSpace_1D_50 *Next[RC_FrontRadarObjectSpace_1D_50];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct FrontRadarObjectSpace_1D_50 Elements[RC_FrontRadarObjectSpace_1D_50];
};

struct M_SampleSet_1
{
	int32_t CurrentCount;
	struct SampleSet_1 *Next[RC_SampleSet_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct SampleSet_1 Elements[RC_SampleSet_1];
};

struct M_StaticList_14
{
	int32_t CurrentCount;
	struct StaticList_14 *Next[RC_StaticList_14];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_14 Elements[RC_StaticList_14];
};

struct M_SampleProbabilityPair_1
{
	int32_t CurrentCount;
	struct SampleProbabilityPair_1 *Next[RC_SampleProbabilityPair_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct SampleProbabilityPair_1 Elements[RC_SampleProbabilityPair_1];
};

struct M_SampleProbabilityPair_1_1D_50
{
	int32_t CurrentCount;
	struct SampleProbabilityPair_1_1D_50 *Next[RC_SampleProbabilitPair_1_1D_50];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct SampleProbabilityPair_1_1D_50 Elements[RC_SampleProbabilitPair_1_1D_50];
};

struct M_StaticListEnumerator_6
{
	int32_t CurrentCount;
	struct StaticListEnumerator_6 *Next[RC_StaticListEnumerator_6];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListEnumerator_6 Elements[RC_StaticListEnumerator_6];
};

struct M_StaticListEnumerator_9
{
	int32_t CurrentCount;
	struct StaticListEnumerator_9 *Next[RC_StaticListEnumerator_9];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListEnumerator_9 Elements[RC_StaticListEnumerator_9];
};

struct M_ProbabilityGate_1
{
	int32_t CurrentCount;
	struct ProbabilityGate_1 *Next[RC_ProbabilityGate_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct ProbabilityGate_1 Elements[RC_ProbabilityGate_1];
};

struct M_SquaredMahalanobisDistance_1
{
	int32_t CurrentCount;
	struct SquaredMahalanobisDistance_1 *Next[RC_SquaredMahalanobisDistance_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct SquaredMahalanobisDistance_1 Elements[RC_SquaredMahalanobisDistance_1];
};

struct M_IMetric_1
{
	int32_t CurrentCount;
	struct IMetric_1 *Next[RC_IMetric_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct IMetric_1 Elements[RC_IMetric_1];
};

struct M_IEnumerable_3
{
	int32_t CurrentCount;
	struct IEnumerable_3 *Next[RC_IEnumerable_3];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct IEnumerable_3 Elements[RC_IEnumerable_3];
};

struct M_IEnumerable_4
{
	int32_t CurrentCount;
	struct IEnumerable_4 *Next[RC_IEnumerable_4];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct IEnumerable_4 Elements[RC_IEnumerable_4];
};

struct M_MeasurementAssociation_1
{
	int32_t CurrentCount;
	struct MeasurementAssociation_1 *Next[RC_MeasurementAssociation_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MeasurementAssociation_1 Elements[RC_MeasurementAssociation_1];
};

struct M_StaticListEnumerator_13
{
	int32_t CurrentCount;
	struct StaticListEnumerator_13 *Next[RC_StaticListEnumerator_13];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListEnumerator_13 Elements[RC_StaticListEnumerator_13];
};

struct M_StaticListEnumerator_5
{
	int32_t CurrentCount;
	struct StaticListEnumerator_5 *Next[RC_StaticListEnumerator_5];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListEnumerator_5 Elements[RC_StaticListEnumerator_5];
};

struct M_MatrixData_1
{
	int32_t CurrentCount;
	struct MatrixData_1 *Next[RC_MatrixData_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct MatrixData_1 Elements[RC_MatrixData_1];
};

struct M_int32_t_1D_5
{
	int32_t CurrentCount;
	struct int32_t_1D_5 *Next[RC_int32_t_1D_5];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct int32_t_1D_5 Elements[RC_int32_t_1D_5];
};

struct M_IEvaluable_3
{
	int32_t CurrentCount;
	struct IEvaluable_3 *Next[RC_IEvaluable_3];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct IEvaluable_3 Elements[RC_IEvaluable_3];
};

struct M_IPDA_1
{
	int32_t CurrentCount;
	struct IPDA_1 *Next[RC_IPDA_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct IPDA_1 Elements[RC_IPDA_1];
};

struct M_StaticList_19
{
	int32_t CurrentCount;
	struct StaticList_19 *Next[RC_StaticList_19];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_19 Elements[RC_StaticList_19];
};

struct M_TruePositivesHypothesis_1
{
	int32_t CurrentCount;
	struct TruePositivesHypothesis_1 *Next[RC_TruePositivesHypothesis_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct TruePositivesHypothesis_1 Elements[RC_TruePositivesHypothesis_1];
};

struct M_TruePositiveHypothesi_1_1D_41
{
	int32_t CurrentCount;
	struct TruePositivesHypothesis_1_1D_41 *Next[RC_TruePositiveHypothes_1_1D_41];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct TruePositivesHypothesis_1_1D_41 Elements[RC_TruePositiveHypothes_1_1D_41];
};

struct M_StaticList_11
{
	int32_t CurrentCount;
	struct StaticList_11 *Next[RC_StaticList_11];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticList_11 Elements[RC_StaticList_11];
};

struct M_FrontRadarObjectSpace_1D_1
{
	int32_t CurrentCount;
	struct FrontRadarObjectSpace_1D_1 *Next[RC_FrontRadarObjectSpace_1D_1];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct FrontRadarObjectSpace_1D_1 Elements[RC_FrontRadarObjectSpace_1D_1];
};

struct M_StaticListEnumerator_11
{
	int32_t CurrentCount;
	struct StaticListEnumerator_11 *Next[RC_StaticListEnumerator_11];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListEnumerator_11 Elements[RC_StaticListEnumerator_11];
};

struct M_StaticListEnumerator_7
{
	int32_t CurrentCount;
	struct StaticListEnumerator_7 *Next[RC_StaticListEnumerator_7];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct StaticListEnumerator_7 Elements[RC_StaticListEnumerator_7];
};

struct M_InveCartMeasModeWithVectVeloc
{
	int32_t CurrentCount;
	struct InveCartMeasModelWithVectoVeloc *Next[RC_InveCartMeasModeWithVectVelo];
	#ifndef DISABLE_MEMORY_PROFILING
	int32_t MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	struct InveCartMeasModelWithVectoVeloc Elements[RC_InveCartMeasModeWithVectVelo];
};

static void Del_int32_t_1D_13(struct int32_t_1D_13 *const self);

static void RemRef_int32_t_1D_13(struct int32_t_1D_13 *const self);

static void DateTime_1_cctor(void);

static int64_t DateTime_1_DateToTicks(int32_t year, int32_t month, int32_t day);

static void RemRef_StaticList_27(struct StaticList_27 *const self);

static void RemRef_TrackWithMeasurements(struct TrackWithMeasurements *const self);

static void Del_TrackWithMeasurements_1D_15(struct TrackWithMeasurements_1D_15 *const self);

static void RemRef_TrackWithMeasureme_1D_15(struct TrackWithMeasurements_1D_15 *const self);

static void RemRef_CASpace(struct CASpace *const self);

static void Del_int32_t_1D_0(struct int32_t_1D_0 *const self);

static void RemRef_int32_t_1D_0(struct int32_t_1D_0 *const self);

static void Del_int32_t_1D_1(struct int32_t_1D_1 *const self);

static void RemRef_int32_t_1D_1(struct int32_t_1D_1 *const self);

static void RemRef_Object(struct Object *const self);

static void Del_float64_t_1D_0(struct float64_t_1D_0 *const self);

static void RemRef_float64_t_1D_0(struct float64_t_1D_0 *const self);

static void MatrixData_20_cctor(void);

static void RemRef_MatrixData(struct MatrixData *const self);

static void MatrixData_20_CheckRange(int32_t rows, int32_t columns);

static void Del_float64_t_1D_5(struct float64_t_1D_5 *const self);

static void RemRef_float64_t_1D_5(struct float64_t_1D_5 *const self);

static void Space_ctor(struct Space *const self, int32_t dimensions);

static void AngulSpace_set_AngulDimenIndice(struct AngularSpace *const self, struct int32_t_1D_1 *value);

static void AngularSpace_ctor(struct AngularSpace *const self, int32_t dimensions, struct int32_t_1D_1 *angularDimensionsIndices, struct int32_t_1D_0 *additionAngularDimensionIndices);

static void CVSpace_ctor(struct CVSpace *const self, int32_t additionalDimensions, struct int32_t_1D_0 *additionAngularDimensionIndices);

static void CVSpace_ctor_1(struct CVSpace *const self, int32_t additionalDimensions);

static void RemRef_PositiveDefiniteMatrix_7(struct PositiveDefiniteMatrix_7 *const self);

static void RemRef_MatrixData_2(struct MatrixData_2 *const self);

static void Del_float64_t_1D_25(struct float64_t_1D_25 *const self);

static void RemRef_float64_t_1D_25(struct float64_t_1D_25 *const self);

static void MatrixData_2_SetValueFast(struct MatrixData_2 *const self, float64_t value, int32_t row, int32_t column);

static void Matrix_10_set_UncheckMatrixData(struct Matrix_10 *const self, struct MatrixData_2 *value);

static void Matrix_10_CheckMatrix(struct Matrix_10 *const self);

static void SquareMatrix_7_CheckMatrix(struct SquareMatrix_7 *const self);

static float64_t MatrixData_2_GetValueFast(struct MatrixData_2 *const self, int32_t row, int32_t column);

static float64_t Matrix_10_UncheckedGet(struct Matrix_10 *const self, int32_t row, int32_t column);

static int32_t FloatCompare_Exponent(float64_t d);

static struct MatrixData_2 *Matrix_10_get_UncheckMatrixData(struct Matrix_10 *const self);

static void RemRef_LinearAlgebra(struct LinearAlgebra *const self);

static void MatrixMath_cctor(void);

static void PositDefiniMatrix_7_CheckMatrix(struct PositiveDefiniteMatrix_7 *const self);

static void Gaussian_9_cctor(void);

static void RemRef_Gaussian_5(struct Gaussian_5 *const self);

static struct CASpace *Object_MemberwiseClone(struct CASpace *const self);

static void MatrixData_ctor_2(struct MatrixData *const self, struct float64_t_1D_5 *data, int32_t rows, int32_t columns, bool_t takeDataOwnership);

static struct CASpace *Space_ShallowCopy(struct CASpace *const self);

static void Gaussian_5_set_Expectation(struct Gaussian_5 *const self, struct CASpace *value);

static bool_t Matri_10_get_InterMatriIsInitia(struct Matrix_10 *const self);

static void MatrixData_2_ctor_1(struct MatrixData_2 *const self, struct float64_t_1D_25 *data, int32_t rows, int32_t columns, bool_t takeDataOwnership);

static void Gaussian_5_ResetCachedValues(struct Gaussian_5 *const self);

static void Gaussian_5_set_Covariance(struct Gaussian_5 *const self, struct PositiveDefiniteMatrix_7 *value);

static void RemRef_Existence(struct Existence *const self);

static void RemRef_ExistenceSpace(struct ExistenceSpace *const self);

static void RemRef_MatrixData_3(struct MatrixData_3 *const self);

static void Del_float64_t_1D_1(struct float64_t_1D_1 *const self);

static void RemRef_float64_t_1D_1(struct float64_t_1D_1 *const self);

static void Space_1_ctor(struct Space_1 *const self, int32_t dimensions);

static void FiniteSpace_ctor(struct FiniteSpace *const self, int32_t dimensions);

static void MatrixData_3_ctor_2(struct MatrixData_3 *const self, struct float64_t_1D_1 *data, int32_t rows, int32_t columns, bool_t takeDataOwnership);

static void Space_1_set_Array(struct Space_1 *const self, struct float64_t_1D_1 *value);

static void ExistenceSpace_1_cctor(void);

static void RemRef_StaticListFactory(struct StaticListFactory *const self);

static void RemRef_UniformRandomGenerator(struct UniformRandomGenerator *const self);

static void RemRef_Random(struct Random *const self);

static void Del_int32_t_1D_56(struct int32_t_1D_56 *const self);

static void RemRef_int32_t_1D_56(struct int32_t_1D_56 *const self);

static int32_t Math_AbsHelper(int32_t value);

static void RemRef_StaticList_15(struct StaticList_15 *const self);

static void RemRef_SampleProbabilityPair_2(struct SampleProbabilityPair_2 *const self);

static void Del_SampleProbabilitPair_2_1D_2(struct SampleProbabilityPair_2_1D_2 *const self);

static void RemRef_SampleProbabiPair_2_1D_2(struct SampleProbabilityPair_2_1D_2 *const self);

static void SampleSet_2_set_Samples(struct SampleSet_2 *const self, struct StaticList_15 *value);

static struct StaticList_15 *SampleSet_2_get_Samples(struct SampleSet_2 *const self);

static void StaticList_15_CheckCount(struct StaticList_15 *const self);

static void StaticList_15_set_Count(struct StaticList_15 *const self, int32_t value);

static void TwoPointDistri_set_SuccesSample(struct TwoPointDistribution *const self, struct ExistenceSpace *value);

static void TwoPointDistri_set_FailurSample(struct TwoPointDistribution *const self, struct ExistenceSpace *value);

static void RemRef_Obstacle(struct Obstacle *const self);

static void RemRef_Object_1(struct Object_1 *const self);

static void TrackWithMeasurements_1_cctor(void);

static void GaussianTrack_set_State(struct GaussianTrack *const self, struct Gaussian_5 *value);

static void GaussianTrack_set_Existence(struct GaussianTrack *const self, struct Existence *value);

static void GaussianTrack_set_ID(struct GaussianTrack *const self, uint64_t value);

static void TrackWithMeasu_set_ARS308Object(struct TrackWithMeasurements *const self, struct Object_1 *value);

static void TrackWithMeasureme_set_Obstacle(struct TrackWithMeasurements *const self, struct Obstacle *value);

static void RemRef_StaticList_12(struct StaticList_12 *const self);

static void Del_float64_t_1D_3(struct float64_t_1D_3 *const self);

static void RemRef_float64_t_1D_3(struct float64_t_1D_3 *const self);

static void Del_RadarSpace_1D_15(struct RadarSpace_1D_15 *const self);

static void RemRef_RadarSpace_1D_15(struct RadarSpace_1D_15 *const self);

static void RemRef_RadarSpace(struct RadarSpace *const self);

static void RemRef_MatrixData_4(struct MatrixData_4 *const self);

static void Space_2_ctor(struct Space_2 *const self, int32_t dimensions);

static void AnguSpace_1_set_AngulDimenIndic(struct AngularSpace_1 *const self, struct int32_t_1D_1 *value);

static void AngularSpace_1_ctor(struct AngularSpace_1 *const self, int32_t dimensions, struct int32_t_1D_1 *angularDimensionsIndices, struct int32_t_1D_0 *additionAngularDimensionIndices);

static void AngularSpace_1_ctor_1(struct AngularSpace_1 *const self, int32_t dimensions, struct int32_t_1D_1 *angularDimensionsIndices);

static void StaticList_12_CheckCount(struct StaticList_12 *const self);

static void StaticList_12_set_Count(struct StaticList_12 *const self, int32_t value);

static void RemRef_StaticList_4(struct StaticList_4 *const self);

static void Del_Obstacle_1D_40(struct Obstacle_1D_40 *const self);

static void RemRef_Obstacle_1D_40(struct Obstacle_1D_40 *const self);

static void Obstacle_set_Id(struct Obstacle *const self, int32_t value);

static void Obstacle_set_PositionX(struct Obstacle *const self, float64_t value);

static void Obstacle_set_PositionY(struct Obstacle *const self, float64_t value);

static void Obstacle_set_VelocityX(struct Obstacle *const self, float64_t value);

static void Obstacle_set_VelocityY(struct Obstacle *const self, float64_t value);

static void Obstacle_set_Width(struct Obstacle *const self, float64_t value);

static void Obstacle_set_Length(struct Obstacle *const self, float64_t value);

static void Obstacle_set_Timestamp(struct Obstacle *const self, uint32_t value);

static void Obstacle_set_ObstacleStatus(struct Obstacle *const self, ObstacleStatus value);

static void Obstacle_set_ObstacleType(struct Obstacle *const self, ObstacleType value);

static void Obstacle_set_AngleRate(struct Obstacle *const self, float64_t value);

static void Obstacle_set_AccelerationX(struct Obstacle *const self, float64_t value);

static void Obstacle_set_Angle(struct Obstacle *const self, float64_t value);

static void Obstacle_set_CIPVFlag(struct Obstacle *const self, bool_t value);

static void StaticList_4_CheckCount(struct StaticList_4 *const self);

static void StaticList_4_set_Count(struct StaticList_4 *const self, int32_t value);

static void RemRef_StaticList_6(struct StaticList_6 *const self);

static void Del_float64_t_1D_4(struct float64_t_1D_4 *const self);

static void RemRef_float64_t_1D_4(struct float64_t_1D_4 *const self);

static void Del_MobilEyeSpace_1D_40(struct MobilEyeSpace_1D_40 *const self);

static void RemRef_MobilEyeSpace_1D_40(struct MobilEyeSpace_1D_40 *const self);

static void RemRef_MobilEyeSpace(struct MobilEyeSpace *const self);

static void RemRef_MatrixData_5(struct MatrixData_5 *const self);

static void Space_3_ctor(struct Space_3 *const self, int32_t dimensions);

static void StaticList_6_CheckCount(struct StaticList_6 *const self);

static void StaticList_6_set_Count(struct StaticList_6 *const self, int32_t value);

static void Object_1_set_RollingCounter(struct Object_1 *const self, uint32_t value);

static void Object_1_set_ID(struct Object_1 *const self, uint32_t value);

static void Object_1_set_LongitudiDisplacem(struct Object_1 *const self, float64_t value);

static void Object_1_set_RelatiLongitVeloci(struct Object_1 *const self, float64_t value);

static void Object_1_set_AcceleratLongitudi(struct Object_1 *const self, float64_t value);

static void Object_1_set_ProbabilOfExistanc(struct Object_1 *const self, float64_t value);

static void Object_1_set_DynamicProperty(struct Object_1 *const self, DynamicProperty value);

static void Object_1_set_LateralDisplacemen(struct Object_1 *const self, float64_t value);

static void Object_1_set_Length(struct Object_1 *const self, float64_t value);

static void Object_1_set_Width(struct Object_1 *const self, float64_t value);

static void Object_1_set_MeasurementStatus(struct Object_1 *const self, MeasurementStatus value);

static void Object_1_set_RCSValue(struct Object_1 *const self, float64_t value);

static void Object_1_set_LateralSpeed(struct Object_1 *const self, float64_t value);

static void Object_1_set_ObstacleProbabilit(struct Object_1 *const self, float64_t value);

static void RemRef_StaticList_9(struct StaticList_9 *const self);

static void RemRef_FrontRadarObjectSpace(struct FrontRadarObjectSpace *const self);

static void Del_FrontRadarObjectSpace_1D_40(struct FrontRadarObjectSpace_1D_40 *const self);

static void RemRef_FronRadaObjecSpace_1D_40(struct FrontRadarObjectSpace_1D_40 *const self);

static void CVComponentsSpace_ctor(struct CVComponentsSpace *const self, int32_t additionalDimensions);

static void Space_set_LastSetIndex(struct Space *const self, struct Nullable value);

static void StaticList_9_CheckCount(struct StaticList_9 *const self);

static void StaticList_9_set_Count(struct StaticList_9 *const self, int32_t value);

static void RemRef_Measure_2(struct Measure_2 *const self);

static void RemRef_Measure_3(struct Measure_3 *const self);

static void Tracking_1_cctor(void);

static void RemRef_Tracking(struct Tracking *const self);

static void RemRef_SensorProperties(struct SensorProperties *const self);

static void RemRef_FrontRadarNearParameters(struct FrontRadarNearParameters *const self);

static void FroRadNearPara_CalcNoisMatrDiag(struct FrontRadarNearParameters *const self);

static struct FrontRadarNearParameters *SenPro_1_GetDefFronRadaNearPara(void);

static void RemRef_FrontRadarFarParameters(struct FrontRadarFarParameters *const self);

static void FroRadaFarPara_CalcNoisMatrDiag(struct FrontRadarFarParameters *const self);

static struct FrontRadarFarParameters *SenPro_1_GetDefaFronRadaFarPara(void);

static void RemRef_MobilEyeParameters(struct MobilEyeParameters *const self);

static void MobiEyePara_CalcNoiseMatriDiago(struct MobilEyeParameters *const self);

static struct MobilEyeParameters *SensProp_1_GetDefaMobilEyeParam(void);

static void Del_Vector2D_1D_10(struct Vector2D_1D_10 *const self);

static void RemRef_Vector2D_1D_10(struct Vector2D_1D_10 *const self);

static void RemRef_FrontRadarObjectParamete(struct FrontRadarObjectParameters *const self);

static void FroRadObjePara_CalcNoisMatrDiag(struct FrontRadarObjectParameters *const self);

static struct FrontRadarObjectParameters *SenPro_1_GetDefFronRadaObjePara(void);

static void Space_set_LastGetIndex(struct Space *const self, struct Nullable value);

static void RemRef_EgoMotionFilter(struct EgoMotionFilter *const self);

static void Del_float64_t_1D_2(struct float64_t_1D_2 *const self);

static void RemRef_float64_t_1D_2(struct float64_t_1D_2 *const self);

static void RemRef_PositiveDefiniteMatrix_4(struct PositiveDefiniteMatrix_4 *const self);

static void RemRef_CTRAErrorSpace(struct CTRAErrorSpace *const self);

static void RemRef_MatrixData_8(struct MatrixData_8 *const self);

static void Space_4_ctor(struct Space_4 *const self, int32_t dimensions);

static void RemRef_MatrixData_6(struct MatrixData_6 *const self);

static void MatrixData_6_SetValueFast(struct MatrixData_6 *const self, float64_t value, int32_t row, int32_t column);

static void Matrix_4_set_UncheckeMatrixData(struct Matrix_4 *const self, struct MatrixData_6 *value);

static void Matrix_4_CheckMatrix(struct Matrix_4 *const self);

static void SquareMatrix_4_CheckMatrix(struct SquareMatrix_4 *const self);

static float64_t MatrixData_6_GetValueFast(struct MatrixData_6 *const self, int32_t row, int32_t column);

static float64_t Matrix_4_UncheckedGet(struct Matrix_4 *const self, int32_t row, int32_t column);

static struct MatrixData_6 *Matrix_4_get_UncheckeMatrixData(struct Matrix_4 *const self);

static void PositDefiniMatrix_4_CheckMatrix(struct PositiveDefiniteMatrix_4 *const self);

static void RemRef_CTRASpace(struct CTRASpace *const self);

static void RemRef_MatrixData_9(struct MatrixData_9 *const self);

static void Del_float64_t_1D_6(struct float64_t_1D_6 *const self);

static void RemRef_float64_t_1D_6(struct float64_t_1D_6 *const self);

static void Space_5_ctor(struct Space_5 *const self, int32_t dimensions);

static void AnguSpace_2_set_AngulDimenIndic(struct AngularSpace_2 *const self, struct int32_t_1D_1 *value);

static void AngularSpace_2_ctor(struct AngularSpace_2 *const self, int32_t dimensions, struct int32_t_1D_1 *angularDimensionsIndices, struct int32_t_1D_0 *additionAngularDimensionIndices);

static void CTRASpace_ctor_1(struct CTRASpace *const self, int32_t additionalDimensions, struct int32_t_1D_0 *additionAngularDimensionIndices);

static void CTRASpace_ctor_2(struct CTRASpace *const self, int32_t additionalDimensions);

static void CTRAModel_1_cctor(void);

static void RemRef_CTRAModel(struct CTRAModel *const self);

static void TimeSpan_1_cctor(void);

static void SystemModel_1_ctor(struct SystemModel_1 *const self, struct PositiveDefiniteMatrix_4 *processNoiseCovariance);

static void SystemModel_3_ctor(struct SystemModel_3 *const self, struct PositiveDefiniteMatrix_4 *processNoiseCovariance);

static void SystemModel_5_ctor(struct SystemModel_5 *const self, struct PositiveDefiniteMatrix_4 *processNoiseCovariance);

static void RemRef_PositiveDefiniteMatrix(struct PositiveDefiniteMatrix *const self);

static void RemRef_VelocitySpace(struct VelocitySpace *const self);

static void MatrixData_3_SetValueFast(struct MatrixData_3 *const self, float64_t value, int32_t row, int32_t column);

static void Matrix_set_UncheckedMatrixData(struct Matrix *const self, struct MatrixData_3 *value);

static void Matrix_CheckMatrix(struct Matrix *const self);

static void SquareMatrix_CheckMatrix(struct SquareMatrix *const self);

static float64_t MatrixData_3_GetValueFast(struct MatrixData_3 *const self, int32_t row, int32_t column);

static float64_t Matrix_UncheckedGet(struct Matrix *const self, int32_t row, int32_t column);

static struct MatrixData_3 *Matrix_get_UncheckedMatrixData(struct Matrix *const self);

static void PositiDefinitMatrix_CheckMatrix(struct PositiveDefiniteMatrix *const self);

static void VelocityMeasuremenModel_1_cctor(void);

static void RemRef_VelocityMeasurementModel(struct VelocityMeasurementModel *const self);

static void MeasurementModel_ctor(struct MeasurementModel *const self, struct PositiveDefiniteMatrix *measurementNoiseCovariance);

static void MeasurementModel_4_ctor(struct MeasurementModel_4 *const self, struct PositiveDefiniteMatrix *measurementNoiseCovariance);

static void MeasurementModel_8_ctor(struct MeasurementModel_8 *const self, struct PositiveDefiniteMatrix *measurementNoiseCovariance);

static void RemRef_PositiveDefiniteMatrix_1(struct PositiveDefiniteMatrix_1 *const self);

static void RemRef_YawRateSpace(struct YawRateSpace *const self);

static void Matrix_1_set_UncheckeMatrixData(struct Matrix_1 *const self, struct MatrixData_3 *value);

static void Matrix_1_CheckMatrix(struct Matrix_1 *const self);

static void SquareMatrix_1_CheckMatrix(struct SquareMatrix_1 *const self);

static float64_t Matrix_1_UncheckedGet(struct Matrix_1 *const self, int32_t row, int32_t column);

static struct MatrixData_3 *Matrix_1_get_UncheckeMatrixData(struct Matrix_1 *const self);

static void PositDefiniMatrix_1_CheckMatrix(struct PositiveDefiniteMatrix_1 *const self);

static void YawRateMeasurementModel_1_cctor(void);

static void RemRef_YawRateMeasurementModel(struct YawRateMeasurementModel *const self);

static void MeasurementModel_1_ctor(struct MeasurementModel_1 *const self, struct PositiveDefiniteMatrix_1 *measurementNoiseCovariance);

static void MeasurementModel_5_ctor(struct MeasurementModel_5 *const self, struct PositiveDefiniteMatrix_1 *measurementNoiseCovariance);

static void Gaussian_6_cctor(void);

static void RemRef_Gaussian_4(struct Gaussian_4 *const self);

static void Gaussian_4_set_Expectation(struct Gaussian_4 *const self, struct CTRASpace *value);

static void RemRef_PositiveDefiniteMatrix_6(struct PositiveDefiniteMatrix_6 *const self);

static void Gaussian_4_ResetCachedValues(struct Gaussian_4 *const self);

static void Gaussian_4_set_Covariance(struct Gaussian_4 *const self, struct PositiveDefiniteMatrix_6 *value);

static void Del_float64_t_1D_36(struct float64_t_1D_36 *const self);

static void RemRef_float64_t_1D_36(struct float64_t_1D_36 *const self);

static void RemRef_MatrixData_11(struct MatrixData_11 *const self);

static void MatrixData_11_SetValueFast(struct MatrixData_11 *const self, float64_t value, int32_t row, int32_t column);

static void Matrix_6_MatrixChanged(struct Matrix_6 *const self);

static void SquareMatrix_6_MatrixChanged(struct SquareMatrix_6 *const self);

static void PositDefinMatrix_6_MatrixChange(struct PositiveDefiniteMatrix_6 *const self);

static void RemRef_StaticListEnumerator_15(struct StaticListEnumerator_15 *const self);

static void StaticList_27_CheckCount(struct StaticList_27 *const self);

static void StaticList_27_set_Count(struct StaticList_27 *const self, int32_t value);

static void ThrowHelpe_ThrowInvalOperaExcep(ExceptionResource resource);

static int64_t DateTime_get_InternalTicks(struct DateTime *const self);

static void RemRef_SquareMatrix_6(struct SquareMatrix_6 *const self);

static void Matrix_6_CheckMatrix(struct Matrix_6 *const self);

static void SquareMatrix_6_CheckMatrix(struct SquareMatrix_6 *const self);

static struct CTRASpace *SystemModel_1_get_Condition(struct SystemModel_1 *const self);

static struct TimeSpan SystemModel_1_get_TimeCondition(struct SystemModel_1 *const self);

static void Space_5_set_LastGetIndex(struct Space_5 *const self, struct Nullable value);

static void MatrixData_11_ctor_1(struct MatrixData_11 *const self, struct float64_t_1D_36 *data, int32_t rows, int32_t columns, bool_t takeDataOwnership);

static void RemRef_Matrix_7(struct Matrix_7 *const self);

static void Space_4_set_LastGetIndex(struct Space_4 *const self, struct Nullable value);

static void Del_float64_t_1D_12(struct float64_t_1D_12 *const self);

static void RemRef_float64_t_1D_12(struct float64_t_1D_12 *const self);

static void RemRef_MatrixData_12(struct MatrixData_12 *const self);

static void MatrixData_12_SetValueFast(struct MatrixData_12 *const self, float64_t value, int32_t row, int32_t column);

static void Matrix_7_MatrixChanged(struct Matrix_7 *const self);

static float64_t MatrixData_11_GetValueFast(struct MatrixData_11 *const self, int32_t row, int32_t column);

static void Matrix_6_set_UncheckeMatrixData(struct Matrix_6 *const self, struct MatrixData_11 *value);

static struct CTRASpace *Object_MemberwiseClone_1(struct CTRASpace *const self);

static void MatrixData_9_ctor_1(struct MatrixData_9 *const self, struct float64_t_1D_6 *data, int32_t rows, int32_t columns, bool_t takeDataOwnership);

static struct CTRASpace *Space_5_ShallowCopy(struct CTRASpace *const self);

static struct CTRAErrorSpace *SystemModel_1_get_Condition2(struct SystemModel_1 *const self);

static void Space_5_set_LastSetIndex(struct Space_5 *const self, struct Nullable value);

static void Gaussian_4_ctor_2(struct Gaussian_4 *const self, bool_t noInitialization);

static void Space_1_set_LastSetIndex(struct Space_1 *const self, struct Nullable value);

static void RemRef_Matrix_8(struct Matrix_8 *const self);

static struct CTRASpace *MeasurementModel_get_Condition(struct MeasurementModel *const self);

static void Space_1_set_LastGetIndex(struct Space_1 *const self, struct Nullable value);

static void RemRef_MatrixData_10(struct MatrixData_10 *const self);

static void MatrixData_10_SetValueFast(struct MatrixData_10 *const self, float64_t value, int32_t row, int32_t column);

static void Matrix_8_MatrixChanged(struct Matrix_8 *const self);

static void Gaussian_7_cctor(void);

static void RemRef_Gaussian(struct Gaussian *const self);

static void Gaussian_set_Expectation(struct Gaussian *const self, struct VelocitySpace *value);

static void Gaussian_ResetCachedValues(struct Gaussian *const self);

static void Gaussian_set_Covariance(struct Gaussian *const self, struct PositiveDefiniteMatrix *value);

static void Gaussian_ctor(struct Gaussian *const self, bool_t noInitialization);

static void LinearAlgebr_1_SolveUpperTriang(struct float64_t_1D_1 *a, int32_t lda, int32_t rank, struct float64_t_1D_1 *b, int32_t ldb, int32_t rightHandSides, bool_t ignoreDiagonal);

static struct float64_t_1D_1 *Space_1_Subtract(struct Space_1 *const self, struct Space_1 *other);

static void MatrixData_3_ctor_3(struct MatrixData_3 *const self, struct float64_t_1D_1 *data, bool_t takeDataOwnership);

static struct float64_t_1D_6 *Space_5_Subtract(struct Space_5 *const self, struct Space_5 *other);

static struct float64_t_1D_6 *AngularSpace_2_Subtract(struct AngularSpace_2 *const self, struct Space_5 *other);

static void RemRef_Matrix_9(struct Matrix_9 *const self);

static struct CTRASpace *MeasuremenModel_1_get_Condition(struct MeasurementModel_1 *const self);

static void Matrix_9_MatrixChanged(struct Matrix_9 *const self);

static void Gaussian_8_cctor(void);

static void RemRef_Gaussian_1(struct Gaussian_1 *const self);

static void Gaussian_1_set_Expectation(struct Gaussian_1 *const self, struct YawRateSpace *value);

static void Gaussian_1_ResetCachedValues(struct Gaussian_1 *const self);

static void Gaussian_1_set_Covariance(struct Gaussian_1 *const self, struct PositiveDefiniteMatrix_1 *value);

static void Gaussian_1_ctor(struct Gaussian_1 *const self, bool_t noInitialization);

static void RemRef_StaticListFactory_1(struct StaticListFactory_1 *const self);

static void RemRef_StatIPDATracCollFactProv(struct StatiIPDATrackColleFactorProvid *const self);

static void RemRef_StaticListFactory_2(struct StaticListFactory_2 *const self);

static void RemRef_StaticListFactory_3(struct StaticListFactory_3 *const self);

static void RemRef_StaticAssociTableFactory(struct StaticAssociationTableFactory *const self);

static void RemRef_StaticListFactory_4(struct StaticListFactory_4 *const self);

static void RemRef_StaticListFactory_5(struct StaticListFactory_5 *const self);

static bool_t Matri_6_get_InterMatrixIsInitia(struct Matrix_6 *const self);

static struct MatrixData_11 *Matrix_6_get_UncheckeMatrixData(struct Matrix_6 *const self);

static void EgoMotionFilter_ResetPosition(struct EgoMotionFilter *const self);

static void RemRef_StaticList_23(struct StaticList_23 *const self);

static void Del_Gaussian_5_1D_15(struct Gaussian_5_1D_15 *const self);

static void RemRef_Gaussian_5_1D_15(struct Gaussian_5_1D_15 *const self);

static void RemRef_StaticList_20(struct StaticList_20 *const self);

static void RemRef_Gaussian_2(struct Gaussian_2 *const self);

static void Del_Gaussian_2_1D_15(struct Gaussian_2_1D_15 *const self);

static void RemRef_Gaussian_2_1D_15(struct Gaussian_2_1D_15 *const self);

static void RemRef_StaticList_16(struct StaticList_16 *const self);

static void RemRef_Matrix_11(struct Matrix_11 *const self);

static void Del_Matrix_11_1D_15(struct Matrix_11_1D_15 *const self);

static void RemRef_Matrix_11_1D_15(struct Matrix_11_1D_15 *const self);

static void RemRef_StaticList_26(struct StaticList_26 *const self);

static void Del_Existence_1D_15(struct Existence_1D_15 *const self);

static void RemRef_Existence_1D_15(struct Existence_1D_15 *const self);

static void RemRef_StaticList_22(struct StaticList_22 *const self);

static void RemRef_MarginalizedEvaluable(struct MarginalizedEvaluable *const self);

static void Del_MarginalizedEvaluable_1D_15(struct MarginalizedEvaluable_1D_15 *const self);

static void RemRef_MarginaliEvaluable_1D_15(struct MarginalizedEvaluable_1D_15 *const self);

static void RemRef_PositiveDefiniteMatrix_2(struct PositiveDefiniteMatrix_2 *const self);

static void RemRef_CAErrorSpace(struct CAErrorSpace *const self);

static void RemRef_MatrixData_13(struct MatrixData_13 *const self);

static void Del_float64_t_1D_9(struct float64_t_1D_9 *const self);

static void RemRef_float64_t_1D_9(struct float64_t_1D_9 *const self);

static void MatrixData_13_SetValueFast(struct MatrixData_13 *const self, float64_t value, int32_t row, int32_t column);

static void Matrix_2_set_UncheckeMatrixData(struct Matrix_2 *const self, struct MatrixData_13 *value);

static void Matrix_2_CheckMatrix(struct Matrix_2 *const self);

static void SquareMatrix_2_CheckMatrix(struct SquareMatrix_2 *const self);

static float64_t MatrixData_13_GetValueFast(struct MatrixData_13 *const self, int32_t row, int32_t column);

static float64_t Matrix_2_UncheckedGet(struct Matrix_2 *const self, int32_t row, int32_t column);

static struct MatrixData_13 *Matrix_2_get_UncheckeMatrixData(struct Matrix_2 *const self);

static void PositDefiniMatrix_2_CheckMatrix(struct PositiveDefiniteMatrix_2 *const self);

static void CAModel_1_cctor(void);

static void RemRef_CAModel(struct CAModel *const self);

static void SystemModel_ctor(struct SystemModel *const self, struct PositiveDefiniteMatrix_2 *processNoiseCovariance);

static void SystemModel_2_ctor(struct SystemModel_2 *const self, struct PositiveDefiniteMatrix_2 *processNoiseCovariance);

static void SystemModel_4_ctor(struct SystemModel_4 *const self, struct PositiveDefiniteMatrix_2 *processNoiseCovariance);

static struct CAModel *Tracking_GetSystemModel(struct Tracking *const self);

static void RemRef_PersistenceModel(struct PersistenceModel *const self);

static void RemRef_MobilEyeDetectionModel(struct MobilEyeDetectionModel *const self);

static void DetectionModel_ctor(struct DetectionModel *const self);

static void SingleDetectionModel_ctor(struct SingleDetectionModel *const self, float64_t gateProbability);

static void RemRef_EgoMotionCompensation(struct EgoMotionCompensation *const self);

static void Gaussian_5_ctor_2(struct Gaussian_5 *const self, bool_t noInitialization);

static void RemRef_SquareMatrix_7(struct SquareMatrix_7 *const self);

static void Matrix_10_MatrixChanged(struct Matrix_10 *const self);

static void SquareMatrix_7_MatrixChanged(struct SquareMatrix_7 *const self);

static struct CASpace *SystemModel_get_Condition(struct SystemModel *const self);

static struct TimeSpan SystemModel_get_TimeCondition(struct SystemModel *const self);

static void RemRef_Matrix_12(struct Matrix_12 *const self);

static void Space_2_set_LastGetIndex(struct Space_2 *const self, struct Nullable value);

static void Del_float64_t_1D_15(struct float64_t_1D_15 *const self);

static void RemRef_float64_t_1D_15(struct float64_t_1D_15 *const self);

static void RemRef_MatrixData_14(struct MatrixData_14 *const self);

static void MatrixData_14_SetValueFast(struct MatrixData_14 *const self, float64_t value, int32_t row, int32_t column);

static void Matrix_12_MatrixChanged(struct Matrix_12 *const self);

static struct CAErrorSpace *SystemModel_get_Condition2(struct SystemModel *const self);

static void StaticList_23_CheckCount(struct StaticList_23 *const self);

static void StaticList_23_set_Count(struct StaticList_23 *const self, int32_t value);

static void TwoPointDistribution_1_cctor(void);

static void RemRef_TwoPointDistribution(struct TwoPointDistribution *const self);

static struct ExistenceSpace *PersistenceModel_get_Condition(struct PersistenceModel *const self);

static void RemRef_Type(struct Type *const self);

static struct TimeSpan PersisteModel_get_TimeCondition(struct PersistenceModel *const self);

static void StaticList_26_CheckCount(struct StaticList_26 *const self);

static void StaticList_26_set_Count(struct StaticList_26 *const self, int32_t value);

static void MobilEyeMeasuremenModel_1_cctor(void);

static void RemRef_MobilEyeMeasurementModel(struct MobilEyeMeasurementModel *const self);

static void RemRef_PositiveDefiniteMatrix_3(struct PositiveDefiniteMatrix_3 *const self);

static void RemRef_MatrixData_15(struct MatrixData_15 *const self);

static void Del_float64_t_1D_16(struct float64_t_1D_16 *const self);

static void RemRef_float64_t_1D_16(struct float64_t_1D_16 *const self);

static void MatrixData_15_SetValueFast(struct MatrixData_15 *const self, float64_t value, int32_t row, int32_t column);

static void Matrix_3_set_UncheckeMatrixData(struct Matrix_3 *const self, struct MatrixData_15 *value);

static void Matrix_3_CheckMatrix(struct Matrix_3 *const self);

static void SquareMatrix_3_CheckMatrix(struct SquareMatrix_3 *const self);

static float64_t MatrixData_15_GetValueFast(struct MatrixData_15 *const self, int32_t row, int32_t column);

static float64_t Matrix_3_UncheckedGet(struct Matrix_3 *const self, int32_t row, int32_t column);

static struct MatrixData_15 *Matrix_3_get_UncheckeMatrixData(struct Matrix_3 *const self);

static void PositDefiniMatrix_3_CheckMatrix(struct PositiveDefiniteMatrix_3 *const self);

static void MeasurementModel_2_ctor(struct MeasurementModel_2 *const self, struct PositiveDefiniteMatrix_3 *measurementNoiseCovariance);

static void MeasurementModel_6_ctor(struct MeasurementModel_6 *const self, struct PositiveDefiniteMatrix_3 *measurementNoiseCovariance);

static void CarteMeasuModel_set_SensoParame(struct CartesianMeasurementModel *const self, struct MobilEyeParameters *value);

static void CartesianMeasurementModel_ctor(struct CartesianMeasurementModel *const self, struct MobilEyeParameters *sensorParameters);

static void MobiEyeMeasModel_set_EgoYawRate(struct MobilEyeMeasurementModel *const self, float64_t value);

static void Matrix_3_MatrixChanged(struct Matrix_3 *const self);

static void SquareMatrix_3_MatrixChanged(struct SquareMatrix_3 *const self);

static void PositDefinMatrix_3_MatrixChange(struct PositiveDefiniteMatrix_3 *const self);

static struct CASpace *MeasuremenModel_2_get_Condition(struct MeasurementModel_2 *const self);

static void Space_3_set_LastGetIndex(struct Space_3 *const self, struct Nullable value);

static void Del_float64_t_1D_20(struct float64_t_1D_20 *const self);

static void RemRef_float64_t_1D_20(struct float64_t_1D_20 *const self);

static void RemRef_MatrixData_16(struct MatrixData_16 *const self);

static void MatrixData_16_SetValueFast(struct MatrixData_16 *const self, float64_t value, int32_t row, int32_t column);

static void Matrix_11_MatrixChanged(struct Matrix_11 *const self);

static float64_t MobiEyeMeasModel_get_EgoYawRate(struct MobilEyeMeasurementModel *const self);

static void Space_3_set_LastSetIndex(struct Space_3 *const self, struct Nullable value);

static float64_t CartesMeasureModel_get_Conditi2(struct CartesianMeasurementModel *const self);

static void Gaussian_10_cctor(void);

static void Gaussian_2_set_Expectation(struct Gaussian_2 *const self, struct MobilEyeSpace *value);

static void Gaussian_2_ResetCachedValues(struct Gaussian_2 *const self);

static void Gaussian_2_set_Covariance(struct Gaussian_2 *const self, struct PositiveDefiniteMatrix_3 *value);

static void Gaussian_2_ctor(struct Gaussian_2 *const self, bool_t noInitialization);

static void StaticList_16_CheckCount(struct StaticList_16 *const self);

static void StaticList_16_set_Count(struct StaticList_16 *const self, int32_t value);

static void StaticList_20_CheckCount(struct StaticList_20 *const self);

static void StaticList_20_set_Count(struct StaticList_20 *const self, int32_t value);

static int32_t MatrixData_15_GetIndexTranspose(struct MatrixData_15 *const self, int32_t row, int32_t column);

static int32_t MatrixData_15_GetIndex(struct MatrixData_15 *const self, int32_t row, int32_t column);

static void RemRef_SquareMatrix_3(struct SquareMatrix_3 *const self);

static void RemRef_MatrixData_18(struct MatrixData_18 *const self);

static void Del_float64_t_1D_200(struct float64_t_1D_200 *const self);

static void RemRef_float64_t_1D_200(struct float64_t_1D_200 *const self);

static int32_t Random_InternalSample(struct Random *const self);

static float64_t Random_Sample(struct Random *const self);

static struct MatrixData_18 *Tracking_1_CreateRandnMatrix(int32_t rows, int32_t columns);

static void RemRef_StaticList_7(struct StaticList_7 *const self);

static void Del_MobilEyeSpace_1D_50(struct MobilEyeSpace_1D_50 *const self);

static void RemRef_MobilEyeSpace_1D_50(struct MobilEyeSpace_1D_50 *const self);

static void StaticList_7_CheckCount(struct StaticList_7 *const self);

static void StaticList_7_set_Count(struct StaticList_7 *const self, int32_t value);

static struct StaticList_7 *Tracking_1_Draw(struct Gaussian_2 *state, int32_t count);

static void SampleSet_3_cctor(void);

static void RemRef_SampleSet(struct SampleSet *const self);

static void RemRef_StaticList_13(struct StaticList_13 *const self);

static void RemRef_SampleProbabilityPair(struct SampleProbabilityPair *const self);

static void Del_SampleProbabilityPair_1D_50(struct SampleProbabilityPair_1D_50 *const self);

static void RemRef_SampleProbabilPair_1D_50(struct SampleProbabilityPair_1D_50 *const self);

static void SampleSet_set_Samples(struct SampleSet *const self, struct StaticList_13 *value);

static void RemRef_StaticListEnumerator_3(struct StaticListEnumerator_3 *const self);

static struct MobilEyeSpace *Object_MemberwiseClone_2(struct MobilEyeSpace *const self);

static void MatrixData_5_ctor_1(struct MatrixData_5 *const self, struct float64_t_1D_4 *data, int32_t rows, int32_t columns, bool_t takeDataOwnership);

static struct MobilEyeSpace *Space_3_ShallowCopy(struct MobilEyeSpace *const self);

static struct StaticList_13 *SampleSet_get_Samples(struct SampleSet *const self);

static void StaticList_13_CheckCount(struct StaticList_13 *const self);

static void StaticList_13_set_Count(struct StaticList_13 *const self, int32_t value);

static void RemRef_StaticListEnumerator_8(struct StaticListEnumerator_8 *const self);

static void StaticList_22_CheckCount(struct StaticList_22 *const self);

static void StaticList_22_set_Count(struct StaticList_22 *const self, int32_t value);

static void RemRef_ProbabilityGate(struct ProbabilityGate *const self);

static float64_t Gaussia_10_InverseNormalDistrib(float64_t y0);

static float64_t Gaus_10_LnGammXGreaOrEquaMinu34(float64_t x);

static float64_t Gaussian_10_LnGamma(float64_t x);

static float64_t Ga_10_InGamIntXSmaTha1OrSmaThaA(float64_t a, float64_t x);

static float64_t Gauss_10_ComplIncompGammaIntegr(float64_t a, float64_t x);

static float64_t Gaus_10_InveCompIncomGammaInteg(float64_t a, float64_t y0);

static void RemRef_SquaredMahalanobDistance(struct SquaredMahalanobisDistance *const self);

static void RemRef_IMetric(struct IMetric *const self);

static void Gate_set_MaximumDistance(struct Gate *const self, float64_t value);

static void GaussianGate_set_GateProbabilit(struct GaussianGate *const self, float64_t value);

static void GaussianGate_ctor(struct GaussianGate *const self, float64_t maxSquaredMahalanobisDistance, float64_t gateProbability);

static void MultipLocalNearesNeighb_1_cctor(void);

static void RemRef_MultipLocalNearesNeighbo(struct MultipleLocalNearestNeighbor *const self);

static void RemRef_IEnumerable(struct IEnumerable *const self);

static void RemRef_IEnumerable_1(struct IEnumerable_1 *const self);

static void RemRef_IEnumerable_2(struct IEnumerable_2 *const self);

static void RemRef_IAssociationAlgorithm(struct IAssociationAlgorithm *const self);

static void RemRef_MeasurementAssociation(struct MeasurementAssociation *const self);

static void Association_set_Objects1(struct Association *const self, struct StaticList_20 *value);

static void Association_set_Objects2(struct Association *const self, struct StaticList_6 *value);

static void RemRef_StaticListEnumerator_12(struct StaticListEnumerator_12 *const self);

static struct StaticList_20 *Association_get_Objects1(struct Association *const self);

static void RemRef_StaticListEnumerator_2(struct StaticListEnumerator_2 *const self);

static struct StaticList_6 *Association_get_Objects2(struct Association *const self);

static void RemRef_AssociationTable(struct AssociationTable *const self);

static void Del_float64_t_2D_15_40(struct float64_t_2D_15_40 *const self);

static void RemRef_float64_t_2D_15_40(struct float64_t_2D_15_40 *const self);

static void AssociationTable_ctor(struct AssociationTable *const self, int32_t rows, int32_t columns, int32_t maximumNumberOfRows, int32_t maximumNumberOfColumns);

static void Associatio_set_AssociationTable(struct Association *const self, struct AssociationTable *value);

static void Association_ctor(struct Association *const self, struct StaticList_20 *objects1, struct StaticList_6 *objects2, struct MultipleLocalNearestNeighbor *associationAlgorithm, struct StatiIPDATrackColleFactorProvid *factoryProvider);

static void RemRef_StaticListEnumerator_14(struct StaticListEnumerator_14 *const self);

static struct AssociationTable *Associatio_get_AssociationTable(struct Association *const self);

static struct float64_t_1D_4 *Space_3_Subtract(struct Space_3 *const self, struct Space_3 *other);

static void MatrixData_5_ctor_2(struct MatrixData_5 *const self, struct float64_t_1D_4 *data, bool_t takeDataOwnership);

static void MatrixData_15_ctor_1(struct MatrixData_15 *const self, struct float64_t_1D_16 *data, int32_t rows, int32_t columns, bool_t takeDataOwnership);

static void LineaAlgebr_1_SolveUpperTriang(struct float64_t_1D_16 *a, int32_t lda, int32_t rank, struct float64_t_1D_16 *b, int32_t ldb, int32_t rightHandSides, bool_t ignoreDiagonal);

static void RemRef_MatrixData_7(struct MatrixData_7 *const self);

static void Del_int32_t_1D_4(struct int32_t_1D_4 *const self);

static void RemRef_int32_t_1D_4(struct int32_t_1D_4 *const self);

static void Del_int32_t_1D_40(struct int32_t_1D_40 *const self);

static void RemRef_int32_t_1D_40(struct int32_t_1D_40 *const self);

static void RemRef_IAssociationTable(struct IAssociationTable *const self);

static void RemRef_StaticList_5(struct StaticList_5 *const self);

static void Del_StaticList_1D_15(struct StaticList_1D_15 *const self);

static void RemRef_StaticList_1D_15(struct StaticList_1D_15 *const self);

static void RemRef_StaticList(struct StaticList *const self);

static void StaticList_5_CheckCount(struct StaticList_5 *const self);

static void StaticList_5_set_Count(struct StaticList_5 *const self, int32_t value);

static void StaticList_CheckCount(struct StaticList *const self);

static void StaticList_set_Count(struct StaticList *const self, int32_t value);

static void Associatio_DetermineAssociation(struct Association *const self);

static void RemRef_StaticListEnumerator(struct StaticListEnumerator *const self);

static void RemRef_IEvaluable(struct IEvaluable *const self);

static void RemRef_IEvaluable_1(struct IEvaluable_1 *const self);

static void RemRef_IEvaluable_2(struct IEvaluable_2 *const self);

static void IPDA_3_cctor(void);

static void RemRef_IPDA(struct IPDA *const self);

static void IPDA_set_Lambda(struct IPDA *const self, float64_t value);

static void RemRef_CardinalitySpace(struct CardinalitySpace *const self);

static struct MobilEyeSpace *DetectionModel_get_Condition(struct DetectionModel *const self);

static float64_t MobiEyeDetecModel_GetDetecProba(struct MobilEyeDetectionModel *const self, struct MobilEyeSpace *state);

static float64_t SinglDetecModel_GetDetectProbab(struct MobilEyeDetectionModel *const self, struct CardinalitySpace *sample, struct MobilEyeSpace *state);

static void RemRef_StaticList_1(struct StaticList_1 *const self);

static void Del_float64_t_1D_40(struct float64_t_1D_40 *const self);

static void RemRef_float64_t_1D_40(struct float64_t_1D_40 *const self);

static void StaticList_1_CheckCount(struct StaticList_1 *const self);

static void StaticList_1_set_Count(struct StaticList_1 *const self, int32_t value);

static void RemRef_MeasurementSetLikelihood(struct MeasurementSetLikelihood *const self);

static void RemRef_StaticList_18(struct StaticList_18 *const self);

static void RemRef_TruePositivesHypothesis(struct TruePositivesHypothesis *const self);

static void Del_TruePositiveHypothesi_1D_41(struct TruePositivesHypothesis_1D_41 *const self);

static void RemRef_TruePositivHypothe_1D_41(struct TruePositivesHypothesis_1D_41 *const self);

static void RemRef_StaticList_8(struct StaticList_8 *const self);

static void Del_MobilEyeSpace_1D_1(struct MobilEyeSpace_1D_1 *const self);

static void RemRef_MobilEyeSpace_1D_1(struct MobilEyeSpace_1D_1 *const self);

static void TruePositivHypothe_set_Elements(struct TruePositivesHypothesis *const self, struct StaticList_8 *value);

static void TruePositiveHypothes_set_Weight(struct TruePositivesHypothesis *const self, float64_t value);

static void StaticList_18_CheckCount(struct StaticList_18 *const self);

static void StaticList_18_set_Count(struct StaticList_18 *const self, int32_t value);

static void StaticList_8_CheckCount(struct StaticList_8 *const self);

static void StaticList_8_set_Count(struct StaticList_8 *const self, int32_t value);

static void GaussianMixture_1_cctor(void);

static void RemRef_GaussianMixture(struct GaussianMixture *const self);

static void RemRef_IListFactory(struct IListFactory *const self);

static void RemRef_StaticList_24(struct StaticList_24 *const self);

static void Del_Gaussian_5_1D_41(struct Gaussian_5_1D_41 *const self);

static void RemRef_Gaussian_5_1D_41(struct Gaussian_5_1D_41 *const self);

static void RemRef_StaticList_2(struct StaticList_2 *const self);

static void Del_float64_t_1D_41(struct float64_t_1D_41 *const self);

static void RemRef_float64_t_1D_41(struct float64_t_1D_41 *const self);

static void RemRef_StaticListEnumerator_10(struct StaticListEnumerator_10 *const self);

static void RemRef_StaticListEnumerator_4(struct StaticListEnumerator_4 *const self);

static void RemRef_Space(struct Space *const self);

static void StaticList_24_CheckCount(struct StaticList_24 *const self);

static void StaticList_24_set_Count(struct StaticList_24 *const self, int32_t value);

static void StaticList_2_CheckCount(struct StaticList_2 *const self);

static void StaticList_2_set_Count(struct StaticList_2 *const self, int32_t value);

static void RemRef_MatrixData_17(struct MatrixData_17 *const self);

static struct float64_t_1D_5 *Space_Subtract(struct Space *const self, struct Space *other);

static struct float64_t_1D_5 *AngularSpace_Subtract(struct AngularSpace *const self, struct Space *other);

static void RemRef_StaticListEnumerator_1(struct StaticListEnumerator_1 *const self);

static void MatrixData_ctor_3(struct MatrixData *const self, struct float64_t_1D_5 *data, bool_t takeDataOwnership);

static struct ExistenceSpace *MeasureSetLikeliho_get_Conditio(struct MeasurementSetLikelihood *const self);

static void CovaElliParam_set_MajorSemiAxis(struct CovarianceEllipseParameters *const self, float64_t value);

static void CovaElliParam_set_MinorSemiAxis(struct CovarianceEllipseParameters *const self, float64_t value);

static void CovariaEllipseParamet_set_Angle(struct CovarianceEllipseParameters *const self, float64_t value);

static bool_t Tracking_KeepTrack(struct Tracking *const self, struct TrackWithMeasurements *trackHypothesis);

static void RemRef_InverMobilEyeMeasurModel(struct InverseMobilEyeMeasurementModel *const self);

static void InveCartMeasMode_set_SensoParam(struct InverseCartesianMeasuremenModel *const self, struct MobilEyeParameters *value);

static void MatrixData_17_SetValueFast(struct MatrixData_17 *const self, float64_t value, int32_t row, int32_t column);

static void PositDefinMatrix_7_MatrixChange(struct PositiveDefiniteMatrix_7 *const self);

static struct TrackWithMeasurements *Trackin_CreateTrackFromMobilEye(struct Tracking *const self, struct MobilEyeSpace *measurement, float64_t egoVelocity, float64_t egoYawRate, struct MobilEyeParameters *parameters, struct Obstacle *obstacle);

static void Del_MatrixData_2_1D_1(struct MatrixData_2_1D_1 *const self);

static void RemRef_MatrixData_2_1D_1(struct MatrixData_2_1D_1 *const self);

static void Del_MatrixData_1D_0(struct MatrixData_1D_0 *const self);

static void RemRef_MatrixData_1D_0(struct MatrixData_1D_0 *const self);

static void RemRef_StaticList_21(struct StaticList_21 *const self);

static void RemRef_Gaussian_3(struct Gaussian_3 *const self);

static void Del_Gaussian_3_1D_15(struct Gaussian_3_1D_15 *const self);

static void RemRef_Gaussian_3_1D_15(struct Gaussian_3_1D_15 *const self);

static void RemRef_StaticList_17(struct StaticList_17 *const self);

static void RemRef_Matrix_13(struct Matrix_13 *const self);

static void Del_Matrix_13_1D_15(struct Matrix_13_1D_15 *const self);

static void RemRef_Matrix_13_1D_15(struct Matrix_13_1D_15 *const self);

static void RemRef_StaticList_25(struct StaticList_25 *const self);

static void RemRef_MarginalizedEvaluable_1(struct MarginalizedEvaluable_1 *const self);

static void Del_MarginalizEvaluable_1_1D_15(struct MarginalizedEvaluable_1_1D_15 *const self);

static void RemRef_MarginalEvaluabl_1_1D_15(struct MarginalizedEvaluable_1_1D_15 *const self);

static void RemRef_FronRadarObjecMeasuModel(struct FrontRadarObjectMeasuremenModel *const self);

static void RemRef_PositiveDefiniteMatrix_5(struct PositiveDefiniteMatrix_5 *const self);

static void Matrix_5_set_UncheckeMatrixData(struct Matrix_5 *const self, struct MatrixData_2 *value);

static void Matrix_5_CheckMatrix(struct Matrix_5 *const self);

static void SquareMatrix_5_CheckMatrix(struct SquareMatrix_5 *const self);

static float64_t Matrix_5_UncheckedGet(struct Matrix_5 *const self, int32_t row, int32_t column);

static struct MatrixData_2 *Matrix_5_get_UncheckeMatrixData(struct Matrix_5 *const self);

static void PositDefiniMatrix_5_CheckMatrix(struct PositiveDefiniteMatrix_5 *const self);

static void MeasurementModel_3_ctor(struct MeasurementModel_3 *const self, struct PositiveDefiniteMatrix_5 *measurementNoiseCovariance);

static void MeasurementModel_7_ctor(struct MeasurementModel_7 *const self, struct PositiveDefiniteMatrix_5 *measurementNoiseCovariance);

static void CartMeasuModel_1_set_SensoParam(struct CartesianMeasurementModel_1 *const self, struct FrontRadarObjectParameters *value);

static void CartesianMeasuremenModel_1_ctor(struct CartesianMeasurementModel_1 *const self, struct FrontRadarObjectParameters *sensorParameters);

static void CaMeMoWiVeVeAnAcc_set_EgoYawRat(struct CartMeasModeWithVectVeloAndAcce *const self, float64_t value);

static void CaMeMoWiVecVelAndAcc_set_EgoAcc(struct CartMeasModeWithVectVeloAndAcce *const self, float64_t value);

static void CarMeaModWitVecVeloAndAcce_ctor(struct CartMeasModeWithVectVeloAndAcce *const self, struct FrontRadarObjectParameters *sensorParameters, float64_t egoVelocity, float64_t egoYawrate, float64_t egoAcceleration);

static void RemRef_FronRadarObjecDetecModel(struct FrontRadarObjectDetectionModel *const self);

static void DetectionModel_1_ctor(struct DetectionModel_1 *const self);

static void SingleDetectionModel_1_ctor(struct SingleDetectionModel_1 *const self, float64_t gateProbability);

static void RemRef_StaticList_3(struct StaticList_3 *const self);

static void StaticList_3_CheckCount(struct StaticList_3 *const self);

static void StaticList_3_set_Count(struct StaticList_3 *const self, int32_t value);

static struct CASpace *MeasuremenModel_3_get_Condition(struct MeasurementModel_3 *const self);

static void CarMeaModWitVecVeloAndAcce_ccto(void);

static void Matrix_13_MatrixChanged(struct Matrix_13 *const self);

static float64_t CaMeMoWiVeVeAnAcc_get_EgoYawRat(struct CartMeasModeWithVectVeloAndAcce *const self);

static float64_t CartesMeasurModel_1_get_Condit2(struct CartesianMeasurementModel_1 *const self);

static float64_t CaMeMoWiVecVelAndAcc_get_EgoAcc(struct CartMeasModeWithVectVeloAndAcce *const self);

static void Gaussian_11_cctor(void);

static void Gaussian_3_set_Expectation(struct Gaussian_3 *const self, struct FrontRadarObjectSpace *value);

static void Gaussian_3_ResetCachedValues(struct Gaussian_3 *const self);

static void Gaussian_3_set_Covariance(struct Gaussian_3 *const self, struct PositiveDefiniteMatrix_5 *value);

static void Gaussian_3_ctor(struct Gaussian_3 *const self, bool_t noInitialization);

static void StaticList_17_CheckCount(struct StaticList_17 *const self);

static void StaticList_17_set_Count(struct StaticList_17 *const self, int32_t value);

static void StaticList_21_CheckCount(struct StaticList_21 *const self);

static void StaticList_21_set_Count(struct StaticList_21 *const self, int32_t value);

static int32_t MatrixData_2_GetIndexTransposed(struct MatrixData_2 *const self, int32_t row, int32_t column);

static int32_t MatrixData_2_GetIndex(struct MatrixData_2 *const self, int32_t row, int32_t column);

static void RemRef_SquareMatrix_5(struct SquareMatrix_5 *const self);

static void RemRef_MatrixData_19(struct MatrixData_19 *const self);

static void Del_float64_t_1D_250(struct float64_t_1D_250 *const self);

static void RemRef_float64_t_1D_250(struct float64_t_1D_250 *const self);

static struct MatrixData_19 *Tracking_1_CreateRandnMatrix_1(int32_t rows, int32_t columns);

static void RemRef_StaticList_10(struct StaticList_10 *const self);

static void Del_FrontRadarObjectSpace_1D_50(struct FrontRadarObjectSpace_1D_50 *const self);

static void RemRef_FronRadaObjecSpace_1D_50(struct FrontRadarObjectSpace_1D_50 *const self);

static void StaticList_10_CheckCount(struct StaticList_10 *const self);

static void StaticList_10_set_Count(struct StaticList_10 *const self, int32_t value);

static struct StaticList_10 *Tracking_1_Draw_1(struct Gaussian_3 *state, int32_t count);

static void SampleSet_4_cctor(void);

static void RemRef_SampleSet_1(struct SampleSet_1 *const self);

static void RemRef_StaticList_14(struct StaticList_14 *const self);

static void RemRef_SampleProbabilityPair_1(struct SampleProbabilityPair_1 *const self);

static void Del_SampleProbabiliPair_1_1D_50(struct SampleProbabilityPair_1_1D_50 *const self);

static void RemRef_SampleProbabPair_1_1D_50(struct SampleProbabilityPair_1_1D_50 *const self);

static void SampleSet_1_set_Samples(struct SampleSet_1 *const self, struct StaticList_14 *value);

static void RemRef_StaticListEnumerator_6(struct StaticListEnumerator_6 *const self);

static struct FrontRadarObjectSpace *Object_MemberwiseClone_3(struct FrontRadarObjectSpace *const self);

static struct FrontRadarObjectSpace *Space_ShallowCopy_1(struct FrontRadarObjectSpace *const self);

static struct StaticList_14 *SampleSet_1_get_Samples(struct SampleSet_1 *const self);

static void StaticList_14_CheckCount(struct StaticList_14 *const self);

static void StaticList_14_set_Count(struct StaticList_14 *const self, int32_t value);

static void RemRef_StaticListEnumerator_9(struct StaticListEnumerator_9 *const self);

static void StaticList_25_CheckCount(struct StaticList_25 *const self);

static void StaticList_25_set_Count(struct StaticList_25 *const self, int32_t value);

static void RemRef_ProbabilityGate_1(struct ProbabilityGate_1 *const self);

static float64_t Gaussia_11_InverseNormalDistrib(float64_t y0);

static float64_t Gaus_11_LnGammXGreaOrEquaMinu34(float64_t x);

static float64_t Gaussian_11_LnGamma(float64_t x);

static float64_t Ga_11_InGamIntXSmaTha1OrSmaThaA(float64_t a, float64_t x);

static float64_t Gauss_11_ComplIncompGammaIntegr(float64_t a, float64_t x);

static float64_t Gaus_11_InveCompIncomGammaInteg(float64_t a, float64_t y0);

static void RemRef_SquaredMahalanDistance_1(struct SquaredMahalanobisDistance_1 *const self);

static void RemRef_IMetric_1(struct IMetric_1 *const self);

static void Gate_1_set_MaximumDistance(struct Gate_1 *const self, float64_t value);

static void GaussianGate_1_set_GateProbabil(struct GaussianGate_1 *const self, float64_t value);

static void GaussianGate_1_ctor(struct GaussianGate_1 *const self, float64_t maxSquaredMahalanobisDistance, float64_t gateProbability);

static void RemRef_IEnumerable_3(struct IEnumerable_3 *const self);

static void RemRef_IEnumerable_4(struct IEnumerable_4 *const self);

static void RemRef_MeasurementAssociation_1(struct MeasurementAssociation_1 *const self);

static void Association_1_set_Objects1(struct Association_1 *const self, struct StaticList_21 *value);

static void Association_1_set_Objects2(struct Association_1 *const self, struct StaticList_9 *value);

static void RemRef_StaticListEnumerator_13(struct StaticListEnumerator_13 *const self);

static struct StaticList_21 *Association_1_get_Objects1(struct Association_1 *const self);

static void RemRef_StaticListEnumerator_5(struct StaticListEnumerator_5 *const self);

static struct StaticList_9 *Association_1_get_Objects2(struct Association_1 *const self);

static void Associati_1_set_AssociatioTable(struct Association_1 *const self, struct AssociationTable *value);

static void Association_1_ctor(struct Association_1 *const self, struct StaticList_21 *objects1, struct StaticList_9 *objects2, struct MultipleLocalNearestNeighbor *associationAlgorithm, struct StatiIPDATrackColleFactorProvid *factoryProvider);

static struct AssociationTable *Associati_1_get_AssociatioTable(struct Association_1 *const self);

static void LineaAlgeb_1_SolveUpperTriang(struct float64_t_1D_25 *a, int32_t lda, int32_t rank, struct float64_t_1D_25 *b, int32_t ldb, int32_t rightHandSides, bool_t ignoreDiagonal);

static void RemRef_MatrixData_1(struct MatrixData_1 *const self);

static void Del_int32_t_1D_5(struct int32_t_1D_5 *const self);

static void RemRef_int32_t_1D_5(struct int32_t_1D_5 *const self);

static void Associati_1_DetermineAssociatio(struct Association_1 *const self);

static void RemRef_IEvaluable_3(struct IEvaluable_3 *const self);

static void IPDA_4_cctor(void);

static void RemRef_IPDA_1(struct IPDA_1 *const self);

static void IPDA_1_set_Lambda(struct IPDA_1 *const self, float64_t value);

static struct FrontRadarObjectSpace *DetectionModel_1_get_Condition(struct DetectionModel_1 *const self);

static float64_t Polygon_IsLeft(struct Vector2D linePoint1, struct Vector2D linePoint2, struct Vector2D testPoint);

static float64_t PolygDetecModel_GetDetectProbab(struct PolygonDetectionModel *const self, struct FrontRadarObjectSpace *state);

static float64_t SinglDetecModel_1_GetDetecProba(struct PolygonDetectionModel *const self, struct CardinalitySpace *sample, struct FrontRadarObjectSpace *state);

static void RemRef_StaticList_19(struct StaticList_19 *const self);

static void RemRef_TruePositivesHypothesi_1(struct TruePositivesHypothesis_1 *const self);

static void Del_TruePositivHypothes_1_1D_41(struct TruePositivesHypothesis_1_1D_41 *const self);

static void RemRef_TruePositiHypoth_1_1D_41(struct TruePositivesHypothesis_1_1D_41 *const self);

static void RemRef_StaticList_11(struct StaticList_11 *const self);

static void Del_FrontRadarObjectSpace_1D_1(struct FrontRadarObjectSpace_1D_1 *const self);

static void RemRef_FronRadarObjecSpace_1D_1(struct FrontRadarObjectSpace_1D_1 *const self);

static void TruePositiHypothe_1_set_Element(struct TruePositivesHypothesis_1 *const self, struct StaticList_11 *value);

static void TruePositivHypothe_1_set_Weight(struct TruePositivesHypothesis_1 *const self, float64_t value);

static void StaticList_19_CheckCount(struct StaticList_19 *const self);

static void StaticList_19_set_Count(struct StaticList_19 *const self, int32_t value);

static void StaticList_11_CheckCount(struct StaticList_11 *const self);

static void StaticList_11_set_Count(struct StaticList_11 *const self, int32_t value);

static void RemRef_StaticListEnumerator_11(struct StaticListEnumerator_11 *const self);

static void RemRef_StaticListEnumerator_7(struct StaticListEnumerator_7 *const self);

static void RemRef_InvCarMeaModWithVectVelo(struct InveCartMeasModelWithVectoVeloc *const self);

static void InveCartMeasMode_set_SensParam(struct InverseCartesianMeasuremeModel *const self, struct FrontRadarObjectParameters *value);

static void InCarMeaModWitVecVel_set_EgoVel(struct InveCartMeasModelWithVectoVeloc *const self, float64_t value);

static void InCaMeMoWitVecVel_set_EgoYawRat(struct InveCartMeasModelWithVectoVeloc *const self, float64_t value);

static void InCarMeaModWitVecVel_set_EgoAcc(struct InveCartMeasModelWithVectoVeloc *const self, float64_t value);

static float64_t InCarMeaModWitVecVel_get_EgoVel(struct InveCartMeasModelWithVectoVeloc *const self);

static float64_t InCaMeMoWitVecVel_get_EgoYawRat(struct InveCartMeasModelWithVectoVeloc *const self);

static float64_t InCarMeaModWitVecVel_get_EgoAcc(struct InveCartMeasModelWithVectoVeloc *const self);

static struct TrackWithMeasurements *Trac_CreaTracFromFronRadarObjec(struct Tracking *const self, struct FrontRadarObjectSpace *measurement, float64_t egoVelocity, float64_t egoYawRate, float64_t egoAcceleration, struct FrontRadarObjectParameters *parameters);

static void Clone_CASpace(struct CASpace *const self);

static void Clone_CVSpace(struct CVSpace *const self);

static void Clone_AngularSpace(struct AngularSpace *const self);

static void Clone_Space(struct Space *const self);

static void Clone_Object(struct Object *const self);

static void Clone_CTRASpace(struct CTRASpace *const self);

static void Clone_AngularSpace_2(struct AngularSpace_2 *const self);

static void Clone_Space_5(struct Space_5 *const self);

static void Clone_MobilEyeSpace(struct MobilEyeSpace *const self);

static void Clone_Space_3(struct Space_3 *const self);

static void Clone_FrontRadarObjectSpace(struct FrontRadarObjectSpace *const self);

static void Clone_CVComponentsSpace(struct CVComponentsSpace *const self);

static void Del_Object(struct Object *const self);

static void Del_StaticList_27(struct StaticList_27 *const self);

static void Del_TrackWithMeasurements(struct TrackWithMeasurements *const self);

static void Del_GaussianTrack(struct GaussianTrack *const self);

static void Del_CASpace(struct CASpace *const self);

static void Del_CVSpace(struct CVSpace *const self);

static void Del_AngularSpace(struct AngularSpace *const self);

static void Del_Space(struct Space *const self);

static void Del_MatrixData(struct MatrixData *const self);

static void Del_PositiveDefiniteMatrix_7(struct PositiveDefiniteMatrix_7 *const self);

static void Del_SquareMatrix_7(struct SquareMatrix_7 *const self);

static void Del_Matrix_10(struct Matrix_10 *const self);

static void Del_MatrixData_2(struct MatrixData_2 *const self);

static void Del_LinearAlgebra(struct LinearAlgebra *const self);

static void Del_Gaussian_5(struct Gaussian_5 *const self);

static void Del_Existence(struct Existence *const self);

static void Del_TwoPointDistribution(struct TwoPointDistribution *const self);

static void Del_SampleSet_2(struct SampleSet_2 *const self);

static void Del_ExistenceSpace(struct ExistenceSpace *const self);

static void Del_FiniteSpace(struct FiniteSpace *const self);

static void Del_Space_1(struct Space_1 *const self);

static void Del_MatrixData_3(struct MatrixData_3 *const self);

static void Del_StaticListFactory(struct StaticListFactory *const self);

static void Del_UniformRandomGenerator(struct UniformRandomGenerator *const self);

static void Del_Random(struct Random *const self);

static void Del_StaticList_15(struct StaticList_15 *const self);

static void Del_SampleProbabilityPair_2(struct SampleProbabilityPair_2 *const self);

static void Del_Obstacle(struct Obstacle *const self);

static void Del_Object_1(struct Object_1 *const self);

static void Del_StaticList_12(struct StaticList_12 *const self);

static void Del_RadarSpace(struct RadarSpace *const self);

static void Del_AngularSpace_1(struct AngularSpace_1 *const self);

static void Del_Space_2(struct Space_2 *const self);

static void Del_MatrixData_4(struct MatrixData_4 *const self);

static void Del_StaticList_4(struct StaticList_4 *const self);

static void Del_StaticList_6(struct StaticList_6 *const self);

static void Del_MobilEyeSpace(struct MobilEyeSpace *const self);

static void Del_Space_3(struct Space_3 *const self);

static void Del_MatrixData_5(struct MatrixData_5 *const self);

static void Del_StaticList_9(struct StaticList_9 *const self);

static void Del_FrontRadarObjectSpace(struct FrontRadarObjectSpace *const self);

static void Del_CVComponentsSpace(struct CVComponentsSpace *const self);

static void Del_Measure_2(struct Measure_2 *const self);

static void Del_Measure(struct Measure *const self);

static void Del_Measure_3(struct Measure_3 *const self);

static void Del_Measure_1(struct Measure_1 *const self);

static void Del_Tracking(struct Tracking *const self);

static void Del_SensorProperties(struct SensorProperties *const self);

static void Del_FrontRadarNearParameters(struct FrontRadarNearParameters *const self);

static void Del_FrontRadarFarParameters(struct FrontRadarFarParameters *const self);

static void Del_MobilEyeParameters(struct MobilEyeParameters *const self);

static void Del_FrontRadarObjectParameters(struct FrontRadarObjectParameters *const self);

static void Del_EgoMotionFilter(struct EgoMotionFilter *const self);

static void Del_PositiveDefiniteMatrix_4(struct PositiveDefiniteMatrix_4 *const self);

static void Del_SquareMatrix_4(struct SquareMatrix_4 *const self);

static void Del_Matrix_4(struct Matrix_4 *const self);

static void Del_CTRAErrorSpace(struct CTRAErrorSpace *const self);

static void Del_Space_4(struct Space_4 *const self);

static void Del_MatrixData_8(struct MatrixData_8 *const self);

static void Del_MatrixData_6(struct MatrixData_6 *const self);

static void Del_CTRASpace(struct CTRASpace *const self);

static void Del_AngularSpace_2(struct AngularSpace_2 *const self);

static void Del_Space_5(struct Space_5 *const self);

static void Del_MatrixData_9(struct MatrixData_9 *const self);

static void Del_CTRAModel(struct CTRAModel *const self);

static void Del_SystemModel_5(struct SystemModel_5 *const self);

static void Del_SystemModel_3(struct SystemModel_3 *const self);

static void Del_SystemModel_1(struct SystemModel_1 *const self);

static void Del_PositiveDefiniteMatrix(struct PositiveDefiniteMatrix *const self);

static void Del_SquareMatrix(struct SquareMatrix *const self);

static void Del_Matrix(struct Matrix *const self);

static void Del_VelocitySpace(struct VelocitySpace *const self);

static void Del_VelocityMeasurementModel(struct VelocityMeasurementModel *const self);

static void Del_MeasurementModel_8(struct MeasurementModel_8 *const self);

static void Del_MeasurementModel_4(struct MeasurementModel_4 *const self);

static void Del_MeasurementModel(struct MeasurementModel *const self);

static void Del_PositiveDefiniteMatrix_1(struct PositiveDefiniteMatrix_1 *const self);

static void Del_SquareMatrix_1(struct SquareMatrix_1 *const self);

static void Del_Matrix_1(struct Matrix_1 *const self);

static void Del_YawRateSpace(struct YawRateSpace *const self);

static void Del_YawRateMeasurementModel(struct YawRateMeasurementModel *const self);

static void Del_MeasurementModel_5(struct MeasurementModel_5 *const self);

static void Del_MeasurementModel_1(struct MeasurementModel_1 *const self);

static void Del_Gaussian_4(struct Gaussian_4 *const self);

static void Del_PositiveDefiniteMatrix_6(struct PositiveDefiniteMatrix_6 *const self);

static void Del_SquareMatrix_6(struct SquareMatrix_6 *const self);

static void Del_Matrix_6(struct Matrix_6 *const self);

static void Del_MatrixData_11(struct MatrixData_11 *const self);

static void Del_StaticListEnumerator_15(struct StaticListEnumerator_15 *const self);

static void Del_Matrix_7(struct Matrix_7 *const self);

static void Del_MatrixData_12(struct MatrixData_12 *const self);

static void Del_Matrix_8(struct Matrix_8 *const self);

static void Del_MatrixData_10(struct MatrixData_10 *const self);

static void Del_Gaussian(struct Gaussian *const self);

static void Del_Matrix_9(struct Matrix_9 *const self);

static void Del_Gaussian_1(struct Gaussian_1 *const self);

static void Del_StaticListFactory_1(struct StaticListFactory_1 *const self);

static void Del_StatIPDATracColleFactoProvi(struct StatiIPDATrackColleFactorProvid *const self);

static void Del_StaticListFactory_2(struct StaticListFactory_2 *const self);

static void Del_StaticListFactory_3(struct StaticListFactory_3 *const self);

static void Del_StaticAssociatiTableFactory(struct StaticAssociationTableFactory *const self);

static void Del_StaticListFactory_4(struct StaticListFactory_4 *const self);

static void Del_StaticListFactory_5(struct StaticListFactory_5 *const self);

static void Del_StaticList_23(struct StaticList_23 *const self);

static void Del_StaticList_20(struct StaticList_20 *const self);

static void Del_Gaussian_2(struct Gaussian_2 *const self);

static void Del_StaticList_16(struct StaticList_16 *const self);

static void Del_Matrix_11(struct Matrix_11 *const self);

static void Del_StaticList_26(struct StaticList_26 *const self);

static void Del_StaticList_22(struct StaticList_22 *const self);

static void Del_MarginalizedEvaluable(struct MarginalizedEvaluable *const self);

static void Del_PositiveDefiniteMatrix_2(struct PositiveDefiniteMatrix_2 *const self);

static void Del_SquareMatrix_2(struct SquareMatrix_2 *const self);

static void Del_Matrix_2(struct Matrix_2 *const self);

static void Del_CAErrorSpace(struct CAErrorSpace *const self);

static void Del_MatrixData_13(struct MatrixData_13 *const self);

static void Del_CAModel(struct CAModel *const self);

static void Del_SystemModel_4(struct SystemModel_4 *const self);

static void Del_SystemModel_2(struct SystemModel_2 *const self);

static void Del_SystemModel(struct SystemModel *const self);

static void Del_PersistenceModel(struct PersistenceModel *const self);

static void Del_MobilEyeDetectionModel(struct MobilEyeDetectionModel *const self);

static void Del_SingleDetectionModel(struct SingleDetectionModel *const self);

static void Del_DetectionModel(struct DetectionModel *const self);

static void Del_EgoMotionCompensation(struct EgoMotionCompensation *const self);

static void Del_Matrix_12(struct Matrix_12 *const self);

static void Del_MatrixData_14(struct MatrixData_14 *const self);

static void Del_Type(struct Type *const self);

static void Del_MemberInfo(struct MemberInfo *const self);

static void Del_MobilEyeMeasurementModel(struct MobilEyeMeasurementModel *const self);

static void Del_CartesianMeasurementModel(struct CartesianMeasurementModel *const self);

static void Del_MeasurementModel_6(struct MeasurementModel_6 *const self);

static void Del_MeasurementModel_2(struct MeasurementModel_2 *const self);

static void Del_PositiveDefiniteMatrix_3(struct PositiveDefiniteMatrix_3 *const self);

static void Del_SquareMatrix_3(struct SquareMatrix_3 *const self);

static void Del_Matrix_3(struct Matrix_3 *const self);

static void Del_MatrixData_15(struct MatrixData_15 *const self);

static void Del_MatrixData_16(struct MatrixData_16 *const self);

static void Del_MatrixData_18(struct MatrixData_18 *const self);

static void Del_StaticList_7(struct StaticList_7 *const self);

static void Del_SampleSet(struct SampleSet *const self);

static void Del_StaticList_13(struct StaticList_13 *const self);

static void Del_SampleProbabilityPair(struct SampleProbabilityPair *const self);

static void Del_StaticListEnumerator_3(struct StaticListEnumerator_3 *const self);

static void Del_StaticListEnumerator_8(struct StaticListEnumerator_8 *const self);

static void Del_ProbabilityGate(struct ProbabilityGate *const self);

static void Del_GaussianGate(struct GaussianGate *const self);

static void Del_Gate(struct Gate *const self);

static void Del_SquaredMahalanobisDistance(struct SquaredMahalanobisDistance *const self);

static void Del_IMetric(struct IMetric *const self);

static void Del_MultiplLocalNearestNeighbor(struct MultipleLocalNearestNeighbor *const self);

static void Del_IEnumerable(struct IEnumerable *const self);

static void Del_IEnumerable_1(struct IEnumerable_1 *const self);

static void Del_IEnumerable_2(struct IEnumerable_2 *const self);

static void Del_IAssociationAlgorithm(struct IAssociationAlgorithm *const self);

static void Del_MeasurementAssociation(struct MeasurementAssociation *const self);

static void Del_Association(struct Association *const self);

static void Del_StaticListEnumerator_12(struct StaticListEnumerator_12 *const self);

static void Del_StaticListEnumerator_2(struct StaticListEnumerator_2 *const self);

static void Del_AssociationTable(struct AssociationTable *const self);

static void Del_StaticListEnumerator_14(struct StaticListEnumerator_14 *const self);

static void Del_MatrixData_7(struct MatrixData_7 *const self);

static void Del_StaticList(struct StaticList *const self);

static void Del_IAssociationTable(struct IAssociationTable *const self);

static void Del_StaticList_5(struct StaticList_5 *const self);

static void Del_StaticListEnumerator(struct StaticListEnumerator *const self);

static void Del_IEvaluable(struct IEvaluable *const self);

static void Del_IEvaluable_1(struct IEvaluable_1 *const self);

static void Del_IEvaluable_2(struct IEvaluable_2 *const self);

static void Del_IPDA(struct IPDA *const self);

static void Del_CardinalitySpace(struct CardinalitySpace *const self);

static void Del_StaticList_1(struct StaticList_1 *const self);

static void Del_MeasurementSetLikelihood(struct MeasurementSetLikelihood *const self);

static void Del_StaticList_18(struct StaticList_18 *const self);

static void Del_TruePositivesHypothesis(struct TruePositivesHypothesis *const self);

static void Del_StaticList_8(struct StaticList_8 *const self);

static void Del_GaussianMixture(struct GaussianMixture *const self);

static void Del_IListFactory(struct IListFactory *const self);

static void Del_StaticList_24(struct StaticList_24 *const self);

static void Del_StaticList_2(struct StaticList_2 *const self);

static void Del_StaticListEnumerator_10(struct StaticListEnumerator_10 *const self);

static void Del_StaticListEnumerator_4(struct StaticListEnumerator_4 *const self);

static void Del_MatrixData_17(struct MatrixData_17 *const self);

static void Del_StaticListEnumerator_1(struct StaticListEnumerator_1 *const self);

static void Del_InverseMobilEyeMeasureModel(struct InverseMobilEyeMeasurementModel *const self);

static void Del_InverseCartesiMeasuremModel(struct InverseCartesianMeasuremenModel *const self);

static void Del_StaticList_21(struct StaticList_21 *const self);

static void Del_Gaussian_3(struct Gaussian_3 *const self);

static void Del_StaticList_17(struct StaticList_17 *const self);

static void Del_Matrix_13(struct Matrix_13 *const self);

static void Del_StaticList_25(struct StaticList_25 *const self);

static void Del_MarginalizedEvaluable_1(struct MarginalizedEvaluable_1 *const self);

static void Del_FrontRadarObjectMeasurModel(struct FrontRadarObjectMeasuremenModel *const self);

static void Del_CarMeaModWitVectVeloAndAcce(struct CartMeasModeWithVectVeloAndAcce *const self);

static void Del_CartesianMeasurementModel_1(struct CartesianMeasurementModel_1 *const self);

static void Del_MeasurementModel_7(struct MeasurementModel_7 *const self);

static void Del_MeasurementModel_3(struct MeasurementModel_3 *const self);

static void Del_PositiveDefiniteMatrix_5(struct PositiveDefiniteMatrix_5 *const self);

static void Del_SquareMatrix_5(struct SquareMatrix_5 *const self);

static void Del_Matrix_5(struct Matrix_5 *const self);

static void Del_FrontRadarObjectDetectModel(struct FrontRadarObjectDetectionModel *const self);

static void Del_PolygonDetectionModel(struct PolygonDetectionModel *const self);

static void Del_SingleDetectionModel_1(struct SingleDetectionModel_1 *const self);

static void Del_DetectionModel_1(struct DetectionModel_1 *const self);

static void Del_StaticList_3(struct StaticList_3 *const self);

static void Del_MatrixData_19(struct MatrixData_19 *const self);

static void Del_StaticList_10(struct StaticList_10 *const self);

static void Del_SampleSet_1(struct SampleSet_1 *const self);

static void Del_StaticList_14(struct StaticList_14 *const self);

static void Del_SampleProbabilityPair_1(struct SampleProbabilityPair_1 *const self);

static void Del_StaticListEnumerator_6(struct StaticListEnumerator_6 *const self);

static void Del_StaticListEnumerator_9(struct StaticListEnumerator_9 *const self);

static void Del_ProbabilityGate_1(struct ProbabilityGate_1 *const self);

static void Del_GaussianGate_1(struct GaussianGate_1 *const self);

static void Del_Gate_1(struct Gate_1 *const self);

static void Del_SquaredMahalanobiDistance_1(struct SquaredMahalanobisDistance_1 *const self);

static void Del_IMetric_1(struct IMetric_1 *const self);

static void Del_IEnumerable_3(struct IEnumerable_3 *const self);

static void Del_IEnumerable_4(struct IEnumerable_4 *const self);

static void Del_MeasurementAssociation_1(struct MeasurementAssociation_1 *const self);

static void Del_Association_1(struct Association_1 *const self);

static void Del_StaticListEnumerator_13(struct StaticListEnumerator_13 *const self);

static void Del_StaticListEnumerator_5(struct StaticListEnumerator_5 *const self);

static void Del_MatrixData_1(struct MatrixData_1 *const self);

static void Del_IEvaluable_3(struct IEvaluable_3 *const self);

static void Del_IPDA_1(struct IPDA_1 *const self);

static void Del_StaticList_19(struct StaticList_19 *const self);

static void Del_TruePositivesHypothesis_1(struct TruePositivesHypothesis_1 *const self);

static void Del_StaticList_11(struct StaticList_11 *const self);

static void Del_StaticListEnumerator_11(struct StaticListEnumerator_11 *const self);

static void Del_StaticListEnumerator_7(struct StaticListEnumerator_7 *const self);

static void Del_InvCartMeasModeWithVectVelo(struct InveCartMeasModelWithVectoVeloc *const self);

static void Del_InverseCartesiMeasureModel(struct InverseCartesianMeasuremeModel *const self);

static struct M_int32_t_1D_13 Res_int32_t_1D_13;

static struct int32_t_1D_13 *DateTime_1_DaysToMonth365;

static struct int32_t_1D_13 *DateTime_1_DaysToMonth366;

struct DateTime DateTime_1_MinValue;

struct DateTime DateTime_1_MaxValue;

static struct M_StaticList_27 Res_StaticList_27;

static struct M_TrackWithMeasurements Res_TrackWithMeasurements;

static struct M_TrackWithMeasurements_1D_15 Res_TrackWithMeasurements_1D_15;

static struct M_CASpace Res_CASpace;

static struct M_int32_t_1D_0 Res_int32_t_1D_0;

static struct M_int32_t_1D_1 Res_int32_t_1D_1;

static struct M_Object Res_Object;

static struct SubmatrixFullDimension MatrData_20_SubmaFullDimenInsta;

static struct M_float64_t_1D_0 Res_float64_t_1D_0;

static struct float64_t_1D_0 *MatrixData_20_EmptyData;

static struct M_MatrixData Res_MatrixData;

static struct M_float64_t_1D_5 Res_float64_t_1D_5;

static struct M_PositiveDefiniteMatrix_7 Res_PositiveDefiniteMatrix_7;

static struct M_MatrixData_2 Res_MatrixData_2;

static struct M_float64_t_1D_25 Res_float64_t_1D_25;

static struct M_LinearAlgebra Res_LinearAlgebra;

static struct LinearAlgebra *MatrixMath_LinearAlgebra;

static struct CASpace *Gaussian_9_EmptySpace;

static struct M_Gaussian_5 Res_Gaussian_5;

static struct M_Existence Res_Existence;

static struct M_ExistenceSpace Res_ExistenceSpace;

static struct M_MatrixData_3 Res_MatrixData_3;

static struct M_float64_t_1D_1 Res_float64_t_1D_1;

struct ExistenceSpace *ExistenceSpace_1_Existent;

struct ExistenceSpace *ExistenceSpace_1_NonExistent;

static struct M_StaticListFactory Res_StaticListFactory;

static struct M_UniformRandomGenerator Res_UniformRandomGenerator;

static struct M_Random Res_Random;

static struct M_int32_t_1D_56 Res_int32_t_1D_56;

static int32_t __ContrRunti_insideContraEvalua;

static struct M_StaticList_15 Res_StaticList_15;

static struct M_SampleProbabilityPair_2 Res_SampleProbabilityPair_2;

static struct M_SampleProbabilityPair_2_1D_2 Res_SampleProbabilitPair_2_1D_2;

static struct M_Obstacle Res_Obstacle;

static struct M_Object_1 Res_Object_1;

static struct CASpace *TrackWithMeasure_1_StateIndices;

static struct M_StaticList_12 Res_StaticList_12;

static struct M_float64_t_1D_3 Res_float64_t_1D_3;

static struct M_RadarSpace_1D_15 Res_RadarSpace_1D_15;

static struct M_RadarSpace Res_RadarSpace;

static struct M_MatrixData_4 Res_MatrixData_4;

static struct M_StaticList_4 Res_StaticList_4;

static struct M_Obstacle_1D_40 Res_Obstacle_1D_40;

static struct M_StaticList_6 Res_StaticList_6;

static struct M_float64_t_1D_4 Res_float64_t_1D_4;

static struct M_MobilEyeSpace_1D_40 Res_MobilEyeSpace_1D_40;

static struct M_MobilEyeSpace Res_MobilEyeSpace;

static struct M_MatrixData_5 Res_MatrixData_5;

static struct M_StaticList_9 Res_StaticList_9;

static struct M_FrontRadarObjectSpace Res_FrontRadarObjectSpace;

static struct M_FrontRadarObjectSpace_1D_40 Res_FrontRadarObjectSpace_1D_40;

static struct M_Measure_2 Res_Measure_2;

static struct M_Measure_3 Res_Measure_3;

static struct CASpace *Tracking_1_StateIndices;

static struct FrontRadarObjectSpace *Tracki_1_FrontRadarObjectIndice;

static struct MobilEyeSpace *Tracking_1_MobilEyeIndices;

static struct M_Tracking Res_Tracking;

static struct M_SensorProperties Res_SensorProperties;

static struct M_FrontRadarNearParameters Res_FrontRadarNearParameters;

static struct M_FrontRadarFarParameters Res_FrontRadarFarParameters;

static struct M_MobilEyeParameters Res_MobilEyeParameters;

static struct M_Vector2D_1D_10 Res_Vector2D_1D_10;

static struct M_FrontRadarObjectParameters Res_FrontRadarObjectParameters;

static struct M_EgoMotionFilter Res_EgoMotionFilter;

static struct M_float64_t_1D_2 Res_float64_t_1D_2;

static struct M_PositiveDefiniteMatrix_4 Res_PositiveDefiniteMatrix_4;

static struct M_CTRAErrorSpace Res_CTRAErrorSpace;

static struct M_MatrixData_8 Res_MatrixData_8;

static struct M_MatrixData_6 Res_MatrixData_6;

static struct CTRAErrorSpace *CTRAModel_1_ZeroProcessNoise;

static struct M_CTRASpace Res_CTRASpace;

static struct M_MatrixData_9 Res_MatrixData_9;

static struct M_float64_t_1D_6 Res_float64_t_1D_6;

static struct CTRASpace *CTRAModel_1_S;

static struct CTRAErrorSpace *CTRAModel_1_N;

static struct M_CTRAModel Res_CTRAModel;

struct TimeSpan TimeSpan_1_Zero;

struct TimeSpan TimeSpan_1_MaxValue;

struct TimeSpan TimeSpan_1_MinValue;

static struct M_PositiveDefiniteMatrix Res_PositiveDefiniteMatrix;

static struct M_VelocitySpace Res_VelocitySpace;

static struct CTRASpace *VelocitMeasureModel_1_StateIdxs;

static struct VelocitySpace *VelociMeasurModel_1_MeasureIdxs;

static struct M_VelocityMeasurementModel Res_VelocityMeasurementModel;

static struct M_PositiveDefiniteMatrix_1 Res_PositiveDefiniteMatrix_1;

static struct M_YawRateSpace Res_YawRateSpace;

static struct CTRASpace *YawRateMeasureModel_1_StateIdxs;

static struct YawRateSpace *YawRateMeasurModel_1_MeasurIdxs;

static struct M_YawRateMeasurementModel Res_YawRateMeasurementModel;

static struct CTRASpace *Gaussian_6_EmptySpace;

static struct M_Gaussian_4 Res_Gaussian_4;

static struct M_PositiveDefiniteMatrix_6 Res_PositiveDefiniteMatrix_6;

static struct M_float64_t_1D_36 Res_float64_t_1D_36;

static struct M_MatrixData_11 Res_MatrixData_11;

static struct M_StaticListEnumerator_15 Res_StaticListEnumerator_15;

static struct M_SquareMatrix_6 Res_SquareMatrix_6;

static struct M_Matrix_7 Res_Matrix_7;

static struct M_float64_t_1D_12 Res_float64_t_1D_12;

static struct M_MatrixData_12 Res_MatrixData_12;

static struct M_Matrix_8 Res_Matrix_8;

static int32_t __ContrRunti_1_insidContrEvalua;

static struct M_MatrixData_10 Res_MatrixData_10;

static struct VelocitySpace *Gaussian_7_EmptySpace;

static struct M_Gaussian Res_Gaussian;

static struct M_Matrix_9 Res_Matrix_9;

static struct YawRateSpace *Gaussian_8_EmptySpace;

static struct M_Gaussian_1 Res_Gaussian_1;

static struct M_StaticListFactory_1 Res_StaticListFactory_1;

static struct M_StatiIPDATrackColleFactoProvi Res_StatIPDATracColleFactoProvi;

static struct M_StaticListFactory_2 Res_StaticListFactory_2;

static struct M_StaticListFactory_3 Res_StaticListFactory_3;

static struct M_StaticAssociationTableFactory Res_StaticAssociatiTableFactory;

static struct M_StaticListFactory_4 Res_StaticListFactory_4;

static struct M_StaticListFactory_5 Res_StaticListFactory_5;

static struct M_StaticList_23 Res_StaticList_23;

static struct M_Gaussian_5_1D_15 Res_Gaussian_5_1D_15;

static struct M_StaticList_20 Res_StaticList_20;

static struct M_Gaussian_2 Res_Gaussian_2;

static struct M_Gaussian_2_1D_15 Res_Gaussian_2_1D_15;

static struct M_StaticList_16 Res_StaticList_16;

static struct M_Matrix_11 Res_Matrix_11;

static struct M_Matrix_11_1D_15 Res_Matrix_11_1D_15;

static struct M_StaticList_26 Res_StaticList_26;

static struct M_Existence_1D_15 Res_Existence_1D_15;

static struct M_StaticList_22 Res_StaticList_22;

static struct M_MarginalizedEvaluable Res_MarginalizedEvaluable;

static struct M_MarginalizedEvaluable_1D_15 Res_MarginalizedEvaluable_1D_15;

static struct M_PositiveDefiniteMatrix_2 Res_PositiveDefiniteMatrix_2;

static struct M_CAErrorSpace Res_CAErrorSpace;

static struct M_MatrixData_13 Res_MatrixData_13;

static struct M_float64_t_1D_9 Res_float64_t_1D_9;

static struct CAErrorSpace *CAModel_1_ZeroProcessNoise;

static struct CASpace *CAModel_1_S;

static struct CAErrorSpace *CAModel_1_N;

static struct M_CAModel Res_CAModel;

static struct M_PersistenceModel Res_PersistenceModel;

static struct M_MobilEyeDetectionModel Res_MobilEyeDetectionModel;

static struct M_EgoMotionCompensation Res_EgoMotionCompensation;

static struct M_SquareMatrix_7 Res_SquareMatrix_7;

static struct M_Matrix_12 Res_Matrix_12;

static struct M_float64_t_1D_15 Res_float64_t_1D_15;

static struct M_MatrixData_14 Res_MatrixData_14;

static struct M_TwoPointDistribution Res_TwoPointDistribution;

static struct M_Type Res_Type;

static struct CASpace *MobilEyeMeasuModel_1_StateIndic;

static struct M_MobilEyeMeasurementModel Res_MobilEyeMeasurementModel;

static struct M_PositiveDefiniteMatrix_3 Res_PositiveDefiniteMatrix_3;

static struct M_MatrixData_15 Res_MatrixData_15;

static struct M_float64_t_1D_16 Res_float64_t_1D_16;

static struct M_float64_t_1D_20 Res_float64_t_1D_20;

static struct M_MatrixData_16 Res_MatrixData_16;

static struct MobilEyeSpace *Gaussian_10_EmptySpace;

static struct M_SquareMatrix_3 Res_SquareMatrix_3;

static struct M_MatrixData_18 Res_MatrixData_18;

static struct M_float64_t_1D_200 Res_float64_t_1D_200;

static struct M_StaticList_7 Res_StaticList_7;

static struct M_MobilEyeSpace_1D_50 Res_MobilEyeSpace_1D_50;

static struct MobilEyeSpace *SampleSet_3_EmptySample;

static struct M_SampleSet Res_SampleSet;

static struct M_StaticList_13 Res_StaticList_13;

static struct M_SampleProbabilityPair Res_SampleProbabilityPair;

static struct M_SampleProbabilityPair_1D_50 Res_SampleProbabilityPair_1D_50;

static struct M_StaticListEnumerator_3 Res_StaticListEnumerator_3;

static struct M_StaticListEnumerator_8 Res_StaticListEnumerator_8;

static struct M_ProbabilityGate Res_ProbabilityGate;

static struct M_SquaredMahalanobisDistance Res_SquaredMahalanobisDistance;

static struct M_IMetric Res_IMetric;

static struct M_MultipleLocalNearestNeighbor Res_MultiplLocalNearestNeighbor;

static struct M_IEnumerable Res_IEnumerable;

static struct M_IEnumerable_1 Res_IEnumerable_1;

static struct M_IEnumerable_2 Res_IEnumerable_2;

static struct M_IAssociationAlgorithm Res_IAssociationAlgorithm;

static struct M_MeasurementAssociation Res_MeasurementAssociation;

static struct M_StaticListEnumerator_12 Res_StaticListEnumerator_12;

static struct M_StaticListEnumerator_2 Res_StaticListEnumerator_2;

static struct M_AssociationTable Res_AssociationTable;

static struct M_float64_t_2D_15_40 Res_float64_t_2D_15_40;

static struct M_StaticListEnumerator_14 Res_StaticListEnumerator_14;

static struct M_MatrixData_7 Res_MatrixData_7;

static struct M_int32_t_1D_4 Res_int32_t_1D_4;

static struct M_int32_t_1D_40 Res_int32_t_1D_40;

static struct M_IAssociationTable Res_IAssociationTable;

static struct M_StaticList_5 Res_StaticList_5;

static struct M_StaticList_1D_15 Res_StaticList_1D_15;

static struct M_StaticList Res_StaticList;

static struct M_StaticListEnumerator Res_StaticListEnumerator;

static struct M_IEvaluable Res_IEvaluable;

static struct M_IEvaluable_1 Res_IEvaluable_1;

static struct M_IEvaluable_2 Res_IEvaluable_2;

static struct M_IPDA Res_IPDA;

static struct M_CardinalitySpace Res_CardinalitySpace;

static struct M_StaticList_1 Res_StaticList_1;

static struct M_float64_t_1D_40 Res_float64_t_1D_40;

static struct M_MeasurementSetLikelihood Res_MeasurementSetLikelihood;

static struct M_StaticList_18 Res_StaticList_18;

static struct M_TruePositivesHypothesis Res_TruePositivesHypothesis;

static struct M_TruePositivesHypothesis_1D_41 Res_TruePositiveHypothesi_1D_41;

static struct M_StaticList_8 Res_StaticList_8;

static struct M_MobilEyeSpace_1D_1 Res_MobilEyeSpace_1D_1;

static struct M_GaussianMixture Res_GaussianMixture;

static struct M_IListFactory Res_IListFactory;

static struct M_StaticList_24 Res_StaticList_24;

static struct M_Gaussian_5_1D_41 Res_Gaussian_5_1D_41;

static struct M_StaticList_2 Res_StaticList_2;

static struct M_float64_t_1D_41 Res_float64_t_1D_41;

static struct M_StaticListEnumerator_10 Res_StaticListEnumerator_10;

static struct M_StaticListEnumerator_4 Res_StaticListEnumerator_4;

static struct M_Space Res_Space;

static struct M_MatrixData_17 Res_MatrixData_17;

static struct M_StaticListEnumerator_1 Res_StaticListEnumerator_1;

static struct M_InverseMobilEyeMeasuremeModel Res_InverseMobilEyeMeasureModel;

static uint32_t IDGenerator__id;

static struct M_MatrixData_2_1D_1 Res_MatrixData_2_1D_1;

static struct M_MatrixData_1D_0 Res_MatrixData_1D_0;

static struct M_StaticList_21 Res_StaticList_21;

static struct M_Gaussian_3 Res_Gaussian_3;

static struct M_Gaussian_3_1D_15 Res_Gaussian_3_1D_15;

static struct M_StaticList_17 Res_StaticList_17;

static struct M_Matrix_13 Res_Matrix_13;

static struct M_Matrix_13_1D_15 Res_Matrix_13_1D_15;

static struct M_StaticList_25 Res_StaticList_25;

static struct M_MarginalizedEvaluable_1 Res_MarginalizedEvaluable_1;

static struct M_MarginalizedEvaluable_1_1D_15 Res_MarginalizEvaluable_1_1D_15;

static struct M_FrontRadarObjectMeasuremModel Res_FrontRadarObjectMeasurModel;

static struct M_PositiveDefiniteMatrix_5 Res_PositiveDefiniteMatrix_5;

static struct M_FrontRadarObjectDetectioModel Res_FrontRadarObjectDetectModel;

static struct M_StaticList_3 Res_StaticList_3;

static struct FrontRadarObjectSpace *CarMeaModWitVecVelAndAcc_MeaInd;

static struct CASpace *CarMeaModWitVecVelAndAcc_StaInd;

static struct FrontRadarObjectSpace *Gaussian_11_EmptySpace;

static struct M_SquareMatrix_5 Res_SquareMatrix_5;

static struct M_MatrixData_19 Res_MatrixData_19;

static struct M_float64_t_1D_250 Res_float64_t_1D_250;

static struct M_StaticList_10 Res_StaticList_10;

static struct M_FrontRadarObjectSpace_1D_50 Res_FrontRadarObjectSpace_1D_50;

static struct FrontRadarObjectSpace *SampleSet_4_EmptySample;

static struct M_SampleSet_1 Res_SampleSet_1;

static struct M_StaticList_14 Res_StaticList_14;

static struct M_SampleProbabilityPair_1 Res_SampleProbabilityPair_1;

static struct M_SampleProbabilityPair_1_1D_50 Res_SampleProbabiliPair_1_1D_50;

static struct M_StaticListEnumerator_6 Res_StaticListEnumerator_6;

static struct M_StaticListEnumerator_9 Res_StaticListEnumerator_9;

static struct M_ProbabilityGate_1 Res_ProbabilityGate_1;

static struct M_SquaredMahalanobisDistance_1 Res_SquaredMahalanobiDistance_1;

static struct M_IMetric_1 Res_IMetric_1;

static struct M_IEnumerable_3 Res_IEnumerable_3;

static struct M_IEnumerable_4 Res_IEnumerable_4;

static struct M_MeasurementAssociation_1 Res_MeasurementAssociation_1;

static struct M_StaticListEnumerator_13 Res_StaticListEnumerator_13;

static struct M_StaticListEnumerator_5 Res_StaticListEnumerator_5;

static struct M_MatrixData_1 Res_MatrixData_1;

static struct M_int32_t_1D_5 Res_int32_t_1D_5;

static struct M_IEvaluable_3 Res_IEvaluable_3;

static struct M_IPDA_1 Res_IPDA_1;

static struct M_StaticList_19 Res_StaticList_19;

static struct M_TruePositivesHypothesis_1 Res_TruePositivesHypothesis_1;

static struct M_TruePositiveHypothesi_1_1D_41 Res_TruePositivHypothes_1_1D_41;

static struct M_StaticList_11 Res_StaticList_11;

static struct M_FrontRadarObjectSpace_1D_1 Res_FrontRadarObjectSpace_1D_1;

static struct M_StaticListEnumerator_11 Res_StaticListEnumerator_11;

static struct M_StaticListEnumerator_7 Res_StaticListEnumerator_7;

static struct M_InveCartMeasModeWithVectVeloc Res_InvCartMeasModeWithVectVelo;

bool_t DateTime_1_IsLeapYear(int32_t year)
{
	if (!((year >= ((int32_t)1)) && (year <= ((int32_t)9999))))
	{
		abort();
	}
	if (!!((year % ((int32_t)4)) != ((int32_t)0)))
	{
		return false;
	}
	if (!((year % ((int32_t)100)) != ((int32_t)0)))
	{
		return (year % ((int32_t)400)) == ((int32_t)0);
	}
	return true;
}

static void Del_int32_t_1D_13(struct int32_t_1D_13 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_int32_t_1D_13(struct int32_t_1D_13 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_int32_t_1D_13.CurrentCount--;
		Res_int32_t_1D_13.Next[Res_int32_t_1D_13.CurrentCount] = self;
		Del_int32_t_1D_13(self);
	}
}

struct int32_t_1D_13 *New_int32_t_1D_13(void)
{
	static struct int32_t_1D_13 const Default_int32_t_1D_13 = { 1 };
	struct int32_t_1D_13 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_int32_t_1D_13.CurrentCount == RC_int32_t_1D_13)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_int32_t_1D_13.Next[Res_int32_t_1D_13.CurrentCount];
	Res_int32_t_1D_13.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_int32_t_1D_13.MaximumCount = (Res_int32_t_1D_13.CurrentCount > Res_int32_t_1D_13.MaximumCount) ? Res_int32_t_1D_13.CurrentCount : Res_int32_t_1D_13.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_int32_t_1D_13;
	return instance;
}

struct int32_t_1D_13 *Assign_int32_t_1D_13(struct int32_t_1D_13 **const left, struct int32_t_1D_13 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_int32_t_1D_13(*left);
	*left = right;
	return right;
}

void DateTime_ctor(struct DateTime *const self, int64_t ticks, DateTimeKind kind)
{
	if (!((ticks >= ((int64_t)0)) && (ticks <= ((int64_t)3155378975999999999))))
	{
		abort();
	}
	if (!((kind >= DateTimeKind_Unspecified) && (kind <= DateTimeKind_Local)))
	{
		abort();
	}
	(*self).dateData = (uint64_t)ticks | (uint64_t)((int64_t)kind << ((int32_t)62));
}

static void DateTime_1_cctor(void)
{
	struct int32_t_1D_13 *array = NULL;
	struct int32_t_1D_13 *array_1 = NULL;
	struct DateTime dateTime = { 0 };
	struct DateTime dateTime_1 = { 0 };

	array = New_int32_t_1D_13();
	array->Elements[((int32_t)0)] = ((int32_t)0);
	array->Elements[((int32_t)1)] = ((int32_t)31);
	array->Elements[((int32_t)2)] = ((int32_t)59);
	array->Elements[((int32_t)3)] = ((int32_t)90);
	array->Elements[((int32_t)4)] = ((int32_t)120);
	array->Elements[((int32_t)5)] = ((int32_t)151);
	array->Elements[((int32_t)6)] = ((int32_t)181);
	array->Elements[((int32_t)7)] = ((int32_t)212);
	array->Elements[((int32_t)8)] = ((int32_t)243);
	array->Elements[((int32_t)9)] = ((int32_t)273);
	array->Elements[((int32_t)10)] = ((int32_t)304);
	array->Elements[((int32_t)11)] = ((int32_t)334);
	array->Elements[((int32_t)12)] = ((int32_t)365);
	(void)Assign_int32_t_1D_13(&DateTime_1_DaysToMonth365, array);
	(void)Assign_int32_t_1D_13(&array, NULL);
	array_1 = New_int32_t_1D_13();
	array_1->Elements[((int32_t)0)] = ((int32_t)0);
	array_1->Elements[((int32_t)1)] = ((int32_t)31);
	array_1->Elements[((int32_t)2)] = ((int32_t)60);
	array_1->Elements[((int32_t)3)] = ((int32_t)91);
	array_1->Elements[((int32_t)4)] = ((int32_t)121);
	array_1->Elements[((int32_t)5)] = ((int32_t)152);
	array_1->Elements[((int32_t)6)] = ((int32_t)182);
	array_1->Elements[((int32_t)7)] = ((int32_t)213);
	array_1->Elements[((int32_t)8)] = ((int32_t)244);
	array_1->Elements[((int32_t)9)] = ((int32_t)274);
	array_1->Elements[((int32_t)10)] = ((int32_t)305);
	array_1->Elements[((int32_t)11)] = ((int32_t)335);
	array_1->Elements[((int32_t)12)] = ((int32_t)366);
	(void)Assign_int32_t_1D_13(&DateTime_1_DaysToMonth366, array_1);
	(void)Assign_int32_t_1D_13(&array_1, NULL);
	DateTime_ctor(&dateTime, ((int64_t)0), DateTimeKind_Unspecified);
	DateTime_1_MinValue = dateTime;
	DateTime_ctor(&dateTime_1, ((int64_t)3155378975999999999), DateTimeKind_Unspecified);
	DateTime_1_MaxValue = dateTime_1;
}

static int64_t DateTime_1_DateToTicks(int32_t year, int32_t month, int32_t day)
{
	struct int32_t_1D_13 *arg_29_0 = NULL;
	struct int32_t_1D_13 *array = NULL;
	int32_t num = ((int32_t)0);

	if (!((((year < ((int32_t)1)) || (year > ((int32_t)9999))) || (month < ((int32_t)1))) || (month > ((int32_t)12))))
	{
		bool_t boolean = false;

		boolean = DateTime_1_IsLeapYear(year);
		if (!boolean)
		{
			(void)Assign_int32_t_1D_13(&arg_29_0, DateTime_1_DaysToMonth365);
		}
		else
		{
			(void)Assign_int32_t_1D_13(&arg_29_0, DateTime_1_DaysToMonth366);
		}
		(void)Assign_int32_t_1D_13(&array, arg_29_0);
		if (!((day < ((int32_t)1)) || (day > (array->Elements[month] - array->Elements[month - ((int32_t)1)]))))
		{
			num = year - ((int32_t)1);
			RemRef_int32_t_1D_13(arg_29_0);
			RemRef_int32_t_1D_13(array);
			return (int64_t)(((((((num * ((int32_t)365)) + (num / ((int32_t)4))) - (num / ((int32_t)100))) + (num / ((int32_t)400))) + array->Elements[month - ((int32_t)1)]) + day) - ((int32_t)1)) * ((int64_t)864000000000);
		}
	}
	abort();
}

void DateTime_ctor_1(struct DateTime *const self, int32_t year, int32_t month, int32_t day)
{
	int64_t int64 = ((int64_t)0);

	int64 = DateTime_1_DateToTicks(year, month, day);
	(*self).dateData = int64;
}

static void RemRef_StaticList_27(struct StaticList_27 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_27.CurrentCount--;
		Res_StaticList_27.Next[Res_StaticList_27.CurrentCount] = self;
		Del_StaticList_27(self);
	}
}

struct StaticList_27 *New_StaticList_27(void)
{
	static struct StaticList_27 const Default_StaticList_27 = { 1 };
	struct StaticList_27 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_27.CurrentCount == RC_StaticList_27)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_27.Next[Res_StaticList_27.CurrentCount];
	Res_StaticList_27.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_27.MaximumCount = (Res_StaticList_27.CurrentCount > Res_StaticList_27.MaximumCount) ? Res_StaticList_27.CurrentCount : Res_StaticList_27.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_27;
	return instance;
}

struct StaticList_27 *Assign_StaticList_27(struct StaticList_27 **const left, struct StaticList_27 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_27(*left);
	*left = right;
	return right;
}

void Object_ctor(struct Object *const self)
{
}

static void RemRef_TrackWithMeasurements(struct TrackWithMeasurements *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_TrackWithMeasurements.CurrentCount--;
		Res_TrackWithMeasurements.Next[Res_TrackWithMeasurements.CurrentCount] = self;
		Del_TrackWithMeasurements(self);
	}
}

struct TrackWithMeasurements *New_TrackWithMeasurements(void)
{
	static struct TrackWithMeasurements const Default_TrackWithMeasurements = { 1 };
	struct TrackWithMeasurements *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_TrackWithMeasurements.CurrentCount == RC_TrackWithMeasurements)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_TrackWithMeasurements.Next[Res_TrackWithMeasurements.CurrentCount];
	Res_TrackWithMeasurements.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_TrackWithMeasurements.MaximumCount = (Res_TrackWithMeasurements.CurrentCount > Res_TrackWithMeasurements.MaximumCount) ? Res_TrackWithMeasurements.CurrentCount : Res_TrackWithMeasurements.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_TrackWithMeasurements;
	return instance;
}

struct TrackWithMeasurements *Assign_TrackWithMeasurements(struct TrackWithMeasurements **const left, struct TrackWithMeasurements *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_TrackWithMeasurements(*left);
	*left = right;
	return right;
}

static void Del_TrackWithMeasurements_1D_15(struct TrackWithMeasurements_1D_15 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)15);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_TrackWithMeasurements(self->Elements[i]);
	}
}

static void RemRef_TrackWithMeasureme_1D_15(struct TrackWithMeasurements_1D_15 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_TrackWithMeasurements_1D_15.CurrentCount--;
		Res_TrackWithMeasurements_1D_15.Next[Res_TrackWithMeasurements_1D_15.CurrentCount] = self;
		Del_TrackWithMeasurements_1D_15(self);
	}
}

struct TrackWithMeasurements_1D_15 *New_TrackWithMeasurements_1D_15(void)
{
	static struct TrackWithMeasurements_1D_15 const Default_TrackWithMeasurem_1D_15 = { 1 };
	struct TrackWithMeasurements_1D_15 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_TrackWithMeasurements_1D_15.CurrentCount == RC_TrackWithMeasurements_1D_15)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_TrackWithMeasurements_1D_15.Next[Res_TrackWithMeasurements_1D_15.CurrentCount];
	Res_TrackWithMeasurements_1D_15.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_TrackWithMeasurements_1D_15.MaximumCount = (Res_TrackWithMeasurements_1D_15.CurrentCount > Res_TrackWithMeasurements_1D_15.MaximumCount) ? Res_TrackWithMeasurements_1D_15.CurrentCount : Res_TrackWithMeasurements_1D_15.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_TrackWithMeasurem_1D_15;
	return instance;
}

struct TrackWithMeasurements_1D_15 *Assign_TrackWithMeasureme_1D_15(struct TrackWithMeasurements_1D_15 **const left, struct TrackWithMeasurements_1D_15 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_TrackWithMeasureme_1D_15(*left);
	*left = right;
	return right;
}

void StaticList_27_ctor(struct StaticList_27 *const self, int32_t maximumCount)
{
	struct TrackWithMeasurements_1D_15 *array = NULL;

	assert(maximumCount == ((int32_t)15));
	Object_ctor(&self->base);
	array = New_TrackWithMeasurements_1D_15();
	(void)Assign_TrackWithMeasureme_1D_15(&self->_items, array);
	(void)Assign_TrackWithMeasureme_1D_15(&array, NULL);
	self->MaximumCount = maximumCount;
}

static void RemRef_CASpace(struct CASpace *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base.base)->ReferenceCount--;
	if ((&self->base.base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_CASpace.CurrentCount--;
		Res_CASpace.Next[Res_CASpace.CurrentCount] = self;
		Del_CASpace(self);
	}
}

struct CASpace *New_CASpace(void)
{
	static struct CASpace const Default_CASpace = { 1 };
	struct CASpace *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_CASpace.CurrentCount == RC_CASpace)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_CASpace.Next[Res_CASpace.CurrentCount];
	Res_CASpace.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_CASpace.MaximumCount = (Res_CASpace.CurrentCount > Res_CASpace.MaximumCount) ? Res_CASpace.CurrentCount : Res_CASpace.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_CASpace;
	return instance;
}

struct CASpace *Assign_CASpace(struct CASpace **const left, struct CASpace *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base.base)->ReferenceCount++;
	}
	RemRef_CASpace(*left);
	*left = right;
	return right;
}

static void Del_int32_t_1D_0(struct int32_t_1D_0 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_int32_t_1D_0(struct int32_t_1D_0 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_int32_t_1D_0.CurrentCount--;
		Res_int32_t_1D_0.Next[Res_int32_t_1D_0.CurrentCount] = self;
		Del_int32_t_1D_0(self);
	}
}

struct int32_t_1D_0 *New_int32_t_1D_0(void)
{
	static struct int32_t_1D_0 const Default_int32_t_1D_0 = { 1 };
	struct int32_t_1D_0 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_int32_t_1D_0.CurrentCount == RC_int32_t_1D_0)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_int32_t_1D_0.Next[Res_int32_t_1D_0.CurrentCount];
	Res_int32_t_1D_0.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_int32_t_1D_0.MaximumCount = (Res_int32_t_1D_0.CurrentCount > Res_int32_t_1D_0.MaximumCount) ? Res_int32_t_1D_0.CurrentCount : Res_int32_t_1D_0.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_int32_t_1D_0;
	return instance;
}

struct int32_t_1D_0 *Assign_int32_t_1D_0(struct int32_t_1D_0 **const left, struct int32_t_1D_0 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_int32_t_1D_0(*left);
	*left = right;
	return right;
}

static void Del_int32_t_1D_1(struct int32_t_1D_1 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_int32_t_1D_1(struct int32_t_1D_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_int32_t_1D_1.CurrentCount--;
		Res_int32_t_1D_1.Next[Res_int32_t_1D_1.CurrentCount] = self;
		Del_int32_t_1D_1(self);
	}
}

struct int32_t_1D_1 *New_int32_t_1D_1(void)
{
	static struct int32_t_1D_1 const Default_int32_t_1D_1 = { 1 };
	struct int32_t_1D_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_int32_t_1D_1.CurrentCount == RC_int32_t_1D_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_int32_t_1D_1.Next[Res_int32_t_1D_1.CurrentCount];
	Res_int32_t_1D_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_int32_t_1D_1.MaximumCount = (Res_int32_t_1D_1.CurrentCount > Res_int32_t_1D_1.MaximumCount) ? Res_int32_t_1D_1.CurrentCount : Res_int32_t_1D_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_int32_t_1D_1;
	return instance;
}

struct int32_t_1D_1 *Assign_int32_t_1D_1(struct int32_t_1D_1 **const left, struct int32_t_1D_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_int32_t_1D_1(*left);
	*left = right;
	return right;
}

static void RemRef_Object(struct Object *const self)
{
	if (self == NULL)
	{
		return;
	}
	self->ReferenceCount--;
	if (self->ReferenceCount == ((int32_t)0))
	{
		Res_Object.CurrentCount--;
		Res_Object.Next[Res_Object.CurrentCount] = self;
		Del_Object(self);
	}
}

struct Object *New_Object(void)
{
	static struct Object const Default_Object = { 1 };
	struct Object *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Object.CurrentCount == RC_Object)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Object.Next[Res_Object.CurrentCount];
	Res_Object.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Object.MaximumCount = (Res_Object.CurrentCount > Res_Object.MaximumCount) ? Res_Object.CurrentCount : Res_Object.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Object;
	return instance;
}

struct Object *Assign_Object(struct Object **const left, struct Object *const right)
{
	if (right != NULL)
	{
		right->ReferenceCount++;
	}
	RemRef_Object(*left);
	*left = right;
	return right;
}

static void Del_float64_t_1D_0(struct float64_t_1D_0 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_1D_0(struct float64_t_1D_0 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_1D_0.CurrentCount--;
		Res_float64_t_1D_0.Next[Res_float64_t_1D_0.CurrentCount] = self;
		Del_float64_t_1D_0(self);
	}
}

struct float64_t_1D_0 *New_float64_t_1D_0(void)
{
	static struct float64_t_1D_0 const Default_float64_t_1D_0 = { 1 };
	struct float64_t_1D_0 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_1D_0.CurrentCount == RC_float64_t_1D_0)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_1D_0.Next[Res_float64_t_1D_0.CurrentCount];
	Res_float64_t_1D_0.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_1D_0.MaximumCount = (Res_float64_t_1D_0.CurrentCount > Res_float64_t_1D_0.MaximumCount) ? Res_float64_t_1D_0.CurrentCount : Res_float64_t_1D_0.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_1D_0;
	return instance;
}

struct float64_t_1D_0 *Assign_float64_t_1D_0(struct float64_t_1D_0 **const left, struct float64_t_1D_0 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_1D_0(*left);
	*left = right;
	return right;
}

static void MatrixData_20_cctor(void)
{
	struct SubmatrixFullDimension submatrixFullDimension = { 0 };
	struct float64_t_1D_0 *array = NULL;

	MatrData_20_SubmaFullDimenInsta = submatrixFullDimension;
	array = New_float64_t_1D_0();
	(void)Assign_float64_t_1D_0(&MatrixData_20_EmptyData, array);
	(void)Assign_float64_t_1D_0(&array, NULL);
}

static void RemRef_MatrixData(struct MatrixData *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData.CurrentCount--;
		Res_MatrixData.Next[Res_MatrixData.CurrentCount] = self;
		Del_MatrixData(self);
	}
}

struct MatrixData *New_MatrixData(void)
{
	static struct MatrixData const Default_MatrixData = { 1 };
	struct MatrixData *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData.CurrentCount == RC_MatrixData)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData.Next[Res_MatrixData.CurrentCount];
	Res_MatrixData.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData.MaximumCount = (Res_MatrixData.CurrentCount > Res_MatrixData.MaximumCount) ? Res_MatrixData.CurrentCount : Res_MatrixData.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData;
	return instance;
}

struct MatrixData *Assign_MatrixData(struct MatrixData **const left, struct MatrixData *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData(*left);
	*left = right;
	return right;
}

static void MatrixData_20_CheckRange(int32_t rows, int32_t columns)
{
	char const *arg_7F_0 = NULL;
	bool_t boolean = false;

	if (!(rows >= ((int32_t)0)))
	{
		abort();
	}
	if (!(columns >= ((int32_t)0)))
	{
		abort();
	}
	boolean = !(!(rows != ((int32_t)0)) && (columns > ((int32_t)0)));
	if (!(boolean && ((rows <= ((int32_t)0)) || (columns != ((int32_t)0)))))
	{
		if (!!(rows != ((int32_t)0)))
		{
			arg_7F_0 = "Columns is zero and rows is not.";
		}
		else
		{
			arg_7F_0 = "Rows is zero and columns is not.";
		}
		abort();
	}
}

static void Del_float64_t_1D_5(struct float64_t_1D_5 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_1D_5(struct float64_t_1D_5 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_1D_5.CurrentCount--;
		Res_float64_t_1D_5.Next[Res_float64_t_1D_5.CurrentCount] = self;
		Del_float64_t_1D_5(self);
	}
}

struct float64_t_1D_5 *New_float64_t_1D_5(void)
{
	static struct float64_t_1D_5 const Default_float64_t_1D_5 = { 1 };
	struct float64_t_1D_5 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_1D_5.CurrentCount == RC_float64_t_1D_5)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_1D_5.Next[Res_float64_t_1D_5.CurrentCount];
	Res_float64_t_1D_5.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_1D_5.MaximumCount = (Res_float64_t_1D_5.CurrentCount > Res_float64_t_1D_5.MaximumCount) ? Res_float64_t_1D_5.CurrentCount : Res_float64_t_1D_5.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_1D_5;
	return instance;
}

struct float64_t_1D_5 *Assign_float64_t_1D_5(struct float64_t_1D_5 **const left, struct float64_t_1D_5 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_1D_5(*left);
	*left = right;
	return right;
}

void MatrixData_ctor(struct MatrixData *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_5 *array = NULL;

	assert(rows == ((int32_t)5));
	assert(columns == ((int32_t)1));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_5();
	(void)Assign_float64_t_1D_5(&self->_data, array);
	(void)Assign_float64_t_1D_5(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct MatrixData *MatrixData_20_Zeros(int32_t rows, int32_t columns)
{
	struct MatrixData *result = NULL;
	struct MatrixData *matrixData = NULL;

	assert(rows == ((int32_t)5));
	assert(columns == ((int32_t)1));
	matrixData = New_MatrixData();
	MatrixData_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData(&result, matrixData);
	(void)Assign_MatrixData(&matrixData, NULL);
	return result;
}

static void Space_ctor(struct Space *const self, int32_t dimensions)
{
	struct Object *object = NULL;
	struct MatrixData *matrixData = NULL;

	assert(dimensions == ((int32_t)5));
	object = New_Object();
	Object_ctor(object);
	(void)Assign_Object(&self->_spaceInformationLock, object);
	(void)Assign_Object(&object, NULL);
	Object_ctor(&self->base);
	self->Dimensions = dimensions;
	matrixData = MatrixData_20_Zeros(self->Dimensions, ((int32_t)1));
	(void)Assign_MatrixData(&self->_vector, matrixData);
	(void)Assign_MatrixData(&matrixData, NULL);
}

static void AngulSpace_set_AngulDimenIndice(struct AngularSpace *const self, struct int32_t_1D_1 *value)
{
	(void)Assign_int32_t_1D_1(&self->AngularDimensionsIndices, value);
}

struct int32_t_1D_1 *AngulSpace_get_AngulDimenIndice(struct AngularSpace *const self)
{
	struct int32_t_1D_1 *result = NULL;

	(void)Assign_int32_t_1D_1(&result, self->AngularDimensionsIndices);
	return result;
}

static void AngularSpace_ctor(struct AngularSpace *const self, int32_t dimensions, struct int32_t_1D_1 *angularDimensionsIndices, struct int32_t_1D_0 *additionAngularDimensionIndices)
{
	int32_t num = ((int32_t)0);
	struct int32_t_1D_1 *array = NULL;
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);

	assert(dimensions == ((int32_t)5));
	Space_ctor(&self->base, dimensions);
	num = ((int32_t)1) + ((int32_t)0);
	array = New_int32_t_1D_1();
	AngulSpace_set_AngulDimenIndice(self, array);
	(void)Assign_int32_t_1D_1(&array, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)1))
	{
		struct int32_t_1D_1 *array_1 = NULL;

		array_1 = AngulSpace_get_AngulDimenIndice(self);
		array_1->Elements[i] = angularDimensionsIndices->Elements[i];
		(void)Assign_int32_t_1D_1(&array_1, NULL);
		i = i + ((int32_t)1);
	}
	j = ((int32_t)0);
	while (j < ((int32_t)0))
	{
		struct int32_t_1D_1 *array_2 = NULL;

		array_2 = AngulSpace_get_AngulDimenIndice(self);
		array_2->Elements[j + ((int32_t)1)] = additionAngularDimensionIndices->Elements[j];
		(void)Assign_int32_t_1D_1(&array_2, NULL);
		j = j + ((int32_t)1);
	}
}

static void CVSpace_ctor(struct CVSpace *const self, int32_t additionalDimensions, struct int32_t_1D_0 *additionAngularDimensionIndices)
{
	struct int32_t_1D_1 *array = NULL;

	assert(additionalDimensions == ((int32_t)1));
	array = New_int32_t_1D_1();
	array->Elements[((int32_t)0)] = ((int32_t)2);
	AngularSpace_ctor(&self->base, ((int32_t)4) + additionalDimensions, array, additionAngularDimensionIndices);
	(void)Assign_int32_t_1D_1(&array, NULL);
}

static void CVSpace_ctor_1(struct CVSpace *const self, int32_t additionalDimensions)
{
	struct int32_t_1D_0 *array = NULL;

	assert(additionalDimensions == ((int32_t)1));
	array = New_int32_t_1D_0();
	CVSpace_ctor(self, additionalDimensions, array);
	(void)Assign_int32_t_1D_0(&array, NULL);
}

void CASpace_ctor(struct CASpace *const self)
{
	CVSpace_ctor_1(&self->base, ((int32_t)1));
}

static void RemRef_PositiveDefiniteMatrix_7(struct PositiveDefiniteMatrix_7 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base)->ReferenceCount--;
	if ((&self->base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_PositiveDefiniteMatrix_7.CurrentCount--;
		Res_PositiveDefiniteMatrix_7.Next[Res_PositiveDefiniteMatrix_7.CurrentCount] = self;
		Del_PositiveDefiniteMatrix_7(self);
	}
}

struct PositiveDefiniteMatrix_7 *New_PositiveDefiniteMatrix_7(void)
{
	static struct PositiveDefiniteMatrix_7 const Default_PositivDefiniteMatrix_7 = { 1 };
	struct PositiveDefiniteMatrix_7 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_PositiveDefiniteMatrix_7.CurrentCount == RC_PositiveDefiniteMatrix_7)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_PositiveDefiniteMatrix_7.Next[Res_PositiveDefiniteMatrix_7.CurrentCount];
	Res_PositiveDefiniteMatrix_7.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_PositiveDefiniteMatrix_7.MaximumCount = (Res_PositiveDefiniteMatrix_7.CurrentCount > Res_PositiveDefiniteMatrix_7.MaximumCount) ? Res_PositiveDefiniteMatrix_7.CurrentCount : Res_PositiveDefiniteMatrix_7.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_PositivDefiniteMatrix_7;
	return instance;
}

struct PositiveDefiniteMatrix_7 *Assign_PositiveDefiniteMatrix_7(struct PositiveDefiniteMatrix_7 **const left, struct PositiveDefiniteMatrix_7 *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base)->ReferenceCount++;
	}
	RemRef_PositiveDefiniteMatrix_7(*left);
	*left = right;
	return right;
}

void Matrix_10_ctor(struct Matrix_10 *const self)
{
	struct CASpace *caSpace = NULL;
	struct CASpace *caSpace_1 = NULL;

	caSpace = New_CASpace();
	CASpace_ctor(caSpace);
	(void)Assign_CASpace(&self->EmptyRowSpace, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	caSpace_1 = New_CASpace();
	CASpace_ctor(caSpace_1);
	(void)Assign_CASpace(&self->EmptyColumnSpace, caSpace_1);
	(void)Assign_CASpace(&caSpace_1, NULL);
	Object_ctor(&self->base);
	self->Columns = (&self->EmptyRowSpace->base.base.base)->Dimensions;
	self->Rows = (&self->EmptyColumnSpace->base.base.base)->Dimensions;
}

void SquareMatrix_7_ctor(struct SquareMatrix_7 *const self)
{
	struct CASpace *caSpace = NULL;

	caSpace = New_CASpace();
	CASpace_ctor(caSpace);
	(void)Assign_CASpace(&self->EmptySpace, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	Matrix_10_ctor(&self->base);
	self->Dimensions = (&self->base)->Rows;
}

static void RemRef_MatrixData_2(struct MatrixData_2 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_2.CurrentCount--;
		Res_MatrixData_2.Next[Res_MatrixData_2.CurrentCount] = self;
		Del_MatrixData_2(self);
	}
}

struct MatrixData_2 *New_MatrixData_2(void)
{
	static struct MatrixData_2 const Default_MatrixData_2 = { 1 };
	struct MatrixData_2 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_2.CurrentCount == RC_MatrixData_2)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_2.Next[Res_MatrixData_2.CurrentCount];
	Res_MatrixData_2.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_2.MaximumCount = (Res_MatrixData_2.CurrentCount > Res_MatrixData_2.MaximumCount) ? Res_MatrixData_2.CurrentCount : Res_MatrixData_2.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_2;
	return instance;
}

struct MatrixData_2 *Assign_MatrixData_2(struct MatrixData_2 **const left, struct MatrixData_2 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_2(*left);
	*left = right;
	return right;
}

static void Del_float64_t_1D_25(struct float64_t_1D_25 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_1D_25(struct float64_t_1D_25 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_1D_25.CurrentCount--;
		Res_float64_t_1D_25.Next[Res_float64_t_1D_25.CurrentCount] = self;
		Del_float64_t_1D_25(self);
	}
}

struct float64_t_1D_25 *New_float64_t_1D_25(void)
{
	static struct float64_t_1D_25 const Default_float64_t_1D_25 = { 1 };
	struct float64_t_1D_25 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_1D_25.CurrentCount == RC_float64_t_1D_25)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_1D_25.Next[Res_float64_t_1D_25.CurrentCount];
	Res_float64_t_1D_25.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_1D_25.MaximumCount = (Res_float64_t_1D_25.CurrentCount > Res_float64_t_1D_25.MaximumCount) ? Res_float64_t_1D_25.CurrentCount : Res_float64_t_1D_25.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_1D_25;
	return instance;
}

struct float64_t_1D_25 *Assign_float64_t_1D_25(struct float64_t_1D_25 **const left, struct float64_t_1D_25 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_1D_25(*left);
	*left = right;
	return right;
}

void MatrixData_2_ctor(struct MatrixData_2 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_25 *array = NULL;

	assert(rows == ((int32_t)5));
	assert(columns == ((int32_t)5));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_25();
	(void)Assign_float64_t_1D_25(&self->_data, array);
	(void)Assign_float64_t_1D_25(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct float64_t_1D_25 *MatrixData_2_get_DataReference(struct MatrixData_2 *const self)
{
	struct float64_t_1D_25 *result = NULL;

	(void)Assign_float64_t_1D_25(&result, self->_data);
	return result;
}

static void MatrixData_2_SetValueFast(struct MatrixData_2 *const self, float64_t value, int32_t row, int32_t column)
{
	struct float64_t_1D_25 *array = NULL;

	array = MatrixData_2_get_DataReference(self);
	array->Elements[(column * self->Rows) + row] = value;
	(void)Assign_float64_t_1D_25(&array, NULL);
}

struct MatrixData_2 *MatrixData_20_Diag(struct float64_t_1D_5 *diagonalElements)
{
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_2 *result = NULL;

	if (!(diagonalElements != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData_2();
	MatrixData_2_ctor(matrixData_1, ((int32_t)5), ((int32_t)5));
	(void)Assign_MatrixData_2(&matrixData, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)5))
	{
		MatrixData_2_SetValueFast(matrixData, diagonalElements->Elements[i], i, i);
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_2(&result, matrixData);
	RemRef_MatrixData_2(matrixData);
	return result;
}

static void Matrix_10_set_UncheckMatrixData(struct Matrix_10 *const self, struct MatrixData_2 *value)
{
	(void)Assign_MatrixData_2(&self->_matrix, value);
}

bool_t Double_IsNaN(float64_t d)
{
	return ((uint64_t)*((int64_t *)&d) & (uint64_t)((int64_t)9223372036854775807)) > (uint64_t)((int64_t)9218868437227405312);
}

static void Matrix_10_CheckMatrix(struct Matrix_10 *const self)
{
	struct float64_t_1D_25 *dataReference = NULL;
	struct float64_t_1D_25 *array = NULL;
	int32_t i = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);

	array = MatrixData_2_get_DataReference(self->_matrix);
	(void)Assign_float64_t_1D_25(&dataReference, array);
	(void)Assign_float64_t_1D_25(&array, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)25))
	{
		bool_t boolean = false;

		boolean = Double_IsNaN(dataReference->Elements[i]);
		if (!!boolean)
		{
			num = i / self->Rows;
			num2 = i - (num * self->Rows);
			abort();
		}
		i = i + ((int32_t)1);
	}
	RemRef_float64_t_1D_25(dataReference);
}

struct MatrixData_2 *MatrixData_20_Zeros_1(int32_t rows, int32_t columns)
{
	struct MatrixData_2 *result = NULL;
	struct MatrixData_2 *matrixData = NULL;

	assert(rows == ((int32_t)5));
	assert(columns == ((int32_t)5));
	matrixData = New_MatrixData_2();
	MatrixData_2_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData_2(&result, matrixData);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	return result;
}

struct MatrixData_2 *Matrix_10_get_MatrixData(struct Matrix_10 *const self)
{
	struct MatrixData_2 *result = NULL;

	if (!(self->_matrix != NULL))
	{
		struct MatrixData_2 *matrixData = NULL;

		matrixData = MatrixData_20_Zeros_1(self->Rows, self->Columns);
		(void)Assign_MatrixData_2(&self->_matrix, matrixData);
		(void)Assign_MatrixData_2(&matrixData, NULL);
	}
	(void)Assign_MatrixData_2(&result, self->_matrix);
	return result;
}

static void SquareMatrix_7_CheckMatrix(struct SquareMatrix_7 *const self)
{
	struct MatrixData_2 *matrixData = NULL;
	int32_t int32 = ((int32_t)0);
	struct MatrixData_2 *matrixData_1 = NULL;

	Matrix_10_CheckMatrix(&self->base);
	matrixData = Matrix_10_get_MatrixData(&self->base);
	int32 = matrixData->Rows;
	matrixData_1 = Matrix_10_get_MatrixData(&self->base);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
}

bool_t MatrixData_2_get_IsZero(struct MatrixData_2 *const self)
{
	struct float64_t_1D_25 *data = NULL;
	int32_t i = ((int32_t)0);
	float64_t num = 0.0;

	(void)Assign_float64_t_1D_25(&data, self->_data);
	i = ((int32_t)0);
	while (i < ((int32_t)25))
	{
		num = data->Elements[i];
		if (!(num == 0.0))
		{
			RemRef_float64_t_1D_25(data);
			return false;
		}
		i = i + ((int32_t)1);
	}
	RemRef_float64_t_1D_25(data);
	return true;
}

bool_t Matrix_10_get_IsZero(struct Matrix_10 *const self)
{
	bool_t result = false;
	struct MatrixData_2 *matrixData = NULL;
	bool_t boolean = false;

	matrixData = Matrix_10_get_MatrixData(self);
	boolean = MatrixData_2_get_IsZero(matrixData);
	result = boolean;
	(void)Assign_MatrixData_2(&matrixData, NULL);
	return result;
}

static float64_t MatrixData_2_GetValueFast(struct MatrixData_2 *const self, int32_t row, int32_t column)
{
	float64_t result = 0.0;
	struct float64_t_1D_25 *array = NULL;

	array = MatrixData_2_get_DataReference(self);
	result = array->Elements[(column * self->Rows) + row];
	(void)Assign_float64_t_1D_25(&array, NULL);
	return result;
}

float64_t MatrixData_2_get_Item(struct MatrixData_2 *const self, int32_t row, int32_t column)
{
	float64_t double_ = 0.0;

	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	double_ = MatrixData_2_GetValueFast(self, row, column);
	return double_;
}

static float64_t Matrix_10_UncheckedGet(struct Matrix_10 *const self, int32_t row, int32_t column)
{
	float64_t result = 0.0;
	struct MatrixData_2 *matrixData = NULL;
	float64_t double_ = 0.0;

	matrixData = Matrix_10_get_MatrixData(self);
	double_ = MatrixData_2_get_Item(matrixData, row, column);
	result = double_;
	(void)Assign_MatrixData_2(&matrixData, NULL);
	return result;
}

int64_t BitConverter_DoubleToInt64Bits(float64_t value)
{
	return *((int64_t *)&value);
}

static int32_t FloatCompare_Exponent(float64_t d)
{
	int64_t num = ((int64_t)0);
	int64_t int64 = ((int64_t)0);

	int64 = BitConverter_DoubleToInt64Bits(d);
	num = int64;
	return (int32_t)((uint64_t)(num >> ((int32_t)52)) & (uint64_t)((int64_t)2047)) - ((int32_t)1023);
}

int32_t Math_Max(int32_t val1, int32_t val2)
{
	if (!(val1 >= val2))
	{
		return val2;
	}
	return val1;
}

float64_t Math_Pow(float64_t x, float64_t y)
{
	return (float64_t)pow(x, y);
}

float64_t Math_Abs(float64_t value)
{
	return (float64_t)fabs(value);
}

int32_t float64_t_CompareTo(float64_t *const self, float64_t value)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;

	if (!(*self >= value))
	{
		return ((int32_t)-1);
	}
	if (!(*self <= value))
	{
		return ((int32_t)1);
	}
	if (!(*self != value))
	{
		return ((int32_t)0);
	}
	boolean = Double_IsNaN(*self);
	if (!!!boolean)
	{
		return ((int32_t)1);
	}
	boolean_1 = Double_IsNaN(value);
	if (!boolean_1)
	{
		return ((int32_t)-1);
	}
	return ((int32_t)0);
}

int32_t FloatCompare_Compare(float64_t d1, float64_t d2)
{
	bool_t boolean = false;
	int32_t num = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t int32_2 = ((int32_t)0);
	int32_t int32_3 = ((int32_t)0);
	int32_t arg_5A_0 = ((int32_t)0);
	int32_t arg_5A_1 = ((int32_t)0);
	int32_t arg_75_0 = ((int32_t)0);
	int32_t arg_75_1 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t int32_4 = ((int32_t)0);
	float64_t num4 = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	int32_t int32_5 = ((int32_t)0);

	boolean = !((d1 == 0.0) && (d2 == 0.0));
	if (!(boolean && (d1 != d2)))
	{
		return ((int32_t)0);
	}
	int32 = FloatCompare_Exponent(d1);
	int32_1 = Math_Max(int32, ((int32_t)0));
	num = int32_1;
	int32_2 = FloatCompare_Exponent(d2);
	int32_3 = Math_Max(int32_2, ((int32_t)0));
	num2 = int32_3;
	arg_5A_0 = num;
	if (!(d1 < 0.0))
	{
		arg_5A_1 = ((int32_t)53);
	}
	else
	{
		arg_5A_1 = ((int32_t)54);
	}
	num = arg_5A_0 - arg_5A_1;
	arg_75_0 = num2;
	if (!(d2 < 0.0))
	{
		arg_75_1 = ((int32_t)53);
	}
	else
	{
		arg_75_1 = ((int32_t)54);
	}
	num2 = arg_75_0 - arg_75_1;
	int32_4 = Math_Max(num, num2);
	num3 = int32_4 + ((int32_t)7);
	double_ = Math_Pow(2.0, (float64_t)num3);
	num4 = double_;
	double__1 = Math_Abs(d1 - d2);
	if (!(double__1 >= num4))
	{
		return ((int32_t)0);
	}
	int32_5 = float64_t_CompareTo(&d1, d2);
	return int32_5;
}

static struct MatrixData_2 *Matrix_10_get_UncheckMatrixData(struct Matrix_10 *const self)
{
	struct MatrixData_2 *result = NULL;

	(void)Assign_MatrixData_2(&result, self->_matrix);
	return result;
}

bool_t MatrixData_2_get_IsEmpty(struct MatrixData_2 *const self)
{
	return ((int32_t)25) == ((int32_t)0);
}

static void RemRef_LinearAlgebra(struct LinearAlgebra *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_LinearAlgebra.CurrentCount--;
		Res_LinearAlgebra.Next[Res_LinearAlgebra.CurrentCount] = self;
		Del_LinearAlgebra(self);
	}
}

struct LinearAlgebra *New_LinearAlgebra(void)
{
	static struct LinearAlgebra const Default_LinearAlgebra = { 1 };
	struct LinearAlgebra *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_LinearAlgebra.CurrentCount == RC_LinearAlgebra)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_LinearAlgebra.Next[Res_LinearAlgebra.CurrentCount];
	Res_LinearAlgebra.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_LinearAlgebra.MaximumCount = (Res_LinearAlgebra.CurrentCount > Res_LinearAlgebra.MaximumCount) ? Res_LinearAlgebra.CurrentCount : Res_LinearAlgebra.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_LinearAlgebra;
	return instance;
}

struct LinearAlgebra *Assign_LinearAlgebra(struct LinearAlgebra **const left, struct LinearAlgebra *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_LinearAlgebra(*left);
	*left = right;
	return right;
}

void LinearAlgebra_ctor(struct LinearAlgebra *const self)
{
	Object_ctor(&self->base);
}

static void MatrixMath_cctor(void)
{
	struct LinearAlgebra *linearAlgebra = NULL;

	linearAlgebra = New_LinearAlgebra();
	LinearAlgebra_ctor(linearAlgebra);
	(void)Assign_LinearAlgebra(&MatrixMath_LinearAlgebra, linearAlgebra);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
}

float64_t Math_Sqrt(float64_t d)
{
	return (float64_t)sqrt(d);
}

void LinearAlgebra_FactorCholesky(struct LinearAlgebra *const self, struct float64_t_1D_25 *a, int32_t rows)
{
	int32_t num = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	float64_t num2 = 0.0;
	int32_t k = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rows > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)25) % rows) != ((int32_t)0)))
	{
		abort();
	}
	num = ((int32_t)25) / rows;
	if (!(num == rows))
	{
		abort();
	}
	i = ((int32_t)0);
	while (i < num)
	{
		j = ((int32_t)0);
		while (j <= i)
		{
			num2 = a->Elements[(i * rows) + j];
			k = ((int32_t)0);
			while (k < j)
			{
				num2 = num2 - (a->Elements[(i * rows) + k] * a->Elements[(j * rows) + k]);
				k = k + ((int32_t)1);
			}
			if (!(j >= i))
			{
				a->Elements[(i * rows) + j] = num2 / a->Elements[(j * rows) + j];
			}
			else
			{
				struct float64_t_1D_25 *array = NULL;
				int32_t int32 = ((int32_t)0);
				float64_t double_ = 0.0;

				if (!!(num2 <= 0.0))
				{
					abort();
				}
				(void)Assign_float64_t_1D_25(&array, a);
				int32 = (i * rows) + i;
				double_ = Math_Sqrt(num2);
				array->Elements[int32] = double_;
				(void)Assign_float64_t_1D_25(&array, NULL);
			}
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
}

struct MatrixData_2 *MatrixMath_Chol(struct MatrixData_2 *matrix)
{
	bool_t boolean = false;
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	struct float64_t_1D_25 *dataReference = NULL;
	struct float64_t_1D_25 *array = NULL;
	struct float64_t_1D_25 *dataReference2 = NULL;
	struct float64_t_1D_25 *array_1 = NULL;
	int32_t i = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t j = ((int32_t)0);
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_25 *array_2 = NULL;
	struct MatrixData_2 *result = NULL;

	if (!(matrix != NULL))
	{
		abort();
	}
	boolean = MatrixData_2_get_IsEmpty(matrix);
	matrixData_1 = New_MatrixData_2();
	MatrixData_2_ctor(matrixData_1, matrix->Rows, matrix->Columns);
	(void)Assign_MatrixData_2(&matrixData, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	array = MatrixData_2_get_DataReference(matrix);
	(void)Assign_float64_t_1D_25(&dataReference, array);
	(void)Assign_float64_t_1D_25(&array, NULL);
	array_1 = MatrixData_2_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_25(&dataReference2, array_1);
	(void)Assign_float64_t_1D_25(&array_1, NULL);
	i = ((int32_t)0);
	while (i < matrixData->Columns)
	{
		num = i * matrix->Rows;
		j = i;
		while (j >= ((int32_t)3))
		{
			dataReference2->Elements[num] = dataReference->Elements[num];
			dataReference2->Elements[num + ((int32_t)1)] = dataReference->Elements[num + ((int32_t)1)];
			dataReference2->Elements[num + ((int32_t)2)] = dataReference->Elements[num + ((int32_t)2)];
			dataReference2->Elements[num + ((int32_t)3)] = dataReference->Elements[num + ((int32_t)3)];
			j = j - ((int32_t)4);
			num = num + ((int32_t)4);
		}
		while (j >= ((int32_t)1))
		{
			dataReference2->Elements[num] = dataReference->Elements[num];
			dataReference2->Elements[num + ((int32_t)1)] = dataReference->Elements[num + ((int32_t)1)];
			j = j - ((int32_t)2);
			num = num + ((int32_t)2);
		}
		while (j >= ((int32_t)0))
		{
			dataReference2->Elements[num] = dataReference->Elements[num];
			j = j - ((int32_t)1);
			num = num + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array_2 = MatrixData_2_get_DataReference(matrixData);
	LinearAlgebra_FactorCholesky(linearAlgebra, array_2, matrixData->Rows);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_25(&array_2, NULL);
	(void)Assign_MatrixData_2(&result, matrixData);
	RemRef_MatrixData_2(matrixData);
	RemRef_float64_t_1D_25(dataReference);
	RemRef_float64_t_1D_25(dataReference2);
	return result;
}

static void PositDefiniMatrix_7_CheckMatrix(struct PositiveDefiniteMatrix_7 *const self)
{
	bool_t boolean = false;
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;

	SquareMatrix_7_CheckMatrix(&self->base);
	boolean = Matrix_10_get_IsZero(&self->base.base);
	if (!!boolean)
	{
		return;
	}
	i = ((int32_t)0);
	while (i < (&self->base.base)->Rows)
	{
		j = ((int32_t)0);
		while (j < i)
		{
			float64_t double_ = 0.0;
			float64_t double__1 = 0.0;
			int32_t int32 = ((int32_t)0);

			double_ = Matrix_10_UncheckedGet(&self->base.base, i, j);
			double__1 = Matrix_10_UncheckedGet(&self->base.base, j, i);
			int32 = FloatCompare_Compare(double_, double__1);
			if (!!(int32 != ((int32_t)0)))
			{
				abort();
			}
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	matrixData = Matrix_10_get_UncheckMatrixData(&self->base.base);
	matrixData_1 = MatrixMath_Chol(matrixData);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
}

void SquareMatrix_7_ctor_1(struct PositiveDefiniteMatrix_7 *const self, struct float64_t_1D_5 *mainDiagonal)
{
	struct MatrixData_2 *matrixData = NULL;

	SquareMatrix_7_ctor(&self->base);
	matrixData = MatrixData_20_Diag(mainDiagonal);
	Matrix_10_set_UncheckMatrixData(&self->base.base, matrixData);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	PositDefiniMatrix_7_CheckMatrix(self);
}

void PositiveDefiniteMatrix_7_ctor(struct PositiveDefiniteMatrix_7 *const self, struct float64_t_1D_5 *mainDiagonal)
{
	SquareMatrix_7_ctor_1(self, mainDiagonal);
}

static void Gaussian_9_cctor(void)
{
	struct CASpace *caSpace = NULL;

	caSpace = New_CASpace();
	CASpace_ctor(caSpace);
	(void)Assign_CASpace(&Gaussian_9_EmptySpace, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
}

static void RemRef_Gaussian_5(struct Gaussian_5 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Gaussian_5.CurrentCount--;
		Res_Gaussian_5.Next[Res_Gaussian_5.CurrentCount] = self;
		Del_Gaussian_5(self);
	}
}

struct Gaussian_5 *New_Gaussian_5(void)
{
	static struct Gaussian_5 const Default_Gaussian_5 = { 1 };
	struct Gaussian_5 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Gaussian_5.CurrentCount == RC_Gaussian_5)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Gaussian_5.Next[Res_Gaussian_5.CurrentCount];
	Res_Gaussian_5.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Gaussian_5.MaximumCount = (Res_Gaussian_5.CurrentCount > Res_Gaussian_5.MaximumCount) ? Res_Gaussian_5.CurrentCount : Res_Gaussian_5.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Gaussian_5;
	return instance;
}

struct Gaussian_5 *Assign_Gaussian_5(struct Gaussian_5 **const left, struct Gaussian_5 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Gaussian_5(*left);
	*left = right;
	return right;
}

static struct CASpace *Object_MemberwiseClone(struct CASpace *const self)
{
	struct CASpace *result;

	result = New_CASpace();
	*result = *self;
	(&result->base.base.base.base)->ReferenceCount = ((int32_t)1);
	Clone_CASpace(result);
	return result;
}

static void MatrixData_ctor_2(struct MatrixData *const self, struct float64_t_1D_5 *data, int32_t rows, int32_t columns, bool_t takeDataOwnership)
{
	assert(rows == ((int32_t)5));
	assert(columns == ((int32_t)1));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	if (!(data != NULL))
	{
		abort();
	}
	if (!!takeDataOwnership)
	{
		(void)Assign_float64_t_1D_5(&self->_data, data);
	}
	else
	{
		struct float64_t_1D_5 *array = NULL;

		array = New_float64_t_1D_5();
		(void)Assign_float64_t_1D_5(&self->_data, array);
		(void)Assign_float64_t_1D_5(&array, NULL);
		(void)memcpy(&self->_data->Elements, &data->Elements, sizeof(float64_t) * ((int32_t)5));
	}
	self->Rows = rows;
	self->Columns = columns;
}

struct MatrixData *MatrixData_get_Copy(struct MatrixData *const self)
{
	struct MatrixData *result = NULL;
	struct MatrixData *matrixData = NULL;

	matrixData = New_MatrixData();
	MatrixData_ctor_2(matrixData, self->_data, self->Rows, self->Columns, false);
	(void)Assign_MatrixData(&result, matrixData);
	(void)Assign_MatrixData(&matrixData, NULL);
	return result;
}

static struct CASpace *Space_ShallowCopy(struct CASpace *const self)
{
	struct CASpace *space = NULL;
	struct CASpace *caSpace = NULL;
	struct CASpace *result = NULL;

	caSpace = Object_MemberwiseClone(self);
	(void)Assign_CASpace(&space, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	if (!!((&self->base.base.base)->_vector != NULL))
	{
		struct CASpace *caSpace_1 = NULL;
		struct MatrixData *matrixData = NULL;

		(void)Assign_CASpace(&caSpace_1, space);
		matrixData = MatrixData_get_Copy((&self->base.base.base)->_vector);
		(void)Assign_MatrixData(&(&caSpace_1->base.base.base)->_vector, matrixData);
		(void)Assign_CASpace(&caSpace_1, NULL);
		(void)Assign_MatrixData(&matrixData, NULL);
	}
	if (!!((&self->base.base.base)->_spaceInformationLock != NULL))
	{
		struct CASpace *caSpace_2 = NULL;
		struct Object *object = NULL;

		(void)Assign_CASpace(&caSpace_2, space);
		object = New_Object();
		Object_ctor(object);
		(void)Assign_Object(&(&caSpace_2->base.base.base)->_spaceInformationLock, object);
		(void)Assign_CASpace(&caSpace_2, NULL);
		(void)Assign_Object(&object, NULL);
	}
	(void)Assign_CASpace(&result, space);
	RemRef_CASpace(space);
	return result;
}

struct CASpace *SpaceExtensions_Clone(struct CASpace *space)
{
	struct CASpace *result = NULL;
	struct CASpace *caSpace = NULL;

	caSpace = Space_ShallowCopy(space);
	(void)Assign_CASpace(&result, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	return result;
}

static void Gaussian_5_set_Expectation(struct Gaussian_5 *const self, struct CASpace *value)
{
	(void)Assign_CASpace(&self->Expectation, value);
}

void PositiveDefiniteMatrix_7_ctor_1(struct PositiveDefiniteMatrix_7 *const self)
{
	SquareMatrix_7_ctor(&self->base);
}

static bool_t Matri_10_get_InterMatriIsInitia(struct Matrix_10 *const self)
{
	return self->_matrix != NULL;
}

static void MatrixData_2_ctor_1(struct MatrixData_2 *const self, struct float64_t_1D_25 *data, int32_t rows, int32_t columns, bool_t takeDataOwnership)
{
	assert(rows == ((int32_t)5));
	assert(columns == ((int32_t)5));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	if (!(data != NULL))
	{
		abort();
	}
	if (!!takeDataOwnership)
	{
		(void)Assign_float64_t_1D_25(&self->_data, data);
	}
	else
	{
		struct float64_t_1D_25 *array = NULL;

		array = New_float64_t_1D_25();
		(void)Assign_float64_t_1D_25(&self->_data, array);
		(void)Assign_float64_t_1D_25(&array, NULL);
		(void)memcpy(&self->_data->Elements, &data->Elements, sizeof(float64_t) * ((int32_t)25));
	}
	self->Rows = rows;
	self->Columns = columns;
}

struct MatrixData_2 *MatrixData_2_get_Copy(struct MatrixData_2 *const self)
{
	struct MatrixData_2 *result = NULL;
	struct MatrixData_2 *matrixData = NULL;

	matrixData = New_MatrixData_2();
	MatrixData_2_ctor_1(matrixData, self->_data, self->Rows, self->Columns, false);
	(void)Assign_MatrixData_2(&result, matrixData);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	return result;
}

struct PositiveDefiniteMatrix_7 *PositiveDefiniteMatrix_7_Clone(struct PositiveDefiniteMatrix_7 *const self)
{
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_1 = NULL;
	bool_t boolean = false;
	struct PositiveDefiniteMatrix_7 *result = NULL;

	positiveDefiniteMatrix_1 = New_PositiveDefiniteMatrix_7();
	PositiveDefiniteMatrix_7_ctor_1(positiveDefiniteMatrix_1);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix, positiveDefiniteMatrix_1);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_1, NULL);
	boolean = Matri_10_get_InterMatriIsInitia(&self->base.base);
	if (!!boolean)
	{
		struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_2 = NULL;
		struct MatrixData_2 *matrixData = NULL;
		struct MatrixData_2 *matrixData_1 = NULL;

		(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_2, positiveDefiniteMatrix);
		matrixData = Matrix_10_get_UncheckMatrixData(&self->base.base);
		matrixData_1 = MatrixData_2_get_Copy(matrixData);
		Matrix_10_set_UncheckMatrixData(&positiveDefiniteMatrix_2->base.base, matrixData_1);
		(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_2, NULL);
		(void)Assign_MatrixData_2(&matrixData, NULL);
		(void)Assign_MatrixData_2(&matrixData_1, NULL);
	}
	(void)Assign_PositiveDefiniteMatrix_7(&result, positiveDefiniteMatrix);
	RemRef_PositiveDefiniteMatrix_7(positiveDefiniteMatrix);
	return result;
}

static void Gaussian_5_ResetCachedValues(struct Gaussian_5 *const self)
{
	struct Nullable_2 nullable = { 0 };

	self->NormalizationFactor = nullable;
}

static void Gaussian_5_set_Covariance(struct Gaussian_5 *const self, struct PositiveDefiniteMatrix_7 *value)
{
	Gaussian_5_ResetCachedValues(self);
	(void)Assign_PositiveDefiniteMatrix_7(&self->covariance, value);
}

void Gaussian_5_ctor(struct Gaussian_5 *const self, struct CASpace *expectation, struct PositiveDefiniteMatrix_7 *covariance)
{
	struct CASpace *caSpace = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix = NULL;

	Object_ctor(&self->base);
	self->_dimensions = (&Gaussian_9_EmptySpace->base.base.base)->Dimensions;
	caSpace = SpaceExtensions_Clone(expectation);
	Gaussian_5_set_Expectation(self, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	positiveDefiniteMatrix = PositiveDefiniteMatrix_7_Clone(covariance);
	Gaussian_5_set_Covariance(self, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix, NULL);
}

static void RemRef_Existence(struct Existence *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base)->ReferenceCount--;
	if ((&self->base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_Existence.CurrentCount--;
		Res_Existence.Next[Res_Existence.CurrentCount] = self;
		Del_Existence(self);
	}
}

struct Existence *New_Existence(void)
{
	static struct Existence const Default_Existence = { 1 };
	struct Existence *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Existence.CurrentCount == RC_Existence)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Existence.Next[Res_Existence.CurrentCount];
	Res_Existence.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Existence.MaximumCount = (Res_Existence.CurrentCount > Res_Existence.MaximumCount) ? Res_Existence.CurrentCount : Res_Existence.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Existence;
	return instance;
}

struct Existence *Assign_Existence(struct Existence **const left, struct Existence *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base)->ReferenceCount++;
	}
	RemRef_Existence(*left);
	*left = right;
	return right;
}

static void RemRef_ExistenceSpace(struct ExistenceSpace *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base)->ReferenceCount--;
	if ((&self->base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_ExistenceSpace.CurrentCount--;
		Res_ExistenceSpace.Next[Res_ExistenceSpace.CurrentCount] = self;
		Del_ExistenceSpace(self);
	}
}

struct ExistenceSpace *New_ExistenceSpace(void)
{
	static struct ExistenceSpace const Default_ExistenceSpace = { 1 };
	struct ExistenceSpace *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_ExistenceSpace.CurrentCount == RC_ExistenceSpace)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_ExistenceSpace.Next[Res_ExistenceSpace.CurrentCount];
	Res_ExistenceSpace.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_ExistenceSpace.MaximumCount = (Res_ExistenceSpace.CurrentCount > Res_ExistenceSpace.MaximumCount) ? Res_ExistenceSpace.CurrentCount : Res_ExistenceSpace.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_ExistenceSpace;
	return instance;
}

struct ExistenceSpace *Assign_ExistenceSpace(struct ExistenceSpace **const left, struct ExistenceSpace *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base)->ReferenceCount++;
	}
	RemRef_ExistenceSpace(*left);
	*left = right;
	return right;
}

static void RemRef_MatrixData_3(struct MatrixData_3 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_3.CurrentCount--;
		Res_MatrixData_3.Next[Res_MatrixData_3.CurrentCount] = self;
		Del_MatrixData_3(self);
	}
}

struct MatrixData_3 *New_MatrixData_3(void)
{
	static struct MatrixData_3 const Default_MatrixData_3 = { 1 };
	struct MatrixData_3 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_3.CurrentCount == RC_MatrixData_3)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_3.Next[Res_MatrixData_3.CurrentCount];
	Res_MatrixData_3.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_3.MaximumCount = (Res_MatrixData_3.CurrentCount > Res_MatrixData_3.MaximumCount) ? Res_MatrixData_3.CurrentCount : Res_MatrixData_3.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_3;
	return instance;
}

struct MatrixData_3 *Assign_MatrixData_3(struct MatrixData_3 **const left, struct MatrixData_3 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_3(*left);
	*left = right;
	return right;
}

static void Del_float64_t_1D_1(struct float64_t_1D_1 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_1D_1(struct float64_t_1D_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_1D_1.CurrentCount--;
		Res_float64_t_1D_1.Next[Res_float64_t_1D_1.CurrentCount] = self;
		Del_float64_t_1D_1(self);
	}
}

struct float64_t_1D_1 *New_float64_t_1D_1(void)
{
	static struct float64_t_1D_1 const Default_float64_t_1D_1 = { 1 };
	struct float64_t_1D_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_1D_1.CurrentCount == RC_float64_t_1D_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_1D_1.Next[Res_float64_t_1D_1.CurrentCount];
	Res_float64_t_1D_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_1D_1.MaximumCount = (Res_float64_t_1D_1.CurrentCount > Res_float64_t_1D_1.MaximumCount) ? Res_float64_t_1D_1.CurrentCount : Res_float64_t_1D_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_1D_1;
	return instance;
}

struct float64_t_1D_1 *Assign_float64_t_1D_1(struct float64_t_1D_1 **const left, struct float64_t_1D_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_1D_1(*left);
	*left = right;
	return right;
}

void MatrixData_3_ctor(struct MatrixData_3 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_1 *array = NULL;

	assert(rows == ((int32_t)1));
	assert(columns == ((int32_t)1));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_1();
	(void)Assign_float64_t_1D_1(&self->_data, array);
	(void)Assign_float64_t_1D_1(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct MatrixData_3 *MatrixData_20_Zeros_2(int32_t rows, int32_t columns)
{
	struct MatrixData_3 *result = NULL;
	struct MatrixData_3 *matrixData = NULL;

	assert(rows == ((int32_t)1));
	assert(columns == ((int32_t)1));
	matrixData = New_MatrixData_3();
	MatrixData_3_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData_3(&result, matrixData);
	(void)Assign_MatrixData_3(&matrixData, NULL);
	return result;
}

static void Space_1_ctor(struct Space_1 *const self, int32_t dimensions)
{
	struct Object *object = NULL;
	struct MatrixData_3 *matrixData = NULL;

	assert(dimensions == ((int32_t)1));
	object = New_Object();
	Object_ctor(object);
	(void)Assign_Object(&self->_spaceInformationLock, object);
	(void)Assign_Object(&object, NULL);
	Object_ctor(&self->base);
	self->Dimensions = dimensions;
	matrixData = MatrixData_20_Zeros_2(self->Dimensions, ((int32_t)1));
	(void)Assign_MatrixData_3(&self->_vector, matrixData);
	(void)Assign_MatrixData_3(&matrixData, NULL);
}

static void FiniteSpace_ctor(struct FiniteSpace *const self, int32_t dimensions)
{
	assert(dimensions == ((int32_t)1));
	Space_1_ctor(&self->base, dimensions);
}

void ExistenceSpace_ctor(struct ExistenceSpace *const self)
{
	FiniteSpace_ctor(&self->base, ((int32_t)1));
}

static void MatrixData_3_ctor_2(struct MatrixData_3 *const self, struct float64_t_1D_1 *data, int32_t rows, int32_t columns, bool_t takeDataOwnership)
{
	assert(rows == ((int32_t)1));
	assert(columns == ((int32_t)1));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	if (!(data != NULL))
	{
		abort();
	}
	if (!!takeDataOwnership)
	{
		(void)Assign_float64_t_1D_1(&self->_data, data);
	}
	else
	{
		struct float64_t_1D_1 *array = NULL;

		array = New_float64_t_1D_1();
		(void)Assign_float64_t_1D_1(&self->_data, array);
		(void)Assign_float64_t_1D_1(&array, NULL);
		(void)memcpy(&self->_data->Elements, &data->Elements, sizeof(float64_t) * ((int32_t)1));
	}
	self->Rows = rows;
	self->Columns = columns;
}

void MatrixData_3_ctor_1(struct MatrixData_3 *const self, struct float64_t_1D_1 *data, int32_t rows, int32_t columns)
{
	assert(rows == ((int32_t)1));
	assert(columns == ((int32_t)1));
	MatrixData_3_ctor_2(self, data, rows, columns, false);
}

static void Space_1_set_Array(struct Space_1 *const self, struct float64_t_1D_1 *value)
{
	struct MatrixData_3 *matrixData = NULL;

	if (!(value != NULL))
	{
		abort();
	}
	matrixData = New_MatrixData_3();
	MatrixData_3_ctor_1(matrixData, value, ((int32_t)1), ((int32_t)1));
	(void)Assign_MatrixData_3(&self->_vector, matrixData);
	(void)Assign_MatrixData_3(&matrixData, NULL);
}

static void ExistenceSpace_1_cctor(void)
{
	struct ExistenceSpace *existenceSpace = NULL;
	struct float64_t_1D_1 *array = NULL;
	struct ExistenceSpace *existenceSpace_1 = NULL;
	struct ExistenceSpace *existenceSpace_2 = NULL;
	struct ExistenceSpace *arg_35_0 = NULL;
	struct float64_t_1D_1 *array_1 = NULL;
	struct float64_t_1D_1 *array_2 = NULL;

	existenceSpace = New_ExistenceSpace();
	ExistenceSpace_ctor(existenceSpace);
	array = New_float64_t_1D_1();
	array->Elements[((int32_t)0)] = 1.0;
	Space_1_set_Array(&existenceSpace->base.base, array);
	(void)Assign_ExistenceSpace(&ExistenceSpace_1_Existent, existenceSpace);
	(void)Assign_ExistenceSpace(&existenceSpace, NULL);
	(void)Assign_float64_t_1D_1(&array, NULL);
	existenceSpace_2 = New_ExistenceSpace();
	ExistenceSpace_ctor(existenceSpace_2);
	(void)Assign_ExistenceSpace(&existenceSpace_1, existenceSpace_2);
	(void)Assign_ExistenceSpace(&existenceSpace_2, NULL);
	(void)Assign_ExistenceSpace(&arg_35_0, existenceSpace_1);
	array_2 = New_float64_t_1D_1();
	(void)Assign_float64_t_1D_1(&array_1, array_2);
	(void)Assign_float64_t_1D_1(&array_2, NULL);
	Space_1_set_Array(&arg_35_0->base.base, array_1);
	(void)Assign_ExistenceSpace(&ExistenceSpace_1_NonExistent, existenceSpace_1);
	RemRef_ExistenceSpace(existenceSpace_1);
	RemRef_ExistenceSpace(arg_35_0);
	RemRef_float64_t_1D_1(array_1);
}

static void RemRef_StaticListFactory(struct StaticListFactory *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListFactory.CurrentCount--;
		Res_StaticListFactory.Next[Res_StaticListFactory.CurrentCount] = self;
		Del_StaticListFactory(self);
	}
}

struct StaticListFactory *New_StaticListFactory(void)
{
	static struct StaticListFactory const Default_StaticListFactory = { 1 };
	struct StaticListFactory *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListFactory.CurrentCount == RC_StaticListFactory)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListFactory.Next[Res_StaticListFactory.CurrentCount];
	Res_StaticListFactory.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListFactory.MaximumCount = (Res_StaticListFactory.CurrentCount > Res_StaticListFactory.MaximumCount) ? Res_StaticListFactory.CurrentCount : Res_StaticListFactory.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListFactory;
	return instance;
}

struct StaticListFactory *Assign_StaticListFactory(struct StaticListFactory **const left, struct StaticListFactory *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListFactory(*left);
	*left = right;
	return right;
}

void StaticListFactory_ctor(struct StaticListFactory *const self, int32_t maximumCount)
{
	assert(maximumCount == ((int32_t)2));
	Object_ctor(&self->base);
	self->_maximumCount = maximumCount;
}

static void RemRef_UniformRandomGenerator(struct UniformRandomGenerator *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_UniformRandomGenerator.CurrentCount--;
		Res_UniformRandomGenerator.Next[Res_UniformRandomGenerator.CurrentCount] = self;
		Del_UniformRandomGenerator(self);
	}
}

struct UniformRandomGenerator *New_UniformRandomGenerator(void)
{
	static struct UniformRandomGenerator const Default_UniformRandomGenerator = { 1 };
	struct UniformRandomGenerator *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_UniformRandomGenerator.CurrentCount == RC_UniformRandomGenerator)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_UniformRandomGenerator.Next[Res_UniformRandomGenerator.CurrentCount];
	Res_UniformRandomGenerator.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_UniformRandomGenerator.MaximumCount = (Res_UniformRandomGenerator.CurrentCount > Res_UniformRandomGenerator.MaximumCount) ? Res_UniformRandomGenerator.CurrentCount : Res_UniformRandomGenerator.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_UniformRandomGenerator;
	return instance;
}

struct UniformRandomGenerator *Assign_UniformRandomGenerator(struct UniformRandomGenerator **const left, struct UniformRandomGenerator *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_UniformRandomGenerator(*left);
	*left = right;
	return right;
}

int64_t Stopwatch_GetTimestamp(void)
{
	return (int64_t)(clock() * (((int32_t)10000000) / CLOCKS_PER_SEC));
}

int32_t Environment_get_TickCount(void)
{
	return (int32_t)((clock() * ((int32_t)1000)) / CLOCKS_PER_SEC);
}

static void RemRef_Random(struct Random *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Random.CurrentCount--;
		Res_Random.Next[Res_Random.CurrentCount] = self;
		Del_Random(self);
	}
}

struct Random *New_Random(void)
{
	static struct Random const Default_Random = { 1 };
	struct Random *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Random.CurrentCount == RC_Random)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Random.Next[Res_Random.CurrentCount];
	Res_Random.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Random.MaximumCount = (Res_Random.CurrentCount > Res_Random.MaximumCount) ? Res_Random.CurrentCount : Res_Random.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Random;
	return instance;
}

struct Random *Assign_Random(struct Random **const left, struct Random *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Random(*left);
	*left = right;
	return right;
}

static void Del_int32_t_1D_56(struct int32_t_1D_56 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_int32_t_1D_56(struct int32_t_1D_56 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_int32_t_1D_56.CurrentCount--;
		Res_int32_t_1D_56.Next[Res_int32_t_1D_56.CurrentCount] = self;
		Del_int32_t_1D_56(self);
	}
}

struct int32_t_1D_56 *New_int32_t_1D_56(void)
{
	static struct int32_t_1D_56 const Default_int32_t_1D_56 = { 1 };
	struct int32_t_1D_56 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_int32_t_1D_56.CurrentCount == RC_int32_t_1D_56)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_int32_t_1D_56.Next[Res_int32_t_1D_56.CurrentCount];
	Res_int32_t_1D_56.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_int32_t_1D_56.MaximumCount = (Res_int32_t_1D_56.CurrentCount > Res_int32_t_1D_56.MaximumCount) ? Res_int32_t_1D_56.CurrentCount : Res_int32_t_1D_56.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_int32_t_1D_56;
	return instance;
}

struct int32_t_1D_56 *Assign_int32_t_1D_56(struct int32_t_1D_56 **const left, struct int32_t_1D_56 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_int32_t_1D_56(*left);
	*left = right;
	return right;
}

static int32_t Math_AbsHelper(int32_t value)
{
	if (!(value != INT32_MIN))
	{
		abort();
	}
	return -value;
}

int32_t Math_Abs_1(int32_t value)
{
	int32_t int32 = ((int32_t)0);

	if (!(value < ((int32_t)0)))
	{
		return value;
	}
	int32 = Math_AbsHelper(value);
	return int32;
}

void Random_ctor(struct Random *const self, int32_t Seed)
{
	struct int32_t_1D_56 *array = NULL;
	int32_t arg_28_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	struct int32_t_1D_56 *expr_90_cp_0 = NULL;
	int32_t expr_90_cp_1 = ((int32_t)0);
	struct int32_t_1D_56 *expr_BE_cp_0 = NULL;
	int32_t expr_BE_cp_1 = ((int32_t)0);

	array = New_int32_t_1D_56();
	(void)Assign_int32_t_1D_56(&self->SeedArray, array);
	(void)Assign_int32_t_1D_56(&array, NULL);
	Object_ctor(&self->base);
	if (!(Seed == INT32_MIN))
	{
		int32_t int32 = ((int32_t)0);

		int32 = Math_Abs_1(Seed);
		arg_28_0 = int32;
	}
	else
	{
		arg_28_0 = ((int32_t)2147483647);
	}
	num = arg_28_0;
	num2 = ((int32_t)161803398) - num;
	self->SeedArray->Elements[((int32_t)55)] = num2;
	num3 = ((int32_t)1);
	i = ((int32_t)1);
	while (i < ((int32_t)55))
	{
		num4 = (((int32_t)21) * i) % ((int32_t)55);
		self->SeedArray->Elements[num4] = num3;
		num3 = num2 - num3;
		if (!(num3 >= ((int32_t)0)))
		{
			num3 = num3 + ((int32_t)2147483647);
		}
		num2 = self->SeedArray->Elements[num4];
		i = i + ((int32_t)1);
	}
	j = ((int32_t)1);
	while (j < ((int32_t)5))
	{
		k = ((int32_t)1);
		while (k < ((int32_t)56))
		{
			(void)Assign_int32_t_1D_56(&expr_90_cp_0, self->SeedArray);
			expr_90_cp_1 = k;
			expr_90_cp_0->Elements[expr_90_cp_1] = expr_90_cp_0->Elements[expr_90_cp_1] - self->SeedArray->Elements[((int32_t)1) + ((k + ((int32_t)30)) % ((int32_t)55))];
			if (!(self->SeedArray->Elements[k] >= ((int32_t)0)))
			{
				(void)Assign_int32_t_1D_56(&expr_BE_cp_0, self->SeedArray);
				expr_BE_cp_1 = k;
				expr_BE_cp_0->Elements[expr_BE_cp_1] = expr_BE_cp_0->Elements[expr_BE_cp_1] + ((int32_t)2147483647);
			}
			k = k + ((int32_t)1);
		}
		j = j + ((int32_t)1);
	}
	self->inext = ((int32_t)0);
	self->inextp = ((int32_t)21);
	Seed = ((int32_t)1);
	RemRef_int32_t_1D_56(expr_90_cp_0);
	RemRef_int32_t_1D_56(expr_BE_cp_0);
}

void UniformRandomGenerator_ctor(struct UniformRandomGenerator *const self)
{
	uint64_t timestamp = ((uint64_t)0u);
	int64_t int64 = ((int64_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t tickCount = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t managedThreadId = ((int32_t)0);
	struct Random *random = NULL;

	Object_ctor(&self->base);
	int64 = Stopwatch_GetTimestamp();
	timestamp = int64;
	num = (int32_t)(timestamp >> (uint32_t)((int32_t)32));
	num2 = (int32_t)(timestamp & (uint64_t)((int32_t)-1));
	int32 = Environment_get_TickCount();
	tickCount = int32;
	managedThreadId = ((int32_t)0);
	random = New_Random();
	Random_ctor(random, (((uint32_t)num ^ (uint32_t)num2) ^ (uint32_t)tickCount) ^ (uint32_t)managedThreadId);
	(void)Assign_Random(&self->_random, random);
	(void)Assign_Random(&random, NULL);
}

int32_t StatiListFactor_get_MaximuCount(struct StaticListFactory *const self)
{
	return self->_maximumCount;
}

static void RemRef_StaticList_15(struct StaticList_15 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_15.CurrentCount--;
		Res_StaticList_15.Next[Res_StaticList_15.CurrentCount] = self;
		Del_StaticList_15(self);
	}
}

struct StaticList_15 *New_StaticList_15(void)
{
	static struct StaticList_15 const Default_StaticList_15 = { 1 };
	struct StaticList_15 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_15.CurrentCount == RC_StaticList_15)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_15.Next[Res_StaticList_15.CurrentCount];
	Res_StaticList_15.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_15.MaximumCount = (Res_StaticList_15.CurrentCount > Res_StaticList_15.MaximumCount) ? Res_StaticList_15.CurrentCount : Res_StaticList_15.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_15;
	return instance;
}

struct StaticList_15 *Assign_StaticList_15(struct StaticList_15 **const left, struct StaticList_15 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_15(*left);
	*left = right;
	return right;
}

static void RemRef_SampleProbabilityPair_2(struct SampleProbabilityPair_2 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_SampleProbabilityPair_2.CurrentCount--;
		Res_SampleProbabilityPair_2.Next[Res_SampleProbabilityPair_2.CurrentCount] = self;
		Del_SampleProbabilityPair_2(self);
	}
}

struct SampleProbabilityPair_2 *New_SampleProbabilityPair_2(void)
{
	static struct SampleProbabilityPair_2 const Default_SampleProbabilityPair_2 = { 1 };
	struct SampleProbabilityPair_2 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_SampleProbabilityPair_2.CurrentCount == RC_SampleProbabilityPair_2)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_SampleProbabilityPair_2.Next[Res_SampleProbabilityPair_2.CurrentCount];
	Res_SampleProbabilityPair_2.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_SampleProbabilityPair_2.MaximumCount = (Res_SampleProbabilityPair_2.CurrentCount > Res_SampleProbabilityPair_2.MaximumCount) ? Res_SampleProbabilityPair_2.CurrentCount : Res_SampleProbabilityPair_2.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_SampleProbabilityPair_2;
	return instance;
}

struct SampleProbabilityPair_2 *Assign_SampleProbabilityPair_2(struct SampleProbabilityPair_2 **const left, struct SampleProbabilityPair_2 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_SampleProbabilityPair_2(*left);
	*left = right;
	return right;
}

static void Del_SampleProbabilitPair_2_1D_2(struct SampleProbabilityPair_2_1D_2 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)2);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_SampleProbabilityPair_2(self->Elements[i]);
	}
}

static void RemRef_SampleProbabiPair_2_1D_2(struct SampleProbabilityPair_2_1D_2 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_SampleProbabilitPair_2_1D_2.CurrentCount--;
		Res_SampleProbabilitPair_2_1D_2.Next[Res_SampleProbabilitPair_2_1D_2.CurrentCount] = self;
		Del_SampleProbabilitPair_2_1D_2(self);
	}
}

struct SampleProbabilityPair_2_1D_2 *New_SampleProbabilitPair_2_1D_2(void)
{
	static struct SampleProbabilityPair_2_1D_2 const Defaul_SampleProbabiPair_2_1D_2 = { 1 };
	struct SampleProbabilityPair_2_1D_2 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_SampleProbabilitPair_2_1D_2.CurrentCount == RC_SampleProbabilityPair_2_1D_2)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_SampleProbabilitPair_2_1D_2.Next[Res_SampleProbabilitPair_2_1D_2.CurrentCount];
	Res_SampleProbabilitPair_2_1D_2.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_SampleProbabilitPair_2_1D_2.MaximumCount = (Res_SampleProbabilitPair_2_1D_2.CurrentCount > Res_SampleProbabilitPair_2_1D_2.MaximumCount) ? Res_SampleProbabilitPair_2_1D_2.CurrentCount : Res_SampleProbabilitPair_2_1D_2.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Defaul_SampleProbabiPair_2_1D_2;
	return instance;
}

struct SampleProbabilityPair_2_1D_2 *Assign_SampleProbabiPair_2_1D_2(struct SampleProbabilityPair_2_1D_2 **const left, struct SampleProbabilityPair_2_1D_2 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_SampleProbabiPair_2_1D_2(*left);
	*left = right;
	return right;
}

void StaticList_15_ctor(struct StaticList_15 *const self, int32_t maximumCount)
{
	struct SampleProbabilityPair_2_1D_2 *array = NULL;

	assert(maximumCount == ((int32_t)2));
	Object_ctor(&self->base);
	array = New_SampleProbabilitPair_2_1D_2();
	(void)Assign_SampleProbabiPair_2_1D_2(&self->_items, array);
	(void)Assign_SampleProbabiPair_2_1D_2(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_15 *StaticListFactory_CreateInstanc(struct StaticListFactory *const self, int32_t capacity)
{
	struct StaticList_15 *result = NULL;
	struct StaticList_15 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFactor_get_MaximuCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_15();
	StaticList_15_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_15(&result, staticList);
	(void)Assign_StaticList_15(&staticList, NULL);
	return result;
}

static void SampleSet_2_set_Samples(struct SampleSet_2 *const self, struct StaticList_15 *value)
{
	(void)Assign_StaticList_15(&self->Samples, value);
}

void SampleSet_2_ctor(struct SampleSet_2 *const self, int32_t capacity, struct StaticListFactory *listFactory)
{
	struct UniformRandomGenerator *uniformRandomGenerator = NULL;
	struct StaticListFactory *arg_1F_1 = NULL;
	struct StaticList_15 *staticList = NULL;

	uniformRandomGenerator = New_UniformRandomGenerator();
	UniformRandomGenerator_ctor(uniformRandomGenerator);
	(void)Assign_UniformRandomGenerator(&self->_randomGenerator, uniformRandomGenerator);
	(void)Assign_UniformRandomGenerator(&uniformRandomGenerator, NULL);
	Object_ctor(&self->base);
	(void)Assign_StaticListFactory(&arg_1F_1, listFactory);
	(void)Assign_StaticListFactory(&self->_listFactory, arg_1F_1);
	staticList = StaticListFactory_CreateInstanc(self->_listFactory, capacity);
	SampleSet_2_set_Samples(self, staticList);
	(void)Assign_StaticList_15(&staticList, NULL);
	RemRef_StaticListFactory(arg_1F_1);
}

static struct StaticList_15 *SampleSet_2_get_Samples(struct SampleSet_2 *const self)
{
	struct StaticList_15 *result = NULL;

	(void)Assign_StaticList_15(&result, self->Samples);
	return result;
}

void SampleProbabilPair_2_set_Sample(struct SampleProbabilityPair_2 *const self, struct ExistenceSpace *value)
{
	(void)Assign_ExistenceSpace(&self->Sample, value);
}

void SampleProbabiPair_2_set_Probabi(struct SampleProbabilityPair_2 *const self, float64_t value)
{
	self->Probability = value;
}

void SampleProbabilityPair_2_ctor(struct SampleProbabilityPair_2 *const self, struct ExistenceSpace *sample, float64_t probability)
{
	Object_ctor(&self->base);
	SampleProbabilPair_2_set_Sample(self, sample);
	SampleProbabiPair_2_set_Probabi(self, probability);
}

int32_t StaticList_15_get_Count(struct StaticList_15 *const self)
{
	return self->Count;
}

static void StaticList_15_CheckCount(struct StaticList_15 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_15_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_15_set_Count(struct StaticList_15 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_15_Add(struct StaticList_15 *const self, struct SampleProbabilityPair_2 *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_15_CheckCount(self);
	int32 = StaticList_15_get_Count(self);
	count = int32;
	(void)Assign_SampleProbabilityPair_2(&self->_items->Elements[count], value);
	int32_1 = StaticList_15_get_Count(self);
	StaticList_15_set_Count(self, int32_1 + ((int32_t)1));
}

static void TwoPointDistri_set_SuccesSample(struct TwoPointDistribution *const self, struct ExistenceSpace *value)
{
	(void)Assign_ExistenceSpace(&self->SuccessSample, value);
}

static void TwoPointDistri_set_FailurSample(struct TwoPointDistribution *const self, struct ExistenceSpace *value)
{
	(void)Assign_ExistenceSpace(&self->FailureSample, value);
}

struct SampleProbabilityPair_2 *StaticList_15_get_Item(struct StaticList_15 *const self, int32_t index)
{
	struct SampleProbabilityPair_2 *result = NULL;

	(void)Assign_SampleProbabilityPair_2(&result, self->_items->Elements[index]);
	return result;
}

float64_t Math_Exp(float64_t d)
{
	return (float64_t)exp(d);
}

float64_t SampleProbabiPair_2_get_Probabi(struct SampleProbabilityPair_2 *const self)
{
	return self->Probability;
}

void TwoPointDistributio_set_LogOdds(struct TwoPointDistribution *const self, float64_t value)
{
	struct StaticList_15 *staticList = NULL;
	struct SampleProbabilityPair_2 *sampleProbabilityPair = NULL;
	float64_t double_ = 0.0;
	struct StaticList_15 *staticList_1 = NULL;
	struct SampleProbabilityPair_2 *sampleProbabilityPair_1 = NULL;
	struct StaticList_15 *staticList_2 = NULL;
	struct SampleProbabilityPair_2 *sampleProbabilityPair_2 = NULL;
	float64_t double__1 = 0.0;

	self->_logOdds = value;
	self->_useLogOdds = true;
	if (!(self->_logOdds < 0.0))
	{
		struct StaticList_15 *staticList_3 = NULL;
		struct SampleProbabilityPair_2 *sampleProbabilityPair_3 = NULL;
		float64_t double__2 = 0.0;
		struct StaticList_15 *staticList_4 = NULL;
		struct SampleProbabilityPair_2 *sampleProbabilityPair_4 = NULL;
		struct StaticList_15 *staticList_5 = NULL;
		struct SampleProbabilityPair_2 *sampleProbabilityPair_5 = NULL;
		float64_t double__3 = 0.0;

		staticList_3 = SampleSet_2_get_Samples(&self->base);
		sampleProbabilityPair_3 = StaticList_15_get_Item(staticList_3, ((int32_t)0));
		double__2 = Math_Exp(-self->_logOdds);
		SampleProbabiPair_2_set_Probabi(sampleProbabilityPair_3, 1.0 / (double__2 + 1.0));
		(void)Assign_StaticList_15(&staticList_3, NULL);
		(void)Assign_SampleProbabilityPair_2(&sampleProbabilityPair_3, NULL);
		staticList_4 = SampleSet_2_get_Samples(&self->base);
		sampleProbabilityPair_4 = StaticList_15_get_Item(staticList_4, ((int32_t)1));
		staticList_5 = SampleSet_2_get_Samples(&self->base);
		sampleProbabilityPair_5 = StaticList_15_get_Item(staticList_5, ((int32_t)0));
		double__3 = SampleProbabiPair_2_get_Probabi(sampleProbabilityPair_5);
		SampleProbabiPair_2_set_Probabi(sampleProbabilityPair_4, 1.0 - double__3);
		(void)Assign_StaticList_15(&staticList_4, NULL);
		(void)Assign_SampleProbabilityPair_2(&sampleProbabilityPair_4, NULL);
		(void)Assign_StaticList_15(&staticList_5, NULL);
		(void)Assign_SampleProbabilityPair_2(&sampleProbabilityPair_5, NULL);
		return;
	}
	staticList = SampleSet_2_get_Samples(&self->base);
	sampleProbabilityPair = StaticList_15_get_Item(staticList, ((int32_t)1));
	double_ = Math_Exp(self->_logOdds);
	SampleProbabiPair_2_set_Probabi(sampleProbabilityPair, 1.0 / (double_ + 1.0));
	(void)Assign_StaticList_15(&staticList, NULL);
	(void)Assign_SampleProbabilityPair_2(&sampleProbabilityPair, NULL);
	staticList_1 = SampleSet_2_get_Samples(&self->base);
	sampleProbabilityPair_1 = StaticList_15_get_Item(staticList_1, ((int32_t)0));
	staticList_2 = SampleSet_2_get_Samples(&self->base);
	sampleProbabilityPair_2 = StaticList_15_get_Item(staticList_2, ((int32_t)1));
	double__1 = SampleProbabiPair_2_get_Probabi(sampleProbabilityPair_2);
	SampleProbabiPair_2_set_Probabi(sampleProbabilityPair_1, 1.0 - double__1);
	(void)Assign_StaticList_15(&staticList_1, NULL);
	(void)Assign_SampleProbabilityPair_2(&sampleProbabilityPair_1, NULL);
	(void)Assign_StaticList_15(&staticList_2, NULL);
	(void)Assign_SampleProbabilityPair_2(&sampleProbabilityPair_2, NULL);
}

void TwoPointDistribution_ctor(struct TwoPointDistribution *const self, struct ExistenceSpace *successSample, struct ExistenceSpace *failureSample)
{
	struct StaticListFactory *staticListFactory = NULL;
	struct StaticList_15 *staticList = NULL;
	struct SampleProbabilityPair_2 *sampleProbabilityPair = NULL;
	struct StaticList_15 *staticList_1 = NULL;
	struct SampleProbabilityPair_2 *sampleProbabilityPair_1 = NULL;

	staticListFactory = New_StaticListFactory();
	StaticListFactory_ctor(staticListFactory, ((int32_t)2));
	SampleSet_2_ctor(&self->base, ((int32_t)2), staticListFactory);
	(void)Assign_StaticListFactory(&staticListFactory, NULL);
	staticList = SampleSet_2_get_Samples(&self->base);
	sampleProbabilityPair = New_SampleProbabilityPair_2();
	SampleProbabilityPair_2_ctor(sampleProbabilityPair, successSample, 0.5);
	StaticList_15_Add(staticList, sampleProbabilityPair);
	(void)Assign_StaticList_15(&staticList, NULL);
	(void)Assign_SampleProbabilityPair_2(&sampleProbabilityPair, NULL);
	staticList_1 = SampleSet_2_get_Samples(&self->base);
	sampleProbabilityPair_1 = New_SampleProbabilityPair_2();
	SampleProbabilityPair_2_ctor(sampleProbabilityPair_1, failureSample, 0.5);
	StaticList_15_Add(staticList_1, sampleProbabilityPair_1);
	(void)Assign_StaticList_15(&staticList_1, NULL);
	(void)Assign_SampleProbabilityPair_2(&sampleProbabilityPair_1, NULL);
	TwoPointDistri_set_SuccesSample(self, successSample);
	TwoPointDistri_set_FailurSample(self, failureSample);
	TwoPointDistributio_set_LogOdds(self, 0.0);
}

void Existence_ctor(struct Existence *const self)
{
	TwoPointDistribution_ctor(&self->base, ExistenceSpace_1_Existent, ExistenceSpace_1_NonExistent);
}

float64_t Math_Log(float64_t d)
{
	return (float64_t)log(d);
}

void Existenc_set_ExistenceProbabili(struct Existence *const self, float64_t value)
{
	float64_t double_ = 0.0;

	if (!((value > 0.0) && (value < 1.0)))
	{
		abort();
	}
	double_ = Math_Log(value / (1.0 - value));
	TwoPointDistributio_set_LogOdds(&self->base, double_);
}

void Existence_ctor_1(struct Existence *const self, float64_t existenceProbability)
{
	Existence_ctor(self);
	Existenc_set_ExistenceProbabili(self, existenceProbability);
}

static void RemRef_Obstacle(struct Obstacle *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Obstacle.CurrentCount--;
		Res_Obstacle.Next[Res_Obstacle.CurrentCount] = self;
		Del_Obstacle(self);
	}
}

struct Obstacle *New_Obstacle(void)
{
	static struct Obstacle const Default_Obstacle = { 1 };
	struct Obstacle *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Obstacle.CurrentCount == RC_Obstacle)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Obstacle.Next[Res_Obstacle.CurrentCount];
	Res_Obstacle.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Obstacle.MaximumCount = (Res_Obstacle.CurrentCount > Res_Obstacle.MaximumCount) ? Res_Obstacle.CurrentCount : Res_Obstacle.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Obstacle;
	return instance;
}

struct Obstacle *Assign_Obstacle(struct Obstacle **const left, struct Obstacle *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Obstacle(*left);
	*left = right;
	return right;
}

static void RemRef_Object_1(struct Object_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Object_1.CurrentCount--;
		Res_Object_1.Next[Res_Object_1.CurrentCount] = self;
		Del_Object_1(self);
	}
}

struct Object_1 *New_Object_1(void)
{
	static struct Object_1 const Default_Object_1 = { 1 };
	struct Object_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Object_1.CurrentCount == RC_Object_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Object_1.Next[Res_Object_1.CurrentCount];
	Res_Object_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Object_1.MaximumCount = (Res_Object_1.CurrentCount > Res_Object_1.MaximumCount) ? Res_Object_1.CurrentCount : Res_Object_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Object_1;
	return instance;
}

struct Object_1 *Assign_Object_1(struct Object_1 **const left, struct Object_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Object_1(*left);
	*left = right;
	return right;
}

struct float64_t_1D_5 *MatrixData_get_DataReference(struct MatrixData *const self)
{
	struct float64_t_1D_5 *result = NULL;

	(void)Assign_float64_t_1D_5(&result, self->_data);
	return result;
}

struct MatrixData *MatrixData_20_Vec(int32_t start, int32_t end)
{
	int32_t num = ((int32_t)0);
	struct MatrixData *matrixData = NULL;
	struct MatrixData *matrixData_1 = NULL;
	struct float64_t_1D_5 *dataReference = NULL;
	struct float64_t_1D_5 *array = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData *result = NULL;

	assert(start == ((int32_t)0));
	assert(end == ((int32_t)4));
	num = (end - start) + ((int32_t)1);
	matrixData_1 = New_MatrixData();
	MatrixData_ctor(matrixData_1, num, ((int32_t)1));
	(void)Assign_MatrixData(&matrixData, matrixData_1);
	(void)Assign_MatrixData(&matrixData_1, NULL);
	array = MatrixData_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_5(&dataReference, array);
	(void)Assign_float64_t_1D_5(&array, NULL);
	i = ((int32_t)0);
	while (i < num)
	{
		dataReference->Elements[i] = (float64_t)(start + i);
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData(&result, matrixData);
	RemRef_MatrixData(matrixData);
	RemRef_float64_t_1D_5(dataReference);
	return result;
}

void Space_set_MatrixData(struct Space *const self, struct MatrixData *value)
{
	if (!(value != NULL))
	{
		abort();
	}
	(void)Assign_MatrixData(&self->_vector, value);
}

struct CASpace *Space_6_GetIndices(void)
{
	struct CASpace *tSpace = NULL;
	struct CASpace *caSpace = NULL;
	struct MatrixData *matrixData = NULL;
	struct CASpace *result = NULL;

	caSpace = New_CASpace();
	CASpace_ctor(caSpace);
	(void)Assign_CASpace(&tSpace, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	matrixData = MatrixData_20_Vec(((int32_t)0), (&tSpace->base.base.base)->Dimensions - ((int32_t)1));
	Space_set_MatrixData(&(*&tSpace)->base.base.base, matrixData);
	(void)Assign_MatrixData(&matrixData, NULL);
	(void)Assign_CASpace(&result, tSpace);
	RemRef_CASpace(tSpace);
	return result;
}

static void TrackWithMeasurements_1_cctor(void)
{
	struct CASpace *caSpace = NULL;

	caSpace = Space_6_GetIndices();
	(void)Assign_CASpace(&TrackWithMeasure_1_StateIndices, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
}

static void GaussianTrack_set_State(struct GaussianTrack *const self, struct Gaussian_5 *value)
{
	(void)Assign_Gaussian_5(&self->State, value);
}

static void GaussianTrack_set_Existence(struct GaussianTrack *const self, struct Existence *value)
{
	(void)Assign_Existence(&self->Existence, value);
}

static void GaussianTrack_set_ID(struct GaussianTrack *const self, uint64_t value)
{
	self->ID = value;
}

void GaussianTrack_ctor(struct GaussianTrack *const self, struct Gaussian_5 *state, struct Existence *existence, uint64_t id)
{
	Object_ctor(&self->base);
	GaussianTrack_set_State(self, state);
	GaussianTrack_set_Existence(self, existence);
	GaussianTrack_set_ID(self, id);
}

static void TrackWithMeasu_set_ARS308Object(struct TrackWithMeasurements *const self, struct Object_1 *value)
{
	(void)Assign_Object_1(&self->ARS308Object, value);
}

static void TrackWithMeasureme_set_Obstacle(struct TrackWithMeasurements *const self, struct Obstacle *value)
{
	(void)Assign_Obstacle(&self->Obstacle, value);
}

void TrackWithMeasurements_ctor(struct TrackWithMeasurements *const self, struct Gaussian_5 *state, struct Existence *existence, uint64_t id, struct Obstacle *obstacle, struct Object_1 *ars308Object)
{
	GaussianTrack_ctor(&self->base, state, existence, id);
	TrackWithMeasu_set_ARS308Object(self, ars308Object);
	TrackWithMeasureme_set_Obstacle(self, obstacle);
}

static void RemRef_StaticList_12(struct StaticList_12 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_12.CurrentCount--;
		Res_StaticList_12.Next[Res_StaticList_12.CurrentCount] = self;
		Del_StaticList_12(self);
	}
}

struct StaticList_12 *New_StaticList_12(void)
{
	static struct StaticList_12 const Default_StaticList_12 = { 1 };
	struct StaticList_12 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_12.CurrentCount == RC_StaticList_12)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_12.Next[Res_StaticList_12.CurrentCount];
	Res_StaticList_12.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_12.MaximumCount = (Res_StaticList_12.CurrentCount > Res_StaticList_12.MaximumCount) ? Res_StaticList_12.CurrentCount : Res_StaticList_12.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_12;
	return instance;
}

struct StaticList_12 *Assign_StaticList_12(struct StaticList_12 **const left, struct StaticList_12 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_12(*left);
	*left = right;
	return right;
}

static void Del_float64_t_1D_3(struct float64_t_1D_3 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_1D_3(struct float64_t_1D_3 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_1D_3.CurrentCount--;
		Res_float64_t_1D_3.Next[Res_float64_t_1D_3.CurrentCount] = self;
		Del_float64_t_1D_3(self);
	}
}

struct float64_t_1D_3 *New_float64_t_1D_3(void)
{
	static struct float64_t_1D_3 const Default_float64_t_1D_3 = { 1 };
	struct float64_t_1D_3 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_1D_3.CurrentCount == RC_float64_t_1D_3)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_1D_3.Next[Res_float64_t_1D_3.CurrentCount];
	Res_float64_t_1D_3.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_1D_3.MaximumCount = (Res_float64_t_1D_3.CurrentCount > Res_float64_t_1D_3.MaximumCount) ? Res_float64_t_1D_3.CurrentCount : Res_float64_t_1D_3.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_1D_3;
	return instance;
}

struct float64_t_1D_3 *Assign_float64_t_1D_3(struct float64_t_1D_3 **const left, struct float64_t_1D_3 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_1D_3(*left);
	*left = right;
	return right;
}

static void Del_RadarSpace_1D_15(struct RadarSpace_1D_15 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)15);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_RadarSpace(self->Elements[i]);
	}
}

static void RemRef_RadarSpace_1D_15(struct RadarSpace_1D_15 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_RadarSpace_1D_15.CurrentCount--;
		Res_RadarSpace_1D_15.Next[Res_RadarSpace_1D_15.CurrentCount] = self;
		Del_RadarSpace_1D_15(self);
	}
}

struct RadarSpace_1D_15 *New_RadarSpace_1D_15(void)
{
	static struct RadarSpace_1D_15 const Default_RadarSpace_1D_15 = { 1 };
	struct RadarSpace_1D_15 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_RadarSpace_1D_15.CurrentCount == RC_RadarSpace_1D_15)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_RadarSpace_1D_15.Next[Res_RadarSpace_1D_15.CurrentCount];
	Res_RadarSpace_1D_15.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_RadarSpace_1D_15.MaximumCount = (Res_RadarSpace_1D_15.CurrentCount > Res_RadarSpace_1D_15.MaximumCount) ? Res_RadarSpace_1D_15.CurrentCount : Res_RadarSpace_1D_15.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_RadarSpace_1D_15;
	return instance;
}

struct RadarSpace_1D_15 *Assign_RadarSpace_1D_15(struct RadarSpace_1D_15 **const left, struct RadarSpace_1D_15 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_RadarSpace_1D_15(*left);
	*left = right;
	return right;
}

void StaticList_12_ctor(struct StaticList_12 *const self, int32_t maximumCount)
{
	struct RadarSpace_1D_15 *array = NULL;

	assert(maximumCount == ((int32_t)15));
	Object_ctor(&self->base);
	array = New_RadarSpace_1D_15();
	(void)Assign_RadarSpace_1D_15(&self->_items, array);
	(void)Assign_RadarSpace_1D_15(&array, NULL);
	self->MaximumCount = maximumCount;
}

static void RemRef_RadarSpace(struct RadarSpace *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base)->ReferenceCount--;
	if ((&self->base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_RadarSpace.CurrentCount--;
		Res_RadarSpace.Next[Res_RadarSpace.CurrentCount] = self;
		Del_RadarSpace(self);
	}
}

struct RadarSpace *New_RadarSpace(void)
{
	static struct RadarSpace const Default_RadarSpace = { 1 };
	struct RadarSpace *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_RadarSpace.CurrentCount == RC_RadarSpace)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_RadarSpace.Next[Res_RadarSpace.CurrentCount];
	Res_RadarSpace.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_RadarSpace.MaximumCount = (Res_RadarSpace.CurrentCount > Res_RadarSpace.MaximumCount) ? Res_RadarSpace.CurrentCount : Res_RadarSpace.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_RadarSpace;
	return instance;
}

struct RadarSpace *Assign_RadarSpace(struct RadarSpace **const left, struct RadarSpace *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base)->ReferenceCount++;
	}
	RemRef_RadarSpace(*left);
	*left = right;
	return right;
}

static void RemRef_MatrixData_4(struct MatrixData_4 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_4.CurrentCount--;
		Res_MatrixData_4.Next[Res_MatrixData_4.CurrentCount] = self;
		Del_MatrixData_4(self);
	}
}

struct MatrixData_4 *New_MatrixData_4(void)
{
	static struct MatrixData_4 const Default_MatrixData_4 = { 1 };
	struct MatrixData_4 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_4.CurrentCount == RC_MatrixData_4)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_4.Next[Res_MatrixData_4.CurrentCount];
	Res_MatrixData_4.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_4.MaximumCount = (Res_MatrixData_4.CurrentCount > Res_MatrixData_4.MaximumCount) ? Res_MatrixData_4.CurrentCount : Res_MatrixData_4.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_4;
	return instance;
}

struct MatrixData_4 *Assign_MatrixData_4(struct MatrixData_4 **const left, struct MatrixData_4 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_4(*left);
	*left = right;
	return right;
}

void MatrixData_4_ctor(struct MatrixData_4 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_3 *array = NULL;

	assert(rows == ((int32_t)3));
	assert(columns == ((int32_t)1));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_3();
	(void)Assign_float64_t_1D_3(&self->_data, array);
	(void)Assign_float64_t_1D_3(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct MatrixData_4 *MatrixData_20_Zeros_3(int32_t rows, int32_t columns)
{
	struct MatrixData_4 *result = NULL;
	struct MatrixData_4 *matrixData = NULL;

	assert(rows == ((int32_t)3));
	assert(columns == ((int32_t)1));
	matrixData = New_MatrixData_4();
	MatrixData_4_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData_4(&result, matrixData);
	(void)Assign_MatrixData_4(&matrixData, NULL);
	return result;
}

static void Space_2_ctor(struct Space_2 *const self, int32_t dimensions)
{
	struct Object *object = NULL;
	struct MatrixData_4 *matrixData = NULL;

	assert(dimensions == ((int32_t)3));
	object = New_Object();
	Object_ctor(object);
	(void)Assign_Object(&self->_spaceInformationLock, object);
	(void)Assign_Object(&object, NULL);
	Object_ctor(&self->base);
	self->Dimensions = dimensions;
	matrixData = MatrixData_20_Zeros_3(self->Dimensions, ((int32_t)1));
	(void)Assign_MatrixData_4(&self->_vector, matrixData);
	(void)Assign_MatrixData_4(&matrixData, NULL);
}

static void AnguSpace_1_set_AngulDimenIndic(struct AngularSpace_1 *const self, struct int32_t_1D_1 *value)
{
	(void)Assign_int32_t_1D_1(&self->AngularDimensionsIndices, value);
}

struct int32_t_1D_1 *AnguSpace_1_get_AngulDimenIndic(struct AngularSpace_1 *const self)
{
	struct int32_t_1D_1 *result = NULL;

	(void)Assign_int32_t_1D_1(&result, self->AngularDimensionsIndices);
	return result;
}

static void AngularSpace_1_ctor(struct AngularSpace_1 *const self, int32_t dimensions, struct int32_t_1D_1 *angularDimensionsIndices, struct int32_t_1D_0 *additionAngularDimensionIndices)
{
	int32_t num = ((int32_t)0);
	struct int32_t_1D_1 *array = NULL;
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);

	assert(dimensions == ((int32_t)3));
	Space_2_ctor(&self->base, dimensions);
	num = ((int32_t)1) + ((int32_t)0);
	array = New_int32_t_1D_1();
	AnguSpace_1_set_AngulDimenIndic(self, array);
	(void)Assign_int32_t_1D_1(&array, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)1))
	{
		struct int32_t_1D_1 *array_1 = NULL;

		array_1 = AnguSpace_1_get_AngulDimenIndic(self);
		array_1->Elements[i] = angularDimensionsIndices->Elements[i];
		(void)Assign_int32_t_1D_1(&array_1, NULL);
		i = i + ((int32_t)1);
	}
	j = ((int32_t)0);
	while (j < ((int32_t)0))
	{
		struct int32_t_1D_1 *array_2 = NULL;

		array_2 = AnguSpace_1_get_AngulDimenIndic(self);
		array_2->Elements[j + ((int32_t)1)] = additionAngularDimensionIndices->Elements[j];
		(void)Assign_int32_t_1D_1(&array_2, NULL);
		j = j + ((int32_t)1);
	}
}

static void AngularSpace_1_ctor_1(struct AngularSpace_1 *const self, int32_t dimensions, struct int32_t_1D_1 *angularDimensionsIndices)
{
	struct int32_t_1D_0 *array = NULL;

	assert(dimensions == ((int32_t)3));
	array = New_int32_t_1D_0();
	AngularSpace_1_ctor(self, dimensions, angularDimensionsIndices, array);
	(void)Assign_int32_t_1D_0(&array, NULL);
}

void RadarSpace_ctor(struct RadarSpace *const self)
{
	struct int32_t_1D_1 *array = NULL;

	array = New_int32_t_1D_1();
	array->Elements[((int32_t)0)] = ((int32_t)1);
	AngularSpace_1_ctor_1(&self->base, ((int32_t)3), array);
	(void)Assign_int32_t_1D_1(&array, NULL);
}

int32_t StaticList_12_get_Count(struct StaticList_12 *const self)
{
	return self->Count;
}

static void StaticList_12_CheckCount(struct StaticList_12 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_12_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_12_set_Count(struct StaticList_12 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_12_Add(struct StaticList_12 *const self, struct RadarSpace *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_12_CheckCount(self);
	int32 = StaticList_12_get_Count(self);
	count = int32;
	(void)Assign_RadarSpace(&self->_items->Elements[count], value);
	int32_1 = StaticList_12_get_Count(self);
	StaticList_12_set_Count(self, int32_1 + ((int32_t)1));
}

static void RemRef_StaticList_4(struct StaticList_4 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_4.CurrentCount--;
		Res_StaticList_4.Next[Res_StaticList_4.CurrentCount] = self;
		Del_StaticList_4(self);
	}
}

struct StaticList_4 *New_StaticList_4(void)
{
	static struct StaticList_4 const Default_StaticList_4 = { 1 };
	struct StaticList_4 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_4.CurrentCount == RC_StaticList_4)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_4.Next[Res_StaticList_4.CurrentCount];
	Res_StaticList_4.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_4.MaximumCount = (Res_StaticList_4.CurrentCount > Res_StaticList_4.MaximumCount) ? Res_StaticList_4.CurrentCount : Res_StaticList_4.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_4;
	return instance;
}

struct StaticList_4 *Assign_StaticList_4(struct StaticList_4 **const left, struct StaticList_4 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_4(*left);
	*left = right;
	return right;
}

static void Del_Obstacle_1D_40(struct Obstacle_1D_40 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)40);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_Obstacle(self->Elements[i]);
	}
}

static void RemRef_Obstacle_1D_40(struct Obstacle_1D_40 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Obstacle_1D_40.CurrentCount--;
		Res_Obstacle_1D_40.Next[Res_Obstacle_1D_40.CurrentCount] = self;
		Del_Obstacle_1D_40(self);
	}
}

struct Obstacle_1D_40 *New_Obstacle_1D_40(void)
{
	static struct Obstacle_1D_40 const Default_Obstacle_1D_40 = { 1 };
	struct Obstacle_1D_40 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Obstacle_1D_40.CurrentCount == RC_Obstacle_1D_40)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Obstacle_1D_40.Next[Res_Obstacle_1D_40.CurrentCount];
	Res_Obstacle_1D_40.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Obstacle_1D_40.MaximumCount = (Res_Obstacle_1D_40.CurrentCount > Res_Obstacle_1D_40.MaximumCount) ? Res_Obstacle_1D_40.CurrentCount : Res_Obstacle_1D_40.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Obstacle_1D_40;
	return instance;
}

struct Obstacle_1D_40 *Assign_Obstacle_1D_40(struct Obstacle_1D_40 **const left, struct Obstacle_1D_40 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Obstacle_1D_40(*left);
	*left = right;
	return right;
}

void StaticList_4_ctor(struct StaticList_4 *const self, int32_t maximumCount)
{
	struct Obstacle_1D_40 *array = NULL;

	assert(maximumCount == ((int32_t)40));
	Object_ctor(&self->base);
	array = New_Obstacle_1D_40();
	(void)Assign_Obstacle_1D_40(&self->_items, array);
	(void)Assign_Obstacle_1D_40(&array, NULL);
	self->MaximumCount = maximumCount;
}

static void Obstacle_set_Id(struct Obstacle *const self, int32_t value)
{
	self->Id = value;
}

static void Obstacle_set_PositionX(struct Obstacle *const self, float64_t value)
{
	self->PositionX = value;
}

static void Obstacle_set_PositionY(struct Obstacle *const self, float64_t value)
{
	self->PositionY = value;
}

static void Obstacle_set_VelocityX(struct Obstacle *const self, float64_t value)
{
	self->VelocityX = value;
}

static void Obstacle_set_VelocityY(struct Obstacle *const self, float64_t value)
{
	self->VelocityY = value;
}

static void Obstacle_set_Width(struct Obstacle *const self, float64_t value)
{
	self->Width = value;
}

static void Obstacle_set_Length(struct Obstacle *const self, float64_t value)
{
	self->Length = value;
}

static void Obstacle_set_Timestamp(struct Obstacle *const self, uint32_t value)
{
	self->Timestamp = value;
}

static void Obstacle_set_ObstacleStatus(struct Obstacle *const self, ObstacleStatus value)
{
	self->ObstacleStatus = value;
}

static void Obstacle_set_ObstacleType(struct Obstacle *const self, ObstacleType value)
{
	self->ObstacleType = value;
}

static void Obstacle_set_AngleRate(struct Obstacle *const self, float64_t value)
{
	self->AngleRate = value;
}

static void Obstacle_set_AccelerationX(struct Obstacle *const self, float64_t value)
{
	self->AccelerationX = value;
}

static void Obstacle_set_Angle(struct Obstacle *const self, float64_t value)
{
	self->Angle = value;
}

static void Obstacle_set_CIPVFlag(struct Obstacle *const self, bool_t value)
{
	self->CIPVFlag = value;
}

void Obstacle_ctor(struct Obstacle *const self, uint32_t timestamp, int32_t id, float64_t positionX, float64_t positionY, float64_t velocityX, float64_t velocityY, ObstacleType obstacleType, ObstacleStatus obstacleStatus, float64_t length, float64_t width, float64_t angleRate, float64_t accelerationX, float64_t angle, bool_t cipvFlag)
{
	Object_ctor(&self->base);
	if (!(timestamp <= ((uint32_t)255u)))
	{
		abort();
	}
	if (!((id >= ((int32_t)0)) && (id <= ((int32_t)63))))
	{
		abort();
	}
	if (!((positionX >= 0.0) && (positionX <= 250.0)))
	{
		abort();
	}
	if (!((positionY >= -31.9375) && (positionY <= 32.0)))
	{
		abort();
	}
	if (!((velocityX >= -127.93) && (velocityX <= 127.93)))
	{
		abort();
	}
	if (!((velocityY >= -12.8) && (velocityY <= 12.7)))
	{
		abort();
	}
	if (!((length >= 0.0) && (length <= 31.5)))
	{
		abort();
	}
	if (!((width >= 0.0) && (width <= 12.5)))
	{
		abort();
	}
	if (!((angleRate >= -327.68) && (angleRate <= 327.68)))
	{
		abort();
	}
	if (!((accelerationX >= -14.97) && (accelerationX <= 14.97)))
	{
		abort();
	}
	if (!((angle >= -327.68) && (angle <= 327.68)))
	{
		abort();
	}
	Obstacle_set_Id(self, id);
	Obstacle_set_PositionX(self, positionX);
	Obstacle_set_PositionY(self, positionY);
	Obstacle_set_VelocityX(self, velocityX);
	Obstacle_set_VelocityY(self, velocityY);
	Obstacle_set_Width(self, width);
	Obstacle_set_Length(self, length);
	Obstacle_set_Timestamp(self, timestamp);
	Obstacle_set_ObstacleStatus(self, obstacleStatus);
	Obstacle_set_ObstacleType(self, obstacleType);
	Obstacle_set_AngleRate(self, angleRate);
	Obstacle_set_AccelerationX(self, accelerationX);
	Obstacle_set_Angle(self, angle);
	Obstacle_set_CIPVFlag(self, cipvFlag);
}

int32_t StaticList_4_get_Count(struct StaticList_4 *const self)
{
	return self->Count;
}

static void StaticList_4_CheckCount(struct StaticList_4 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_4_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_4_set_Count(struct StaticList_4 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_4_Add(struct StaticList_4 *const self, struct Obstacle *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_4_CheckCount(self);
	int32 = StaticList_4_get_Count(self);
	count = int32;
	(void)Assign_Obstacle(&self->_items->Elements[count], value);
	int32_1 = StaticList_4_get_Count(self);
	StaticList_4_set_Count(self, int32_1 + ((int32_t)1));
}

static void RemRef_StaticList_6(struct StaticList_6 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_6.CurrentCount--;
		Res_StaticList_6.Next[Res_StaticList_6.CurrentCount] = self;
		Del_StaticList_6(self);
	}
}

struct StaticList_6 *New_StaticList_6(void)
{
	static struct StaticList_6 const Default_StaticList_6 = { 1 };
	struct StaticList_6 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_6.CurrentCount == RC_StaticList_6)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_6.Next[Res_StaticList_6.CurrentCount];
	Res_StaticList_6.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_6.MaximumCount = (Res_StaticList_6.CurrentCount > Res_StaticList_6.MaximumCount) ? Res_StaticList_6.CurrentCount : Res_StaticList_6.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_6;
	return instance;
}

struct StaticList_6 *Assign_StaticList_6(struct StaticList_6 **const left, struct StaticList_6 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_6(*left);
	*left = right;
	return right;
}

static void Del_float64_t_1D_4(struct float64_t_1D_4 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_1D_4(struct float64_t_1D_4 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_1D_4.CurrentCount--;
		Res_float64_t_1D_4.Next[Res_float64_t_1D_4.CurrentCount] = self;
		Del_float64_t_1D_4(self);
	}
}

struct float64_t_1D_4 *New_float64_t_1D_4(void)
{
	static struct float64_t_1D_4 const Default_float64_t_1D_4 = { 1 };
	struct float64_t_1D_4 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_1D_4.CurrentCount == RC_float64_t_1D_4)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_1D_4.Next[Res_float64_t_1D_4.CurrentCount];
	Res_float64_t_1D_4.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_1D_4.MaximumCount = (Res_float64_t_1D_4.CurrentCount > Res_float64_t_1D_4.MaximumCount) ? Res_float64_t_1D_4.CurrentCount : Res_float64_t_1D_4.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_1D_4;
	return instance;
}

struct float64_t_1D_4 *Assign_float64_t_1D_4(struct float64_t_1D_4 **const left, struct float64_t_1D_4 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_1D_4(*left);
	*left = right;
	return right;
}

static void Del_MobilEyeSpace_1D_40(struct MobilEyeSpace_1D_40 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)40);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_MobilEyeSpace(self->Elements[i]);
	}
}

static void RemRef_MobilEyeSpace_1D_40(struct MobilEyeSpace_1D_40 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MobilEyeSpace_1D_40.CurrentCount--;
		Res_MobilEyeSpace_1D_40.Next[Res_MobilEyeSpace_1D_40.CurrentCount] = self;
		Del_MobilEyeSpace_1D_40(self);
	}
}

struct MobilEyeSpace_1D_40 *New_MobilEyeSpace_1D_40(void)
{
	static struct MobilEyeSpace_1D_40 const Default_MobilEyeSpace_1D_40 = { 1 };
	struct MobilEyeSpace_1D_40 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MobilEyeSpace_1D_40.CurrentCount == RC_MobilEyeSpace_1D_40)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MobilEyeSpace_1D_40.Next[Res_MobilEyeSpace_1D_40.CurrentCount];
	Res_MobilEyeSpace_1D_40.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MobilEyeSpace_1D_40.MaximumCount = (Res_MobilEyeSpace_1D_40.CurrentCount > Res_MobilEyeSpace_1D_40.MaximumCount) ? Res_MobilEyeSpace_1D_40.CurrentCount : Res_MobilEyeSpace_1D_40.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MobilEyeSpace_1D_40;
	return instance;
}

struct MobilEyeSpace_1D_40 *Assign_MobilEyeSpace_1D_40(struct MobilEyeSpace_1D_40 **const left, struct MobilEyeSpace_1D_40 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MobilEyeSpace_1D_40(*left);
	*left = right;
	return right;
}

void StaticList_6_ctor(struct StaticList_6 *const self, int32_t maximumCount)
{
	struct MobilEyeSpace_1D_40 *array = NULL;

	assert(maximumCount == ((int32_t)40));
	Object_ctor(&self->base);
	array = New_MobilEyeSpace_1D_40();
	(void)Assign_MobilEyeSpace_1D_40(&self->_items, array);
	(void)Assign_MobilEyeSpace_1D_40(&array, NULL);
	self->MaximumCount = maximumCount;
}

static void RemRef_MobilEyeSpace(struct MobilEyeSpace *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_MobilEyeSpace.CurrentCount--;
		Res_MobilEyeSpace.Next[Res_MobilEyeSpace.CurrentCount] = self;
		Del_MobilEyeSpace(self);
	}
}

struct MobilEyeSpace *New_MobilEyeSpace(void)
{
	static struct MobilEyeSpace const Default_MobilEyeSpace = { 1 };
	struct MobilEyeSpace *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MobilEyeSpace.CurrentCount == RC_MobilEyeSpace)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MobilEyeSpace.Next[Res_MobilEyeSpace.CurrentCount];
	Res_MobilEyeSpace.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MobilEyeSpace.MaximumCount = (Res_MobilEyeSpace.CurrentCount > Res_MobilEyeSpace.MaximumCount) ? Res_MobilEyeSpace.CurrentCount : Res_MobilEyeSpace.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MobilEyeSpace;
	return instance;
}

struct MobilEyeSpace *Assign_MobilEyeSpace(struct MobilEyeSpace **const left, struct MobilEyeSpace *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_MobilEyeSpace(*left);
	*left = right;
	return right;
}

static void RemRef_MatrixData_5(struct MatrixData_5 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_5.CurrentCount--;
		Res_MatrixData_5.Next[Res_MatrixData_5.CurrentCount] = self;
		Del_MatrixData_5(self);
	}
}

struct MatrixData_5 *New_MatrixData_5(void)
{
	static struct MatrixData_5 const Default_MatrixData_5 = { 1 };
	struct MatrixData_5 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_5.CurrentCount == RC_MatrixData_5)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_5.Next[Res_MatrixData_5.CurrentCount];
	Res_MatrixData_5.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_5.MaximumCount = (Res_MatrixData_5.CurrentCount > Res_MatrixData_5.MaximumCount) ? Res_MatrixData_5.CurrentCount : Res_MatrixData_5.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_5;
	return instance;
}

struct MatrixData_5 *Assign_MatrixData_5(struct MatrixData_5 **const left, struct MatrixData_5 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_5(*left);
	*left = right;
	return right;
}

void MatrixData_5_ctor(struct MatrixData_5 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_4 *array = NULL;

	assert(rows == ((int32_t)4));
	assert(columns == ((int32_t)1));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_4();
	(void)Assign_float64_t_1D_4(&self->_data, array);
	(void)Assign_float64_t_1D_4(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct MatrixData_5 *MatrixData_20_Zeros_4(int32_t rows, int32_t columns)
{
	struct MatrixData_5 *result = NULL;
	struct MatrixData_5 *matrixData = NULL;

	assert(rows == ((int32_t)4));
	assert(columns == ((int32_t)1));
	matrixData = New_MatrixData_5();
	MatrixData_5_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData_5(&result, matrixData);
	(void)Assign_MatrixData_5(&matrixData, NULL);
	return result;
}

static void Space_3_ctor(struct Space_3 *const self, int32_t dimensions)
{
	struct Object *object = NULL;
	struct MatrixData_5 *matrixData = NULL;

	assert(dimensions == ((int32_t)4));
	object = New_Object();
	Object_ctor(object);
	(void)Assign_Object(&self->_spaceInformationLock, object);
	(void)Assign_Object(&object, NULL);
	Object_ctor(&self->base);
	self->Dimensions = dimensions;
	matrixData = MatrixData_20_Zeros_4(self->Dimensions, ((int32_t)1));
	(void)Assign_MatrixData_5(&self->_vector, matrixData);
	(void)Assign_MatrixData_5(&matrixData, NULL);
}

void MobilEyeSpace_ctor(struct MobilEyeSpace *const self)
{
	Space_3_ctor(&self->base, ((int32_t)4));
}

int32_t StaticList_6_get_Count(struct StaticList_6 *const self)
{
	return self->Count;
}

static void StaticList_6_CheckCount(struct StaticList_6 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_6_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_6_set_Count(struct StaticList_6 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_6_Add(struct StaticList_6 *const self, struct MobilEyeSpace *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_6_CheckCount(self);
	int32 = StaticList_6_get_Count(self);
	count = int32;
	(void)Assign_MobilEyeSpace(&self->_items->Elements[count], value);
	int32_1 = StaticList_6_get_Count(self);
	StaticList_6_set_Count(self, int32_1 + ((int32_t)1));
}

static void Object_1_set_RollingCounter(struct Object_1 *const self, uint32_t value)
{
	self->RollingCounter = value;
}

static void Object_1_set_ID(struct Object_1 *const self, uint32_t value)
{
	self->ID = value;
}

static void Object_1_set_LongitudiDisplacem(struct Object_1 *const self, float64_t value)
{
	self->LongitudinalDisplacement = value;
}

static void Object_1_set_RelatiLongitVeloci(struct Object_1 *const self, float64_t value)
{
	self->RelativeLongitudinalVelocity = value;
}

static void Object_1_set_AcceleratLongitudi(struct Object_1 *const self, float64_t value)
{
	self->AccelerationLongitudinal = value;
}

static void Object_1_set_ProbabilOfExistanc(struct Object_1 *const self, float64_t value)
{
	self->ProbabilityOfExistance = value;
}

static void Object_1_set_DynamicProperty(struct Object_1 *const self, DynamicProperty value)
{
	self->DynamicProperty = value;
}

static void Object_1_set_LateralDisplacemen(struct Object_1 *const self, float64_t value)
{
	self->LateralDisplacement = value;
}

static void Object_1_set_Length(struct Object_1 *const self, float64_t value)
{
	self->Length = value;
}

static void Object_1_set_Width(struct Object_1 *const self, float64_t value)
{
	self->Width = value;
}

static void Object_1_set_MeasurementStatus(struct Object_1 *const self, MeasurementStatus value)
{
	self->MeasurementStatus = value;
}

static void Object_1_set_RCSValue(struct Object_1 *const self, float64_t value)
{
	self->RCSValue = value;
}

static void Object_1_set_LateralSpeed(struct Object_1 *const self, float64_t value)
{
	self->LateralSpeed = value;
}

static void Object_1_set_ObstacleProbabilit(struct Object_1 *const self, float64_t value)
{
	self->ObstacleProbability = value;
}

void Object_1_ctor(struct Object_1 *const self, uint32_t rollingCounter, uint32_t id, float64_t longitudinalDisplacement, float64_t relativeLongitudinalVelocity, float64_t accelerationLongitudinal, float64_t probabilityOfExistance, DynamicProperty dynamicProperty, float64_t lateralDisplacement, float64_t length, float64_t width, MeasurementStatus measurementStatus, float64_t rcsValue, float64_t lateralSpeed, float64_t obstacleProbability)
{
	Object_ctor(&self->base);
	if (!(rollingCounter <= ((uint32_t)3u)))
	{
		abort();
	}
	if (!(id <= ((uint32_t)63u)))
	{
		abort();
	}
	if (!((longitudinalDisplacement >= 0.0) && (longitudinalDisplacement <= 204.0)))
	{
		abort();
	}
	if (!((relativeLongitudinalVelocity >= -128.0) && (relativeLongitudinalVelocity <= 127.9375)))
	{
		abort();
	}
	if (!((probabilityOfExistance >= 0.0) && (probabilityOfExistance <= 7.0)))
	{
		abort();
	}
	if (!((accelerationLongitudinal >= -16.0) && (accelerationLongitudinal <= 15.9375)))
	{
		abort();
	}
	if (!((lateralDisplacement >= -51.9) && (lateralDisplacement <= 52.0)))
	{
		abort();
	}
	if (!((length >= 0.0) && (length <= 7.0)))
	{
		abort();
	}
	if (!((width >= 0.0) && (width <= 7.0)))
	{
		abort();
	}
	Object_1_set_RollingCounter(self, rollingCounter);
	Object_1_set_ID(self, id);
	Object_1_set_LongitudiDisplacem(self, longitudinalDisplacement);
	Object_1_set_RelatiLongitVeloci(self, relativeLongitudinalVelocity);
	Object_1_set_AcceleratLongitudi(self, accelerationLongitudinal);
	Object_1_set_ProbabilOfExistanc(self, probabilityOfExistance);
	Object_1_set_DynamicProperty(self, dynamicProperty);
	Object_1_set_LateralDisplacemen(self, lateralDisplacement);
	Object_1_set_Length(self, length);
	Object_1_set_Width(self, width);
	Object_1_set_MeasurementStatus(self, measurementStatus);
	Object_1_set_RCSValue(self, rcsValue);
	Object_1_set_LateralSpeed(self, lateralSpeed);
	Object_1_set_ObstacleProbabilit(self, obstacleProbability);
}

void Object_1_ctor_1(struct Object_1 *const self, uint32_t rollingCounter, uint32_t id, float64_t longitudinalDisplacement, float64_t relativeLongitudinalVelocity, float64_t accelerationLongitudinal, float64_t probabilityOfExistance, int32_t dynamicProperty, float64_t lateralDisplacement, float64_t length, float64_t width, int32_t measurementStatus, float64_t rcsValue, float64_t lateralSpeed, float64_t obstacleProbability)
{
	Object_1_ctor(self, rollingCounter, id, longitudinalDisplacement, relativeLongitudinalVelocity, accelerationLongitudinal, probabilityOfExistance, (DynamicProperty )dynamicProperty, lateralDisplacement, length, width, (MeasurementStatus )measurementStatus, rcsValue, lateralSpeed, obstacleProbability);
}

static void RemRef_StaticList_9(struct StaticList_9 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_9.CurrentCount--;
		Res_StaticList_9.Next[Res_StaticList_9.CurrentCount] = self;
		Del_StaticList_9(self);
	}
}

struct StaticList_9 *New_StaticList_9(void)
{
	static struct StaticList_9 const Default_StaticList_9 = { 1 };
	struct StaticList_9 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_9.CurrentCount == RC_StaticList_9)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_9.Next[Res_StaticList_9.CurrentCount];
	Res_StaticList_9.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_9.MaximumCount = (Res_StaticList_9.CurrentCount > Res_StaticList_9.MaximumCount) ? Res_StaticList_9.CurrentCount : Res_StaticList_9.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_9;
	return instance;
}

struct StaticList_9 *Assign_StaticList_9(struct StaticList_9 **const left, struct StaticList_9 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_9(*left);
	*left = right;
	return right;
}

static void RemRef_FrontRadarObjectSpace(struct FrontRadarObjectSpace *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base)->ReferenceCount--;
	if ((&self->base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_FrontRadarObjectSpace.CurrentCount--;
		Res_FrontRadarObjectSpace.Next[Res_FrontRadarObjectSpace.CurrentCount] = self;
		Del_FrontRadarObjectSpace(self);
	}
}

struct FrontRadarObjectSpace *New_FrontRadarObjectSpace(void)
{
	static struct FrontRadarObjectSpace const Default_FrontRadarObjectSpace = { 1 };
	struct FrontRadarObjectSpace *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_FrontRadarObjectSpace.CurrentCount == RC_FrontRadarObjectSpace)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_FrontRadarObjectSpace.Next[Res_FrontRadarObjectSpace.CurrentCount];
	Res_FrontRadarObjectSpace.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_FrontRadarObjectSpace.MaximumCount = (Res_FrontRadarObjectSpace.CurrentCount > Res_FrontRadarObjectSpace.MaximumCount) ? Res_FrontRadarObjectSpace.CurrentCount : Res_FrontRadarObjectSpace.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_FrontRadarObjectSpace;
	return instance;
}

struct FrontRadarObjectSpace *Assign_FrontRadarObjectSpace(struct FrontRadarObjectSpace **const left, struct FrontRadarObjectSpace *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base)->ReferenceCount++;
	}
	RemRef_FrontRadarObjectSpace(*left);
	*left = right;
	return right;
}

static void Del_FrontRadarObjectSpace_1D_40(struct FrontRadarObjectSpace_1D_40 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)40);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_FrontRadarObjectSpace(self->Elements[i]);
	}
}

static void RemRef_FronRadaObjecSpace_1D_40(struct FrontRadarObjectSpace_1D_40 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_FrontRadarObjectSpace_1D_40.CurrentCount--;
		Res_FrontRadarObjectSpace_1D_40.Next[Res_FrontRadarObjectSpace_1D_40.CurrentCount] = self;
		Del_FrontRadarObjectSpace_1D_40(self);
	}
}

struct FrontRadarObjectSpace_1D_40 *New_FrontRadarObjectSpace_1D_40(void)
{
	static struct FrontRadarObjectSpace_1D_40 const Defa_FrontRadarObjecSpace_1D_40 = { 1 };
	struct FrontRadarObjectSpace_1D_40 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_FrontRadarObjectSpace_1D_40.CurrentCount == RC_FrontRadarObjectSpace_1D_40)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_FrontRadarObjectSpace_1D_40.Next[Res_FrontRadarObjectSpace_1D_40.CurrentCount];
	Res_FrontRadarObjectSpace_1D_40.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_FrontRadarObjectSpace_1D_40.MaximumCount = (Res_FrontRadarObjectSpace_1D_40.CurrentCount > Res_FrontRadarObjectSpace_1D_40.MaximumCount) ? Res_FrontRadarObjectSpace_1D_40.CurrentCount : Res_FrontRadarObjectSpace_1D_40.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Defa_FrontRadarObjecSpace_1D_40;
	return instance;
}

struct FrontRadarObjectSpace_1D_40 *Assi_FrontRadarObjecSpace_1D_40(struct FrontRadarObjectSpace_1D_40 **const left, struct FrontRadarObjectSpace_1D_40 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_FronRadaObjecSpace_1D_40(*left);
	*left = right;
	return right;
}

void StaticList_9_ctor(struct StaticList_9 *const self, int32_t maximumCount)
{
	struct FrontRadarObjectSpace_1D_40 *array = NULL;

	assert(maximumCount == ((int32_t)40));
	Object_ctor(&self->base);
	array = New_FrontRadarObjectSpace_1D_40();
	(void)Assi_FrontRadarObjecSpace_1D_40(&self->_items, array);
	(void)Assi_FrontRadarObjecSpace_1D_40(&array, NULL);
	self->MaximumCount = maximumCount;
}

static void CVComponentsSpace_ctor(struct CVComponentsSpace *const self, int32_t additionalDimensions)
{
	assert(additionalDimensions == ((int32_t)1));
	Space_ctor(&self->base, ((int32_t)4) + additionalDimensions);
}

void FrontRadarObjectSpace_ctor(struct FrontRadarObjectSpace *const self)
{
	CVComponentsSpace_ctor(&self->base, ((int32_t)1));
}

float64_t Object_1_get_LongitudiDisplacem(struct Object_1 *const self)
{
	return self->LongitudinalDisplacement;
}

void Nullable_ctor(struct Nullable *const self, int32_t value)
{
	(*self).value = value;
	(*self).hasValue = true;
}

static void Space_set_LastSetIndex(struct Space *const self, struct Nullable value)
{
	self->LastSetIndex = value;
}

struct MatrixData *Space_get_MatrixData(struct Space *const self)
{
	struct MatrixData *result = NULL;

	(void)Assign_MatrixData(&result, self->_vector);
	return result;
}

void MatrixData_set_Item(struct MatrixData *const self, int32_t index, float64_t value)
{
	if (!((index >= ((int32_t)0)) && (index < ((int32_t)5))))
	{
		abort();
	}
	self->_data->Elements[index] = value;
}

void Space_set_Item(struct Space *const self, int32_t index, float64_t value)
{
	struct Nullable nullable = { 0 };
	struct MatrixData *matrixData = NULL;

	if (!((index < self->Dimensions) && (index >= ((int32_t)0))))
	{
		abort();
	}
	Nullable_ctor(&nullable, index);
	Space_set_LastSetIndex(self, nullable);
	matrixData = Space_get_MatrixData(self);
	MatrixData_set_Item(matrixData, index, value);
	(void)Assign_MatrixData(&matrixData, NULL);
}

void CVComponentsSpace_set_X(struct CVComponentsSpace *const self, float64_t value)
{
	Space_set_Item(&self->base, ((int32_t)0), value);
}

float64_t Object_1_get_LateralDisplacemen(struct Object_1 *const self)
{
	return self->LateralDisplacement;
}

void CVComponentsSpace_set_Y(struct CVComponentsSpace *const self, float64_t value)
{
	Space_set_Item(&self->base, ((int32_t)1), value);
}

float64_t Object_1_get_RelatiLongitVeloci(struct Object_1 *const self)
{
	return self->RelativeLongitudinalVelocity;
}

void CVComponentsSpace_set_Vx(struct CVComponentsSpace *const self, float64_t value)
{
	Space_set_Item(&self->base, ((int32_t)2), value);
}

float64_t Object_1_get_LateralSpeed(struct Object_1 *const self)
{
	return self->LateralSpeed;
}

void CVComponentsSpace_set_Vy(struct CVComponentsSpace *const self, float64_t value)
{
	Space_set_Item(&self->base, ((int32_t)3), value);
}

float64_t Object_1_get_AcceleratLongitudi(struct Object_1 *const self)
{
	return self->AccelerationLongitudinal;
}

void FrontRadarObjectSpace_set_A(struct FrontRadarObjectSpace *const self, float64_t value)
{
	Space_set_Item(&self->base.base, ((int32_t)4), value);
}

void FronRadaObjeSpac_set_Ars308Obje(struct FrontRadarObjectSpace *const self, struct Object_1 *value)
{
	(void)Assign_Object_1(&self->Ars308Object, value);
}

int32_t StaticList_9_get_Count(struct StaticList_9 *const self)
{
	return self->Count;
}

static void StaticList_9_CheckCount(struct StaticList_9 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_9_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_9_set_Count(struct StaticList_9 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_9_Add(struct StaticList_9 *const self, struct FrontRadarObjectSpace *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_9_CheckCount(self);
	int32 = StaticList_9_get_Count(self);
	count = int32;
	(void)Assign_FrontRadarObjectSpace(&self->_items->Elements[count], value);
	int32_1 = StaticList_9_get_Count(self);
	StaticList_9_set_Count(self, int32_1 + ((int32_t)1));
}

static void RemRef_Measure_2(struct Measure_2 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_Measure_2.CurrentCount--;
		Res_Measure_2.Next[Res_Measure_2.CurrentCount] = self;
		Del_Measure_2(self);
	}
}

struct Measure_2 *New_Measure_2(void)
{
	static struct Measure_2 const Default_Measure_2 = { 1 };
	struct Measure_2 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Measure_2.CurrentCount == RC_Measure_2)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Measure_2.Next[Res_Measure_2.CurrentCount];
	Res_Measure_2.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Measure_2.MaximumCount = (Res_Measure_2.CurrentCount > Res_Measure_2.MaximumCount) ? Res_Measure_2.CurrentCount : Res_Measure_2.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Measure_2;
	return instance;
}

struct Measure_2 *Assign_Measure_2(struct Measure_2 **const left, struct Measure_2 *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_Measure_2(*left);
	*left = right;
	return right;
}

void Measure_set_Value(struct Measure *const self, float64_t value)
{
	self->Value = value;
}

void Measure_ctor(struct Measure *const self, float64_t Value)
{
	Object_ctor(&self->base);
	Measure_set_Value(self, Value);
}

void Measure_2_ctor(struct Measure_2 *const self, float64_t Value)
{
	Measure_ctor(&self->base, Value);
	Measure_set_Value(&self->base, Value);
}

static void RemRef_Measure_3(struct Measure_3 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_Measure_3.CurrentCount--;
		Res_Measure_3.Next[Res_Measure_3.CurrentCount] = self;
		Del_Measure_3(self);
	}
}

struct Measure_3 *New_Measure_3(void)
{
	static struct Measure_3 const Default_Measure_3 = { 1 };
	struct Measure_3 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Measure_3.CurrentCount == RC_Measure_3)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Measure_3.Next[Res_Measure_3.CurrentCount];
	Res_Measure_3.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Measure_3.MaximumCount = (Res_Measure_3.CurrentCount > Res_Measure_3.MaximumCount) ? Res_Measure_3.CurrentCount : Res_Measure_3.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Measure_3;
	return instance;
}

struct Measure_3 *Assign_Measure_3(struct Measure_3 **const left, struct Measure_3 *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_Measure_3(*left);
	*left = right;
	return right;
}

void Measure_1_set_Value(struct Measure_1 *const self, float64_t value)
{
	self->Value = value;
}

void Measure_1_ctor(struct Measure_1 *const self, float64_t Value)
{
	Object_ctor(&self->base);
	Measure_1_set_Value(self, Value);
}

void Measure_3_ctor(struct Measure_3 *const self, float64_t Value)
{
	Measure_1_ctor(&self->base, Value);
	Measure_1_set_Value(&self->base, Value);
}

struct FrontRadarObjectSpace *Space_6_GetIndices_1(void)
{
	struct FrontRadarObjectSpace *tSpace = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
	struct MatrixData *matrixData = NULL;
	struct FrontRadarObjectSpace *result = NULL;

	frontRadarObjectSpace = New_FrontRadarObjectSpace();
	FrontRadarObjectSpace_ctor(frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&tSpace, frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	matrixData = MatrixData_20_Vec(((int32_t)0), (&tSpace->base.base)->Dimensions - ((int32_t)1));
	Space_set_MatrixData(&(*&tSpace)->base.base, matrixData);
	(void)Assign_MatrixData(&matrixData, NULL);
	(void)Assign_FrontRadarObjectSpace(&result, tSpace);
	RemRef_FrontRadarObjectSpace(tSpace);
	return result;
}

struct float64_t_1D_4 *MatrixData_5_get_DataReference(struct MatrixData_5 *const self)
{
	struct float64_t_1D_4 *result = NULL;

	(void)Assign_float64_t_1D_4(&result, self->_data);
	return result;
}

struct MatrixData_5 *MatrixData_20_Vec_1(int32_t start, int32_t end)
{
	int32_t num = ((int32_t)0);
	struct MatrixData_5 *matrixData = NULL;
	struct MatrixData_5 *matrixData_1 = NULL;
	struct float64_t_1D_4 *dataReference = NULL;
	struct float64_t_1D_4 *array = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_5 *result = NULL;

	assert(start == ((int32_t)0));
	assert(end == ((int32_t)3));
	num = (end - start) + ((int32_t)1);
	matrixData_1 = New_MatrixData_5();
	MatrixData_5_ctor(matrixData_1, num, ((int32_t)1));
	(void)Assign_MatrixData_5(&matrixData, matrixData_1);
	(void)Assign_MatrixData_5(&matrixData_1, NULL);
	array = MatrixData_5_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_4(&dataReference, array);
	(void)Assign_float64_t_1D_4(&array, NULL);
	i = ((int32_t)0);
	while (i < num)
	{
		dataReference->Elements[i] = (float64_t)(start + i);
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_5(&result, matrixData);
	RemRef_MatrixData_5(matrixData);
	RemRef_float64_t_1D_4(dataReference);
	return result;
}

void Space_3_set_MatrixData(struct Space_3 *const self, struct MatrixData_5 *value)
{
	if (!(value != NULL))
	{
		abort();
	}
	(void)Assign_MatrixData_5(&self->_vector, value);
}

struct MobilEyeSpace *Space_6_GetIndices_2(void)
{
	struct MobilEyeSpace *tSpace = NULL;
	struct MobilEyeSpace *mobilEyeSpace = NULL;
	struct MatrixData_5 *matrixData = NULL;
	struct MobilEyeSpace *result = NULL;

	mobilEyeSpace = New_MobilEyeSpace();
	MobilEyeSpace_ctor(mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&tSpace, mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
	matrixData = MatrixData_20_Vec_1(((int32_t)0), (&tSpace->base)->Dimensions - ((int32_t)1));
	Space_3_set_MatrixData(&(*&tSpace)->base, matrixData);
	(void)Assign_MatrixData_5(&matrixData, NULL);
	(void)Assign_MobilEyeSpace(&result, tSpace);
	RemRef_MobilEyeSpace(tSpace);
	return result;
}

static void Tracking_1_cctor(void)
{
	struct CASpace *caSpace = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
	struct MobilEyeSpace *mobilEyeSpace = NULL;

	caSpace = Space_6_GetIndices();
	(void)Assign_CASpace(&Tracking_1_StateIndices, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	frontRadarObjectSpace = Space_6_GetIndices_1();
	(void)Assign_FrontRadarObjectSpace(&Tracki_1_FrontRadarObjectIndice, frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	mobilEyeSpace = Space_6_GetIndices_2();
	(void)Assign_MobilEyeSpace(&Tracking_1_MobilEyeIndices, mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
}

static void RemRef_Tracking(struct Tracking *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Tracking.CurrentCount--;
		Res_Tracking.Next[Res_Tracking.CurrentCount] = self;
		Del_Tracking(self);
	}
}

struct Tracking *New_Tracking(void)
{
	static struct Tracking const Default_Tracking = { 1 };
	struct Tracking *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Tracking.CurrentCount == RC_Tracking)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Tracking.Next[Res_Tracking.CurrentCount];
	Res_Tracking.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Tracking.MaximumCount = (Res_Tracking.CurrentCount > Res_Tracking.MaximumCount) ? Res_Tracking.CurrentCount : Res_Tracking.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Tracking;
	return instance;
}

struct Tracking *Assign_Tracking(struct Tracking **const left, struct Tracking *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Tracking(*left);
	*left = right;
	return right;
}

static void RemRef_SensorProperties(struct SensorProperties *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_SensorProperties.CurrentCount--;
		Res_SensorProperties.Next[Res_SensorProperties.CurrentCount] = self;
		Del_SensorProperties(self);
	}
}

struct SensorProperties *New_SensorProperties(void)
{
	static struct SensorProperties const Default_SensorProperties = { 1 };
	struct SensorProperties *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_SensorProperties.CurrentCount == RC_SensorProperties)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_SensorProperties.Next[Res_SensorProperties.CurrentCount];
	Res_SensorProperties.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_SensorProperties.MaximumCount = (Res_SensorProperties.CurrentCount > Res_SensorProperties.MaximumCount) ? Res_SensorProperties.CurrentCount : Res_SensorProperties.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_SensorProperties;
	return instance;
}

struct SensorProperties *Assign_SensorProperties(struct SensorProperties **const left, struct SensorProperties *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_SensorProperties(*left);
	*left = right;
	return right;
}

static void RemRef_FrontRadarNearParameters(struct FrontRadarNearParameters *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_FrontRadarNearParameters.CurrentCount--;
		Res_FrontRadarNearParameters.Next[Res_FrontRadarNearParameters.CurrentCount] = self;
		Del_FrontRadarNearParameters(self);
	}
}

struct FrontRadarNearParameters *New_FrontRadarNearParameters(void)
{
	static struct FrontRadarNearParameters const Default_FrontRadarNearParameter = { 1 };
	struct FrontRadarNearParameters *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_FrontRadarNearParameters.CurrentCount == RC_FrontRadarNearParameters)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_FrontRadarNearParameters.Next[Res_FrontRadarNearParameters.CurrentCount];
	Res_FrontRadarNearParameters.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_FrontRadarNearParameters.MaximumCount = (Res_FrontRadarNearParameters.CurrentCount > Res_FrontRadarNearParameters.MaximumCount) ? Res_FrontRadarNearParameters.CurrentCount : Res_FrontRadarNearParameters.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_FrontRadarNearParameter;
	return instance;
}

struct FrontRadarNearParameters *Assign_FrontRadarNearParameters(struct FrontRadarNearParameters **const left, struct FrontRadarNearParameters *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_FrontRadarNearParameters(*left);
	*left = right;
	return right;
}

void FrontRadarNearParameters_ctor(struct FrontRadarNearParameters *const self)
{
	struct float64_t_1D_3 *array = NULL;

	array = New_float64_t_1D_3();
	(void)Assign_float64_t_1D_3(&self->_noiseMatrixDiagonal, array);
	(void)Assign_float64_t_1D_3(&array, NULL);
	Object_ctor(&self->base);
}

void FrontRadarNearParam_set_PositiX(struct FrontRadarNearParameters *const self, float64_t value)
{
	self->PositionX = value;
}

void FrontRadarNearParam_set_PositiY(struct FrontRadarNearParameters *const self, float64_t value)
{
	self->PositionY = value;
}

void FrontRadarNearParam_set_PositiZ(struct FrontRadarNearParameters *const self, float64_t value)
{
	self->PositionZ = value;
}

void FrontRadarNearParam_set_RotatiZ(struct FrontRadarNearParameters *const self, float64_t value)
{
	self->RotationZ = value;
}

void FronRadaNearPara_set_MinimRange(struct FrontRadarNearParameters *const self, float64_t value)
{
	self->MinimumRange = value;
}

void FronRadaNearPara_set_MaximRange(struct FrontRadarNearParameters *const self, float64_t value)
{
	self->MaximumRange = value;
}

void FronRadaNearPara_set_MinimAngle(struct FrontRadarNearParameters *const self, float64_t value)
{
	self->MinimumAngle = value;
}

void FronRadaNearPara_set_MaximAngle(struct FrontRadarNearParameters *const self, float64_t value)
{
	self->MaximumAngle = value;
}

void FronRadaNearPara_set_DetecProba(struct FrontRadarNearParameters *const self, float64_t value)
{
	self->DetectionProbability = value;
}

void FronRadaNearPara_set_CluttLambd(struct FrontRadarNearParameters *const self, float64_t value)
{
	self->ClutterLambda = value;
}

static void FroRadNearPara_CalcNoisMatrDiag(struct FrontRadarNearParameters *const self)
{
	struct float64_t_1D_3 *array = NULL;

	array = New_float64_t_1D_3();
	array->Elements[((int32_t)0)] = self->_sigmaRange * self->_sigmaRange;
	array->Elements[((int32_t)1)] = self->_sigmaAngle * self->_sigmaAngle;
	array->Elements[((int32_t)2)] = self->_sigmaRangeRate * self->_sigmaRangeRate;
	(void)Assign_float64_t_1D_3(&self->_noiseMatrixDiagonal, array);
	(void)Assign_float64_t_1D_3(&array, NULL);
}

void FronRadaNearPara_set_SigmaRange(struct FrontRadarNearParameters *const self, float64_t value)
{
	self->_sigmaRange = value;
	FroRadNearPara_CalcNoisMatrDiag(self);
}

void FronRadaNearPara_set_SigmaAngle(struct FrontRadarNearParameters *const self, float64_t value)
{
	self->_sigmaAngle = value;
	FroRadNearPara_CalcNoisMatrDiag(self);
}

void FroRadNearPara_set_SigmRangRate(struct FrontRadarNearParameters *const self, float64_t value)
{
	self->_sigmaRangeRate = value;
	FroRadNearPara_CalcNoisMatrDiag(self);
}

static struct FrontRadarNearParameters *SenPro_1_GetDefFronRadaNearPara(void)
{
	struct FrontRadarNearParameters *result = NULL;
	struct FrontRadarNearParameters *frontRadarNearParameters = NULL;

	frontRadarNearParameters = New_FrontRadarNearParameters();
	FrontRadarNearParameters_ctor(frontRadarNearParameters);
	FrontRadarNearParam_set_PositiX(frontRadarNearParameters, 3.8);
	FrontRadarNearParam_set_PositiY(frontRadarNearParameters, 0.0);
	FrontRadarNearParam_set_PositiZ(frontRadarNearParameters, 0.62);
	FrontRadarNearParam_set_RotatiZ(frontRadarNearParameters, 0.016057029118347832);
	FronRadaNearPara_set_MinimRange(frontRadarNearParameters, 0.1);
	FronRadaNearPara_set_MaximRange(frontRadarNearParameters, 50.0);
	FronRadaNearPara_set_MinimAngle(frontRadarNearParameters, -0.48869219055841229);
	FronRadaNearPara_set_MaximAngle(frontRadarNearParameters, 0.48869219055841229);
	FronRadaNearPara_set_DetecProba(frontRadarNearParameters, 0.7);
	FronRadaNearPara_set_CluttLambd(frontRadarNearParameters, 0.04);
	FronRadaNearPara_set_SigmaRange(frontRadarNearParameters, 2.0);
	FronRadaNearPara_set_SigmaAngle(frontRadarNearParameters, 0.052359877559829883);
	FroRadNearPara_set_SigmRangRate(frontRadarNearParameters, 0.45);
	(void)Assign_FrontRadarNearParameters(&result, frontRadarNearParameters);
	(void)Assign_FrontRadarNearParameters(&frontRadarNearParameters, NULL);
	return result;
}

static void RemRef_FrontRadarFarParameters(struct FrontRadarFarParameters *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_FrontRadarFarParameters.CurrentCount--;
		Res_FrontRadarFarParameters.Next[Res_FrontRadarFarParameters.CurrentCount] = self;
		Del_FrontRadarFarParameters(self);
	}
}

struct FrontRadarFarParameters *New_FrontRadarFarParameters(void)
{
	static struct FrontRadarFarParameters const Default_FrontRadarFarParameters = { 1 };
	struct FrontRadarFarParameters *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_FrontRadarFarParameters.CurrentCount == RC_FrontRadarFarParameters)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_FrontRadarFarParameters.Next[Res_FrontRadarFarParameters.CurrentCount];
	Res_FrontRadarFarParameters.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_FrontRadarFarParameters.MaximumCount = (Res_FrontRadarFarParameters.CurrentCount > Res_FrontRadarFarParameters.MaximumCount) ? Res_FrontRadarFarParameters.CurrentCount : Res_FrontRadarFarParameters.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_FrontRadarFarParameters;
	return instance;
}

struct FrontRadarFarParameters *Assign_FrontRadarFarParameters(struct FrontRadarFarParameters **const left, struct FrontRadarFarParameters *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_FrontRadarFarParameters(*left);
	*left = right;
	return right;
}

void FrontRadarFarParameters_ctor(struct FrontRadarFarParameters *const self)
{
	struct float64_t_1D_3 *array = NULL;

	array = New_float64_t_1D_3();
	(void)Assign_float64_t_1D_3(&self->_noiseMatrixDiagonal, array);
	(void)Assign_float64_t_1D_3(&array, NULL);
	Object_ctor(&self->base);
}

float64_t FrontRadarNearParam_get_PositiX(struct FrontRadarNearParameters *const self)
{
	return self->PositionX;
}

void FrontRadarFarParame_set_PositiX(struct FrontRadarFarParameters *const self, float64_t value)
{
	self->PositionX = value;
}

float64_t FrontRadarNearParam_get_PositiY(struct FrontRadarNearParameters *const self)
{
	return self->PositionY;
}

void FrontRadarFarParame_set_PositiY(struct FrontRadarFarParameters *const self, float64_t value)
{
	self->PositionY = value;
}

float64_t FrontRadarNearParam_get_PositiZ(struct FrontRadarNearParameters *const self)
{
	return self->PositionZ;
}

void FrontRadarFarParame_set_PositiZ(struct FrontRadarFarParameters *const self, float64_t value)
{
	self->PositionZ = value;
}

float64_t FrontRadarNearParam_get_RotatiZ(struct FrontRadarNearParameters *const self)
{
	return self->RotationZ;
}

void FrontRadarFarParame_set_RotatiZ(struct FrontRadarFarParameters *const self, float64_t value)
{
	self->RotationZ = value;
}

void FronRadaFarParam_set_MinimRange(struct FrontRadarFarParameters *const self, float64_t value)
{
	self->MinimumRange = value;
}

void FronRadaFarParam_set_MaximRange(struct FrontRadarFarParameters *const self, float64_t value)
{
	self->MaximumRange = value;
}

void FronRadaFarParam_set_MinimAngle(struct FrontRadarFarParameters *const self, float64_t value)
{
	self->MinimumAngle = value;
}

void FronRadaFarParam_set_MaximAngle(struct FrontRadarFarParameters *const self, float64_t value)
{
	self->MaximumAngle = value;
}

void FronRadaFarParam_set_DetecProba(struct FrontRadarFarParameters *const self, float64_t value)
{
	self->DetectionProbability = value;
}

void FronRadaFarParam_set_CluttLambd(struct FrontRadarFarParameters *const self, float64_t value)
{
	self->ClutterLambda = value;
}

static void FroRadaFarPara_CalcNoisMatrDiag(struct FrontRadarFarParameters *const self)
{
	struct float64_t_1D_3 *array = NULL;

	array = New_float64_t_1D_3();
	array->Elements[((int32_t)0)] = self->_sigmaRange * self->_sigmaRange;
	array->Elements[((int32_t)1)] = self->_sigmaAngle * self->_sigmaAngle;
	array->Elements[((int32_t)2)] = self->_sigmaRangeRate * self->_sigmaRangeRate;
	(void)Assign_float64_t_1D_3(&self->_noiseMatrixDiagonal, array);
	(void)Assign_float64_t_1D_3(&array, NULL);
}

void FronRadaFarParam_set_SigmaRange(struct FrontRadarFarParameters *const self, float64_t value)
{
	self->_sigmaRange = value;
	FroRadaFarPara_CalcNoisMatrDiag(self);
}

void FronRadaFarParam_set_SigmaAngle(struct FrontRadarFarParameters *const self, float64_t value)
{
	self->_sigmaAngle = value;
	FroRadaFarPara_CalcNoisMatrDiag(self);
}

void FroRadaFarPara_set_SigmRangRate(struct FrontRadarFarParameters *const self, float64_t value)
{
	self->_sigmaRangeRate = value;
	FroRadaFarPara_CalcNoisMatrDiag(self);
}

static struct FrontRadarFarParameters *SenPro_1_GetDefaFronRadaFarPara(void)
{
	struct FrontRadarFarParameters *result = NULL;
	struct FrontRadarFarParameters *frontRadarFarParameters = NULL;
	struct FrontRadarNearParameters *frontRadarNearParameters = NULL;
	float64_t double_ = 0.0;
	struct FrontRadarNearParameters *frontRadarNearParameters_1 = NULL;
	float64_t double__1 = 0.0;
	struct FrontRadarNearParameters *frontRadarNearParameters_2 = NULL;
	float64_t double__2 = 0.0;
	struct FrontRadarNearParameters *frontRadarNearParameters_3 = NULL;
	float64_t double__3 = 0.0;

	frontRadarFarParameters = New_FrontRadarFarParameters();
	FrontRadarFarParameters_ctor(frontRadarFarParameters);
	frontRadarNearParameters = SenPro_1_GetDefFronRadaNearPara();
	double_ = FrontRadarNearParam_get_PositiX(frontRadarNearParameters);
	FrontRadarFarParame_set_PositiX(frontRadarFarParameters, double_);
	frontRadarNearParameters_1 = SenPro_1_GetDefFronRadaNearPara();
	double__1 = FrontRadarNearParam_get_PositiY(frontRadarNearParameters_1);
	FrontRadarFarParame_set_PositiY(frontRadarFarParameters, double__1);
	frontRadarNearParameters_2 = SenPro_1_GetDefFronRadaNearPara();
	double__2 = FrontRadarNearParam_get_PositiZ(frontRadarNearParameters_2);
	FrontRadarFarParame_set_PositiZ(frontRadarFarParameters, double__2);
	frontRadarNearParameters_3 = SenPro_1_GetDefFronRadaNearPara();
	double__3 = FrontRadarNearParam_get_RotatiZ(frontRadarNearParameters_3);
	FrontRadarFarParame_set_RotatiZ(frontRadarFarParameters, double__3);
	FronRadaFarParam_set_MinimRange(frontRadarFarParameters, 5.0);
	FronRadaFarParam_set_MaximRange(frontRadarFarParameters, 200.0);
	FronRadaFarParam_set_MinimAngle(frontRadarFarParameters, -0.14835298641951802);
	FronRadaFarParam_set_MaximAngle(frontRadarFarParameters, 0.14835298641951802);
	FronRadaFarParam_set_DetecProba(frontRadarFarParameters, 0.7);
	FronRadaFarParam_set_CluttLambd(frontRadarFarParameters, 0.03);
	FronRadaFarParam_set_SigmaRange(frontRadarFarParameters, 2.0);
	FronRadaFarParam_set_SigmaAngle(frontRadarFarParameters, 0.029670597283903602);
	FroRadaFarPara_set_SigmRangRate(frontRadarFarParameters, 0.45);
	(void)Assign_FrontRadarFarParameters(&result, frontRadarFarParameters);
	(void)Assign_FrontRadarFarParameters(&frontRadarFarParameters, NULL);
	(void)Assign_FrontRadarNearParameters(&frontRadarNearParameters, NULL);
	(void)Assign_FrontRadarNearParameters(&frontRadarNearParameters_1, NULL);
	(void)Assign_FrontRadarNearParameters(&frontRadarNearParameters_2, NULL);
	(void)Assign_FrontRadarNearParameters(&frontRadarNearParameters_3, NULL);
	return result;
}

static void RemRef_MobilEyeParameters(struct MobilEyeParameters *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MobilEyeParameters.CurrentCount--;
		Res_MobilEyeParameters.Next[Res_MobilEyeParameters.CurrentCount] = self;
		Del_MobilEyeParameters(self);
	}
}

struct MobilEyeParameters *New_MobilEyeParameters(void)
{
	static struct MobilEyeParameters const Default_MobilEyeParameters = { 1 };
	struct MobilEyeParameters *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MobilEyeParameters.CurrentCount == RC_MobilEyeParameters)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MobilEyeParameters.Next[Res_MobilEyeParameters.CurrentCount];
	Res_MobilEyeParameters.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MobilEyeParameters.MaximumCount = (Res_MobilEyeParameters.CurrentCount > Res_MobilEyeParameters.MaximumCount) ? Res_MobilEyeParameters.CurrentCount : Res_MobilEyeParameters.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MobilEyeParameters;
	return instance;
}

struct MobilEyeParameters *Assign_MobilEyeParameters(struct MobilEyeParameters **const left, struct MobilEyeParameters *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MobilEyeParameters(*left);
	*left = right;
	return right;
}

void MobilEyeParameters_ctor(struct MobilEyeParameters *const self)
{
	struct float64_t_1D_4 *array = NULL;

	array = New_float64_t_1D_4();
	(void)Assign_float64_t_1D_4(&self->_noiseMatrixDiagonal, array);
	(void)Assign_float64_t_1D_4(&array, NULL);
	Object_ctor(&self->base);
}

void MobilEyeParameter_set_PositionX(struct MobilEyeParameters *const self, float64_t value)
{
	self->PositionX = value;
}

void MobilEyeParameter_set_PositionY(struct MobilEyeParameters *const self, float64_t value)
{
	self->PositionY = value;
}

void MobilEyeParameter_set_PositionZ(struct MobilEyeParameters *const self, float64_t value)
{
	self->PositionZ = value;
}

void MobilEyeParameter_set_RotationZ(struct MobilEyeParameters *const self, float64_t value)
{
	self->RotationZ = value;
}

void MobilEyeParame_set_MinimumRange(struct MobilEyeParameters *const self, float64_t value)
{
	self->MinimumRange = value;
}

void MobilEyeParame_set_MaximumRange(struct MobilEyeParameters *const self, float64_t value)
{
	self->MaximumRange = value;
}

void MobilEyeParame_set_MinimumAngle(struct MobilEyeParameters *const self, float64_t value)
{
	self->MinimumAngle = value;
}

void MobilEyeParame_set_MaximumAngle(struct MobilEyeParameters *const self, float64_t value)
{
	self->MaximumAngle = value;
}

void MobiEyePara_set_FielOfViewOffsX(struct MobilEyeParameters *const self, float64_t value)
{
	self->FieldOfViewOffsetX = value;
}

void MobiEyePara_set_FielOfViewOffsY(struct MobilEyeParameters *const self, float64_t value)
{
	self->FieldOfViewOffsetY = value;
}

static void MobiEyePara_CalcNoiseMatriDiago(struct MobilEyeParameters *const self)
{
	struct float64_t_1D_4 *array = NULL;

	array = New_float64_t_1D_4();
	array->Elements[((int32_t)0)] = self->_sigmaX * self->_sigmaX;
	array->Elements[((int32_t)1)] = self->_sigmaY * self->_sigmaY;
	array->Elements[((int32_t)2)] = self->_sigmaVx * self->_sigmaVx;
	array->Elements[((int32_t)3)] = self->_sigmaVy * self->_sigmaVy;
	(void)Assign_float64_t_1D_4(&self->_noiseMatrixDiagonal, array);
	(void)Assign_float64_t_1D_4(&array, NULL);
}

void MobilEyeParameters_set_SigmaX(struct MobilEyeParameters *const self, float64_t value)
{
	self->_sigmaX = value;
	MobiEyePara_CalcNoiseMatriDiago(self);
}

void MobilEyeParameters_set_SigmaY(struct MobilEyeParameters *const self, float64_t value)
{
	self->_sigmaY = value;
	MobiEyePara_CalcNoiseMatriDiago(self);
}

void MobilEyeParameters_set_SigmaVx(struct MobilEyeParameters *const self, float64_t value)
{
	self->_sigmaVx = value;
	MobiEyePara_CalcNoiseMatriDiago(self);
}

void MobilEyeParameters_set_SigmaVy(struct MobilEyeParameters *const self, float64_t value)
{
	self->_sigmaVy = value;
	MobiEyePara_CalcNoiseMatriDiago(self);
}

void MobilEyeParame_set_DetectProbab(struct MobilEyeParameters *const self, float64_t value)
{
	self->DetectionProbability = value;
}

void MobilEyeParame_set_ClutteLambda(struct MobilEyeParameters *const self, float64_t value)
{
	self->ClutterLambda = value;
}

static struct MobilEyeParameters *SensProp_1_GetDefaMobilEyeParam(void)
{
	struct MobilEyeParameters *result = NULL;
	struct MobilEyeParameters *mobilEyeParameters = NULL;

	mobilEyeParameters = New_MobilEyeParameters();
	MobilEyeParameters_ctor(mobilEyeParameters);
	MobilEyeParameter_set_PositionX(mobilEyeParameters, 3.832);
	MobilEyeParameter_set_PositionY(mobilEyeParameters, 0.0);
	MobilEyeParameter_set_PositionZ(mobilEyeParameters, 1.485);
	MobilEyeParameter_set_RotationZ(mobilEyeParameters, 0.0);
	MobilEyeParame_set_MinimumRange(mobilEyeParameters, 0.0);
	MobilEyeParame_set_MaximumRange(mobilEyeParameters, 130.0);
	MobilEyeParame_set_MinimumAngle(mobilEyeParameters, -0.45378560551852565);
	MobilEyeParame_set_MaximumAngle(mobilEyeParameters, 0.45378560551852565);
	MobiEyePara_set_FielOfViewOffsX(mobilEyeParameters, 3.832);
	MobiEyePara_set_FielOfViewOffsY(mobilEyeParameters, 0.0);
	MobilEyeParameters_set_SigmaX(mobilEyeParameters, 1.0);
	MobilEyeParameters_set_SigmaY(mobilEyeParameters, 0.5);
	MobilEyeParameters_set_SigmaVx(mobilEyeParameters, 3.0);
	MobilEyeParameters_set_SigmaVy(mobilEyeParameters, 1.5);
	MobilEyeParame_set_DetectProbab(mobilEyeParameters, 0.7);
	MobilEyeParame_set_ClutteLambda(mobilEyeParameters, 2E-05);
	(void)Assign_MobilEyeParameters(&result, mobilEyeParameters);
	(void)Assign_MobilEyeParameters(&mobilEyeParameters, NULL);
	return result;
}

float64_t FronRadaNearPara_get_MinimRange(struct FrontRadarNearParameters *const self)
{
	return self->MinimumRange;
}

float64_t FronRadaNearPara_get_MaximRange(struct FrontRadarNearParameters *const self)
{
	return self->MaximumRange;
}

float64_t FronRadaFarParam_get_MaximRange(struct FrontRadarFarParameters *const self)
{
	return self->MaximumRange;
}

float64_t FronRadaNearPara_get_MinimAngle(struct FrontRadarNearParameters *const self)
{
	return self->MinimumAngle;
}

float64_t Math_Sin(float64_t a)
{
	return (float64_t)sin(a);
}

float64_t Math_Cos(float64_t d)
{
	return (float64_t)cos(d);
}

float64_t FronRadaFarParam_get_MinimAngle(struct FrontRadarFarParameters *const self)
{
	return self->MinimumAngle;
}

float64_t FronRadaNearPara_get_MaximAngle(struct FrontRadarNearParameters *const self)
{
	return self->MaximumAngle;
}

float64_t FronRadaFarParam_get_MaximAngle(struct FrontRadarFarParameters *const self)
{
	return self->MaximumAngle;
}

void Vector2D_ctor(struct Vector2D *const self, float64_t x, float64_t y)
{
	(*self).X = x;
	(*self).Y = y;
}

static void Del_Vector2D_1D_10(struct Vector2D_1D_10 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_Vector2D_1D_10(struct Vector2D_1D_10 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Vector2D_1D_10.CurrentCount--;
		Res_Vector2D_1D_10.Next[Res_Vector2D_1D_10.CurrentCount] = self;
		Del_Vector2D_1D_10(self);
	}
}

struct Vector2D_1D_10 *New_Vector2D_1D_10(void)
{
	static struct Vector2D_1D_10 const Default_Vector2D_1D_10 = { 1 };
	struct Vector2D_1D_10 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Vector2D_1D_10.CurrentCount == RC_Vector2D_1D_10)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Vector2D_1D_10.Next[Res_Vector2D_1D_10.CurrentCount];
	Res_Vector2D_1D_10.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Vector2D_1D_10.MaximumCount = (Res_Vector2D_1D_10.CurrentCount > Res_Vector2D_1D_10.MaximumCount) ? Res_Vector2D_1D_10.CurrentCount : Res_Vector2D_1D_10.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Vector2D_1D_10;
	return instance;
}

struct Vector2D_1D_10 *Assign_Vector2D_1D_10(struct Vector2D_1D_10 **const left, struct Vector2D_1D_10 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Vector2D_1D_10(*left);
	*left = right;
	return right;
}

static void RemRef_FrontRadarObjectParamete(struct FrontRadarObjectParameters *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_FrontRadarObjectParameters.CurrentCount--;
		Res_FrontRadarObjectParameters.Next[Res_FrontRadarObjectParameters.CurrentCount] = self;
		Del_FrontRadarObjectParameters(self);
	}
}

struct FrontRadarObjectParameters *New_FrontRadarObjectParameters(void)
{
	static struct FrontRadarObjectParameters const Default_FrontRadarObjectParamet = { 1 };
	struct FrontRadarObjectParameters *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_FrontRadarObjectParameters.CurrentCount == RC_FrontRadarObjectParameters)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_FrontRadarObjectParameters.Next[Res_FrontRadarObjectParameters.CurrentCount];
	Res_FrontRadarObjectParameters.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_FrontRadarObjectParameters.MaximumCount = (Res_FrontRadarObjectParameters.CurrentCount > Res_FrontRadarObjectParameters.MaximumCount) ? Res_FrontRadarObjectParameters.CurrentCount : Res_FrontRadarObjectParameters.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_FrontRadarObjectParamet;
	return instance;
}

struct FrontRadarObjectParameters *Assign_FrontRadarObjectParamete(struct FrontRadarObjectParameters **const left, struct FrontRadarObjectParameters *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_FrontRadarObjectParamete(*left);
	*left = right;
	return right;
}

void FrontRadarObjectParameters_ctor(struct FrontRadarObjectParameters *const self)
{
	struct float64_t_1D_5 *array = NULL;

	array = New_float64_t_1D_5();
	(void)Assign_float64_t_1D_5(&self->_noiseMatrixDiagonal, array);
	(void)Assign_float64_t_1D_5(&array, NULL);
	Object_ctor(&self->base);
}

void FrontRadarObjecParam_set_PositX(struct FrontRadarObjectParameters *const self, float64_t value)
{
	self->PositionX = value;
}

void FrontRadarObjecParam_set_PositY(struct FrontRadarObjectParameters *const self, float64_t value)
{
	self->PositionY = value;
}

void FrontRadarObjecParam_set_PositZ(struct FrontRadarObjectParameters *const self, float64_t value)
{
	self->PositionZ = value;
}

void FrontRadarObjecParam_set_RotatZ(struct FrontRadarObjectParameters *const self, float64_t value)
{
	self->RotationZ = value;
}

void FronRadaObjePara_set_DetecProba(struct FrontRadarObjectParameters *const self, float64_t value)
{
	self->DetectionProbability = value;
}

void FronRadaObjePara_set_CluttLambd(struct FrontRadarObjectParameters *const self, float64_t value)
{
	self->ClutterLambda = value;
}

static void FroRadObjePara_CalcNoisMatrDiag(struct FrontRadarObjectParameters *const self)
{
	struct float64_t_1D_5 *array = NULL;

	array = New_float64_t_1D_5();
	array->Elements[((int32_t)0)] = self->_sigmaX * self->_sigmaX;
	array->Elements[((int32_t)1)] = self->_sigmaY * self->_sigmaY;
	array->Elements[((int32_t)2)] = self->_sigmaVx * self->_sigmaVx;
	array->Elements[((int32_t)3)] = self->_sigmaVy * self->_sigmaVy;
	array->Elements[((int32_t)4)] = self->_sigmaAx * self->_sigmaAx;
	(void)Assign_float64_t_1D_5(&self->_noiseMatrixDiagonal, array);
	(void)Assign_float64_t_1D_5(&array, NULL);
}

void FrontRadarObjecParam_set_SigmaX(struct FrontRadarObjectParameters *const self, float64_t value)
{
	self->_sigmaX = value;
	FroRadObjePara_CalcNoisMatrDiag(self);
}

void FrontRadarObjecParam_set_SigmaY(struct FrontRadarObjectParameters *const self, float64_t value)
{
	self->_sigmaY = value;
	FroRadObjePara_CalcNoisMatrDiag(self);
}

void FronRadarObjecParam_set_SigmaVx(struct FrontRadarObjectParameters *const self, float64_t value)
{
	self->_sigmaVx = value;
	FroRadObjePara_CalcNoisMatrDiag(self);
}

void FronRadarObjecParam_set_SigmaVy(struct FrontRadarObjectParameters *const self, float64_t value)
{
	self->_sigmaVy = value;
	FroRadObjePara_CalcNoisMatrDiag(self);
}

void FronRadarObjecParam_set_SigmaAx(struct FrontRadarObjectParameters *const self, float64_t value)
{
	self->_sigmaAx = value;
	FroRadObjePara_CalcNoisMatrDiag(self);
}

void FronRadaObjePara_set_FielOfView(struct FrontRadarObjectParameters *const self, struct Vector2D_1D_10 *value)
{
	(void)Assign_Vector2D_1D_10(&self->FieldOfView, value);
}

static struct FrontRadarObjectParameters *SenPro_1_GetDefFronRadaObjePara(void)
{
	float64_t minimumRange = 0.0;
	struct FrontRadarNearParameters *frontRadarNearParameters = NULL;
	float64_t double_ = 0.0;
	float64_t maximumRange = 0.0;
	struct FrontRadarNearParameters *frontRadarNearParameters_1 = NULL;
	float64_t double__1 = 0.0;
	float64_t maximumRange2 = 0.0;
	struct FrontRadarFarParameters *frontRadarFarParameters = NULL;
	float64_t double__2 = 0.0;
	float64_t num = 0.0;
	struct FrontRadarNearParameters *frontRadarNearParameters_2 = NULL;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	float64_t num2 = 0.0;
	struct FrontRadarNearParameters *frontRadarNearParameters_3 = NULL;
	float64_t double__5 = 0.0;
	float64_t double__6 = 0.0;
	float64_t num3 = 0.0;
	struct FrontRadarFarParameters *frontRadarFarParameters_1 = NULL;
	float64_t double__7 = 0.0;
	float64_t double__8 = 0.0;
	float64_t num4 = 0.0;
	struct FrontRadarFarParameters *frontRadarFarParameters_2 = NULL;
	float64_t double__9 = 0.0;
	float64_t double__10 = 0.0;
	float64_t num5 = 0.0;
	struct FrontRadarNearParameters *frontRadarNearParameters_4 = NULL;
	float64_t double__11 = 0.0;
	float64_t double__12 = 0.0;
	float64_t num6 = 0.0;
	struct FrontRadarNearParameters *frontRadarNearParameters_5 = NULL;
	float64_t double__13 = 0.0;
	float64_t double__14 = 0.0;
	float64_t num7 = 0.0;
	struct FrontRadarFarParameters *frontRadarFarParameters_3 = NULL;
	float64_t double__15 = 0.0;
	float64_t double__16 = 0.0;
	float64_t num8 = 0.0;
	struct FrontRadarFarParameters *frontRadarFarParameters_4 = NULL;
	float64_t double__17 = 0.0;
	float64_t double__18 = 0.0;
	struct Vector2D_1D_10 *fieldOfView = NULL;
	struct Vector2D vector2D = { 0 };
	struct Vector2D vector2D_1 = { 0 };
	struct Vector2D vector2D_2 = { 0 };
	struct Vector2D vector2D_3 = { 0 };
	struct Vector2D vector2D_4 = { 0 };
	struct Vector2D vector2D_5 = { 0 };
	struct Vector2D vector2D_6 = { 0 };
	struct Vector2D vector2D_7 = { 0 };
	struct Vector2D vector2D_8 = { 0 };
	struct Vector2D vector2D_9 = { 0 };
	struct Vector2D_1D_10 *array = NULL;
	struct FrontRadarObjectParameters *result = NULL;
	struct FrontRadarObjectParameters *frontRadarObjectParameters = NULL;
	struct FrontRadarNearParameters *frontRadarNearParameters_6 = NULL;
	float64_t double__19 = 0.0;
	struct FrontRadarNearParameters *frontRadarNearParameters_7 = NULL;
	float64_t double__20 = 0.0;
	struct FrontRadarNearParameters *frontRadarNearParameters_8 = NULL;
	float64_t double__21 = 0.0;
	struct FrontRadarNearParameters *frontRadarNearParameters_9 = NULL;
	float64_t double__22 = 0.0;

	frontRadarNearParameters = SenPro_1_GetDefFronRadaNearPara();
	double_ = FronRadaNearPara_get_MinimRange(frontRadarNearParameters);
	minimumRange = double_;
	(void)Assign_FrontRadarNearParameters(&frontRadarNearParameters, NULL);
	frontRadarNearParameters_1 = SenPro_1_GetDefFronRadaNearPara();
	double__1 = FronRadaNearPara_get_MaximRange(frontRadarNearParameters_1);
	maximumRange = double__1;
	(void)Assign_FrontRadarNearParameters(&frontRadarNearParameters_1, NULL);
	frontRadarFarParameters = SenPro_1_GetDefaFronRadaFarPara();
	double__2 = FronRadaFarParam_get_MaximRange(frontRadarFarParameters);
	maximumRange2 = double__2;
	(void)Assign_FrontRadarFarParameters(&frontRadarFarParameters, NULL);
	frontRadarNearParameters_2 = SenPro_1_GetDefFronRadaNearPara();
	double__3 = FronRadaNearPara_get_MinimAngle(frontRadarNearParameters_2);
	double__4 = Math_Sin(double__3);
	num = double__4;
	(void)Assign_FrontRadarNearParameters(&frontRadarNearParameters_2, NULL);
	frontRadarNearParameters_3 = SenPro_1_GetDefFronRadaNearPara();
	double__5 = FronRadaNearPara_get_MinimAngle(frontRadarNearParameters_3);
	double__6 = Math_Cos(double__5);
	num2 = double__6;
	(void)Assign_FrontRadarNearParameters(&frontRadarNearParameters_3, NULL);
	frontRadarFarParameters_1 = SenPro_1_GetDefaFronRadaFarPara();
	double__7 = FronRadaFarParam_get_MinimAngle(frontRadarFarParameters_1);
	double__8 = Math_Sin(double__7);
	num3 = double__8;
	(void)Assign_FrontRadarFarParameters(&frontRadarFarParameters_1, NULL);
	frontRadarFarParameters_2 = SenPro_1_GetDefaFronRadaFarPara();
	double__9 = FronRadaFarParam_get_MinimAngle(frontRadarFarParameters_2);
	double__10 = Math_Cos(double__9);
	num4 = double__10;
	(void)Assign_FrontRadarFarParameters(&frontRadarFarParameters_2, NULL);
	frontRadarNearParameters_4 = SenPro_1_GetDefFronRadaNearPara();
	double__11 = FronRadaNearPara_get_MaximAngle(frontRadarNearParameters_4);
	double__12 = Math_Sin(double__11);
	num5 = double__12;
	(void)Assign_FrontRadarNearParameters(&frontRadarNearParameters_4, NULL);
	frontRadarNearParameters_5 = SenPro_1_GetDefFronRadaNearPara();
	double__13 = FronRadaNearPara_get_MaximAngle(frontRadarNearParameters_5);
	double__14 = Math_Cos(double__13);
	num6 = double__14;
	(void)Assign_FrontRadarNearParameters(&frontRadarNearParameters_5, NULL);
	frontRadarFarParameters_3 = SenPro_1_GetDefaFronRadaFarPara();
	double__15 = FronRadaFarParam_get_MaximAngle(frontRadarFarParameters_3);
	double__16 = Math_Sin(double__15);
	num7 = double__16;
	(void)Assign_FrontRadarFarParameters(&frontRadarFarParameters_3, NULL);
	frontRadarFarParameters_4 = SenPro_1_GetDefaFronRadaFarPara();
	double__17 = FronRadaFarParam_get_MaximAngle(frontRadarFarParameters_4);
	double__18 = Math_Cos(double__17);
	num8 = double__18;
	(void)Assign_FrontRadarFarParameters(&frontRadarFarParameters_4, NULL);
	Vector2D_ctor(&vector2D, minimumRange, 0.0);
	Vector2D_ctor(&vector2D_1, minimumRange * num2, minimumRange * num);
	Vector2D_ctor(&vector2D_2, maximumRange * num2, maximumRange * num);
	Vector2D_ctor(&vector2D_3, maximumRange * num4, maximumRange * num3);
	Vector2D_ctor(&vector2D_4, maximumRange2 * num4, maximumRange2 * num3);
	Vector2D_ctor(&vector2D_5, maximumRange2 * num8, maximumRange2 * num7);
	Vector2D_ctor(&vector2D_6, maximumRange * num8, maximumRange * num7);
	Vector2D_ctor(&vector2D_7, maximumRange * num6, maximumRange * num5);
	Vector2D_ctor(&vector2D_8, minimumRange * num6, minimumRange * num5);
	Vector2D_ctor(&vector2D_9, minimumRange, 0.0);
	array = New_Vector2D_1D_10();
	array->Elements[((int32_t)0)] = vector2D;
	array->Elements[((int32_t)1)] = vector2D_1;
	array->Elements[((int32_t)2)] = vector2D_2;
	array->Elements[((int32_t)3)] = vector2D_3;
	array->Elements[((int32_t)4)] = vector2D_4;
	array->Elements[((int32_t)5)] = vector2D_5;
	array->Elements[((int32_t)6)] = vector2D_6;
	array->Elements[((int32_t)7)] = vector2D_7;
	array->Elements[((int32_t)8)] = vector2D_8;
	array->Elements[((int32_t)9)] = vector2D_9;
	(void)Assign_Vector2D_1D_10(&fieldOfView, array);
	(void)Assign_Vector2D_1D_10(&array, NULL);
	frontRadarObjectParameters = New_FrontRadarObjectParameters();
	FrontRadarObjectParameters_ctor(frontRadarObjectParameters);
	frontRadarNearParameters_6 = SenPro_1_GetDefFronRadaNearPara();
	double__19 = FrontRadarNearParam_get_PositiX(frontRadarNearParameters_6);
	FrontRadarObjecParam_set_PositX(frontRadarObjectParameters, double__19);
	frontRadarNearParameters_7 = SenPro_1_GetDefFronRadaNearPara();
	double__20 = FrontRadarNearParam_get_PositiY(frontRadarNearParameters_7);
	FrontRadarObjecParam_set_PositY(frontRadarObjectParameters, double__20);
	frontRadarNearParameters_8 = SenPro_1_GetDefFronRadaNearPara();
	double__21 = FrontRadarNearParam_get_PositiZ(frontRadarNearParameters_8);
	FrontRadarObjecParam_set_PositZ(frontRadarObjectParameters, double__21);
	frontRadarNearParameters_9 = SenPro_1_GetDefFronRadaNearPara();
	double__22 = FrontRadarNearParam_get_RotatiZ(frontRadarNearParameters_9);
	FrontRadarObjecParam_set_RotatZ(frontRadarObjectParameters, double__22);
	FronRadaObjePara_set_DetecProba(frontRadarObjectParameters, 0.7);
	FronRadaObjePara_set_CluttLambd(frontRadarObjectParameters, 0.0002);
	FrontRadarObjecParam_set_SigmaX(frontRadarObjectParameters, 1.0);
	FrontRadarObjecParam_set_SigmaY(frontRadarObjectParameters, 2.0);
	FronRadarObjecParam_set_SigmaVx(frontRadarObjectParameters, 0.5);
	FronRadarObjecParam_set_SigmaVy(frontRadarObjectParameters, 1.0);
	FronRadarObjecParam_set_SigmaAx(frontRadarObjectParameters, 0.5);
	FronRadaObjePara_set_FielOfView(frontRadarObjectParameters, fieldOfView);
	(void)Assign_FrontRadarObjectParamete(&result, frontRadarObjectParameters);
	(void)Assign_FrontRadarObjectParamete(&frontRadarObjectParameters, NULL);
	(void)Assign_FrontRadarNearParameters(&frontRadarNearParameters_6, NULL);
	(void)Assign_FrontRadarNearParameters(&frontRadarNearParameters_7, NULL);
	(void)Assign_FrontRadarNearParameters(&frontRadarNearParameters_8, NULL);
	(void)Assign_FrontRadarNearParameters(&frontRadarNearParameters_9, NULL);
	RemRef_Vector2D_1D_10(fieldOfView);
	return result;
}

void SensorProperties_ctor(struct SensorProperties *const self)
{
	struct FrontRadarNearParameters *frontRadarNearParameters = NULL;
	struct FrontRadarFarParameters *frontRadarFarParameters = NULL;
	struct MobilEyeParameters *mobilEyeParameters = NULL;
	struct FrontRadarObjectParameters *frontRadarObjectParameters = NULL;

	Object_ctor(&self->base);
	frontRadarNearParameters = SenPro_1_GetDefFronRadaNearPara();
	(void)Assign_FrontRadarNearParameters(&self->_frontRadarNearParameters, frontRadarNearParameters);
	(void)Assign_FrontRadarNearParameters(&frontRadarNearParameters, NULL);
	frontRadarFarParameters = SenPro_1_GetDefaFronRadaFarPara();
	(void)Assign_FrontRadarFarParameters(&self->_frontRadarFarParameters, frontRadarFarParameters);
	(void)Assign_FrontRadarFarParameters(&frontRadarFarParameters, NULL);
	mobilEyeParameters = SensProp_1_GetDefaMobilEyeParam();
	(void)Assign_MobilEyeParameters(&self->_mobilEyeParameters, mobilEyeParameters);
	(void)Assign_MobilEyeParameters(&mobilEyeParameters, NULL);
	frontRadarObjectParameters = SenPro_1_GetDefFronRadaObjePara();
	(void)Assign_FrontRadarObjectParamete(&self->_frontRadarObjectParameters, frontRadarObjectParameters);
	(void)Assign_FrontRadarObjectParamete(&frontRadarObjectParameters, NULL);
}

void Tracking_set_ProcessNoiseSigmaA(struct Tracking *const self, float64_t value)
{
	self->ProcessNoiseSigmaA = value;
}

void Tracki_set_ProcesNoiseSigmaJerk(struct Tracking *const self, float64_t value)
{
	self->ProcessNoiseSigmaJerk = value;
}

void Tracking_set_ProcessNoiseSigmaW(struct Tracking *const self, float64_t value)
{
	self->ProcessNoiseSigmaW = value;
}

void Trackin_set_ProcessNoiseExisten(struct Tracking *const self, float64_t value)
{
	self->ProcessNoiseExistence = value;
}

void Tracking_set_GateProbability(struct Tracking *const self, float64_t value)
{
	if (!((value >= 0.0) && (value <= 1.0)))
	{
		abort();
	}
	self->_gateProbability = value;
}

void Track_set_ExisteProbabForDeleti(struct Tracking *const self, float64_t value)
{
	self->ExistenceProbabilityForDeletion = value;
}

void Track_set_EncloCirclDeletThresh(struct Tracking *const self, float64_t value)
{
	self->EnclosinCircleDeletionThreshold = value;
}

int32_t Math_Min(int32_t val1, int32_t val2)
{
	if (!(val1 <= val2))
	{
		return val2;
	}
	return val1;
}

struct MatrixData_2 *MatrixData_20_Eye(int32_t rows, int32_t columns)
{
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	int32_t num = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	struct MatrixData_2 *result = NULL;

	assert(rows == ((int32_t)5));
	assert(columns == ((int32_t)5));
	matrixData_1 = New_MatrixData_2();
	MatrixData_2_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_2(&matrixData, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	int32 = Math_Min(rows, columns);
	num = int32;
	i = ((int32_t)0);
	while (i < num)
	{
		MatrixData_2_SetValueFast(matrixData, 1.0, i, i);
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_2(&result, matrixData);
	RemRef_MatrixData_2(matrixData);
	return result;
}

static void Space_set_LastGetIndex(struct Space *const self, struct Nullable value)
{
	self->LastGetIndex = value;
}

float64_t MatrixData_get_Item(struct MatrixData *const self, int32_t index)
{
	if (!((index >= ((int32_t)0)) && (index < ((int32_t)5))))
	{
		abort();
	}
	return self->_data->Elements[index];
}

float64_t Space_get_Item(struct Space *const self, int32_t index)
{
	struct Nullable nullable = { 0 };
	float64_t result = 0.0;
	struct MatrixData *matrixData = NULL;
	float64_t double_ = 0.0;

	if (!((index < self->Dimensions) && (index >= ((int32_t)0))))
	{
		abort();
	}
	Nullable_ctor(&nullable, index);
	Space_set_LastGetIndex(self, nullable);
	matrixData = Space_get_MatrixData(self);
	double_ = MatrixData_get_Item(matrixData, index);
	result = double_;
	(void)Assign_MatrixData(&matrixData, NULL);
	return result;
}

float64_t CVSpace_get_V(struct CVSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_get_Item(&self->base.base, ((int32_t)3));
	return double_;
}

void MatrixData_2_set_Item(struct MatrixData_2 *const self, int32_t row, int32_t column, float64_t value)
{
	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	MatrixData_2_SetValueFast(self, value, row, column);
}

float64_t CASpace_get_A(struct CASpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_get_Item(&self->base.base.base, ((int32_t)4));
	return double_;
}

void Tracking_ctor(struct Tracking *const self, struct SensorProperties *sensorProperties)
{
	struct Object *object = NULL;
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	float64_t double_ = 0.0;
	int32_t int32 = ((int32_t)0);
	float64_t double__1 = 0.0;
	struct MatrixData_2 *matrixData_2 = NULL;
	float64_t double__2 = 0.0;
	int32_t int32_1 = ((int32_t)0);
	float64_t double__3 = 0.0;

	object = New_Object();
	Object_ctor(object);
	(void)Assign_Object(&self->_tracksLock, object);
	(void)Assign_Object(&object, NULL);
	Object_ctor(&self->base);
	Tracking_set_ProcessNoiseSigmaA(self, 0.5);
	Tracki_set_ProcesNoiseSigmaJerk(self, 0.5);
	Tracking_set_ProcessNoiseSigmaW(self, 0.5);
	Trackin_set_ProcessNoiseExisten(self, 0.001);
	Tracking_set_GateProbability(self, 0.999);
	Track_set_ExisteProbabForDeleti(self, 0.1);
	Track_set_EncloCirclDeletThresh(self, 100.0);
	(void)Assign_SensorProperties(&self->_sensorProperties, sensorProperties);
	matrixData = MatrixData_20_Eye((&Tracking_1_StateIndices->base.base.base)->Dimensions, (&Tracking_1_StateIndices->base.base.base)->Dimensions);
	(void)Assign_MatrixData_2(&self->_velocityNormalization, matrixData);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	(void)Assign_MatrixData_2(&matrixData_1, self->_velocityNormalization);
	double_ = CVSpace_get_V(&Tracking_1_StateIndices->base);
	int32 = (int32_t)double_;
	double__1 = CVSpace_get_V(&Tracking_1_StateIndices->base);
	MatrixData_2_set_Item(matrixData_1, int32, (int32_t)double__1, -1.0);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	(void)Assign_MatrixData_2(&matrixData_2, self->_velocityNormalization);
	double__2 = CASpace_get_A(Tracking_1_StateIndices);
	int32_1 = (int32_t)double__2;
	double__3 = CASpace_get_A(Tracking_1_StateIndices);
	MatrixData_2_set_Item(matrixData_2, int32_1, (int32_t)double__3, -1.0);
	(void)Assign_MatrixData_2(&matrixData_2, NULL);
}

void Tracking_ctor_1(struct Tracking *const self)
{
	struct SensorProperties *sensorProperties = NULL;

	sensorProperties = New_SensorProperties();
	SensorProperties_ctor(sensorProperties);
	Tracking_ctor(self, sensorProperties);
	(void)Assign_SensorProperties(&sensorProperties, NULL);
}

static void RemRef_EgoMotionFilter(struct EgoMotionFilter *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_EgoMotionFilter.CurrentCount--;
		Res_EgoMotionFilter.Next[Res_EgoMotionFilter.CurrentCount] = self;
		Del_EgoMotionFilter(self);
	}
}

struct EgoMotionFilter *New_EgoMotionFilter(void)
{
	static struct EgoMotionFilter const Default_EgoMotionFilter = { 1 };
	struct EgoMotionFilter *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_EgoMotionFilter.CurrentCount == RC_EgoMotionFilter)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_EgoMotionFilter.Next[Res_EgoMotionFilter.CurrentCount];
	Res_EgoMotionFilter.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_EgoMotionFilter.MaximumCount = (Res_EgoMotionFilter.CurrentCount > Res_EgoMotionFilter.MaximumCount) ? Res_EgoMotionFilter.CurrentCount : Res_EgoMotionFilter.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_EgoMotionFilter;
	return instance;
}

struct EgoMotionFilter *Assign_EgoMotionFilter(struct EgoMotionFilter **const left, struct EgoMotionFilter *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_EgoMotionFilter(*left);
	*left = right;
	return right;
}

static void Del_float64_t_1D_2(struct float64_t_1D_2 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_1D_2(struct float64_t_1D_2 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_1D_2.CurrentCount--;
		Res_float64_t_1D_2.Next[Res_float64_t_1D_2.CurrentCount] = self;
		Del_float64_t_1D_2(self);
	}
}

struct float64_t_1D_2 *New_float64_t_1D_2(void)
{
	static struct float64_t_1D_2 const Default_float64_t_1D_2 = { 1 };
	struct float64_t_1D_2 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_1D_2.CurrentCount == RC_float64_t_1D_2)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_1D_2.Next[Res_float64_t_1D_2.CurrentCount];
	Res_float64_t_1D_2.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_1D_2.MaximumCount = (Res_float64_t_1D_2.CurrentCount > Res_float64_t_1D_2.MaximumCount) ? Res_float64_t_1D_2.CurrentCount : Res_float64_t_1D_2.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_1D_2;
	return instance;
}

struct float64_t_1D_2 *Assign_float64_t_1D_2(struct float64_t_1D_2 **const left, struct float64_t_1D_2 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_1D_2(*left);
	*left = right;
	return right;
}

static void RemRef_PositiveDefiniteMatrix_4(struct PositiveDefiniteMatrix_4 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base)->ReferenceCount--;
	if ((&self->base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_PositiveDefiniteMatrix_4.CurrentCount--;
		Res_PositiveDefiniteMatrix_4.Next[Res_PositiveDefiniteMatrix_4.CurrentCount] = self;
		Del_PositiveDefiniteMatrix_4(self);
	}
}

struct PositiveDefiniteMatrix_4 *New_PositiveDefiniteMatrix_4(void)
{
	static struct PositiveDefiniteMatrix_4 const Default_PositivDefiniteMatrix_4 = { 1 };
	struct PositiveDefiniteMatrix_4 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_PositiveDefiniteMatrix_4.CurrentCount == RC_PositiveDefiniteMatrix_4)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_PositiveDefiniteMatrix_4.Next[Res_PositiveDefiniteMatrix_4.CurrentCount];
	Res_PositiveDefiniteMatrix_4.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_PositiveDefiniteMatrix_4.MaximumCount = (Res_PositiveDefiniteMatrix_4.CurrentCount > Res_PositiveDefiniteMatrix_4.MaximumCount) ? Res_PositiveDefiniteMatrix_4.CurrentCount : Res_PositiveDefiniteMatrix_4.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_PositivDefiniteMatrix_4;
	return instance;
}

struct PositiveDefiniteMatrix_4 *Assign_PositiveDefiniteMatrix_4(struct PositiveDefiniteMatrix_4 **const left, struct PositiveDefiniteMatrix_4 *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base)->ReferenceCount++;
	}
	RemRef_PositiveDefiniteMatrix_4(*left);
	*left = right;
	return right;
}

static void RemRef_CTRAErrorSpace(struct CTRAErrorSpace *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_CTRAErrorSpace.CurrentCount--;
		Res_CTRAErrorSpace.Next[Res_CTRAErrorSpace.CurrentCount] = self;
		Del_CTRAErrorSpace(self);
	}
}

struct CTRAErrorSpace *New_CTRAErrorSpace(void)
{
	static struct CTRAErrorSpace const Default_CTRAErrorSpace = { 1 };
	struct CTRAErrorSpace *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_CTRAErrorSpace.CurrentCount == RC_CTRAErrorSpace)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_CTRAErrorSpace.Next[Res_CTRAErrorSpace.CurrentCount];
	Res_CTRAErrorSpace.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_CTRAErrorSpace.MaximumCount = (Res_CTRAErrorSpace.CurrentCount > Res_CTRAErrorSpace.MaximumCount) ? Res_CTRAErrorSpace.CurrentCount : Res_CTRAErrorSpace.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_CTRAErrorSpace;
	return instance;
}

struct CTRAErrorSpace *Assign_CTRAErrorSpace(struct CTRAErrorSpace **const left, struct CTRAErrorSpace *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_CTRAErrorSpace(*left);
	*left = right;
	return right;
}

static void RemRef_MatrixData_8(struct MatrixData_8 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_8.CurrentCount--;
		Res_MatrixData_8.Next[Res_MatrixData_8.CurrentCount] = self;
		Del_MatrixData_8(self);
	}
}

struct MatrixData_8 *New_MatrixData_8(void)
{
	static struct MatrixData_8 const Default_MatrixData_8 = { 1 };
	struct MatrixData_8 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_8.CurrentCount == RC_MatrixData_8)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_8.Next[Res_MatrixData_8.CurrentCount];
	Res_MatrixData_8.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_8.MaximumCount = (Res_MatrixData_8.CurrentCount > Res_MatrixData_8.MaximumCount) ? Res_MatrixData_8.CurrentCount : Res_MatrixData_8.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_8;
	return instance;
}

struct MatrixData_8 *Assign_MatrixData_8(struct MatrixData_8 **const left, struct MatrixData_8 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_8(*left);
	*left = right;
	return right;
}

void MatrixData_8_ctor(struct MatrixData_8 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_2 *array = NULL;

	assert(rows == ((int32_t)2));
	assert(columns == ((int32_t)1));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_2();
	(void)Assign_float64_t_1D_2(&self->_data, array);
	(void)Assign_float64_t_1D_2(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct MatrixData_8 *MatrixData_20_Zeros_5(int32_t rows, int32_t columns)
{
	struct MatrixData_8 *result = NULL;
	struct MatrixData_8 *matrixData = NULL;

	assert(rows == ((int32_t)2));
	assert(columns == ((int32_t)1));
	matrixData = New_MatrixData_8();
	MatrixData_8_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData_8(&result, matrixData);
	(void)Assign_MatrixData_8(&matrixData, NULL);
	return result;
}

static void Space_4_ctor(struct Space_4 *const self, int32_t dimensions)
{
	struct Object *object = NULL;
	struct MatrixData_8 *matrixData = NULL;

	assert(dimensions == ((int32_t)2));
	object = New_Object();
	Object_ctor(object);
	(void)Assign_Object(&self->_spaceInformationLock, object);
	(void)Assign_Object(&object, NULL);
	Object_ctor(&self->base);
	self->Dimensions = dimensions;
	matrixData = MatrixData_20_Zeros_5(self->Dimensions, ((int32_t)1));
	(void)Assign_MatrixData_8(&self->_vector, matrixData);
	(void)Assign_MatrixData_8(&matrixData, NULL);
}

void CTRAErrorSpace_ctor(struct CTRAErrorSpace *const self)
{
	Space_4_ctor(&self->base, ((int32_t)2));
}

void Matrix_4_ctor(struct Matrix_4 *const self)
{
	struct CTRAErrorSpace *ctraErrorSpace = NULL;
	struct CTRAErrorSpace *ctraErrorSpace_1 = NULL;

	ctraErrorSpace = New_CTRAErrorSpace();
	CTRAErrorSpace_ctor(ctraErrorSpace);
	(void)Assign_CTRAErrorSpace(&self->EmptyRowSpace, ctraErrorSpace);
	(void)Assign_CTRAErrorSpace(&ctraErrorSpace, NULL);
	ctraErrorSpace_1 = New_CTRAErrorSpace();
	CTRAErrorSpace_ctor(ctraErrorSpace_1);
	(void)Assign_CTRAErrorSpace(&self->EmptyColumnSpace, ctraErrorSpace_1);
	(void)Assign_CTRAErrorSpace(&ctraErrorSpace_1, NULL);
	Object_ctor(&self->base);
	self->Columns = (&self->EmptyRowSpace->base)->Dimensions;
	self->Rows = (&self->EmptyColumnSpace->base)->Dimensions;
}

void SquareMatrix_4_ctor(struct SquareMatrix_4 *const self)
{
	struct CTRAErrorSpace *ctraErrorSpace = NULL;

	ctraErrorSpace = New_CTRAErrorSpace();
	CTRAErrorSpace_ctor(ctraErrorSpace);
	(void)Assign_CTRAErrorSpace(&self->EmptySpace, ctraErrorSpace);
	(void)Assign_CTRAErrorSpace(&ctraErrorSpace, NULL);
	Matrix_4_ctor(&self->base);
	self->Dimensions = (&self->base)->Rows;
}

static void RemRef_MatrixData_6(struct MatrixData_6 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_6.CurrentCount--;
		Res_MatrixData_6.Next[Res_MatrixData_6.CurrentCount] = self;
		Del_MatrixData_6(self);
	}
}

struct MatrixData_6 *New_MatrixData_6(void)
{
	static struct MatrixData_6 const Default_MatrixData_6 = { 1 };
	struct MatrixData_6 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_6.CurrentCount == RC_MatrixData_6)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_6.Next[Res_MatrixData_6.CurrentCount];
	Res_MatrixData_6.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_6.MaximumCount = (Res_MatrixData_6.CurrentCount > Res_MatrixData_6.MaximumCount) ? Res_MatrixData_6.CurrentCount : Res_MatrixData_6.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_6;
	return instance;
}

struct MatrixData_6 *Assign_MatrixData_6(struct MatrixData_6 **const left, struct MatrixData_6 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_6(*left);
	*left = right;
	return right;
}

void MatrixData_6_ctor(struct MatrixData_6 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_4 *array = NULL;

	assert(rows == ((int32_t)2));
	assert(columns == ((int32_t)2));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_4();
	(void)Assign_float64_t_1D_4(&self->_data, array);
	(void)Assign_float64_t_1D_4(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct float64_t_1D_4 *MatrixData_6_get_DataReference(struct MatrixData_6 *const self)
{
	struct float64_t_1D_4 *result = NULL;

	(void)Assign_float64_t_1D_4(&result, self->_data);
	return result;
}

static void MatrixData_6_SetValueFast(struct MatrixData_6 *const self, float64_t value, int32_t row, int32_t column)
{
	struct float64_t_1D_4 *array = NULL;

	array = MatrixData_6_get_DataReference(self);
	array->Elements[(column * self->Rows) + row] = value;
	(void)Assign_float64_t_1D_4(&array, NULL);
}

struct MatrixData_6 *MatrixData_20_Diag_1(struct float64_t_1D_2 *diagonalElements)
{
	struct MatrixData_6 *matrixData = NULL;
	struct MatrixData_6 *matrixData_1 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_6 *result = NULL;

	if (!(diagonalElements != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData_6();
	MatrixData_6_ctor(matrixData_1, ((int32_t)2), ((int32_t)2));
	(void)Assign_MatrixData_6(&matrixData, matrixData_1);
	(void)Assign_MatrixData_6(&matrixData_1, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)2))
	{
		MatrixData_6_SetValueFast(matrixData, diagonalElements->Elements[i], i, i);
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_6(&result, matrixData);
	RemRef_MatrixData_6(matrixData);
	return result;
}

static void Matrix_4_set_UncheckeMatrixData(struct Matrix_4 *const self, struct MatrixData_6 *value)
{
	(void)Assign_MatrixData_6(&self->_matrix, value);
}

static void Matrix_4_CheckMatrix(struct Matrix_4 *const self)
{
	struct float64_t_1D_4 *dataReference = NULL;
	struct float64_t_1D_4 *array = NULL;
	int32_t i = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);

	array = MatrixData_6_get_DataReference(self->_matrix);
	(void)Assign_float64_t_1D_4(&dataReference, array);
	(void)Assign_float64_t_1D_4(&array, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)4))
	{
		bool_t boolean = false;

		boolean = Double_IsNaN(dataReference->Elements[i]);
		if (!!boolean)
		{
			num = i / self->Rows;
			num2 = i - (num * self->Rows);
			abort();
		}
		i = i + ((int32_t)1);
	}
	RemRef_float64_t_1D_4(dataReference);
}

struct MatrixData_6 *MatrixData_20_Zeros_6(int32_t rows, int32_t columns)
{
	struct MatrixData_6 *result = NULL;
	struct MatrixData_6 *matrixData = NULL;

	assert(rows == ((int32_t)2));
	assert(columns == ((int32_t)2));
	matrixData = New_MatrixData_6();
	MatrixData_6_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData_6(&result, matrixData);
	(void)Assign_MatrixData_6(&matrixData, NULL);
	return result;
}

struct MatrixData_6 *Matrix_4_get_MatrixData(struct Matrix_4 *const self)
{
	struct MatrixData_6 *result = NULL;

	if (!(self->_matrix != NULL))
	{
		struct MatrixData_6 *matrixData = NULL;

		matrixData = MatrixData_20_Zeros_6(self->Rows, self->Columns);
		(void)Assign_MatrixData_6(&self->_matrix, matrixData);
		(void)Assign_MatrixData_6(&matrixData, NULL);
	}
	(void)Assign_MatrixData_6(&result, self->_matrix);
	return result;
}

static void SquareMatrix_4_CheckMatrix(struct SquareMatrix_4 *const self)
{
	struct MatrixData_6 *matrixData = NULL;
	int32_t int32 = ((int32_t)0);
	struct MatrixData_6 *matrixData_1 = NULL;

	Matrix_4_CheckMatrix(&self->base);
	matrixData = Matrix_4_get_MatrixData(&self->base);
	int32 = matrixData->Rows;
	matrixData_1 = Matrix_4_get_MatrixData(&self->base);
	(void)Assign_MatrixData_6(&matrixData, NULL);
	(void)Assign_MatrixData_6(&matrixData_1, NULL);
}

bool_t MatrixData_6_get_IsZero(struct MatrixData_6 *const self)
{
	struct float64_t_1D_4 *data = NULL;
	int32_t i = ((int32_t)0);
	float64_t num = 0.0;

	(void)Assign_float64_t_1D_4(&data, self->_data);
	i = ((int32_t)0);
	while (i < ((int32_t)4))
	{
		num = data->Elements[i];
		if (!(num == 0.0))
		{
			RemRef_float64_t_1D_4(data);
			return false;
		}
		i = i + ((int32_t)1);
	}
	RemRef_float64_t_1D_4(data);
	return true;
}

bool_t Matrix_4_get_IsZero(struct Matrix_4 *const self)
{
	bool_t result = false;
	struct MatrixData_6 *matrixData = NULL;
	bool_t boolean = false;

	matrixData = Matrix_4_get_MatrixData(self);
	boolean = MatrixData_6_get_IsZero(matrixData);
	result = boolean;
	(void)Assign_MatrixData_6(&matrixData, NULL);
	return result;
}

static float64_t MatrixData_6_GetValueFast(struct MatrixData_6 *const self, int32_t row, int32_t column)
{
	float64_t result = 0.0;
	struct float64_t_1D_4 *array = NULL;

	array = MatrixData_6_get_DataReference(self);
	result = array->Elements[(column * self->Rows) + row];
	(void)Assign_float64_t_1D_4(&array, NULL);
	return result;
}

float64_t MatrixData_6_get_Item(struct MatrixData_6 *const self, int32_t row, int32_t column)
{
	float64_t double_ = 0.0;

	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	double_ = MatrixData_6_GetValueFast(self, row, column);
	return double_;
}

static float64_t Matrix_4_UncheckedGet(struct Matrix_4 *const self, int32_t row, int32_t column)
{
	float64_t result = 0.0;
	struct MatrixData_6 *matrixData = NULL;
	float64_t double_ = 0.0;

	matrixData = Matrix_4_get_MatrixData(self);
	double_ = MatrixData_6_get_Item(matrixData, row, column);
	result = double_;
	(void)Assign_MatrixData_6(&matrixData, NULL);
	return result;
}

static struct MatrixData_6 *Matrix_4_get_UncheckeMatrixData(struct Matrix_4 *const self)
{
	struct MatrixData_6 *result = NULL;

	(void)Assign_MatrixData_6(&result, self->_matrix);
	return result;
}

bool_t MatrixData_6_get_IsEmpty(struct MatrixData_6 *const self)
{
	return ((int32_t)4) == ((int32_t)0);
}

void LinearAlgebra_FactorCholesky_1(struct LinearAlgebra *const self, struct float64_t_1D_4 *a, int32_t rows)
{
	int32_t num = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	float64_t num2 = 0.0;
	int32_t k = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rows > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)4) % rows) != ((int32_t)0)))
	{
		abort();
	}
	num = ((int32_t)4) / rows;
	if (!(num == rows))
	{
		abort();
	}
	i = ((int32_t)0);
	while (i < num)
	{
		j = ((int32_t)0);
		while (j <= i)
		{
			num2 = a->Elements[(i * rows) + j];
			k = ((int32_t)0);
			while (k < j)
			{
				num2 = num2 - (a->Elements[(i * rows) + k] * a->Elements[(j * rows) + k]);
				k = k + ((int32_t)1);
			}
			if (!(j >= i))
			{
				a->Elements[(i * rows) + j] = num2 / a->Elements[(j * rows) + j];
			}
			else
			{
				struct float64_t_1D_4 *array = NULL;
				int32_t int32 = ((int32_t)0);
				float64_t double_ = 0.0;

				if (!!(num2 <= 0.0))
				{
					abort();
				}
				(void)Assign_float64_t_1D_4(&array, a);
				int32 = (i * rows) + i;
				double_ = Math_Sqrt(num2);
				array->Elements[int32] = double_;
				(void)Assign_float64_t_1D_4(&array, NULL);
			}
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
}

struct MatrixData_6 *MatrixMath_Chol_1(struct MatrixData_6 *matrix)
{
	bool_t boolean = false;
	struct MatrixData_6 *matrixData = NULL;
	struct MatrixData_6 *matrixData_1 = NULL;
	struct float64_t_1D_4 *dataReference = NULL;
	struct float64_t_1D_4 *array = NULL;
	struct float64_t_1D_4 *dataReference2 = NULL;
	struct float64_t_1D_4 *array_1 = NULL;
	int32_t i = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t j = ((int32_t)0);
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_4 *array_2 = NULL;
	struct MatrixData_6 *result = NULL;

	if (!(matrix != NULL))
	{
		abort();
	}
	boolean = MatrixData_6_get_IsEmpty(matrix);
	matrixData_1 = New_MatrixData_6();
	MatrixData_6_ctor(matrixData_1, matrix->Rows, matrix->Columns);
	(void)Assign_MatrixData_6(&matrixData, matrixData_1);
	(void)Assign_MatrixData_6(&matrixData_1, NULL);
	array = MatrixData_6_get_DataReference(matrix);
	(void)Assign_float64_t_1D_4(&dataReference, array);
	(void)Assign_float64_t_1D_4(&array, NULL);
	array_1 = MatrixData_6_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_4(&dataReference2, array_1);
	(void)Assign_float64_t_1D_4(&array_1, NULL);
	i = ((int32_t)0);
	while (i < matrixData->Columns)
	{
		num = i * matrix->Rows;
		j = i;
		while (j >= ((int32_t)3))
		{
			dataReference2->Elements[num] = dataReference->Elements[num];
			dataReference2->Elements[num + ((int32_t)1)] = dataReference->Elements[num + ((int32_t)1)];
			dataReference2->Elements[num + ((int32_t)2)] = dataReference->Elements[num + ((int32_t)2)];
			dataReference2->Elements[num + ((int32_t)3)] = dataReference->Elements[num + ((int32_t)3)];
			j = j - ((int32_t)4);
			num = num + ((int32_t)4);
		}
		while (j >= ((int32_t)1))
		{
			dataReference2->Elements[num] = dataReference->Elements[num];
			dataReference2->Elements[num + ((int32_t)1)] = dataReference->Elements[num + ((int32_t)1)];
			j = j - ((int32_t)2);
			num = num + ((int32_t)2);
		}
		while (j >= ((int32_t)0))
		{
			dataReference2->Elements[num] = dataReference->Elements[num];
			j = j - ((int32_t)1);
			num = num + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array_2 = MatrixData_6_get_DataReference(matrixData);
	LinearAlgebra_FactorCholesky_1(linearAlgebra, array_2, matrixData->Rows);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_4(&array_2, NULL);
	(void)Assign_MatrixData_6(&result, matrixData);
	RemRef_MatrixData_6(matrixData);
	RemRef_float64_t_1D_4(dataReference);
	RemRef_float64_t_1D_4(dataReference2);
	return result;
}

static void PositDefiniMatrix_4_CheckMatrix(struct PositiveDefiniteMatrix_4 *const self)
{
	bool_t boolean = false;
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	struct MatrixData_6 *matrixData = NULL;
	struct MatrixData_6 *matrixData_1 = NULL;

	SquareMatrix_4_CheckMatrix(&self->base);
	boolean = Matrix_4_get_IsZero(&self->base.base);
	if (!!boolean)
	{
		return;
	}
	i = ((int32_t)0);
	while (i < (&self->base.base)->Rows)
	{
		j = ((int32_t)0);
		while (j < i)
		{
			float64_t double_ = 0.0;
			float64_t double__1 = 0.0;
			int32_t int32 = ((int32_t)0);

			double_ = Matrix_4_UncheckedGet(&self->base.base, i, j);
			double__1 = Matrix_4_UncheckedGet(&self->base.base, j, i);
			int32 = FloatCompare_Compare(double_, double__1);
			if (!!(int32 != ((int32_t)0)))
			{
				abort();
			}
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	matrixData = Matrix_4_get_UncheckeMatrixData(&self->base.base);
	matrixData_1 = MatrixMath_Chol_1(matrixData);
	(void)Assign_MatrixData_6(&matrixData, NULL);
	(void)Assign_MatrixData_6(&matrixData_1, NULL);
}

void SquareMatrix_4_ctor_1(struct PositiveDefiniteMatrix_4 *const self, struct float64_t_1D_2 *mainDiagonal)
{
	struct MatrixData_6 *matrixData = NULL;

	SquareMatrix_4_ctor(&self->base);
	matrixData = MatrixData_20_Diag_1(mainDiagonal);
	Matrix_4_set_UncheckeMatrixData(&self->base.base, matrixData);
	(void)Assign_MatrixData_6(&matrixData, NULL);
	PositDefiniMatrix_4_CheckMatrix(self);
}

void PositiveDefiniteMatrix_4_ctor(struct PositiveDefiniteMatrix_4 *const self, struct float64_t_1D_2 *mainDiagonal)
{
	SquareMatrix_4_ctor_1(self, mainDiagonal);
}

static void RemRef_CTRASpace(struct CTRASpace *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base)->ReferenceCount--;
	if ((&self->base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_CTRASpace.CurrentCount--;
		Res_CTRASpace.Next[Res_CTRASpace.CurrentCount] = self;
		Del_CTRASpace(self);
	}
}

struct CTRASpace *New_CTRASpace(void)
{
	static struct CTRASpace const Default_CTRASpace = { 1 };
	struct CTRASpace *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_CTRASpace.CurrentCount == RC_CTRASpace)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_CTRASpace.Next[Res_CTRASpace.CurrentCount];
	Res_CTRASpace.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_CTRASpace.MaximumCount = (Res_CTRASpace.CurrentCount > Res_CTRASpace.MaximumCount) ? Res_CTRASpace.CurrentCount : Res_CTRASpace.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_CTRASpace;
	return instance;
}

struct CTRASpace *Assign_CTRASpace(struct CTRASpace **const left, struct CTRASpace *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base)->ReferenceCount++;
	}
	RemRef_CTRASpace(*left);
	*left = right;
	return right;
}

static void RemRef_MatrixData_9(struct MatrixData_9 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_9.CurrentCount--;
		Res_MatrixData_9.Next[Res_MatrixData_9.CurrentCount] = self;
		Del_MatrixData_9(self);
	}
}

struct MatrixData_9 *New_MatrixData_9(void)
{
	static struct MatrixData_9 const Default_MatrixData_9 = { 1 };
	struct MatrixData_9 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_9.CurrentCount == RC_MatrixData_9)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_9.Next[Res_MatrixData_9.CurrentCount];
	Res_MatrixData_9.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_9.MaximumCount = (Res_MatrixData_9.CurrentCount > Res_MatrixData_9.MaximumCount) ? Res_MatrixData_9.CurrentCount : Res_MatrixData_9.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_9;
	return instance;
}

struct MatrixData_9 *Assign_MatrixData_9(struct MatrixData_9 **const left, struct MatrixData_9 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_9(*left);
	*left = right;
	return right;
}

static void Del_float64_t_1D_6(struct float64_t_1D_6 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_1D_6(struct float64_t_1D_6 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_1D_6.CurrentCount--;
		Res_float64_t_1D_6.Next[Res_float64_t_1D_6.CurrentCount] = self;
		Del_float64_t_1D_6(self);
	}
}

struct float64_t_1D_6 *New_float64_t_1D_6(void)
{
	static struct float64_t_1D_6 const Default_float64_t_1D_6 = { 1 };
	struct float64_t_1D_6 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_1D_6.CurrentCount == RC_float64_t_1D_6)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_1D_6.Next[Res_float64_t_1D_6.CurrentCount];
	Res_float64_t_1D_6.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_1D_6.MaximumCount = (Res_float64_t_1D_6.CurrentCount > Res_float64_t_1D_6.MaximumCount) ? Res_float64_t_1D_6.CurrentCount : Res_float64_t_1D_6.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_1D_6;
	return instance;
}

struct float64_t_1D_6 *Assign_float64_t_1D_6(struct float64_t_1D_6 **const left, struct float64_t_1D_6 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_1D_6(*left);
	*left = right;
	return right;
}

void MatrixData_9_ctor(struct MatrixData_9 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_6 *array = NULL;

	assert(rows == ((int32_t)6));
	assert(columns == ((int32_t)1));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_6();
	(void)Assign_float64_t_1D_6(&self->_data, array);
	(void)Assign_float64_t_1D_6(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct MatrixData_9 *MatrixData_20_Zeros_7(int32_t rows, int32_t columns)
{
	struct MatrixData_9 *result = NULL;
	struct MatrixData_9 *matrixData = NULL;

	assert(rows == ((int32_t)6));
	assert(columns == ((int32_t)1));
	matrixData = New_MatrixData_9();
	MatrixData_9_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData_9(&result, matrixData);
	(void)Assign_MatrixData_9(&matrixData, NULL);
	return result;
}

static void Space_5_ctor(struct Space_5 *const self, int32_t dimensions)
{
	struct Object *object = NULL;
	struct MatrixData_9 *matrixData = NULL;

	assert(dimensions == ((int32_t)6));
	object = New_Object();
	Object_ctor(object);
	(void)Assign_Object(&self->_spaceInformationLock, object);
	(void)Assign_Object(&object, NULL);
	Object_ctor(&self->base);
	self->Dimensions = dimensions;
	matrixData = MatrixData_20_Zeros_7(self->Dimensions, ((int32_t)1));
	(void)Assign_MatrixData_9(&self->_vector, matrixData);
	(void)Assign_MatrixData_9(&matrixData, NULL);
}

static void AnguSpace_2_set_AngulDimenIndic(struct AngularSpace_2 *const self, struct int32_t_1D_1 *value)
{
	(void)Assign_int32_t_1D_1(&self->AngularDimensionsIndices, value);
}

struct int32_t_1D_1 *AnguSpace_2_get_AngulDimenIndic(struct AngularSpace_2 *const self)
{
	struct int32_t_1D_1 *result = NULL;

	(void)Assign_int32_t_1D_1(&result, self->AngularDimensionsIndices);
	return result;
}

static void AngularSpace_2_ctor(struct AngularSpace_2 *const self, int32_t dimensions, struct int32_t_1D_1 *angularDimensionsIndices, struct int32_t_1D_0 *additionAngularDimensionIndices)
{
	int32_t num = ((int32_t)0);
	struct int32_t_1D_1 *array = NULL;
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);

	assert(dimensions == ((int32_t)6));
	Space_5_ctor(&self->base, dimensions);
	num = ((int32_t)1) + ((int32_t)0);
	array = New_int32_t_1D_1();
	AnguSpace_2_set_AngulDimenIndic(self, array);
	(void)Assign_int32_t_1D_1(&array, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)1))
	{
		struct int32_t_1D_1 *array_1 = NULL;

		array_1 = AnguSpace_2_get_AngulDimenIndic(self);
		array_1->Elements[i] = angularDimensionsIndices->Elements[i];
		(void)Assign_int32_t_1D_1(&array_1, NULL);
		i = i + ((int32_t)1);
	}
	j = ((int32_t)0);
	while (j < ((int32_t)0))
	{
		struct int32_t_1D_1 *array_2 = NULL;

		array_2 = AnguSpace_2_get_AngulDimenIndic(self);
		array_2->Elements[j + ((int32_t)1)] = additionAngularDimensionIndices->Elements[j];
		(void)Assign_int32_t_1D_1(&array_2, NULL);
		j = j + ((int32_t)1);
	}
}

static void CTRASpace_ctor_1(struct CTRASpace *const self, int32_t additionalDimensions, struct int32_t_1D_0 *additionAngularDimensionIndices)
{
	struct int32_t_1D_1 *array = NULL;

	assert(additionalDimensions == ((int32_t)0));
	array = New_int32_t_1D_1();
	array->Elements[((int32_t)0)] = ((int32_t)2);
	AngularSpace_2_ctor(&self->base, ((int32_t)6) + additionalDimensions, array, additionAngularDimensionIndices);
	(void)Assign_int32_t_1D_1(&array, NULL);
}

static void CTRASpace_ctor_2(struct CTRASpace *const self, int32_t additionalDimensions)
{
	struct int32_t_1D_0 *array = NULL;

	assert(additionalDimensions == ((int32_t)0));
	array = New_int32_t_1D_0();
	CTRASpace_ctor_1(self, additionalDimensions, array);
	(void)Assign_int32_t_1D_0(&array, NULL);
}

void CTRASpace_ctor(struct CTRASpace *const self)
{
	CTRASpace_ctor_2(self, ((int32_t)0));
}

struct float64_t_1D_6 *MatrixData_9_get_DataReference(struct MatrixData_9 *const self)
{
	struct float64_t_1D_6 *result = NULL;

	(void)Assign_float64_t_1D_6(&result, self->_data);
	return result;
}

struct MatrixData_9 *MatrixData_20_Vec_2(int32_t start, int32_t end)
{
	int32_t num = ((int32_t)0);
	struct MatrixData_9 *matrixData = NULL;
	struct MatrixData_9 *matrixData_1 = NULL;
	struct float64_t_1D_6 *dataReference = NULL;
	struct float64_t_1D_6 *array = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_9 *result = NULL;

	assert(start == ((int32_t)0));
	assert(end == ((int32_t)5));
	num = (end - start) + ((int32_t)1);
	matrixData_1 = New_MatrixData_9();
	MatrixData_9_ctor(matrixData_1, num, ((int32_t)1));
	(void)Assign_MatrixData_9(&matrixData, matrixData_1);
	(void)Assign_MatrixData_9(&matrixData_1, NULL);
	array = MatrixData_9_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_6(&dataReference, array);
	(void)Assign_float64_t_1D_6(&array, NULL);
	i = ((int32_t)0);
	while (i < num)
	{
		dataReference->Elements[i] = (float64_t)(start + i);
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_9(&result, matrixData);
	RemRef_MatrixData_9(matrixData);
	RemRef_float64_t_1D_6(dataReference);
	return result;
}

void Space_5_set_MatrixData(struct Space_5 *const self, struct MatrixData_9 *value)
{
	if (!(value != NULL))
	{
		abort();
	}
	(void)Assign_MatrixData_9(&self->_vector, value);
}

struct CTRASpace *Space_6_GetIndices_3(void)
{
	struct CTRASpace *tSpace = NULL;
	struct CTRASpace *ctraSpace = NULL;
	struct MatrixData_9 *matrixData = NULL;
	struct CTRASpace *result = NULL;

	ctraSpace = New_CTRASpace();
	CTRASpace_ctor(ctraSpace);
	(void)Assign_CTRASpace(&tSpace, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	matrixData = MatrixData_20_Vec_2(((int32_t)0), (&tSpace->base.base)->Dimensions - ((int32_t)1));
	Space_5_set_MatrixData(&(*&tSpace)->base.base, matrixData);
	(void)Assign_MatrixData_9(&matrixData, NULL);
	(void)Assign_CTRASpace(&result, tSpace);
	RemRef_CTRASpace(tSpace);
	return result;
}

struct float64_t_1D_2 *MatrixData_8_get_DataReference(struct MatrixData_8 *const self)
{
	struct float64_t_1D_2 *result = NULL;

	(void)Assign_float64_t_1D_2(&result, self->_data);
	return result;
}

struct MatrixData_8 *MatrixData_20_Vec_3(int32_t start, int32_t end)
{
	int32_t num = ((int32_t)0);
	struct MatrixData_8 *matrixData = NULL;
	struct MatrixData_8 *matrixData_1 = NULL;
	struct float64_t_1D_2 *dataReference = NULL;
	struct float64_t_1D_2 *array = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_8 *result = NULL;

	assert(start == ((int32_t)0));
	assert(end == ((int32_t)1));
	num = (end - start) + ((int32_t)1);
	matrixData_1 = New_MatrixData_8();
	MatrixData_8_ctor(matrixData_1, num, ((int32_t)1));
	(void)Assign_MatrixData_8(&matrixData, matrixData_1);
	(void)Assign_MatrixData_8(&matrixData_1, NULL);
	array = MatrixData_8_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_2(&dataReference, array);
	(void)Assign_float64_t_1D_2(&array, NULL);
	i = ((int32_t)0);
	while (i < num)
	{
		dataReference->Elements[i] = (float64_t)(start + i);
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_8(&result, matrixData);
	RemRef_MatrixData_8(matrixData);
	RemRef_float64_t_1D_2(dataReference);
	return result;
}

void Space_4_set_MatrixData(struct Space_4 *const self, struct MatrixData_8 *value)
{
	if (!(value != NULL))
	{
		abort();
	}
	(void)Assign_MatrixData_8(&self->_vector, value);
}

struct CTRAErrorSpace *Space_6_GetIndices_4(void)
{
	struct CTRAErrorSpace *tSpace = NULL;
	struct CTRAErrorSpace *ctraErrorSpace = NULL;
	struct MatrixData_8 *matrixData = NULL;
	struct CTRAErrorSpace *result = NULL;

	ctraErrorSpace = New_CTRAErrorSpace();
	CTRAErrorSpace_ctor(ctraErrorSpace);
	(void)Assign_CTRAErrorSpace(&tSpace, ctraErrorSpace);
	(void)Assign_CTRAErrorSpace(&ctraErrorSpace, NULL);
	matrixData = MatrixData_20_Vec_3(((int32_t)0), (&tSpace->base)->Dimensions - ((int32_t)1));
	Space_4_set_MatrixData(&(*&tSpace)->base, matrixData);
	(void)Assign_MatrixData_8(&matrixData, NULL);
	(void)Assign_CTRAErrorSpace(&result, tSpace);
	RemRef_CTRAErrorSpace(tSpace);
	return result;
}

static void CTRAModel_1_cctor(void)
{
	struct CTRAErrorSpace *ctraErrorSpace = NULL;
	struct CTRASpace *ctraSpace = NULL;
	struct CTRAErrorSpace *ctraErrorSpace_1 = NULL;

	ctraErrorSpace = New_CTRAErrorSpace();
	CTRAErrorSpace_ctor(ctraErrorSpace);
	(void)Assign_CTRAErrorSpace(&CTRAModel_1_ZeroProcessNoise, ctraErrorSpace);
	(void)Assign_CTRAErrorSpace(&ctraErrorSpace, NULL);
	ctraSpace = Space_6_GetIndices_3();
	(void)Assign_CTRASpace(&CTRAModel_1_S, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	ctraErrorSpace_1 = Space_6_GetIndices_4();
	(void)Assign_CTRAErrorSpace(&CTRAModel_1_N, ctraErrorSpace_1);
	(void)Assign_CTRAErrorSpace(&ctraErrorSpace_1, NULL);
}

static void RemRef_CTRAModel(struct CTRAModel *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base.base)->ReferenceCount--;
	if ((&self->base.base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_CTRAModel.CurrentCount--;
		Res_CTRAModel.Next[Res_CTRAModel.CurrentCount] = self;
		Del_CTRAModel(self);
	}
}

struct CTRAModel *New_CTRAModel(void)
{
	static struct CTRAModel const Default_CTRAModel = { 1 };
	struct CTRAModel *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_CTRAModel.CurrentCount == RC_CTRAModel)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_CTRAModel.Next[Res_CTRAModel.CurrentCount];
	Res_CTRAModel.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_CTRAModel.MaximumCount = (Res_CTRAModel.CurrentCount > Res_CTRAModel.MaximumCount) ? Res_CTRAModel.CurrentCount : Res_CTRAModel.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_CTRAModel;
	return instance;
}

struct CTRAModel *Assign_CTRAModel(struct CTRAModel **const left, struct CTRAModel *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base.base)->ReferenceCount++;
	}
	RemRef_CTRAModel(*left);
	*left = right;
	return right;
}

void SystemModel_1_set_Condition(struct SystemModel_1 *const self, struct CTRASpace *value)
{
	(void)Assign_CTRASpace(&self->Condition, value);
}

void SystemModel_1_set_Condition2(struct SystemModel_1 *const self, struct CTRAErrorSpace *value)
{
	(void)Assign_CTRAErrorSpace(&self->Condition2, value);
}

void TimeSpan_ctor(struct TimeSpan *const self, int64_t ticks)
{
	(*self)._ticks = ticks;
}

static void TimeSpan_1_cctor(void)
{
	struct TimeSpan timeSpan = { 0 };
	struct TimeSpan timeSpan_1 = { 0 };
	struct TimeSpan timeSpan_2 = { 0 };

	TimeSpan_ctor(&timeSpan, ((int64_t)0));
	TimeSpan_1_Zero = timeSpan;
	TimeSpan_ctor(&timeSpan_1, ((int64_t)9223372036854775807));
	TimeSpan_1_MaxValue = timeSpan_1;
	TimeSpan_ctor(&timeSpan_2, INT64_MIN);
	TimeSpan_1_MinValue = timeSpan_2;
}

void SystemModel_1_set_TimeCondition(struct SystemModel_1 *const self, struct TimeSpan value)
{
	self->TimeCondition = value;
}

static void SystemModel_1_ctor(struct SystemModel_1 *const self, struct PositiveDefiniteMatrix_4 *processNoiseCovariance)
{
	struct CTRASpace *ctraSpace = NULL;
	struct CTRAErrorSpace *ctraErrorSpace = NULL;

	if (!(processNoiseCovariance != NULL))
	{
		abort();
	}
	Object_ctor(&self->base);
	ctraSpace = New_CTRASpace();
	CTRASpace_ctor(ctraSpace);
	SystemModel_1_set_Condition(self, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	ctraErrorSpace = New_CTRAErrorSpace();
	CTRAErrorSpace_ctor(ctraErrorSpace);
	SystemModel_1_set_Condition2(self, ctraErrorSpace);
	(void)Assign_CTRAErrorSpace(&ctraErrorSpace, NULL);
	SystemModel_1_set_TimeCondition(self, TimeSpan_1_Zero);
	(void)Assign_PositiveDefiniteMatrix_4(&self->_processNoiseCovariance, processNoiseCovariance);
}

static void SystemModel_3_ctor(struct SystemModel_3 *const self, struct PositiveDefiniteMatrix_4 *processNoiseCovariance)
{
	SystemModel_1_ctor(&self->base, processNoiseCovariance);
}

static void SystemModel_5_ctor(struct SystemModel_5 *const self, struct PositiveDefiniteMatrix_4 *processNoiseCovariance)
{
	SystemModel_3_ctor(&self->base, processNoiseCovariance);
}

void CTRAModel_ctor(struct CTRAModel *const self, struct PositiveDefiniteMatrix_4 *processNoiseCovariance)
{
	SystemModel_5_ctor(&self->base, processNoiseCovariance);
}

static void RemRef_PositiveDefiniteMatrix(struct PositiveDefiniteMatrix *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base)->ReferenceCount--;
	if ((&self->base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_PositiveDefiniteMatrix.CurrentCount--;
		Res_PositiveDefiniteMatrix.Next[Res_PositiveDefiniteMatrix.CurrentCount] = self;
		Del_PositiveDefiniteMatrix(self);
	}
}

struct PositiveDefiniteMatrix *New_PositiveDefiniteMatrix(void)
{
	static struct PositiveDefiniteMatrix const Default_PositiveDefiniteMatrix = { 1 };
	struct PositiveDefiniteMatrix *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_PositiveDefiniteMatrix.CurrentCount == RC_PositiveDefiniteMatrix)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_PositiveDefiniteMatrix.Next[Res_PositiveDefiniteMatrix.CurrentCount];
	Res_PositiveDefiniteMatrix.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_PositiveDefiniteMatrix.MaximumCount = (Res_PositiveDefiniteMatrix.CurrentCount > Res_PositiveDefiniteMatrix.MaximumCount) ? Res_PositiveDefiniteMatrix.CurrentCount : Res_PositiveDefiniteMatrix.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_PositiveDefiniteMatrix;
	return instance;
}

struct PositiveDefiniteMatrix *Assign_PositiveDefiniteMatrix(struct PositiveDefiniteMatrix **const left, struct PositiveDefiniteMatrix *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base)->ReferenceCount++;
	}
	RemRef_PositiveDefiniteMatrix(*left);
	*left = right;
	return right;
}

static void RemRef_VelocitySpace(struct VelocitySpace *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_VelocitySpace.CurrentCount--;
		Res_VelocitySpace.Next[Res_VelocitySpace.CurrentCount] = self;
		Del_VelocitySpace(self);
	}
}

struct VelocitySpace *New_VelocitySpace(void)
{
	static struct VelocitySpace const Default_VelocitySpace = { 1 };
	struct VelocitySpace *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_VelocitySpace.CurrentCount == RC_VelocitySpace)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_VelocitySpace.Next[Res_VelocitySpace.CurrentCount];
	Res_VelocitySpace.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_VelocitySpace.MaximumCount = (Res_VelocitySpace.CurrentCount > Res_VelocitySpace.MaximumCount) ? Res_VelocitySpace.CurrentCount : Res_VelocitySpace.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_VelocitySpace;
	return instance;
}

struct VelocitySpace *Assign_VelocitySpace(struct VelocitySpace **const left, struct VelocitySpace *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_VelocitySpace(*left);
	*left = right;
	return right;
}

void VelocitySpace_ctor(struct VelocitySpace *const self)
{
	Space_1_ctor(&self->base, ((int32_t)1));
}

void Matrix_ctor(struct Matrix *const self)
{
	struct VelocitySpace *velocitySpace = NULL;
	struct VelocitySpace *velocitySpace_1 = NULL;

	velocitySpace = New_VelocitySpace();
	VelocitySpace_ctor(velocitySpace);
	(void)Assign_VelocitySpace(&self->EmptyRowSpace, velocitySpace);
	(void)Assign_VelocitySpace(&velocitySpace, NULL);
	velocitySpace_1 = New_VelocitySpace();
	VelocitySpace_ctor(velocitySpace_1);
	(void)Assign_VelocitySpace(&self->EmptyColumnSpace, velocitySpace_1);
	(void)Assign_VelocitySpace(&velocitySpace_1, NULL);
	Object_ctor(&self->base);
	self->Columns = (&self->EmptyRowSpace->base)->Dimensions;
	self->Rows = (&self->EmptyColumnSpace->base)->Dimensions;
}

void SquareMatrix_ctor(struct SquareMatrix *const self)
{
	struct VelocitySpace *velocitySpace = NULL;

	velocitySpace = New_VelocitySpace();
	VelocitySpace_ctor(velocitySpace);
	(void)Assign_VelocitySpace(&self->EmptySpace, velocitySpace);
	(void)Assign_VelocitySpace(&velocitySpace, NULL);
	Matrix_ctor(&self->base);
	self->Dimensions = (&self->base)->Rows;
}

struct float64_t_1D_1 *MatrixData_3_get_DataReference(struct MatrixData_3 *const self)
{
	struct float64_t_1D_1 *result = NULL;

	(void)Assign_float64_t_1D_1(&result, self->_data);
	return result;
}

static void MatrixData_3_SetValueFast(struct MatrixData_3 *const self, float64_t value, int32_t row, int32_t column)
{
	struct float64_t_1D_1 *array = NULL;

	array = MatrixData_3_get_DataReference(self);
	array->Elements[(column * self->Rows) + row] = value;
	(void)Assign_float64_t_1D_1(&array, NULL);
}

struct MatrixData_3 *MatrixData_20_Diag_2(struct float64_t_1D_1 *diagonalElements)
{
	struct MatrixData_3 *matrixData = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_3 *result = NULL;

	if (!(diagonalElements != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData_3();
	MatrixData_3_ctor(matrixData_1, ((int32_t)1), ((int32_t)1));
	(void)Assign_MatrixData_3(&matrixData, matrixData_1);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)1))
	{
		MatrixData_3_SetValueFast(matrixData, diagonalElements->Elements[i], i, i);
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_3(&result, matrixData);
	RemRef_MatrixData_3(matrixData);
	return result;
}

static void Matrix_set_UncheckedMatrixData(struct Matrix *const self, struct MatrixData_3 *value)
{
	(void)Assign_MatrixData_3(&self->_matrix, value);
}

static void Matrix_CheckMatrix(struct Matrix *const self)
{
	struct float64_t_1D_1 *dataReference = NULL;
	struct float64_t_1D_1 *array = NULL;
	int32_t i = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);

	array = MatrixData_3_get_DataReference(self->_matrix);
	(void)Assign_float64_t_1D_1(&dataReference, array);
	(void)Assign_float64_t_1D_1(&array, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)1))
	{
		bool_t boolean = false;

		boolean = Double_IsNaN(dataReference->Elements[i]);
		if (!!boolean)
		{
			num = i / self->Rows;
			num2 = i - (num * self->Rows);
			abort();
		}
		i = i + ((int32_t)1);
	}
	RemRef_float64_t_1D_1(dataReference);
}

struct MatrixData_3 *Matrix_get_MatrixData(struct Matrix *const self)
{
	struct MatrixData_3 *result = NULL;

	if (!(self->_matrix != NULL))
	{
		struct MatrixData_3 *matrixData = NULL;

		matrixData = MatrixData_20_Zeros_2(self->Rows, self->Columns);
		(void)Assign_MatrixData_3(&self->_matrix, matrixData);
		(void)Assign_MatrixData_3(&matrixData, NULL);
	}
	(void)Assign_MatrixData_3(&result, self->_matrix);
	return result;
}

static void SquareMatrix_CheckMatrix(struct SquareMatrix *const self)
{
	struct MatrixData_3 *matrixData = NULL;
	int32_t int32 = ((int32_t)0);
	struct MatrixData_3 *matrixData_1 = NULL;

	Matrix_CheckMatrix(&self->base);
	matrixData = Matrix_get_MatrixData(&self->base);
	int32 = matrixData->Rows;
	matrixData_1 = Matrix_get_MatrixData(&self->base);
	(void)Assign_MatrixData_3(&matrixData, NULL);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
}

bool_t MatrixData_3_get_IsZero(struct MatrixData_3 *const self)
{
	struct float64_t_1D_1 *data = NULL;
	int32_t i = ((int32_t)0);
	float64_t num = 0.0;

	(void)Assign_float64_t_1D_1(&data, self->_data);
	i = ((int32_t)0);
	while (i < ((int32_t)1))
	{
		num = data->Elements[i];
		if (!(num == 0.0))
		{
			RemRef_float64_t_1D_1(data);
			return false;
		}
		i = i + ((int32_t)1);
	}
	RemRef_float64_t_1D_1(data);
	return true;
}

bool_t Matrix_get_IsZero(struct Matrix *const self)
{
	bool_t result = false;
	struct MatrixData_3 *matrixData = NULL;
	bool_t boolean = false;

	matrixData = Matrix_get_MatrixData(self);
	boolean = MatrixData_3_get_IsZero(matrixData);
	result = boolean;
	(void)Assign_MatrixData_3(&matrixData, NULL);
	return result;
}

static float64_t MatrixData_3_GetValueFast(struct MatrixData_3 *const self, int32_t row, int32_t column)
{
	float64_t result = 0.0;
	struct float64_t_1D_1 *array = NULL;

	array = MatrixData_3_get_DataReference(self);
	result = array->Elements[(column * self->Rows) + row];
	(void)Assign_float64_t_1D_1(&array, NULL);
	return result;
}

float64_t MatrixData_3_get_Item(struct MatrixData_3 *const self, int32_t row, int32_t column)
{
	float64_t double_ = 0.0;

	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	double_ = MatrixData_3_GetValueFast(self, row, column);
	return double_;
}

static float64_t Matrix_UncheckedGet(struct Matrix *const self, int32_t row, int32_t column)
{
	float64_t result = 0.0;
	struct MatrixData_3 *matrixData = NULL;
	float64_t double_ = 0.0;

	matrixData = Matrix_get_MatrixData(self);
	double_ = MatrixData_3_get_Item(matrixData, row, column);
	result = double_;
	(void)Assign_MatrixData_3(&matrixData, NULL);
	return result;
}

static struct MatrixData_3 *Matrix_get_UncheckedMatrixData(struct Matrix *const self)
{
	struct MatrixData_3 *result = NULL;

	(void)Assign_MatrixData_3(&result, self->_matrix);
	return result;
}

bool_t MatrixData_3_get_IsEmpty(struct MatrixData_3 *const self)
{
	return ((int32_t)1) == ((int32_t)0);
}

void LinearAlgebra_FactorCholesky_2(struct LinearAlgebra *const self, struct float64_t_1D_1 *a, int32_t rows)
{
	int32_t num = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	float64_t num2 = 0.0;
	int32_t k = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rows > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)1) % rows) != ((int32_t)0)))
	{
		abort();
	}
	num = ((int32_t)1) / rows;
	if (!(num == rows))
	{
		abort();
	}
	i = ((int32_t)0);
	while (i < num)
	{
		j = ((int32_t)0);
		while (j <= i)
		{
			num2 = a->Elements[(i * rows) + j];
			k = ((int32_t)0);
			while (k < j)
			{
				num2 = num2 - (a->Elements[(i * rows) + k] * a->Elements[(j * rows) + k]);
				k = k + ((int32_t)1);
			}
			if (!(j >= i))
			{
				a->Elements[(i * rows) + j] = num2 / a->Elements[(j * rows) + j];
			}
			else
			{
				struct float64_t_1D_1 *array = NULL;
				int32_t int32 = ((int32_t)0);
				float64_t double_ = 0.0;

				if (!!(num2 <= 0.0))
				{
					abort();
				}
				(void)Assign_float64_t_1D_1(&array, a);
				int32 = (i * rows) + i;
				double_ = Math_Sqrt(num2);
				array->Elements[int32] = double_;
				(void)Assign_float64_t_1D_1(&array, NULL);
			}
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
}

struct MatrixData_3 *MatrixMath_Chol_2(struct MatrixData_3 *matrix)
{
	bool_t boolean = false;
	struct MatrixData_3 *matrixData = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;
	struct float64_t_1D_1 *dataReference = NULL;
	struct float64_t_1D_1 *array = NULL;
	struct float64_t_1D_1 *dataReference2 = NULL;
	struct float64_t_1D_1 *array_1 = NULL;
	int32_t i = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t j = ((int32_t)0);
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_1 *array_2 = NULL;
	struct MatrixData_3 *result = NULL;

	if (!(matrix != NULL))
	{
		abort();
	}
	boolean = MatrixData_3_get_IsEmpty(matrix);
	matrixData_1 = New_MatrixData_3();
	MatrixData_3_ctor(matrixData_1, matrix->Rows, matrix->Columns);
	(void)Assign_MatrixData_3(&matrixData, matrixData_1);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
	array = MatrixData_3_get_DataReference(matrix);
	(void)Assign_float64_t_1D_1(&dataReference, array);
	(void)Assign_float64_t_1D_1(&array, NULL);
	array_1 = MatrixData_3_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_1(&dataReference2, array_1);
	(void)Assign_float64_t_1D_1(&array_1, NULL);
	i = ((int32_t)0);
	while (i < matrixData->Columns)
	{
		num = i * matrix->Rows;
		j = i;
		while (j >= ((int32_t)3))
		{
			dataReference2->Elements[num] = dataReference->Elements[num];
			dataReference2->Elements[num + ((int32_t)1)] = dataReference->Elements[num + ((int32_t)1)];
			dataReference2->Elements[num + ((int32_t)2)] = dataReference->Elements[num + ((int32_t)2)];
			dataReference2->Elements[num + ((int32_t)3)] = dataReference->Elements[num + ((int32_t)3)];
			j = j - ((int32_t)4);
			num = num + ((int32_t)4);
		}
		while (j >= ((int32_t)1))
		{
			dataReference2->Elements[num] = dataReference->Elements[num];
			dataReference2->Elements[num + ((int32_t)1)] = dataReference->Elements[num + ((int32_t)1)];
			j = j - ((int32_t)2);
			num = num + ((int32_t)2);
		}
		while (j >= ((int32_t)0))
		{
			dataReference2->Elements[num] = dataReference->Elements[num];
			j = j - ((int32_t)1);
			num = num + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array_2 = MatrixData_3_get_DataReference(matrixData);
	LinearAlgebra_FactorCholesky_2(linearAlgebra, array_2, matrixData->Rows);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_1(&array_2, NULL);
	(void)Assign_MatrixData_3(&result, matrixData);
	RemRef_MatrixData_3(matrixData);
	RemRef_float64_t_1D_1(dataReference);
	RemRef_float64_t_1D_1(dataReference2);
	return result;
}

static void PositiDefinitMatrix_CheckMatrix(struct PositiveDefiniteMatrix *const self)
{
	bool_t boolean = false;
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	struct MatrixData_3 *matrixData = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;

	SquareMatrix_CheckMatrix(&self->base);
	boolean = Matrix_get_IsZero(&self->base.base);
	if (!!boolean)
	{
		return;
	}
	i = ((int32_t)0);
	while (i < (&self->base.base)->Rows)
	{
		j = ((int32_t)0);
		while (j < i)
		{
			float64_t double_ = 0.0;
			float64_t double__1 = 0.0;
			int32_t int32 = ((int32_t)0);

			double_ = Matrix_UncheckedGet(&self->base.base, i, j);
			double__1 = Matrix_UncheckedGet(&self->base.base, j, i);
			int32 = FloatCompare_Compare(double_, double__1);
			if (!!(int32 != ((int32_t)0)))
			{
				abort();
			}
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	matrixData = Matrix_get_UncheckedMatrixData(&self->base.base);
	matrixData_1 = MatrixMath_Chol_2(matrixData);
	(void)Assign_MatrixData_3(&matrixData, NULL);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
}

void SquareMatrix_ctor_1(struct PositiveDefiniteMatrix *const self, struct float64_t_1D_1 *mainDiagonal)
{
	struct MatrixData_3 *matrixData = NULL;

	SquareMatrix_ctor(&self->base);
	matrixData = MatrixData_20_Diag_2(mainDiagonal);
	Matrix_set_UncheckedMatrixData(&self->base.base, matrixData);
	(void)Assign_MatrixData_3(&matrixData, NULL);
	PositiDefinitMatrix_CheckMatrix(self);
}

void PositiveDefiniteMatrix_ctor(struct PositiveDefiniteMatrix *const self, struct float64_t_1D_1 *mainDiagonal)
{
	SquareMatrix_ctor_1(self, mainDiagonal);
}

struct MatrixData_3 *MatrixData_20_Vec_4(int32_t start, int32_t end)
{
	int32_t num = ((int32_t)0);
	struct MatrixData_3 *matrixData = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;
	struct float64_t_1D_1 *dataReference = NULL;
	struct float64_t_1D_1 *array = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_3 *result = NULL;

	assert(start == ((int32_t)0));
	assert(end == ((int32_t)0));
	num = (end - start) + ((int32_t)1);
	matrixData_1 = New_MatrixData_3();
	MatrixData_3_ctor(matrixData_1, num, ((int32_t)1));
	(void)Assign_MatrixData_3(&matrixData, matrixData_1);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
	array = MatrixData_3_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_1(&dataReference, array);
	(void)Assign_float64_t_1D_1(&array, NULL);
	i = ((int32_t)0);
	while (i < num)
	{
		dataReference->Elements[i] = (float64_t)(start + i);
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_3(&result, matrixData);
	RemRef_MatrixData_3(matrixData);
	RemRef_float64_t_1D_1(dataReference);
	return result;
}

void Space_1_set_MatrixData(struct Space_1 *const self, struct MatrixData_3 *value)
{
	if (!(value != NULL))
	{
		abort();
	}
	(void)Assign_MatrixData_3(&self->_vector, value);
}

struct VelocitySpace *Space_6_GetIndices_5(void)
{
	struct VelocitySpace *tSpace = NULL;
	struct VelocitySpace *velocitySpace = NULL;
	struct MatrixData_3 *matrixData = NULL;
	struct VelocitySpace *result = NULL;

	velocitySpace = New_VelocitySpace();
	VelocitySpace_ctor(velocitySpace);
	(void)Assign_VelocitySpace(&tSpace, velocitySpace);
	(void)Assign_VelocitySpace(&velocitySpace, NULL);
	matrixData = MatrixData_20_Vec_4(((int32_t)0), (&tSpace->base)->Dimensions - ((int32_t)1));
	Space_1_set_MatrixData(&(*&tSpace)->base, matrixData);
	(void)Assign_MatrixData_3(&matrixData, NULL);
	(void)Assign_VelocitySpace(&result, tSpace);
	RemRef_VelocitySpace(tSpace);
	return result;
}

static void VelocityMeasuremenModel_1_cctor(void)
{
	struct CTRASpace *ctraSpace = NULL;
	struct VelocitySpace *velocitySpace = NULL;

	ctraSpace = Space_6_GetIndices_3();
	(void)Assign_CTRASpace(&VelocitMeasureModel_1_StateIdxs, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	velocitySpace = Space_6_GetIndices_5();
	(void)Assign_VelocitySpace(&VelociMeasurModel_1_MeasureIdxs, velocitySpace);
	(void)Assign_VelocitySpace(&velocitySpace, NULL);
}

static void RemRef_VelocityMeasurementModel(struct VelocityMeasurementModel *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base.base)->ReferenceCount--;
	if ((&self->base.base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_VelocityMeasurementModel.CurrentCount--;
		Res_VelocityMeasurementModel.Next[Res_VelocityMeasurementModel.CurrentCount] = self;
		Del_VelocityMeasurementModel(self);
	}
}

struct VelocityMeasurementModel *New_VelocityMeasurementModel(void)
{
	static struct VelocityMeasurementModel const Default_VelocityMeasuremenModel = { 1 };
	struct VelocityMeasurementModel *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_VelocityMeasurementModel.CurrentCount == RC_VelocityMeasurementModel)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_VelocityMeasurementModel.Next[Res_VelocityMeasurementModel.CurrentCount];
	Res_VelocityMeasurementModel.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_VelocityMeasurementModel.MaximumCount = (Res_VelocityMeasurementModel.CurrentCount > Res_VelocityMeasurementModel.MaximumCount) ? Res_VelocityMeasurementModel.CurrentCount : Res_VelocityMeasurementModel.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_VelocityMeasuremenModel;
	return instance;
}

struct VelocityMeasurementModel *Assign_VelocityMeasurementModel(struct VelocityMeasurementModel **const left, struct VelocityMeasurementModel *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base.base)->ReferenceCount++;
	}
	RemRef_VelocityMeasurementModel(*left);
	*left = right;
	return right;
}

void MeasurementModel_set_Condition(struct MeasurementModel *const self, struct CTRASpace *value)
{
	(void)Assign_CTRASpace(&self->Condition, value);
}

static void MeasurementModel_ctor(struct MeasurementModel *const self, struct PositiveDefiniteMatrix *measurementNoiseCovariance)
{
	struct CTRASpace *ctraSpace = NULL;

	if (!(measurementNoiseCovariance != NULL))
	{
		abort();
	}
	Object_ctor(&self->base);
	ctraSpace = New_CTRASpace();
	CTRASpace_ctor(ctraSpace);
	MeasurementModel_set_Condition(self, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	(void)Assign_PositiveDefiniteMatrix(&self->_measurementNoiseCovariance, measurementNoiseCovariance);
}

static void MeasurementModel_4_ctor(struct MeasurementModel_4 *const self, struct PositiveDefiniteMatrix *measurementNoiseCovariance)
{
	MeasurementModel_ctor(&self->base, measurementNoiseCovariance);
}

static void MeasurementModel_8_ctor(struct MeasurementModel_8 *const self, struct PositiveDefiniteMatrix *measurementNoiseCovariance)
{
	MeasurementModel_4_ctor(&self->base, measurementNoiseCovariance);
}

void VelocMeasuModel_set_VelociScale(struct VelocityMeasurementModel *const self, float64_t value)
{
	self->VelocityScale = value;
}

void VelocityMeasurementModel_ctor(struct VelocityMeasurementModel *const self, struct PositiveDefiniteMatrix *measurementNoiseCovariance)
{
	MeasurementModel_8_ctor(&self->base, measurementNoiseCovariance);
	VelocMeasuModel_set_VelociScale(self, 1.0);
}

static void RemRef_PositiveDefiniteMatrix_1(struct PositiveDefiniteMatrix_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base)->ReferenceCount--;
	if ((&self->base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_PositiveDefiniteMatrix_1.CurrentCount--;
		Res_PositiveDefiniteMatrix_1.Next[Res_PositiveDefiniteMatrix_1.CurrentCount] = self;
		Del_PositiveDefiniteMatrix_1(self);
	}
}

struct PositiveDefiniteMatrix_1 *New_PositiveDefiniteMatrix_1(void)
{
	static struct PositiveDefiniteMatrix_1 const Default_PositivDefiniteMatrix_1 = { 1 };
	struct PositiveDefiniteMatrix_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_PositiveDefiniteMatrix_1.CurrentCount == RC_PositiveDefiniteMatrix_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_PositiveDefiniteMatrix_1.Next[Res_PositiveDefiniteMatrix_1.CurrentCount];
	Res_PositiveDefiniteMatrix_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_PositiveDefiniteMatrix_1.MaximumCount = (Res_PositiveDefiniteMatrix_1.CurrentCount > Res_PositiveDefiniteMatrix_1.MaximumCount) ? Res_PositiveDefiniteMatrix_1.CurrentCount : Res_PositiveDefiniteMatrix_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_PositivDefiniteMatrix_1;
	return instance;
}

struct PositiveDefiniteMatrix_1 *Assign_PositiveDefiniteMatrix_1(struct PositiveDefiniteMatrix_1 **const left, struct PositiveDefiniteMatrix_1 *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base)->ReferenceCount++;
	}
	RemRef_PositiveDefiniteMatrix_1(*left);
	*left = right;
	return right;
}

static void RemRef_YawRateSpace(struct YawRateSpace *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_YawRateSpace.CurrentCount--;
		Res_YawRateSpace.Next[Res_YawRateSpace.CurrentCount] = self;
		Del_YawRateSpace(self);
	}
}

struct YawRateSpace *New_YawRateSpace(void)
{
	static struct YawRateSpace const Default_YawRateSpace = { 1 };
	struct YawRateSpace *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_YawRateSpace.CurrentCount == RC_YawRateSpace)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_YawRateSpace.Next[Res_YawRateSpace.CurrentCount];
	Res_YawRateSpace.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_YawRateSpace.MaximumCount = (Res_YawRateSpace.CurrentCount > Res_YawRateSpace.MaximumCount) ? Res_YawRateSpace.CurrentCount : Res_YawRateSpace.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_YawRateSpace;
	return instance;
}

struct YawRateSpace *Assign_YawRateSpace(struct YawRateSpace **const left, struct YawRateSpace *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_YawRateSpace(*left);
	*left = right;
	return right;
}

void YawRateSpace_ctor(struct YawRateSpace *const self)
{
	Space_1_ctor(&self->base, ((int32_t)1));
}

void Matrix_1_ctor(struct Matrix_1 *const self)
{
	struct YawRateSpace *yawRateSpace = NULL;
	struct YawRateSpace *yawRateSpace_1 = NULL;

	yawRateSpace = New_YawRateSpace();
	YawRateSpace_ctor(yawRateSpace);
	(void)Assign_YawRateSpace(&self->EmptyRowSpace, yawRateSpace);
	(void)Assign_YawRateSpace(&yawRateSpace, NULL);
	yawRateSpace_1 = New_YawRateSpace();
	YawRateSpace_ctor(yawRateSpace_1);
	(void)Assign_YawRateSpace(&self->EmptyColumnSpace, yawRateSpace_1);
	(void)Assign_YawRateSpace(&yawRateSpace_1, NULL);
	Object_ctor(&self->base);
	self->Columns = (&self->EmptyRowSpace->base)->Dimensions;
	self->Rows = (&self->EmptyColumnSpace->base)->Dimensions;
}

void SquareMatrix_1_ctor(struct SquareMatrix_1 *const self)
{
	struct YawRateSpace *yawRateSpace = NULL;

	yawRateSpace = New_YawRateSpace();
	YawRateSpace_ctor(yawRateSpace);
	(void)Assign_YawRateSpace(&self->EmptySpace, yawRateSpace);
	(void)Assign_YawRateSpace(&yawRateSpace, NULL);
	Matrix_1_ctor(&self->base);
	self->Dimensions = (&self->base)->Rows;
}

static void Matrix_1_set_UncheckeMatrixData(struct Matrix_1 *const self, struct MatrixData_3 *value)
{
	(void)Assign_MatrixData_3(&self->_matrix, value);
}

static void Matrix_1_CheckMatrix(struct Matrix_1 *const self)
{
	struct float64_t_1D_1 *dataReference = NULL;
	struct float64_t_1D_1 *array = NULL;
	int32_t i = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);

	array = MatrixData_3_get_DataReference(self->_matrix);
	(void)Assign_float64_t_1D_1(&dataReference, array);
	(void)Assign_float64_t_1D_1(&array, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)1))
	{
		bool_t boolean = false;

		boolean = Double_IsNaN(dataReference->Elements[i]);
		if (!!boolean)
		{
			num = i / self->Rows;
			num2 = i - (num * self->Rows);
			abort();
		}
		i = i + ((int32_t)1);
	}
	RemRef_float64_t_1D_1(dataReference);
}

struct MatrixData_3 *Matrix_1_get_MatrixData(struct Matrix_1 *const self)
{
	struct MatrixData_3 *result = NULL;

	if (!(self->_matrix != NULL))
	{
		struct MatrixData_3 *matrixData = NULL;

		matrixData = MatrixData_20_Zeros_2(self->Rows, self->Columns);
		(void)Assign_MatrixData_3(&self->_matrix, matrixData);
		(void)Assign_MatrixData_3(&matrixData, NULL);
	}
	(void)Assign_MatrixData_3(&result, self->_matrix);
	return result;
}

static void SquareMatrix_1_CheckMatrix(struct SquareMatrix_1 *const self)
{
	struct MatrixData_3 *matrixData = NULL;
	int32_t int32 = ((int32_t)0);
	struct MatrixData_3 *matrixData_1 = NULL;

	Matrix_1_CheckMatrix(&self->base);
	matrixData = Matrix_1_get_MatrixData(&self->base);
	int32 = matrixData->Rows;
	matrixData_1 = Matrix_1_get_MatrixData(&self->base);
	(void)Assign_MatrixData_3(&matrixData, NULL);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
}

bool_t Matrix_1_get_IsZero(struct Matrix_1 *const self)
{
	bool_t result = false;
	struct MatrixData_3 *matrixData = NULL;
	bool_t boolean = false;

	matrixData = Matrix_1_get_MatrixData(self);
	boolean = MatrixData_3_get_IsZero(matrixData);
	result = boolean;
	(void)Assign_MatrixData_3(&matrixData, NULL);
	return result;
}

static float64_t Matrix_1_UncheckedGet(struct Matrix_1 *const self, int32_t row, int32_t column)
{
	float64_t result = 0.0;
	struct MatrixData_3 *matrixData = NULL;
	float64_t double_ = 0.0;

	matrixData = Matrix_1_get_MatrixData(self);
	double_ = MatrixData_3_get_Item(matrixData, row, column);
	result = double_;
	(void)Assign_MatrixData_3(&matrixData, NULL);
	return result;
}

static struct MatrixData_3 *Matrix_1_get_UncheckeMatrixData(struct Matrix_1 *const self)
{
	struct MatrixData_3 *result = NULL;

	(void)Assign_MatrixData_3(&result, self->_matrix);
	return result;
}

static void PositDefiniMatrix_1_CheckMatrix(struct PositiveDefiniteMatrix_1 *const self)
{
	bool_t boolean = false;
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	struct MatrixData_3 *matrixData = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;

	SquareMatrix_1_CheckMatrix(&self->base);
	boolean = Matrix_1_get_IsZero(&self->base.base);
	if (!!boolean)
	{
		return;
	}
	i = ((int32_t)0);
	while (i < (&self->base.base)->Rows)
	{
		j = ((int32_t)0);
		while (j < i)
		{
			float64_t double_ = 0.0;
			float64_t double__1 = 0.0;
			int32_t int32 = ((int32_t)0);

			double_ = Matrix_1_UncheckedGet(&self->base.base, i, j);
			double__1 = Matrix_1_UncheckedGet(&self->base.base, j, i);
			int32 = FloatCompare_Compare(double_, double__1);
			if (!!(int32 != ((int32_t)0)))
			{
				abort();
			}
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	matrixData = Matrix_1_get_UncheckeMatrixData(&self->base.base);
	matrixData_1 = MatrixMath_Chol_2(matrixData);
	(void)Assign_MatrixData_3(&matrixData, NULL);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
}

void SquareMatrix_1_ctor_1(struct PositiveDefiniteMatrix_1 *const self, struct float64_t_1D_1 *mainDiagonal)
{
	struct MatrixData_3 *matrixData = NULL;

	SquareMatrix_1_ctor(&self->base);
	matrixData = MatrixData_20_Diag_2(mainDiagonal);
	Matrix_1_set_UncheckeMatrixData(&self->base.base, matrixData);
	(void)Assign_MatrixData_3(&matrixData, NULL);
	PositDefiniMatrix_1_CheckMatrix(self);
}

void PositiveDefiniteMatrix_1_ctor(struct PositiveDefiniteMatrix_1 *const self, struct float64_t_1D_1 *mainDiagonal)
{
	SquareMatrix_1_ctor_1(self, mainDiagonal);
}

struct YawRateSpace *Space_6_GetIndices_6(void)
{
	struct YawRateSpace *tSpace = NULL;
	struct YawRateSpace *yawRateSpace = NULL;
	struct MatrixData_3 *matrixData = NULL;
	struct YawRateSpace *result = NULL;

	yawRateSpace = New_YawRateSpace();
	YawRateSpace_ctor(yawRateSpace);
	(void)Assign_YawRateSpace(&tSpace, yawRateSpace);
	(void)Assign_YawRateSpace(&yawRateSpace, NULL);
	matrixData = MatrixData_20_Vec_4(((int32_t)0), (&tSpace->base)->Dimensions - ((int32_t)1));
	Space_1_set_MatrixData(&(*&tSpace)->base, matrixData);
	(void)Assign_MatrixData_3(&matrixData, NULL);
	(void)Assign_YawRateSpace(&result, tSpace);
	RemRef_YawRateSpace(tSpace);
	return result;
}

static void YawRateMeasurementModel_1_cctor(void)
{
	struct CTRASpace *ctraSpace = NULL;
	struct YawRateSpace *yawRateSpace = NULL;

	ctraSpace = Space_6_GetIndices_3();
	(void)Assign_CTRASpace(&YawRateMeasureModel_1_StateIdxs, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	yawRateSpace = Space_6_GetIndices_6();
	(void)Assign_YawRateSpace(&YawRateMeasurModel_1_MeasurIdxs, yawRateSpace);
	(void)Assign_YawRateSpace(&yawRateSpace, NULL);
}

static void RemRef_YawRateMeasurementModel(struct YawRateMeasurementModel *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base)->ReferenceCount--;
	if ((&self->base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_YawRateMeasurementModel.CurrentCount--;
		Res_YawRateMeasurementModel.Next[Res_YawRateMeasurementModel.CurrentCount] = self;
		Del_YawRateMeasurementModel(self);
	}
}

struct YawRateMeasurementModel *New_YawRateMeasurementModel(void)
{
	static struct YawRateMeasurementModel const Default_YawRateMeasurementModel = { 1 };
	struct YawRateMeasurementModel *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_YawRateMeasurementModel.CurrentCount == RC_YawRateMeasurementModel)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_YawRateMeasurementModel.Next[Res_YawRateMeasurementModel.CurrentCount];
	Res_YawRateMeasurementModel.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_YawRateMeasurementModel.MaximumCount = (Res_YawRateMeasurementModel.CurrentCount > Res_YawRateMeasurementModel.MaximumCount) ? Res_YawRateMeasurementModel.CurrentCount : Res_YawRateMeasurementModel.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_YawRateMeasurementModel;
	return instance;
}

struct YawRateMeasurementModel *Assign_YawRateMeasurementModel(struct YawRateMeasurementModel **const left, struct YawRateMeasurementModel *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base)->ReferenceCount++;
	}
	RemRef_YawRateMeasurementModel(*left);
	*left = right;
	return right;
}

void MeasuremenModel_1_set_Condition(struct MeasurementModel_1 *const self, struct CTRASpace *value)
{
	(void)Assign_CTRASpace(&self->Condition, value);
}

static void MeasurementModel_1_ctor(struct MeasurementModel_1 *const self, struct PositiveDefiniteMatrix_1 *measurementNoiseCovariance)
{
	struct CTRASpace *ctraSpace = NULL;

	if (!(measurementNoiseCovariance != NULL))
	{
		abort();
	}
	Object_ctor(&self->base);
	ctraSpace = New_CTRASpace();
	CTRASpace_ctor(ctraSpace);
	MeasuremenModel_1_set_Condition(self, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	(void)Assign_PositiveDefiniteMatrix_1(&self->_measurementNoiseCovariance, measurementNoiseCovariance);
}

static void MeasurementModel_5_ctor(struct MeasurementModel_5 *const self, struct PositiveDefiniteMatrix_1 *measurementNoiseCovariance)
{
	MeasurementModel_1_ctor(&self->base, measurementNoiseCovariance);
}

void YawRateMeasMode_set_YawRateBias(struct YawRateMeasurementModel *const self, float64_t value)
{
	self->YawRateBias = value;
}

void YawRateMeasurementModel_ctor(struct YawRateMeasurementModel *const self, struct PositiveDefiniteMatrix_1 *measurementNoiseCovariance)
{
	MeasurementModel_5_ctor(&self->base, measurementNoiseCovariance);
	YawRateMeasMode_set_YawRateBias(self, 0.0);
}

static void Gaussian_6_cctor(void)
{
	struct CTRASpace *ctraSpace = NULL;

	ctraSpace = New_CTRASpace();
	CTRASpace_ctor(ctraSpace);
	(void)Assign_CTRASpace(&Gaussian_6_EmptySpace, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
}

static void RemRef_Gaussian_4(struct Gaussian_4 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Gaussian_4.CurrentCount--;
		Res_Gaussian_4.Next[Res_Gaussian_4.CurrentCount] = self;
		Del_Gaussian_4(self);
	}
}

struct Gaussian_4 *New_Gaussian_4(void)
{
	static struct Gaussian_4 const Default_Gaussian_4 = { 1 };
	struct Gaussian_4 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Gaussian_4.CurrentCount == RC_Gaussian_4)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Gaussian_4.Next[Res_Gaussian_4.CurrentCount];
	Res_Gaussian_4.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Gaussian_4.MaximumCount = (Res_Gaussian_4.CurrentCount > Res_Gaussian_4.MaximumCount) ? Res_Gaussian_4.CurrentCount : Res_Gaussian_4.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Gaussian_4;
	return instance;
}

struct Gaussian_4 *Assign_Gaussian_4(struct Gaussian_4 **const left, struct Gaussian_4 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Gaussian_4(*left);
	*left = right;
	return right;
}

static void Gaussian_4_set_Expectation(struct Gaussian_4 *const self, struct CTRASpace *value)
{
	(void)Assign_CTRASpace(&self->Expectation, value);
}

static void RemRef_PositiveDefiniteMatrix_6(struct PositiveDefiniteMatrix_6 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base)->ReferenceCount--;
	if ((&self->base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_PositiveDefiniteMatrix_6.CurrentCount--;
		Res_PositiveDefiniteMatrix_6.Next[Res_PositiveDefiniteMatrix_6.CurrentCount] = self;
		Del_PositiveDefiniteMatrix_6(self);
	}
}

struct PositiveDefiniteMatrix_6 *New_PositiveDefiniteMatrix_6(void)
{
	static struct PositiveDefiniteMatrix_6 const Default_PositivDefiniteMatrix_6 = { 1 };
	struct PositiveDefiniteMatrix_6 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_PositiveDefiniteMatrix_6.CurrentCount == RC_PositiveDefiniteMatrix_6)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_PositiveDefiniteMatrix_6.Next[Res_PositiveDefiniteMatrix_6.CurrentCount];
	Res_PositiveDefiniteMatrix_6.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_PositiveDefiniteMatrix_6.MaximumCount = (Res_PositiveDefiniteMatrix_6.CurrentCount > Res_PositiveDefiniteMatrix_6.MaximumCount) ? Res_PositiveDefiniteMatrix_6.CurrentCount : Res_PositiveDefiniteMatrix_6.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_PositivDefiniteMatrix_6;
	return instance;
}

struct PositiveDefiniteMatrix_6 *Assign_PositiveDefiniteMatrix_6(struct PositiveDefiniteMatrix_6 **const left, struct PositiveDefiniteMatrix_6 *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base)->ReferenceCount++;
	}
	RemRef_PositiveDefiniteMatrix_6(*left);
	*left = right;
	return right;
}

void Matrix_6_ctor(struct Matrix_6 *const self)
{
	struct CTRASpace *ctraSpace = NULL;
	struct CTRASpace *ctraSpace_1 = NULL;

	ctraSpace = New_CTRASpace();
	CTRASpace_ctor(ctraSpace);
	(void)Assign_CTRASpace(&self->EmptyRowSpace, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	ctraSpace_1 = New_CTRASpace();
	CTRASpace_ctor(ctraSpace_1);
	(void)Assign_CTRASpace(&self->EmptyColumnSpace, ctraSpace_1);
	(void)Assign_CTRASpace(&ctraSpace_1, NULL);
	Object_ctor(&self->base);
	self->Columns = (&self->EmptyRowSpace->base.base)->Dimensions;
	self->Rows = (&self->EmptyColumnSpace->base.base)->Dimensions;
}

void SquareMatrix_6_ctor(struct SquareMatrix_6 *const self)
{
	struct CTRASpace *ctraSpace = NULL;

	ctraSpace = New_CTRASpace();
	CTRASpace_ctor(ctraSpace);
	(void)Assign_CTRASpace(&self->EmptySpace, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	Matrix_6_ctor(&self->base);
	self->Dimensions = (&self->base)->Rows;
}

void PositiveDefiniteMatrix_6_ctor(struct PositiveDefiniteMatrix_6 *const self)
{
	SquareMatrix_6_ctor(&self->base);
}

static void Gaussian_4_ResetCachedValues(struct Gaussian_4 *const self)
{
	struct Nullable_2 nullable = { 0 };

	self->NormalizationFactor = nullable;
}

static void Gaussian_4_set_Covariance(struct Gaussian_4 *const self, struct PositiveDefiniteMatrix_6 *value)
{
	Gaussian_4_ResetCachedValues(self);
	(void)Assign_PositiveDefiniteMatrix_6(&self->covariance, value);
}

void Gaussian_4_ctor(struct Gaussian_4 *const self)
{
	struct CTRASpace *ctraSpace = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix = NULL;

	Object_ctor(&self->base);
	self->_dimensions = (&Gaussian_6_EmptySpace->base.base)->Dimensions;
	ctraSpace = New_CTRASpace();
	CTRASpace_ctor(ctraSpace);
	Gaussian_4_set_Expectation(self, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_6();
	PositiveDefiniteMatrix_6_ctor(positiveDefiniteMatrix);
	Gaussian_4_set_Covariance(self, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix, NULL);
}

struct PositiveDefiniteMatrix_6 *Gaussian_4_get_Covariance(struct Gaussian_4 *const self)
{
	struct PositiveDefiniteMatrix_6 *result = NULL;

	Gaussian_4_ResetCachedValues(self);
	(void)Assign_PositiveDefiniteMatrix_6(&result, self->covariance);
	return result;
}

static void Del_float64_t_1D_36(struct float64_t_1D_36 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_1D_36(struct float64_t_1D_36 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_1D_36.CurrentCount--;
		Res_float64_t_1D_36.Next[Res_float64_t_1D_36.CurrentCount] = self;
		Del_float64_t_1D_36(self);
	}
}

struct float64_t_1D_36 *New_float64_t_1D_36(void)
{
	static struct float64_t_1D_36 const Default_float64_t_1D_36 = { 1 };
	struct float64_t_1D_36 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_1D_36.CurrentCount == RC_float64_t_1D_36)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_1D_36.Next[Res_float64_t_1D_36.CurrentCount];
	Res_float64_t_1D_36.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_1D_36.MaximumCount = (Res_float64_t_1D_36.CurrentCount > Res_float64_t_1D_36.MaximumCount) ? Res_float64_t_1D_36.CurrentCount : Res_float64_t_1D_36.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_1D_36;
	return instance;
}

struct float64_t_1D_36 *Assign_float64_t_1D_36(struct float64_t_1D_36 **const left, struct float64_t_1D_36 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_1D_36(*left);
	*left = right;
	return right;
}

static void RemRef_MatrixData_11(struct MatrixData_11 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_11.CurrentCount--;
		Res_MatrixData_11.Next[Res_MatrixData_11.CurrentCount] = self;
		Del_MatrixData_11(self);
	}
}

struct MatrixData_11 *New_MatrixData_11(void)
{
	static struct MatrixData_11 const Default_MatrixData_11 = { 1 };
	struct MatrixData_11 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_11.CurrentCount == RC_MatrixData_11)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_11.Next[Res_MatrixData_11.CurrentCount];
	Res_MatrixData_11.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_11.MaximumCount = (Res_MatrixData_11.CurrentCount > Res_MatrixData_11.MaximumCount) ? Res_MatrixData_11.CurrentCount : Res_MatrixData_11.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_11;
	return instance;
}

struct MatrixData_11 *Assign_MatrixData_11(struct MatrixData_11 **const left, struct MatrixData_11 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_11(*left);
	*left = right;
	return right;
}

void MatrixData_11_ctor(struct MatrixData_11 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_36 *array = NULL;

	assert(rows == ((int32_t)6));
	assert(columns == ((int32_t)6));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_36();
	(void)Assign_float64_t_1D_36(&self->_data, array);
	(void)Assign_float64_t_1D_36(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct MatrixData_11 *MatrixData_20_Zeros_8(int32_t rows, int32_t columns)
{
	struct MatrixData_11 *result = NULL;
	struct MatrixData_11 *matrixData = NULL;

	assert(rows == ((int32_t)6));
	assert(columns == ((int32_t)6));
	matrixData = New_MatrixData_11();
	MatrixData_11_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData_11(&result, matrixData);
	(void)Assign_MatrixData_11(&matrixData, NULL);
	return result;
}

struct MatrixData_11 *Matrix_6_get_MatrixData(struct Matrix_6 *const self)
{
	struct MatrixData_11 *result = NULL;

	if (!(self->_matrix != NULL))
	{
		struct MatrixData_11 *matrixData = NULL;

		matrixData = MatrixData_20_Zeros_8(self->Rows, self->Columns);
		(void)Assign_MatrixData_11(&self->_matrix, matrixData);
		(void)Assign_MatrixData_11(&matrixData, NULL);
	}
	(void)Assign_MatrixData_11(&result, self->_matrix);
	return result;
}

struct float64_t_1D_36 *MatrixData_11_get_DataReference(struct MatrixData_11 *const self)
{
	struct float64_t_1D_36 *result = NULL;

	(void)Assign_float64_t_1D_36(&result, self->_data);
	return result;
}

static void MatrixData_11_SetValueFast(struct MatrixData_11 *const self, float64_t value, int32_t row, int32_t column)
{
	struct float64_t_1D_36 *array = NULL;

	array = MatrixData_11_get_DataReference(self);
	array->Elements[(column * self->Rows) + row] = value;
	(void)Assign_float64_t_1D_36(&array, NULL);
}

void MatrixData_11_set_Item(struct MatrixData_11 *const self, int32_t row, int32_t column, float64_t value)
{
	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	MatrixData_11_SetValueFast(self, value, row, column);
}

static void Matrix_6_MatrixChanged(struct Matrix_6 *const self)
{
	(void)Assign_MatrixData(&self->CachedTranspose, NULL);
}

static void SquareMatrix_6_MatrixChanged(struct SquareMatrix_6 *const self)
{
	struct Nullable_2 nullable = { 0 };

	Matrix_6_MatrixChanged(&self->base);
	self->CachedDeterminant = nullable;
}

static void PositDefinMatrix_6_MatrixChange(struct PositiveDefiniteMatrix_6 *const self)
{
	SquareMatrix_6_MatrixChanged(&self->base);
	(void)Assign_MatrixData(&self->CachedCholeskyDecomposition, NULL);
	(void)Assign_MatrixData(&self->CachedInverse, NULL);
}

void PositivDefinitMatrix_6_set_Item(struct PositiveDefiniteMatrix_6 *const self, int32_t row, int32_t column, float64_t value)
{
	struct MatrixData_11 *matrixData = NULL;
	struct MatrixData_11 *matrixData_1 = NULL;

	if (!((row >= ((int32_t)0)) && (row < (&self->base.base)->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < (&self->base.base)->Columns)))
	{
		abort();
	}
	matrixData = Matrix_6_get_MatrixData(&self->base.base);
	MatrixData_11_set_Item(matrixData, row, column, value);
	(void)Assign_MatrixData_11(&matrixData, NULL);
	matrixData_1 = Matrix_6_get_MatrixData(&self->base.base);
	MatrixData_11_set_Item(matrixData_1, column, row, value);
	(void)Assign_MatrixData_11(&matrixData_1, NULL);
	PositDefinMatrix_6_MatrixChange(self);
}

void EgoMotionFilter_Reset(struct EgoMotionFilter *const self)
{
	struct Nullable_1 nullable = { 0 };
	struct Gaussian_4 *gaussian = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_1 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_2 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_3 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_4 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_5 = NULL;

	self->_lastCorrectionTime = nullable;
	self->_isVelocityFiltered = false;
	self->_isYawRateFiltered = false;
	gaussian = New_Gaussian_4();
	Gaussian_4_ctor(gaussian);
	(void)Assign_Gaussian_4(&self->_state, gaussian);
	(void)Assign_Gaussian_4(&gaussian, NULL);
	positiveDefiniteMatrix = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix, ((int32_t)0), ((int32_t)0), 0.001);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix, NULL);
	positiveDefiniteMatrix_1 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_1, ((int32_t)1), ((int32_t)1), 0.001);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_1, NULL);
	positiveDefiniteMatrix_2 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_2, ((int32_t)2), ((int32_t)2), 0.001);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_2, NULL);
	positiveDefiniteMatrix_3 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_3, ((int32_t)3), ((int32_t)3), 1000.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_3, NULL);
	positiveDefiniteMatrix_4 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_4, ((int32_t)4), ((int32_t)4), 1000.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_4, NULL);
	positiveDefiniteMatrix_5 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_5, ((int32_t)5), ((int32_t)5), 1000.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_5, NULL);
}

void EgoMotionFilter_ctor(struct EgoMotionFilter *const self)
{
	struct float64_t_1D_2 *array = NULL;
	struct PositiveDefiniteMatrix_4 *positiveDefiniteMatrix = NULL;
	struct CTRAModel *ctraModel = NULL;
	struct float64_t_1D_1 *array_1 = NULL;
	struct PositiveDefiniteMatrix *positiveDefiniteMatrix_1 = NULL;
	struct VelocityMeasurementModel *velocityMeasurementModel = NULL;
	struct float64_t_1D_1 *array_2 = NULL;
	struct PositiveDefiniteMatrix_1 *positiveDefiniteMatrix_2 = NULL;
	struct YawRateMeasurementModel *yawRateMeasurementModel = NULL;
	struct Object *object = NULL;

	array = New_float64_t_1D_2();
	array->Elements[((int32_t)0)] = 2.25;
	array->Elements[((int32_t)1)] = 0.0841;
	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_4();
	PositiveDefiniteMatrix_4_ctor(positiveDefiniteMatrix, array);
	ctraModel = New_CTRAModel();
	CTRAModel_ctor(ctraModel, positiveDefiniteMatrix);
	(void)Assign_CTRAModel(&self->_systemModel, ctraModel);
	(void)Assign_float64_t_1D_2(&array, NULL);
	(void)Assign_PositiveDefiniteMatrix_4(&positiveDefiniteMatrix, NULL);
	(void)Assign_CTRAModel(&ctraModel, NULL);
	array_1 = New_float64_t_1D_1();
	array_1->Elements[((int32_t)0)] = 0.010000000000000002;
	positiveDefiniteMatrix_1 = New_PositiveDefiniteMatrix();
	PositiveDefiniteMatrix_ctor(positiveDefiniteMatrix_1, array_1);
	velocityMeasurementModel = New_VelocityMeasurementModel();
	VelocityMeasurementModel_ctor(velocityMeasurementModel, positiveDefiniteMatrix_1);
	(void)Assign_VelocityMeasurementModel(&self->_velocityMeasurementModel, velocityMeasurementModel);
	(void)Assign_float64_t_1D_1(&array_1, NULL);
	(void)Assign_PositiveDefiniteMatrix(&positiveDefiniteMatrix_1, NULL);
	(void)Assign_VelocityMeasurementModel(&velocityMeasurementModel, NULL);
	array_2 = New_float64_t_1D_1();
	array_2->Elements[((int32_t)0)] = 0.0004;
	positiveDefiniteMatrix_2 = New_PositiveDefiniteMatrix_1();
	PositiveDefiniteMatrix_1_ctor(positiveDefiniteMatrix_2, array_2);
	yawRateMeasurementModel = New_YawRateMeasurementModel();
	YawRateMeasurementModel_ctor(yawRateMeasurementModel, positiveDefiniteMatrix_2);
	(void)Assign_YawRateMeasurementModel(&self->_yawRateMeasurementModel, yawRateMeasurementModel);
	(void)Assign_float64_t_1D_1(&array_2, NULL);
	(void)Assign_PositiveDefiniteMatrix_1(&positiveDefiniteMatrix_2, NULL);
	(void)Assign_YawRateMeasurementModel(&yawRateMeasurementModel, NULL);
	object = New_Object();
	Object_ctor(object);
	(void)Assign_Object(&self->_stateLock, object);
	(void)Assign_Object(&object, NULL);
	Object_ctor(&self->base);
	EgoMotionFilter_Reset(self);
}

void Tracking_Initialize(struct Tracking *const self)
{
	struct EgoMotionFilter *egoMotionFilter = NULL;
	struct StaticList_27 *staticList = NULL;
	struct Nullable_1 nullable = { 0 };

	egoMotionFilter = New_EgoMotionFilter();
	EgoMotionFilter_ctor(egoMotionFilter);
	(void)Assign_EgoMotionFilter(&self->_egoMotionFilter, egoMotionFilter);
	(void)Assign_EgoMotionFilter(&egoMotionFilter, NULL);
	staticList = New_StaticList_27();
	StaticList_27_ctor(staticList, ((int32_t)15));
	(void)Assign_StaticList_27(&self->_tracks, staticList);
	(void)Assign_StaticList_27(&staticList, NULL);
	self->_lastUpdateTime = nullable;
}

bool_t Nullable_1_get_HasValue(struct Nullable_1 *const self)
{
	return (*self).hasValue;
}

static void RemRef_StaticListEnumerator_15(struct StaticListEnumerator_15 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListEnumerator_15.CurrentCount--;
		Res_StaticListEnumerator_15.Next[Res_StaticListEnumerator_15.CurrentCount] = self;
		Del_StaticListEnumerator_15(self);
	}
}

struct StaticListEnumerator_15 *New_StaticListEnumerator_15(void)
{
	static struct StaticListEnumerator_15 const Default_StaticListEnumerator_15 = { 1 };
	struct StaticListEnumerator_15 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListEnumerator_15.CurrentCount == RC_StaticListEnumerator_15)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListEnumerator_15.Next[Res_StaticListEnumerator_15.CurrentCount];
	Res_StaticListEnumerator_15.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListEnumerator_15.MaximumCount = (Res_StaticListEnumerator_15.CurrentCount > Res_StaticListEnumerator_15.MaximumCount) ? Res_StaticListEnumerator_15.CurrentCount : Res_StaticListEnumerator_15.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListEnumerator_15;
	return instance;
}

struct StaticListEnumerator_15 *Assign_StaticListEnumerator_15(struct StaticListEnumerator_15 **const left, struct StaticListEnumerator_15 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListEnumerator_15(*left);
	*left = right;
	return right;
}

void StaticListEnumerator_15_ctor(struct StaticListEnumerator_15 *const self, struct StaticList_27 *list)
{
	self->_current = ((int32_t)-1);
	Object_ctor(&self->base);
	(void)Assign_StaticList_27(&self->_list, list);
}

struct StaticListEnumerator_15 *StaticList_27_GetEnumerator(struct StaticList_27 *const self)
{
	struct StaticListEnumerator_15 *result = NULL;
	struct StaticListEnumerator_15 *staticListEnumerator = NULL;

	staticListEnumerator = New_StaticListEnumerator_15();
	StaticListEnumerator_15_ctor(staticListEnumerator, self);
	(void)Assign_StaticListEnumerator_15(&result, staticListEnumerator);
	(void)Assign_StaticListEnumerator_15(&staticListEnumerator, NULL);
	return result;
}

int32_t StaticList_27_get_Count(struct StaticList_27 *const self)
{
	return self->Count;
}

bool_t StaticListEnumerato_15_MoveNext(struct StaticListEnumerator_15 *const self)
{
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	self->_current = self->_current + ((int32_t)1);
	int32 = self->_current;
	int32_1 = StaticList_27_get_Count(self->_list);
	return int32 != int32_1;
}

struct TrackWithMeasurements *StaticList_27_get_Item(struct StaticList_27 *const self, int32_t index)
{
	struct TrackWithMeasurements *result = NULL;

	(void)Assign_TrackWithMeasurements(&result, self->_items->Elements[index]);
	return result;
}

struct TrackWithMeasurements *StaticListEnumer_15_get_Current(struct StaticListEnumerator_15 *const self)
{
	struct TrackWithMeasurements *result = NULL;
	struct TrackWithMeasurements *trackWithMeasurements = NULL;

	trackWithMeasurements = StaticList_27_get_Item(self->_list, self->_current);
	(void)Assign_TrackWithMeasurements(&result, trackWithMeasurements);
	(void)Assign_TrackWithMeasurements(&trackWithMeasurements, NULL);
	return result;
}

struct Existence *GaussianTrack_get_Existence(struct GaussianTrack *const self)
{
	struct Existence *result = NULL;

	(void)Assign_Existence(&result, self->Existence);
	return result;
}

float64_t TwoPointDistributio_get_LogOdds(struct TwoPointDistribution *const self)
{
	float64_t result = 0.0;
	struct StaticList_15 *staticList = NULL;
	struct SampleProbabilityPair_2 *sampleProbabilityPair = NULL;
	float64_t double_ = 0.0;
	struct StaticList_15 *staticList_1 = NULL;
	struct SampleProbabilityPair_2 *sampleProbabilityPair_1 = NULL;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;

	if (!!self->_useLogOdds)
	{
		return self->_logOdds;
	}
	staticList = SampleSet_2_get_Samples(&self->base);
	sampleProbabilityPair = StaticList_15_get_Item(staticList, ((int32_t)0));
	double_ = SampleProbabiPair_2_get_Probabi(sampleProbabilityPair);
	staticList_1 = SampleSet_2_get_Samples(&self->base);
	sampleProbabilityPair_1 = StaticList_15_get_Item(staticList_1, ((int32_t)1));
	double__1 = SampleProbabiPair_2_get_Probabi(sampleProbabilityPair_1);
	double__2 = Math_Log(double_ / double__1);
	result = double__2;
	(void)Assign_StaticList_15(&staticList, NULL);
	(void)Assign_SampleProbabilityPair_2(&sampleProbabilityPair, NULL);
	(void)Assign_StaticList_15(&staticList_1, NULL);
	(void)Assign_SampleProbabilityPair_2(&sampleProbabilityPair_1, NULL);
	return result;
}

void Existence_ctor_2(struct Existence *const self, struct TwoPointDistribution *twoPointDistribution)
{
	float64_t double_ = 0.0;

	Existence_ctor(self);
	double_ = TwoPointDistributio_get_LogOdds(twoPointDistribution);
	TwoPointDistributio_set_LogOdds(&self->base, double_);
}

struct Gaussian_5 *GaussianTrack_get_State(struct GaussianTrack *const self)
{
	struct Gaussian_5 *result = NULL;

	(void)Assign_Gaussian_5(&result, self->State);
	return result;
}

struct CASpace *Gaussian_5_get_Expectation(struct Gaussian_5 *const self)
{
	struct CASpace *result = NULL;

	(void)Assign_CASpace(&result, self->Expectation);
	return result;
}

struct PositiveDefiniteMatrix_7 *Gaussian_5_get_Covariance(struct Gaussian_5 *const self)
{
	struct PositiveDefiniteMatrix_7 *result = NULL;

	Gaussian_5_ResetCachedValues(self);
	(void)Assign_PositiveDefiniteMatrix_7(&result, self->covariance);
	return result;
}

struct Gaussian_5 *Gaussian_5_Clone(struct Gaussian_5 *const self)
{
	struct Gaussian_5 *result = NULL;
	struct CASpace *caSpace = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix = NULL;
	struct Gaussian_5 *gaussian = NULL;

	caSpace = Gaussian_5_get_Expectation(self);
	positiveDefiniteMatrix = Gaussian_5_get_Covariance(self);
	gaussian = New_Gaussian_5();
	Gaussian_5_ctor(gaussian, caSpace, positiveDefiniteMatrix);
	(void)Assign_Gaussian_5(&result, gaussian);
	(void)Assign_CASpace(&caSpace, NULL);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix, NULL);
	(void)Assign_Gaussian_5(&gaussian, NULL);
	return result;
}

uint64_t GaussianTrack_get_ID(struct GaussianTrack *const self)
{
	return self->ID;
}

struct Obstacle *TrackWithMeasureme_get_Obstacle(struct TrackWithMeasurements *const self)
{
	struct Obstacle *result = NULL;

	(void)Assign_Obstacle(&result, self->Obstacle);
	return result;
}

struct Object_1 *TrackWithMeasu_get_ARS308Object(struct TrackWithMeasurements *const self)
{
	struct Object_1 *result = NULL;

	(void)Assign_Object_1(&result, self->ARS308Object);
	return result;
}

static void StaticList_27_CheckCount(struct StaticList_27 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_27_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_27_set_Count(struct StaticList_27 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_27_Add(struct StaticList_27 *const self, struct TrackWithMeasurements *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_27_CheckCount(self);
	int32 = StaticList_27_get_Count(self);
	count = int32;
	(void)Assign_TrackWithMeasurements(&self->_items->Elements[count], value);
	int32_1 = StaticList_27_get_Count(self);
	StaticList_27_set_Count(self, int32_1 + ((int32_t)1));
}

void StaticListEnumerator_15_Dispose(struct StaticListEnumerator_15 *const self)
{
}

struct StaticList_27 *Tracking_GetTracks(struct Tracking *const self)
{
	bool_t s__LockTaken0 = false;
	struct Object *CS_2_0001 = NULL;
	struct Object *object = NULL;
	struct StaticList_27 *trackList = NULL;
	struct StaticList_27 *staticList = NULL;
	struct Tracking *tracking = NULL;
	struct StaticList_27 *CS_1_0000 = NULL;
	struct StaticListEnumerator_15 *CS_5_0002 = NULL;
	struct TrackWithMeasurements *track = NULL;
	struct Existence *clonedExistence = NULL;
	bool_t boolean = false;
	struct StaticList_27 *result = NULL;

	s__LockTaken0 = false;
	(void)Assign_Object(&object, Assign_Object(&CS_2_0001, self->_tracksLock));
	s__LockTaken0 = true;
	(void)Assign_Object(&object, NULL);
	staticList = New_StaticList_27();
	StaticList_27_ctor(staticList, ((int32_t)15));
	(void)Assign_StaticList_27(&trackList, staticList);
	(void)Assign_StaticList_27(&staticList, NULL);
	(void)Assign_Tracking(&tracking, self);
	boolean = Nullable_1_get_HasValue(&tracking->_lastUpdateTime);
	if (!boolean)
	{
		(void)Assign_StaticList_27(&CS_1_0000, NULL);
	}
	else
	{
		struct StaticListEnumerator_15 *staticListEnumerator = NULL;
		bool_t boolean_1 = false;

		staticListEnumerator = StaticList_27_GetEnumerator(self->_tracks);
		(void)Assign_StaticListEnumerator_15(&CS_5_0002, staticListEnumerator);
		(void)Assign_StaticListEnumerator_15(&staticListEnumerator, NULL);
		boolean_1 = StaticListEnumerato_15_MoveNext(CS_5_0002);
		while (boolean_1)
		{
			struct TrackWithMeasurements *trackWithMeasurements = NULL;
			struct Existence *existence = NULL;
			struct Existence *existence_1 = NULL;
			struct StaticList_27 *staticList_1 = NULL;
			struct Gaussian_5 *gaussian = NULL;
			struct Gaussian_5 *gaussian_1 = NULL;
			struct Gaussian_5 *gaussian_2 = NULL;
			struct Existence *existence_2 = NULL;
			uint64_t uInt64 = ((uint64_t)0u);
			struct Obstacle *obstacle = NULL;
			struct Object_1 *object_1 = NULL;
			struct TrackWithMeasurements *trackWithMeasurements_1 = NULL;

			trackWithMeasurements = StaticListEnumer_15_get_Current(CS_5_0002);
			(void)Assign_TrackWithMeasurements(&track, trackWithMeasurements);
			(void)Assign_TrackWithMeasurements(&trackWithMeasurements, NULL);
			existence = GaussianTrack_get_Existence(&track->base);
			existence_1 = New_Existence();
			Existence_ctor_2(existence_1, &existence->base);
			(void)Assign_Existence(&clonedExistence, existence_1);
			(void)Assign_Existence(&existence, NULL);
			(void)Assign_Existence(&existence_1, NULL);
			(void)Assign_StaticList_27(&staticList_1, trackList);
			gaussian = GaussianTrack_get_State(&track->base);
			gaussian_1 = Gaussian_5_Clone(gaussian);
			(void)Assign_Gaussian_5(&gaussian_2, gaussian_1);
			(void)Assign_Existence(&existence_2, clonedExistence);
			uInt64 = GaussianTrack_get_ID(&track->base);
			obstacle = TrackWithMeasureme_get_Obstacle(track);
			object_1 = TrackWithMeasu_get_ARS308Object(track);
			trackWithMeasurements_1 = New_TrackWithMeasurements();
			TrackWithMeasurements_ctor(trackWithMeasurements_1, gaussian_2, existence_2, uInt64, obstacle, object_1);
			StaticList_27_Add(staticList_1, trackWithMeasurements_1);
			(void)Assign_StaticList_27(&staticList_1, NULL);
			(void)Assign_Gaussian_5(&gaussian, NULL);
			(void)Assign_Gaussian_5(&gaussian_1, NULL);
			(void)Assign_Gaussian_5(&gaussian_2, NULL);
			(void)Assign_Existence(&existence_2, NULL);
			(void)Assign_Obstacle(&obstacle, NULL);
			(void)Assign_Object_1(&object_1, NULL);
			(void)Assign_TrackWithMeasurements(&trackWithMeasurements_1, NULL);
			boolean_1 = StaticListEnumerato_15_MoveNext(CS_5_0002);
		}
		if (!!(CS_5_0002 != NULL))
		{
			StaticListEnumerator_15_Dispose(CS_5_0002);
		}
		(void)Assign_StaticList_27(&CS_1_0000, trackList);
	}
	(void)Assign_StaticList_27(&result, CS_1_0000);
	RemRef_Object(CS_2_0001);
	RemRef_StaticList_27(trackList);
	RemRef_Tracking(tracking);
	RemRef_StaticList_27(CS_1_0000);
	RemRef_StaticListEnumerator_15(CS_5_0002);
	RemRef_TrackWithMeasurements(track);
	RemRef_Existence(clonedExistence);
	return result;
}

void Nullable_1_ctor(struct Nullable_1 *const self, struct DateTime value)
{
	(*self).value = value;
	(*self).hasValue = true;
}

static void ThrowHelpe_ThrowInvalOperaExcep(ExceptionResource resource)
{
	abort();
}

struct DateTime Nullable_1_get_Value(struct Nullable_1 *const self)
{
	if (!(*self).hasValue)
	{
		ThrowHelpe_ThrowInvalOperaExcep(ExcepResou_InvaliOperat_NoValue);
	}
	return (*self).value;
}

static int64_t DateTime_get_InternalTicks(struct DateTime *const self)
{
	return (*self).dateData & ((uint64_t)4611686018427387903u);
}

struct TimeSpan DateTime_1_op_Subtraction(struct DateTime d1, struct DateTime d2)
{
	int64_t int64 = ((int64_t)0);
	int64_t int64_1 = ((int64_t)0);
	struct TimeSpan timeSpan = { 0 };

	int64 = DateTime_get_InternalTicks(&d1);
	int64_1 = DateTime_get_InternalTicks(&d2);
	TimeSpan_ctor(&timeSpan, int64 - int64_1);
	return timeSpan;
}

struct CTRASpace *Gaussian_4_get_Expectation(struct Gaussian_4 *const self)
{
	struct CTRASpace *result = NULL;

	(void)Assign_CTRASpace(&result, self->Expectation);
	return result;
}

static void RemRef_SquareMatrix_6(struct SquareMatrix_6 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_SquareMatrix_6.CurrentCount--;
		Res_SquareMatrix_6.Next[Res_SquareMatrix_6.CurrentCount] = self;
		Del_SquareMatrix_6(self);
	}
}

struct SquareMatrix_6 *New_SquareMatrix_6(void)
{
	static struct SquareMatrix_6 const Default_SquareMatrix_6 = { 1 };
	struct SquareMatrix_6 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_SquareMatrix_6.CurrentCount == RC_SquareMatrix_6)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_SquareMatrix_6.Next[Res_SquareMatrix_6.CurrentCount];
	Res_SquareMatrix_6.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_SquareMatrix_6.MaximumCount = (Res_SquareMatrix_6.CurrentCount > Res_SquareMatrix_6.MaximumCount) ? Res_SquareMatrix_6.CurrentCount : Res_SquareMatrix_6.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_SquareMatrix_6;
	return instance;
}

struct SquareMatrix_6 *Assign_SquareMatrix_6(struct SquareMatrix_6 **const left, struct SquareMatrix_6 *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_SquareMatrix_6(*left);
	*left = right;
	return right;
}

struct MatrixData_11 *MatrixData_20_Eye_1(int32_t rows, int32_t columns)
{
	struct MatrixData_11 *matrixData = NULL;
	struct MatrixData_11 *matrixData_1 = NULL;
	int32_t num = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	struct MatrixData_11 *result = NULL;

	assert(rows == ((int32_t)6));
	assert(columns == ((int32_t)6));
	matrixData_1 = New_MatrixData_11();
	MatrixData_11_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_11(&matrixData, matrixData_1);
	(void)Assign_MatrixData_11(&matrixData_1, NULL);
	int32 = Math_Min(rows, columns);
	num = int32;
	i = ((int32_t)0);
	while (i < num)
	{
		MatrixData_11_SetValueFast(matrixData, 1.0, i, i);
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_11(&result, matrixData);
	RemRef_MatrixData_11(matrixData);
	return result;
}

static void Matrix_6_CheckMatrix(struct Matrix_6 *const self)
{
	struct float64_t_1D_36 *dataReference = NULL;
	struct float64_t_1D_36 *array = NULL;
	int32_t i = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);

	array = MatrixData_11_get_DataReference(self->_matrix);
	(void)Assign_float64_t_1D_36(&dataReference, array);
	(void)Assign_float64_t_1D_36(&array, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)36))
	{
		bool_t boolean = false;

		boolean = Double_IsNaN(dataReference->Elements[i]);
		if (!!boolean)
		{
			num = i / self->Rows;
			num2 = i - (num * self->Rows);
			abort();
		}
		i = i + ((int32_t)1);
	}
	RemRef_float64_t_1D_36(dataReference);
}

static void SquareMatrix_6_CheckMatrix(struct SquareMatrix_6 *const self)
{
	struct MatrixData_11 *matrixData = NULL;
	int32_t int32 = ((int32_t)0);
	struct MatrixData_11 *matrixData_1 = NULL;

	Matrix_6_CheckMatrix(&self->base);
	matrixData = Matrix_6_get_MatrixData(&self->base);
	int32 = matrixData->Rows;
	matrixData_1 = Matrix_6_get_MatrixData(&self->base);
	(void)Assign_MatrixData_11(&matrixData, NULL);
	(void)Assign_MatrixData_11(&matrixData_1, NULL);
}

void Matrix_6_set_MatrixData(struct SquareMatrix_6 *const self, struct MatrixData_11 *value)
{
	struct MatrixData_11 *matrix = NULL;

	if (!(value != NULL))
	{
		abort();
	}
	(void)Assign_MatrixData_11(&matrix, (&self->base)->_matrix);
	(void)Assign_MatrixData_11(&(&self->base)->_matrix, value);
	SquareMatrix_6_CheckMatrix(self);
	SquareMatrix_6_MatrixChanged(self);
	RemRef_MatrixData_11(matrix);
}

struct SquareMatrix_6 *SquareMatrix_8_Eye(void)
{
	struct SquareMatrix_6 *squareMatrix = NULL;
	struct SquareMatrix_6 *squareMatrix_1 = NULL;
	struct SquareMatrix_6 *squareMatrix_2 = NULL;
	struct MatrixData_11 *matrixData = NULL;
	struct SquareMatrix_6 *result = NULL;

	squareMatrix_1 = New_SquareMatrix_6();
	SquareMatrix_6_ctor(squareMatrix_1);
	(void)Assign_SquareMatrix_6(&squareMatrix, squareMatrix_1);
	(void)Assign_SquareMatrix_6(&squareMatrix_1, NULL);
	(void)Assign_SquareMatrix_6(&squareMatrix_2, squareMatrix);
	matrixData = MatrixData_20_Eye_1(squareMatrix->Dimensions, squareMatrix->Dimensions);
	Matrix_6_set_MatrixData(squareMatrix_2, matrixData);
	(void)Assign_SquareMatrix_6(&squareMatrix_2, NULL);
	(void)Assign_MatrixData_11(&matrixData, NULL);
	(void)Assign_SquareMatrix_6(&result, squareMatrix);
	RemRef_SquareMatrix_6(squareMatrix);
	return result;
}

static struct CTRASpace *SystemModel_1_get_Condition(struct SystemModel_1 *const self)
{
	struct CTRASpace *result = NULL;

	(void)Assign_CTRASpace(&result, self->Condition);
	return result;
}

static struct TimeSpan SystemModel_1_get_TimeCondition(struct SystemModel_1 *const self)
{
	return self->TimeCondition;
}

float64_t TimeSpan_get_TotalSeconds(struct TimeSpan *const self)
{
	return (float64_t)(*self)._ticks * 1E-07;
}

static void Space_5_set_LastGetIndex(struct Space_5 *const self, struct Nullable value)
{
	self->LastGetIndex = value;
}

struct MatrixData_9 *Space_5_get_MatrixData(struct Space_5 *const self)
{
	struct MatrixData_9 *result = NULL;

	(void)Assign_MatrixData_9(&result, self->_vector);
	return result;
}

float64_t MatrixData_9_get_Item(struct MatrixData_9 *const self, int32_t index)
{
	if (!((index >= ((int32_t)0)) && (index < ((int32_t)6))))
	{
		abort();
	}
	return self->_data->Elements[index];
}

float64_t Space_5_get_Item(struct Space_5 *const self, int32_t index)
{
	struct Nullable nullable = { 0 };
	float64_t result = 0.0;
	struct MatrixData_9 *matrixData = NULL;
	float64_t double_ = 0.0;

	if (!((index < self->Dimensions) && (index >= ((int32_t)0))))
	{
		abort();
	}
	Nullable_ctor(&nullable, index);
	Space_5_set_LastGetIndex(self, nullable);
	matrixData = Space_5_get_MatrixData(self);
	double_ = MatrixData_9_get_Item(matrixData, index);
	result = double_;
	(void)Assign_MatrixData_9(&matrixData, NULL);
	return result;
}

float64_t CTRASpace_get_G(struct CTRASpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_5_get_Item(&self->base.base, ((int32_t)2));
	return double_;
}

float64_t CTRASpace_get_V(struct CTRASpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_5_get_Item(&self->base.base, ((int32_t)3));
	return double_;
}

float64_t CTRASpace_get_W(struct CTRASpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_5_get_Item(&self->base.base, ((int32_t)5));
	return double_;
}

float64_t CTRASpace_get_A(struct CTRASpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_5_get_Item(&self->base.base, ((int32_t)4));
	return double_;
}

float64_t CTRASpace_get_X(struct CTRASpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_5_get_Item(&self->base.base, ((int32_t)0));
	return double_;
}

void Matrix_6_set_Item(struct SquareMatrix_6 *const self, int32_t row, int32_t column, float64_t value)
{
	struct MatrixData_11 *matrixData = NULL;

	if (!((row >= ((int32_t)0)) && (row < (&self->base)->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < (&self->base)->Columns)))
	{
		abort();
	}
	matrixData = Matrix_6_get_MatrixData(&self->base);
	MatrixData_11_set_Item(matrixData, row, column, value);
	(void)Assign_MatrixData_11(&matrixData, NULL);
	SquareMatrix_6_MatrixChanged(self);
}

void Matrix_6_set_Item_1(struct SquareMatrix_6 *const self, float64_t row, float64_t column, float64_t value)
{
	Matrix_6_set_Item(self, (int32_t)row, (int32_t)column, value);
}

float64_t CTRASpace_get_Y(struct CTRASpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_5_get_Item(&self->base.base, ((int32_t)1));
	return double_;
}

void CTRAModel_FillTransitionMatrix(struct CTRAModel *const self, struct CTRASpace *stateExpectation, struct TimeSpan deltaT, struct SquareMatrix_6 **F)
{
	float64_t T = 0.0;
	float64_t double_ = 0.0;
	float64_t g = 0.0;
	float64_t double__1 = 0.0;
	float64_t v = 0.0;
	float64_t double__2 = 0.0;
	float64_t w = 0.0;
	float64_t double__3 = 0.0;
	float64_t a = 0.0;
	float64_t double__4 = 0.0;
	float64_t sinG = 0.0;
	float64_t double__5 = 0.0;
	float64_t cosG = 0.0;
	float64_t double__6 = 0.0;
	float64_t sin_1 = 0.0;
	float64_t double__7 = 0.0;
	float64_t cos_1 = 0.0;
	float64_t double__8 = 0.0;
	struct SquareMatrix_6 *arg_BF_0 = NULL;
	struct CTRASpace *CS_0_0000 = NULL;
	float64_t arg_BF_1 = 0.0;
	struct CTRASpace *CS_0_0001 = NULL;
	struct SquareMatrix_6 *arg_F2_0 = NULL;
	struct CTRASpace *CS_0_0002 = NULL;
	float64_t arg_F2_1 = 0.0;
	struct CTRASpace *CS_0_0003 = NULL;
	struct SquareMatrix_6 *arg_131_0 = NULL;
	struct CTRASpace *CS_0_0004 = NULL;
	float64_t arg_131_1 = 0.0;
	struct CTRASpace *CS_0_0005 = NULL;
	struct SquareMatrix_6 *arg_177_0 = NULL;
	struct CTRASpace *CS_0_0006 = NULL;
	float64_t arg_177_1 = 0.0;
	struct CTRASpace *CS_0_0007 = NULL;
	struct SquareMatrix_6 *arg_1AA_0 = NULL;
	struct CTRASpace *CS_0_0008 = NULL;
	float64_t arg_1AA_1 = 0.0;
	struct CTRASpace *CS_0_0009 = NULL;
	struct SquareMatrix_6 *arg_1E9_0 = NULL;
	struct CTRASpace *CS_0_0010 = NULL;
	float64_t arg_1E9_1 = 0.0;
	struct CTRASpace *CS_0_0011 = NULL;
	struct SquareMatrix_6 *arg_23A_0 = NULL;
	struct CTRASpace *CS_0_0012 = NULL;
	float64_t arg_23A_1 = 0.0;
	struct CTRASpace *CS_0_0013 = NULL;
	struct SquareMatrix_6 *arg_270_0 = NULL;
	struct CTRASpace *CS_0_0014 = NULL;
	float64_t arg_270_1 = 0.0;
	struct CTRASpace *CS_0_0015 = NULL;
	struct SquareMatrix_6 *arg_2AF_0 = NULL;
	struct CTRASpace *CS_0_0016 = NULL;
	float64_t arg_2AF_1 = 0.0;
	struct CTRASpace *CS_0_0017 = NULL;
	struct SquareMatrix_6 *arg_2FB_0 = NULL;
	struct CTRASpace *CS_0_0018 = NULL;
	float64_t arg_2FB_1 = 0.0;
	struct CTRASpace *CS_0_0019 = NULL;
	struct SquareMatrix_6 *arg_331_0 = NULL;
	struct CTRASpace *CS_0_0020 = NULL;
	float64_t arg_331_1 = 0.0;
	struct CTRASpace *CS_0_0021 = NULL;
	struct SquareMatrix_6 *arg_371_0 = NULL;
	struct CTRASpace *CS_0_0022 = NULL;
	float64_t arg_371_1 = 0.0;
	struct CTRASpace *CS_0_0023 = NULL;
	float64_t double__9 = 0.0;
	struct SquareMatrix_6 *arg_3A1_0 = NULL;
	struct CTRASpace *CS_0_0024 = NULL;
	float64_t arg_3A1_1 = 0.0;
	float64_t double__10 = 0.0;
	struct CTRASpace *CS_0_0025 = NULL;
	struct SquareMatrix_6 *squareMatrix = NULL;
	float64_t double__11 = 0.0;
	float64_t double__12 = 0.0;
	struct SquareMatrix_6 *arg_3D1_0 = NULL;
	struct CTRASpace *CS_0_0026 = NULL;
	float64_t arg_3D1_1 = 0.0;
	float64_t double__13 = 0.0;
	struct CTRASpace *CS_0_0027 = NULL;
	struct SquareMatrix_6 *squareMatrix_1 = NULL;
	float64_t double__14 = 0.0;
	float64_t double__15 = 0.0;

	double_ = TimeSpan_get_TotalSeconds(&deltaT);
	T = double_;
	double__1 = CTRASpace_get_G(stateExpectation);
	g = double__1;
	double__2 = CTRASpace_get_V(stateExpectation);
	v = double__2;
	double__3 = CTRASpace_get_W(stateExpectation);
	w = double__3;
	double__4 = CTRASpace_get_A(stateExpectation);
	a = double__4;
	double__5 = Math_Sin(g);
	sinG = double__5;
	double__6 = Math_Cos(g);
	cosG = double__6;
	double__7 = Math_Sin((w * T) + g);
	sin_1 = double__7;
	double__8 = Math_Cos((w * T) + g);
	cos_1 = double__8;
	double__9 = Math_Abs(w);
	if (!(double__9 >= 1E-07))
	{
		float64_t double__16 = 0.0;
		struct SquareMatrix_6 *squareMatrix_2 = NULL;
		float64_t double__17 = 0.0;
		float64_t double__18 = 0.0;
		float64_t double__19 = 0.0;
		struct SquareMatrix_6 *squareMatrix_3 = NULL;
		float64_t double__20 = 0.0;
		float64_t double__21 = 0.0;
		float64_t double__22 = 0.0;
		struct SquareMatrix_6 *squareMatrix_4 = NULL;
		float64_t double__23 = 0.0;
		float64_t double__24 = 0.0;
		float64_t double__25 = 0.0;
		struct SquareMatrix_6 *squareMatrix_5 = NULL;
		float64_t double__26 = 0.0;
		float64_t double__27 = 0.0;
		float64_t double__28 = 0.0;
		struct SquareMatrix_6 *squareMatrix_6 = NULL;
		float64_t double__29 = 0.0;
		float64_t double__30 = 0.0;
		float64_t double__31 = 0.0;
		struct SquareMatrix_6 *squareMatrix_7 = NULL;
		float64_t double__32 = 0.0;
		float64_t double__33 = 0.0;

		(void)Assign_SquareMatrix_6(&arg_BF_0, *F);
		(void)Assign_CTRASpace(&CS_0_0000, CTRAModel_1_S);
		double__16 = CTRASpace_get_X(CS_0_0000);
		arg_BF_1 = double__16;
		(void)Assign_CTRASpace(&CS_0_0001, CTRAModel_1_S);
		(void)Assign_SquareMatrix_6(&squareMatrix_2, arg_BF_0);
		double__17 = arg_BF_1;
		double__18 = CTRASpace_get_G(CS_0_0001);
		Matrix_6_set_Item_1(squareMatrix_2, double__17, double__18, -((((a * T) * T) / 2.0) + (v * T)) * sinG);
		(void)Assign_SquareMatrix_6(&squareMatrix_2, NULL);
		(void)Assign_SquareMatrix_6(&arg_F2_0, *F);
		(void)Assign_CTRASpace(&CS_0_0002, CTRAModel_1_S);
		double__19 = CTRASpace_get_X(CS_0_0002);
		arg_F2_1 = double__19;
		(void)Assign_CTRASpace(&CS_0_0003, CTRAModel_1_S);
		(void)Assign_SquareMatrix_6(&squareMatrix_3, arg_F2_0);
		double__20 = arg_F2_1;
		double__21 = CTRASpace_get_V(CS_0_0003);
		Matrix_6_set_Item_1(squareMatrix_3, double__20, double__21, T * cosG);
		(void)Assign_SquareMatrix_6(&squareMatrix_3, NULL);
		(void)Assign_SquareMatrix_6(&arg_131_0, *F);
		(void)Assign_CTRASpace(&CS_0_0004, CTRAModel_1_S);
		double__22 = CTRASpace_get_X(CS_0_0004);
		arg_131_1 = double__22;
		(void)Assign_CTRASpace(&CS_0_0005, CTRAModel_1_S);
		(void)Assign_SquareMatrix_6(&squareMatrix_4, arg_131_0);
		double__23 = arg_131_1;
		double__24 = CTRASpace_get_A(CS_0_0005);
		Matrix_6_set_Item_1(squareMatrix_4, double__23, double__24, ((T * T) / 2.0) * cosG);
		(void)Assign_SquareMatrix_6(&squareMatrix_4, NULL);
		(void)Assign_SquareMatrix_6(&arg_177_0, *F);
		(void)Assign_CTRASpace(&CS_0_0006, CTRAModel_1_S);
		double__25 = CTRASpace_get_Y(CS_0_0006);
		arg_177_1 = double__25;
		(void)Assign_CTRASpace(&CS_0_0007, CTRAModel_1_S);
		(void)Assign_SquareMatrix_6(&squareMatrix_5, arg_177_0);
		double__26 = arg_177_1;
		double__27 = CTRASpace_get_G(CS_0_0007);
		Matrix_6_set_Item_1(squareMatrix_5, double__26, double__27, ((((a * T) * T) / 2.0) + (v * T)) * cosG);
		(void)Assign_SquareMatrix_6(&squareMatrix_5, NULL);
		(void)Assign_SquareMatrix_6(&arg_1AA_0, *F);
		(void)Assign_CTRASpace(&CS_0_0008, CTRAModel_1_S);
		double__28 = CTRASpace_get_Y(CS_0_0008);
		arg_1AA_1 = double__28;
		(void)Assign_CTRASpace(&CS_0_0009, CTRAModel_1_S);
		(void)Assign_SquareMatrix_6(&squareMatrix_6, arg_1AA_0);
		double__29 = arg_1AA_1;
		double__30 = CTRASpace_get_V(CS_0_0009);
		Matrix_6_set_Item_1(squareMatrix_6, double__29, double__30, T * sinG);
		(void)Assign_SquareMatrix_6(&squareMatrix_6, NULL);
		(void)Assign_SquareMatrix_6(&arg_1E9_0, *F);
		(void)Assign_CTRASpace(&CS_0_0010, CTRAModel_1_S);
		double__31 = CTRASpace_get_Y(CS_0_0010);
		arg_1E9_1 = double__31;
		(void)Assign_CTRASpace(&CS_0_0011, CTRAModel_1_S);
		(void)Assign_SquareMatrix_6(&squareMatrix_7, arg_1E9_0);
		double__32 = arg_1E9_1;
		double__33 = CTRASpace_get_A(CS_0_0011);
		Matrix_6_set_Item_1(squareMatrix_7, double__32, double__33, ((T * T) / 2.0) * sinG);
		(void)Assign_SquareMatrix_6(&squareMatrix_7, NULL);
	}
	else
	{
		float64_t double__34 = 0.0;
		struct SquareMatrix_6 *squareMatrix_8 = NULL;
		float64_t double__35 = 0.0;
		float64_t double__36 = 0.0;
		float64_t double__37 = 0.0;
		struct SquareMatrix_6 *squareMatrix_9 = NULL;
		float64_t double__38 = 0.0;
		float64_t double__39 = 0.0;
		float64_t double__40 = 0.0;
		struct SquareMatrix_6 *squareMatrix_10 = NULL;
		float64_t double__41 = 0.0;
		float64_t double__42 = 0.0;
		float64_t double__43 = 0.0;
		struct SquareMatrix_6 *squareMatrix_11 = NULL;
		float64_t double__44 = 0.0;
		float64_t double__45 = 0.0;
		float64_t double__46 = 0.0;
		struct SquareMatrix_6 *squareMatrix_12 = NULL;
		float64_t double__47 = 0.0;
		float64_t double__48 = 0.0;
		float64_t double__49 = 0.0;
		struct SquareMatrix_6 *squareMatrix_13 = NULL;
		float64_t double__50 = 0.0;
		float64_t double__51 = 0.0;

		(void)Assign_SquareMatrix_6(&arg_23A_0, *F);
		(void)Assign_CTRASpace(&CS_0_0012, CTRAModel_1_S);
		double__34 = CTRASpace_get_X(CS_0_0012);
		arg_23A_1 = double__34;
		(void)Assign_CTRASpace(&CS_0_0013, CTRAModel_1_S);
		(void)Assign_SquareMatrix_6(&squareMatrix_8, arg_23A_0);
		double__35 = arg_23A_1;
		double__36 = CTRASpace_get_G(CS_0_0013);
		Matrix_6_set_Item_1(squareMatrix_8, double__35, double__36, (((((a * T) + v) * cos_1) - (v * cosG)) / w) + ((a * (sinG - sin_1)) / (w * w)));
		(void)Assign_SquareMatrix_6(&squareMatrix_8, NULL);
		(void)Assign_SquareMatrix_6(&arg_270_0, *F);
		(void)Assign_CTRASpace(&CS_0_0014, CTRAModel_1_S);
		double__37 = CTRASpace_get_X(CS_0_0014);
		arg_270_1 = double__37;
		(void)Assign_CTRASpace(&CS_0_0015, CTRAModel_1_S);
		(void)Assign_SquareMatrix_6(&squareMatrix_9, arg_270_0);
		double__38 = arg_270_1;
		double__39 = CTRASpace_get_V(CS_0_0015);
		Matrix_6_set_Item_1(squareMatrix_9, double__38, double__39, (sin_1 - sinG) / w);
		(void)Assign_SquareMatrix_6(&squareMatrix_9, NULL);
		(void)Assign_SquareMatrix_6(&arg_2AF_0, *F);
		(void)Assign_CTRASpace(&CS_0_0016, CTRAModel_1_S);
		double__40 = CTRASpace_get_X(CS_0_0016);
		arg_2AF_1 = double__40;
		(void)Assign_CTRASpace(&CS_0_0017, CTRAModel_1_S);
		(void)Assign_SquareMatrix_6(&squareMatrix_10, arg_2AF_0);
		double__41 = arg_2AF_1;
		double__42 = CTRASpace_get_A(CS_0_0017);
		Matrix_6_set_Item_1(squareMatrix_10, double__41, double__42, ((T * sin_1) / w) + ((cos_1 - cosG) / (w * w)));
		(void)Assign_SquareMatrix_6(&squareMatrix_10, NULL);
		(void)Assign_SquareMatrix_6(&arg_2FB_0, *F);
		(void)Assign_CTRASpace(&CS_0_0018, CTRAModel_1_S);
		double__43 = CTRASpace_get_Y(CS_0_0018);
		arg_2FB_1 = double__43;
		(void)Assign_CTRASpace(&CS_0_0019, CTRAModel_1_S);
		(void)Assign_SquareMatrix_6(&squareMatrix_11, arg_2FB_0);
		double__44 = arg_2FB_1;
		double__45 = CTRASpace_get_G(CS_0_0019);
		Matrix_6_set_Item_1(squareMatrix_11, double__44, double__45, (((((a * T) + v) * sin_1) - (v * sinG)) / w) + ((a * (cos_1 - cosG)) / (w * w)));
		(void)Assign_SquareMatrix_6(&squareMatrix_11, NULL);
		(void)Assign_SquareMatrix_6(&arg_331_0, *F);
		(void)Assign_CTRASpace(&CS_0_0020, CTRAModel_1_S);
		double__46 = CTRASpace_get_Y(CS_0_0020);
		arg_331_1 = double__46;
		(void)Assign_CTRASpace(&CS_0_0021, CTRAModel_1_S);
		(void)Assign_SquareMatrix_6(&squareMatrix_12, arg_331_0);
		double__47 = arg_331_1;
		double__48 = CTRASpace_get_V(CS_0_0021);
		Matrix_6_set_Item_1(squareMatrix_12, double__47, double__48, (cosG - cos_1) / w);
		(void)Assign_SquareMatrix_6(&squareMatrix_12, NULL);
		(void)Assign_SquareMatrix_6(&arg_371_0, *F);
		(void)Assign_CTRASpace(&CS_0_0022, CTRAModel_1_S);
		double__49 = CTRASpace_get_Y(CS_0_0022);
		arg_371_1 = double__49;
		(void)Assign_CTRASpace(&CS_0_0023, CTRAModel_1_S);
		(void)Assign_SquareMatrix_6(&squareMatrix_13, arg_371_0);
		double__50 = arg_371_1;
		double__51 = CTRASpace_get_A(CS_0_0023);
		Matrix_6_set_Item_1(squareMatrix_13, double__50, double__51, ((-T * cos_1) / w) + ((sin_1 - sinG) / (w * w)));
		(void)Assign_SquareMatrix_6(&squareMatrix_13, NULL);
	}
	(void)Assign_SquareMatrix_6(&arg_3A1_0, *F);
	(void)Assign_CTRASpace(&CS_0_0024, CTRAModel_1_S);
	double__10 = CTRASpace_get_G(CS_0_0024);
	arg_3A1_1 = double__10;
	(void)Assign_CTRASpace(&CS_0_0025, CTRAModel_1_S);
	(void)Assign_SquareMatrix_6(&squareMatrix, arg_3A1_0);
	double__11 = arg_3A1_1;
	double__12 = CTRASpace_get_W(CS_0_0025);
	Matrix_6_set_Item_1(squareMatrix, double__11, double__12, T);
	(void)Assign_SquareMatrix_6(&squareMatrix, NULL);
	(void)Assign_SquareMatrix_6(&arg_3D1_0, *F);
	(void)Assign_CTRASpace(&CS_0_0026, CTRAModel_1_S);
	double__13 = CTRASpace_get_V(CS_0_0026);
	arg_3D1_1 = double__13;
	(void)Assign_CTRASpace(&CS_0_0027, CTRAModel_1_S);
	(void)Assign_SquareMatrix_6(&squareMatrix_1, arg_3D1_0);
	double__14 = arg_3D1_1;
	double__15 = CTRASpace_get_A(CS_0_0027);
	Matrix_6_set_Item_1(squareMatrix_1, double__14, double__15, T);
	(void)Assign_SquareMatrix_6(&squareMatrix_1, NULL);
	RemRef_SquareMatrix_6(arg_BF_0);
	RemRef_CTRASpace(CS_0_0000);
	RemRef_CTRASpace(CS_0_0001);
	RemRef_SquareMatrix_6(arg_F2_0);
	RemRef_CTRASpace(CS_0_0002);
	RemRef_CTRASpace(CS_0_0003);
	RemRef_SquareMatrix_6(arg_131_0);
	RemRef_CTRASpace(CS_0_0004);
	RemRef_CTRASpace(CS_0_0005);
	RemRef_SquareMatrix_6(arg_177_0);
	RemRef_CTRASpace(CS_0_0006);
	RemRef_CTRASpace(CS_0_0007);
	RemRef_SquareMatrix_6(arg_1AA_0);
	RemRef_CTRASpace(CS_0_0008);
	RemRef_CTRASpace(CS_0_0009);
	RemRef_SquareMatrix_6(arg_1E9_0);
	RemRef_CTRASpace(CS_0_0010);
	RemRef_CTRASpace(CS_0_0011);
	RemRef_SquareMatrix_6(arg_23A_0);
	RemRef_CTRASpace(CS_0_0012);
	RemRef_CTRASpace(CS_0_0013);
	RemRef_SquareMatrix_6(arg_270_0);
	RemRef_CTRASpace(CS_0_0014);
	RemRef_CTRASpace(CS_0_0015);
	RemRef_SquareMatrix_6(arg_2AF_0);
	RemRef_CTRASpace(CS_0_0016);
	RemRef_CTRASpace(CS_0_0017);
	RemRef_SquareMatrix_6(arg_2FB_0);
	RemRef_CTRASpace(CS_0_0018);
	RemRef_CTRASpace(CS_0_0019);
	RemRef_SquareMatrix_6(arg_331_0);
	RemRef_CTRASpace(CS_0_0020);
	RemRef_CTRASpace(CS_0_0021);
	RemRef_SquareMatrix_6(arg_371_0);
	RemRef_CTRASpace(CS_0_0022);
	RemRef_CTRASpace(CS_0_0023);
	RemRef_SquareMatrix_6(arg_3A1_0);
	RemRef_CTRASpace(CS_0_0024);
	RemRef_CTRASpace(CS_0_0025);
	RemRef_SquareMatrix_6(arg_3D1_0);
	RemRef_CTRASpace(CS_0_0026);
	RemRef_CTRASpace(CS_0_0027);
}

struct SquareMatrix_6 *SystemModel_5_get_TransitMatrix(struct CTRAModel *const self)
{
	struct SquareMatrix_6 *result = NULL;
	struct SquareMatrix_6 *squareMatrix = NULL;
	struct CTRASpace *ctraSpace = NULL;
	struct TimeSpan timeSpan = { 0 };
	struct SquareMatrix_6 *result_1 = NULL;

	squareMatrix = SquareMatrix_8_Eye();
	(void)Assign_SquareMatrix_6(&result, squareMatrix);
	(void)Assign_SquareMatrix_6(&squareMatrix, NULL);
	ctraSpace = SystemModel_1_get_Condition(&self->base.base.base);
	timeSpan = SystemModel_1_get_TimeCondition(&self->base.base.base);
	CTRAModel_FillTransitionMatrix(self, ctraSpace, timeSpan, &result);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	(void)Assign_SquareMatrix_6(&result_1, result);
	RemRef_SquareMatrix_6(result);
	return result_1;
}

static void MatrixData_11_ctor_1(struct MatrixData_11 *const self, struct float64_t_1D_36 *data, int32_t rows, int32_t columns, bool_t takeDataOwnership)
{
	assert(rows == ((int32_t)6));
	assert(columns == ((int32_t)6));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	if (!(data != NULL))
	{
		abort();
	}
	if (!!takeDataOwnership)
	{
		(void)Assign_float64_t_1D_36(&self->_data, data);
	}
	else
	{
		struct float64_t_1D_36 *array = NULL;

		array = New_float64_t_1D_36();
		(void)Assign_float64_t_1D_36(&self->_data, array);
		(void)Assign_float64_t_1D_36(&array, NULL);
		(void)memcpy(&self->_data->Elements, &data->Elements, sizeof(float64_t) * ((int32_t)36));
	}
	self->Rows = rows;
	self->Columns = columns;
}

struct MatrixData_11 *MatrixData_11_get_Copy(struct MatrixData_11 *const self)
{
	struct MatrixData_11 *result = NULL;
	struct MatrixData_11 *matrixData = NULL;

	matrixData = New_MatrixData_11();
	MatrixData_11_ctor_1(matrixData, self->_data, self->Rows, self->Columns, false);
	(void)Assign_MatrixData_11(&result, matrixData);
	(void)Assign_MatrixData_11(&matrixData, NULL);
	return result;
}

bool_t Object_2_ReferenceEquals(struct Object *objA, struct Object *objB)
{
	return objA == objB;
}

void LinearAlgebra_MatrixMultiply(struct LinearAlgebra *const self, struct float64_t_1D_36 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_36 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_36 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)36) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)36) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)36) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)36) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)36) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)36) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)36) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)36) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_11 *MatrixMath_Multiply(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_11 *left, struct MatrixData_11 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_11 *matrixData = NULL;
	struct MatrixData_11 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_36 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_36 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_36 *array_2 = NULL;
	struct MatrixData_11 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == false);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Columns;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_11();
	MatrixData_11_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_11(&matrixData, matrixData_1);
	(void)Assign_MatrixData_11(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_11_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_11_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_11_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_36(&array, NULL);
	(void)Assign_float64_t_1D_36(&array_1, NULL);
	(void)Assign_float64_t_1D_36(&array_2, NULL);
	(void)Assign_MatrixData_11(&result, matrixData);
	RemRef_MatrixData_11(matrixData);
	return result;
}

struct MatrixData_11 *MatrixMath_Multiply_1(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_11 *left, struct MatrixData_11 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_11 *matrixData = NULL;
	struct MatrixData_11 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_36 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_36 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_36 *array_2 = NULL;
	struct MatrixData_11 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == true);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Rows;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_11();
	MatrixData_11_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_11(&matrixData, matrixData_1);
	(void)Assign_MatrixData_11(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_11_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_11_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_11_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_36(&array, NULL);
	(void)Assign_float64_t_1D_36(&array_1, NULL);
	(void)Assign_float64_t_1D_36(&array_2, NULL);
	(void)Assign_MatrixData_11(&result, matrixData);
	RemRef_MatrixData_11(matrixData);
	return result;
}

struct MatrixData_11 *MatrixMath_Multiply_2(bool_t transposeFirst, bool_t transposeSecond, bool_t transposeThird, struct MatrixData_11 *first, struct MatrixData_11 *second, struct MatrixData_11 *third)
{
	struct MatrixData_11 *left = NULL;
	struct MatrixData_11 *matrixData = NULL;
	struct MatrixData_11 *result = NULL;
	struct MatrixData_11 *matrixData_1 = NULL;

	assert(transposeFirst == false);
	assert(transposeSecond == false);
	assert(transposeThird == true);
	if (!(first != NULL))
	{
		abort();
	}
	if (!(second != NULL))
	{
		abort();
	}
	if (!(third != NULL))
	{
		abort();
	}
	matrixData = MatrixMath_Multiply(transposeFirst, transposeSecond, first, second);
	(void)Assign_MatrixData_11(&left, matrixData);
	(void)Assign_MatrixData_11(&matrixData, NULL);
	matrixData_1 = MatrixMath_Multiply_1(false, transposeThird, left, third);
	(void)Assign_MatrixData_11(&result, matrixData_1);
	(void)Assign_MatrixData_11(&matrixData_1, NULL);
	RemRef_MatrixData_11(left);
	return result;
}

static void RemRef_Matrix_7(struct Matrix_7 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Matrix_7.CurrentCount--;
		Res_Matrix_7.Next[Res_Matrix_7.CurrentCount] = self;
		Del_Matrix_7(self);
	}
}

struct Matrix_7 *New_Matrix_7(void)
{
	static struct Matrix_7 const Default_Matrix_7 = { 1 };
	struct Matrix_7 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Matrix_7.CurrentCount == RC_Matrix_7)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Matrix_7.Next[Res_Matrix_7.CurrentCount];
	Res_Matrix_7.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Matrix_7.MaximumCount = (Res_Matrix_7.CurrentCount > Res_Matrix_7.MaximumCount) ? Res_Matrix_7.CurrentCount : Res_Matrix_7.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Matrix_7;
	return instance;
}

struct Matrix_7 *Assign_Matrix_7(struct Matrix_7 **const left, struct Matrix_7 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Matrix_7(*left);
	*left = right;
	return right;
}

void Matrix_7_ctor(struct Matrix_7 *const self)
{
	struct CTRAErrorSpace *ctraErrorSpace = NULL;
	struct CTRASpace *ctraSpace = NULL;

	ctraErrorSpace = New_CTRAErrorSpace();
	CTRAErrorSpace_ctor(ctraErrorSpace);
	(void)Assign_CTRAErrorSpace(&self->EmptyRowSpace, ctraErrorSpace);
	(void)Assign_CTRAErrorSpace(&ctraErrorSpace, NULL);
	ctraSpace = New_CTRASpace();
	CTRASpace_ctor(ctraSpace);
	(void)Assign_CTRASpace(&self->EmptyColumnSpace, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	Object_ctor(&self->base);
	self->Columns = (&self->EmptyRowSpace->base)->Dimensions;
	self->Rows = (&self->EmptyColumnSpace->base.base)->Dimensions;
}

static void Space_4_set_LastGetIndex(struct Space_4 *const self, struct Nullable value)
{
	self->LastGetIndex = value;
}

struct MatrixData_8 *Space_4_get_MatrixData(struct Space_4 *const self)
{
	struct MatrixData_8 *result = NULL;

	(void)Assign_MatrixData_8(&result, self->_vector);
	return result;
}

float64_t MatrixData_8_get_Item(struct MatrixData_8 *const self, int32_t index)
{
	if (!((index >= ((int32_t)0)) && (index < ((int32_t)2))))
	{
		abort();
	}
	return self->_data->Elements[index];
}

float64_t Space_4_get_Item(struct Space_4 *const self, int32_t index)
{
	struct Nullable nullable = { 0 };
	float64_t result = 0.0;
	struct MatrixData_8 *matrixData = NULL;
	float64_t double_ = 0.0;

	if (!((index < self->Dimensions) && (index >= ((int32_t)0))))
	{
		abort();
	}
	Nullable_ctor(&nullable, index);
	Space_4_set_LastGetIndex(self, nullable);
	matrixData = Space_4_get_MatrixData(self);
	double_ = MatrixData_8_get_Item(matrixData, index);
	result = double_;
	(void)Assign_MatrixData_8(&matrixData, NULL);
	return result;
}

float64_t CTRAErrorSpace_get_J(struct CTRAErrorSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_4_get_Item(&self->base, ((int32_t)0));
	return double_;
}

static void Del_float64_t_1D_12(struct float64_t_1D_12 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_1D_12(struct float64_t_1D_12 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_1D_12.CurrentCount--;
		Res_float64_t_1D_12.Next[Res_float64_t_1D_12.CurrentCount] = self;
		Del_float64_t_1D_12(self);
	}
}

struct float64_t_1D_12 *New_float64_t_1D_12(void)
{
	static struct float64_t_1D_12 const Default_float64_t_1D_12 = { 1 };
	struct float64_t_1D_12 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_1D_12.CurrentCount == RC_float64_t_1D_12)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_1D_12.Next[Res_float64_t_1D_12.CurrentCount];
	Res_float64_t_1D_12.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_1D_12.MaximumCount = (Res_float64_t_1D_12.CurrentCount > Res_float64_t_1D_12.MaximumCount) ? Res_float64_t_1D_12.CurrentCount : Res_float64_t_1D_12.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_1D_12;
	return instance;
}

struct float64_t_1D_12 *Assign_float64_t_1D_12(struct float64_t_1D_12 **const left, struct float64_t_1D_12 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_1D_12(*left);
	*left = right;
	return right;
}

static void RemRef_MatrixData_12(struct MatrixData_12 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_12.CurrentCount--;
		Res_MatrixData_12.Next[Res_MatrixData_12.CurrentCount] = self;
		Del_MatrixData_12(self);
	}
}

struct MatrixData_12 *New_MatrixData_12(void)
{
	static struct MatrixData_12 const Default_MatrixData_12 = { 1 };
	struct MatrixData_12 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_12.CurrentCount == RC_MatrixData_12)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_12.Next[Res_MatrixData_12.CurrentCount];
	Res_MatrixData_12.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_12.MaximumCount = (Res_MatrixData_12.CurrentCount > Res_MatrixData_12.MaximumCount) ? Res_MatrixData_12.CurrentCount : Res_MatrixData_12.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_12;
	return instance;
}

struct MatrixData_12 *Assign_MatrixData_12(struct MatrixData_12 **const left, struct MatrixData_12 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_12(*left);
	*left = right;
	return right;
}

void MatrixData_12_ctor(struct MatrixData_12 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_12 *array = NULL;

	assert(rows == ((int32_t)6));
	assert(columns == ((int32_t)2));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_12();
	(void)Assign_float64_t_1D_12(&self->_data, array);
	(void)Assign_float64_t_1D_12(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct MatrixData_12 *MatrixData_20_Zeros_9(int32_t rows, int32_t columns)
{
	struct MatrixData_12 *result = NULL;
	struct MatrixData_12 *matrixData = NULL;

	assert(rows == ((int32_t)6));
	assert(columns == ((int32_t)2));
	matrixData = New_MatrixData_12();
	MatrixData_12_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData_12(&result, matrixData);
	(void)Assign_MatrixData_12(&matrixData, NULL);
	return result;
}

struct MatrixData_12 *Matrix_7_get_MatrixData(struct Matrix_7 *const self)
{
	struct MatrixData_12 *result = NULL;

	if (!(self->_matrix != NULL))
	{
		struct MatrixData_12 *matrixData = NULL;

		matrixData = MatrixData_20_Zeros_9(self->Rows, self->Columns);
		(void)Assign_MatrixData_12(&self->_matrix, matrixData);
		(void)Assign_MatrixData_12(&matrixData, NULL);
	}
	(void)Assign_MatrixData_12(&result, self->_matrix);
	return result;
}

struct float64_t_1D_12 *MatrixData_12_get_DataReference(struct MatrixData_12 *const self)
{
	struct float64_t_1D_12 *result = NULL;

	(void)Assign_float64_t_1D_12(&result, self->_data);
	return result;
}

static void MatrixData_12_SetValueFast(struct MatrixData_12 *const self, float64_t value, int32_t row, int32_t column)
{
	struct float64_t_1D_12 *array = NULL;

	array = MatrixData_12_get_DataReference(self);
	array->Elements[(column * self->Rows) + row] = value;
	(void)Assign_float64_t_1D_12(&array, NULL);
}

void MatrixData_12_set_Item(struct MatrixData_12 *const self, int32_t row, int32_t column, float64_t value)
{
	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	MatrixData_12_SetValueFast(self, value, row, column);
}

static void Matrix_7_MatrixChanged(struct Matrix_7 *const self)
{
	(void)Assign_MatrixData(&self->CachedTranspose, NULL);
}

void Matrix_7_set_Item(struct Matrix_7 *const self, int32_t row, int32_t column, float64_t value)
{
	struct MatrixData_12 *matrixData = NULL;

	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	matrixData = Matrix_7_get_MatrixData(self);
	MatrixData_12_set_Item(matrixData, row, column, value);
	(void)Assign_MatrixData_12(&matrixData, NULL);
	Matrix_7_MatrixChanged(self);
}

void Matrix_7_set_Item_1(struct Matrix_7 *const self, float64_t row, float64_t column, float64_t value)
{
	Matrix_7_set_Item(self, (int32_t)row, (int32_t)column, value);
}

float64_t CTRAErrorSpace_get_Alpha(struct CTRAErrorSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_4_get_Item(&self->base, ((int32_t)1));
	return double_;
}

void CTRAModel_FillNoiseDiscreMatrix(struct CTRAModel *const self, struct CTRASpace *stateExpectation, struct TimeSpan deltaT, struct Matrix_7 **G)
{
	float64_t T = 0.0;
	float64_t double_ = 0.0;
	float64_t v = 0.0;
	float64_t double__1 = 0.0;
	float64_t g = 0.0;
	float64_t double__2 = 0.0;
	float64_t a = 0.0;
	float64_t double__3 = 0.0;
	float64_t w = 0.0;
	float64_t double__4 = 0.0;
	float64_t sinG = 0.0;
	float64_t double__5 = 0.0;
	float64_t cosG = 0.0;
	float64_t double__6 = 0.0;
	float64_t sin_1 = 0.0;
	float64_t double__7 = 0.0;
	float64_t cos_1 = 0.0;
	float64_t double__8 = 0.0;
	struct Matrix_7 *arg_BF_0 = NULL;
	struct CTRASpace *CS_0_0000 = NULL;
	float64_t arg_BF_1 = 0.0;
	struct CTRAErrorSpace *CS_0_0001 = NULL;
	struct Matrix_7 *arg_F7_0 = NULL;
	struct CTRASpace *CS_0_0002 = NULL;
	float64_t arg_F7_1 = 0.0;
	struct CTRAErrorSpace *CS_0_0003 = NULL;
	struct Matrix_7 *arg_138_0 = NULL;
	struct CTRASpace *CS_0_0004 = NULL;
	float64_t arg_138_1 = 0.0;
	struct CTRAErrorSpace *CS_0_0005 = NULL;
	struct Matrix_7 *arg_170_0 = NULL;
	struct CTRASpace *CS_0_0006 = NULL;
	float64_t arg_170_1 = 0.0;
	struct CTRAErrorSpace *CS_0_0007 = NULL;
	struct Matrix_7 *arg_1F7_0 = NULL;
	struct CTRASpace *CS_0_0008 = NULL;
	float64_t arg_1F7_1 = 0.0;
	struct CTRAErrorSpace *CS_0_0009 = NULL;
	struct Matrix_7 *arg_253_0 = NULL;
	struct CTRASpace *CS_0_0010 = NULL;
	float64_t arg_253_1 = 0.0;
	struct CTRAErrorSpace *CS_0_0011 = NULL;
	struct Matrix_7 *arg_2D8_0 = NULL;
	struct CTRASpace *CS_0_0012 = NULL;
	float64_t arg_2D8_1 = 0.0;
	struct CTRAErrorSpace *CS_0_0013 = NULL;
	struct Matrix_7 *arg_335_0 = NULL;
	struct CTRASpace *CS_0_0014 = NULL;
	float64_t arg_335_1 = 0.0;
	struct CTRAErrorSpace *CS_0_0015 = NULL;
	float64_t double__9 = 0.0;
	struct Matrix_7 *arg_367_0 = NULL;
	struct CTRASpace *CS_0_0016 = NULL;
	float64_t arg_367_1 = 0.0;
	float64_t double__10 = 0.0;
	struct CTRAErrorSpace *CS_0_0017 = NULL;
	struct Matrix_7 *matrix = NULL;
	float64_t double__11 = 0.0;
	float64_t double__12 = 0.0;
	struct Matrix_7 *arg_3A3_0 = NULL;
	struct CTRASpace *CS_0_0018 = NULL;
	float64_t arg_3A3_1 = 0.0;
	float64_t double__13 = 0.0;
	struct CTRAErrorSpace *CS_0_0019 = NULL;
	struct Matrix_7 *matrix_1 = NULL;
	float64_t double__14 = 0.0;
	float64_t double__15 = 0.0;
	struct Matrix_7 *arg_3D3_0 = NULL;
	struct CTRASpace *CS_0_0020 = NULL;
	float64_t arg_3D3_1 = 0.0;
	float64_t double__16 = 0.0;
	struct CTRAErrorSpace *CS_0_0021 = NULL;
	struct Matrix_7 *matrix_2 = NULL;
	float64_t double__17 = 0.0;
	float64_t double__18 = 0.0;
	struct Matrix_7 *arg_403_0 = NULL;
	struct CTRASpace *CS_0_0022 = NULL;
	float64_t arg_403_1 = 0.0;
	float64_t double__19 = 0.0;
	struct CTRAErrorSpace *CS_0_0023 = NULL;
	struct Matrix_7 *matrix_3 = NULL;
	float64_t double__20 = 0.0;
	float64_t double__21 = 0.0;

	double_ = TimeSpan_get_TotalSeconds(&deltaT);
	T = double_;
	double__1 = CTRASpace_get_V(stateExpectation);
	v = double__1;
	double__2 = CTRASpace_get_G(stateExpectation);
	g = double__2;
	double__3 = CTRASpace_get_A(stateExpectation);
	a = double__3;
	double__4 = CTRASpace_get_W(stateExpectation);
	w = double__4;
	double__5 = Math_Sin(g);
	sinG = double__5;
	double__6 = Math_Cos(g);
	cosG = double__6;
	double__7 = Math_Sin(g + (w * T));
	sin_1 = double__7;
	double__8 = Math_Cos(g + (w * T));
	cos_1 = double__8;
	double__9 = Math_Abs(cos_1 - cosG);
	if (!(double__9 >= 1E-07))
	{
		float64_t double__22 = 0.0;
		struct Matrix_7 *matrix_4 = NULL;
		float64_t double__23 = 0.0;
		float64_t double__24 = 0.0;
		float64_t double__25 = 0.0;
		struct Matrix_7 *matrix_5 = NULL;
		float64_t double__26 = 0.0;
		float64_t double__27 = 0.0;
		float64_t double__28 = 0.0;
		struct Matrix_7 *matrix_6 = NULL;
		float64_t double__29 = 0.0;
		float64_t double__30 = 0.0;
		float64_t double__31 = 0.0;
		struct Matrix_7 *matrix_7 = NULL;
		float64_t double__32 = 0.0;
		float64_t double__33 = 0.0;

		(void)Assign_Matrix_7(&arg_BF_0, *G);
		(void)Assign_CTRASpace(&CS_0_0000, CTRAModel_1_S);
		double__22 = CTRASpace_get_X(CS_0_0000);
		arg_BF_1 = double__22;
		(void)Assign_CTRAErrorSpace(&CS_0_0001, CTRAModel_1_N);
		(void)Assign_Matrix_7(&matrix_4, arg_BF_0);
		double__23 = arg_BF_1;
		double__24 = CTRAErrorSpace_get_J(CS_0_0001);
		Matrix_7_set_Item_1(matrix_4, double__23, double__24, (((T * T) * T) / 6.0) * cosG);
		(void)Assign_Matrix_7(&matrix_4, NULL);
		(void)Assign_Matrix_7(&arg_F7_0, *G);
		(void)Assign_CTRASpace(&CS_0_0002, CTRAModel_1_S);
		double__25 = CTRASpace_get_X(CS_0_0002);
		arg_F7_1 = double__25;
		(void)Assign_CTRAErrorSpace(&CS_0_0003, CTRAModel_1_N);
		(void)Assign_Matrix_7(&matrix_5, arg_F7_0);
		double__26 = arg_F7_1;
		double__27 = CTRAErrorSpace_get_Alpha(CS_0_0003);
		Matrix_7_set_Item_1(matrix_5, double__26, double__27, 0.0);
		(void)Assign_Matrix_7(&matrix_5, NULL);
		(void)Assign_Matrix_7(&arg_138_0, *G);
		(void)Assign_CTRASpace(&CS_0_0004, CTRAModel_1_S);
		double__28 = CTRASpace_get_Y(CS_0_0004);
		arg_138_1 = double__28;
		(void)Assign_CTRAErrorSpace(&CS_0_0005, CTRAModel_1_N);
		(void)Assign_Matrix_7(&matrix_6, arg_138_0);
		double__29 = arg_138_1;
		double__30 = CTRAErrorSpace_get_J(CS_0_0005);
		Matrix_7_set_Item_1(matrix_6, double__29, double__30, (((T * T) * T) / 6.0) * sinG);
		(void)Assign_Matrix_7(&matrix_6, NULL);
		(void)Assign_Matrix_7(&arg_170_0, *G);
		(void)Assign_CTRASpace(&CS_0_0006, CTRAModel_1_S);
		double__31 = CTRASpace_get_Y(CS_0_0006);
		arg_170_1 = double__31;
		(void)Assign_CTRAErrorSpace(&CS_0_0007, CTRAModel_1_N);
		(void)Assign_Matrix_7(&matrix_7, arg_170_0);
		double__32 = arg_170_1;
		double__33 = CTRAErrorSpace_get_Alpha(CS_0_0007);
		Matrix_7_set_Item_1(matrix_7, double__32, double__33, 0.0);
		(void)Assign_Matrix_7(&matrix_7, NULL);
	}
	else
	{
		float64_t double__34 = 0.0;
		struct Matrix_7 *matrix_8 = NULL;
		float64_t double__35 = 0.0;
		float64_t double__36 = 0.0;
		float64_t double__37 = 0.0;
		struct Matrix_7 *matrix_9 = NULL;
		float64_t double__38 = 0.0;
		float64_t double__39 = 0.0;
		float64_t double__40 = 0.0;
		struct Matrix_7 *matrix_10 = NULL;
		float64_t double__41 = 0.0;
		float64_t double__42 = 0.0;
		float64_t double__43 = 0.0;
		struct Matrix_7 *matrix_11 = NULL;
		float64_t double__44 = 0.0;
		float64_t double__45 = 0.0;

		(void)Assign_Matrix_7(&arg_1F7_0, *G);
		(void)Assign_CTRASpace(&CS_0_0008, CTRAModel_1_S);
		double__34 = CTRASpace_get_X(CS_0_0008);
		arg_1F7_1 = double__34;
		(void)Assign_CTRAErrorSpace(&CS_0_0009, CTRAModel_1_N);
		(void)Assign_Matrix_7(&matrix_8, arg_1F7_0);
		double__35 = arg_1F7_1;
		double__36 = CTRAErrorSpace_get_Alpha(CS_0_0009);
		Matrix_7_set_Item_1(matrix_8, double__35, double__36, ((((((v * T) * T) + (((a * T) * T) * T)) * cos_1) / w) + ((((v * T) * (sinG - sin_1)) - ((((2.0 * a) * T) * T) * sin_1)) / (w * w))) + ((((2.0 * a) * T) * (cosG - cos_1)) / ((w * w) * w)));
		(void)Assign_Matrix_7(&matrix_8, NULL);
		(void)Assign_Matrix_7(&arg_253_0, *G);
		(void)Assign_CTRASpace(&CS_0_0010, CTRAModel_1_S);
		double__37 = CTRASpace_get_X(CS_0_0010);
		arg_253_1 = double__37;
		(void)Assign_CTRAErrorSpace(&CS_0_0011, CTRAModel_1_N);
		(void)Assign_Matrix_7(&matrix_9, arg_253_0);
		double__38 = arg_253_1;
		double__39 = CTRAErrorSpace_get_J(CS_0_0011);
		Matrix_7_set_Item_1(matrix_9, double__38, double__39, ((((T * T) / (2.0 * w)) * sin_1) + ((T / (w * w)) * cos_1)) + ((sinG - sin_1) / ((w * w) * w)));
		(void)Assign_Matrix_7(&matrix_9, NULL);
		(void)Assign_Matrix_7(&arg_2D8_0, *G);
		(void)Assign_CTRASpace(&CS_0_0012, CTRAModel_1_S);
		double__40 = CTRASpace_get_Y(CS_0_0012);
		arg_2D8_1 = double__40;
		(void)Assign_CTRAErrorSpace(&CS_0_0013, CTRAModel_1_N);
		(void)Assign_Matrix_7(&matrix_10, arg_2D8_0);
		double__41 = arg_2D8_1;
		double__42 = CTRAErrorSpace_get_Alpha(CS_0_0013);
		Matrix_7_set_Item_1(matrix_10, double__41, double__42, ((((((v * T) * T) * sin_1) + ((((a * T) * T) * T) * sin_1)) / w) + ((((v * T) * (cos_1 - cosG)) + ((((2.0 * a) * T) * T) * cos_1)) / (w * w))) + ((((2.0 * a) * T) * (sinG - sin_1)) / ((w * w) * w)));
		(void)Assign_Matrix_7(&matrix_10, NULL);
		(void)Assign_Matrix_7(&arg_335_0, *G);
		(void)Assign_CTRASpace(&CS_0_0014, CTRAModel_1_S);
		double__43 = CTRASpace_get_Y(CS_0_0014);
		arg_335_1 = double__43;
		(void)Assign_CTRAErrorSpace(&CS_0_0015, CTRAModel_1_N);
		(void)Assign_Matrix_7(&matrix_11, arg_335_0);
		double__44 = arg_335_1;
		double__45 = CTRAErrorSpace_get_J(CS_0_0015);
		Matrix_7_set_Item_1(matrix_11, double__44, double__45, ((((-T * T) / (2.0 * w)) * cos_1) + ((T / (w * w)) * sin_1)) + ((cos_1 - cosG) / ((w * w) * w)));
		(void)Assign_Matrix_7(&matrix_11, NULL);
	}
	(void)Assign_Matrix_7(&arg_367_0, *G);
	(void)Assign_CTRASpace(&CS_0_0016, CTRAModel_1_S);
	double__10 = CTRASpace_get_G(CS_0_0016);
	arg_367_1 = double__10;
	(void)Assign_CTRAErrorSpace(&CS_0_0017, CTRAModel_1_N);
	(void)Assign_Matrix_7(&matrix, arg_367_0);
	double__11 = arg_367_1;
	double__12 = CTRAErrorSpace_get_Alpha(CS_0_0017);
	Matrix_7_set_Item_1(matrix, double__11, double__12, T * T);
	(void)Assign_Matrix_7(&matrix, NULL);
	(void)Assign_Matrix_7(&arg_3A3_0, *G);
	(void)Assign_CTRASpace(&CS_0_0018, CTRAModel_1_S);
	double__13 = CTRASpace_get_V(CS_0_0018);
	arg_3A3_1 = double__13;
	(void)Assign_CTRAErrorSpace(&CS_0_0019, CTRAModel_1_N);
	(void)Assign_Matrix_7(&matrix_1, arg_3A3_0);
	double__14 = arg_3A3_1;
	double__15 = CTRAErrorSpace_get_J(CS_0_0019);
	Matrix_7_set_Item_1(matrix_1, double__14, double__15, (T * T) / 2.0);
	(void)Assign_Matrix_7(&matrix_1, NULL);
	(void)Assign_Matrix_7(&arg_3D3_0, *G);
	(void)Assign_CTRASpace(&CS_0_0020, CTRAModel_1_S);
	double__16 = CTRASpace_get_A(CS_0_0020);
	arg_3D3_1 = double__16;
	(void)Assign_CTRAErrorSpace(&CS_0_0021, CTRAModel_1_N);
	(void)Assign_Matrix_7(&matrix_2, arg_3D3_0);
	double__17 = arg_3D3_1;
	double__18 = CTRAErrorSpace_get_J(CS_0_0021);
	Matrix_7_set_Item_1(matrix_2, double__17, double__18, T);
	(void)Assign_Matrix_7(&matrix_2, NULL);
	(void)Assign_Matrix_7(&arg_403_0, *G);
	(void)Assign_CTRASpace(&CS_0_0022, CTRAModel_1_S);
	double__19 = CTRASpace_get_W(CS_0_0022);
	arg_403_1 = double__19;
	(void)Assign_CTRAErrorSpace(&CS_0_0023, CTRAModel_1_N);
	(void)Assign_Matrix_7(&matrix_3, arg_403_0);
	double__20 = arg_403_1;
	double__21 = CTRAErrorSpace_get_Alpha(CS_0_0023);
	Matrix_7_set_Item_1(matrix_3, double__20, double__21, T);
	(void)Assign_Matrix_7(&matrix_3, NULL);
	RemRef_Matrix_7(arg_BF_0);
	RemRef_CTRASpace(CS_0_0000);
	RemRef_CTRAErrorSpace(CS_0_0001);
	RemRef_Matrix_7(arg_F7_0);
	RemRef_CTRASpace(CS_0_0002);
	RemRef_CTRAErrorSpace(CS_0_0003);
	RemRef_Matrix_7(arg_138_0);
	RemRef_CTRASpace(CS_0_0004);
	RemRef_CTRAErrorSpace(CS_0_0005);
	RemRef_Matrix_7(arg_170_0);
	RemRef_CTRASpace(CS_0_0006);
	RemRef_CTRAErrorSpace(CS_0_0007);
	RemRef_Matrix_7(arg_1F7_0);
	RemRef_CTRASpace(CS_0_0008);
	RemRef_CTRAErrorSpace(CS_0_0009);
	RemRef_Matrix_7(arg_253_0);
	RemRef_CTRASpace(CS_0_0010);
	RemRef_CTRAErrorSpace(CS_0_0011);
	RemRef_Matrix_7(arg_2D8_0);
	RemRef_CTRASpace(CS_0_0012);
	RemRef_CTRAErrorSpace(CS_0_0013);
	RemRef_Matrix_7(arg_335_0);
	RemRef_CTRASpace(CS_0_0014);
	RemRef_CTRAErrorSpace(CS_0_0015);
	RemRef_Matrix_7(arg_367_0);
	RemRef_CTRASpace(CS_0_0016);
	RemRef_CTRAErrorSpace(CS_0_0017);
	RemRef_Matrix_7(arg_3A3_0);
	RemRef_CTRASpace(CS_0_0018);
	RemRef_CTRAErrorSpace(CS_0_0019);
	RemRef_Matrix_7(arg_3D3_0);
	RemRef_CTRASpace(CS_0_0020);
	RemRef_CTRAErrorSpace(CS_0_0021);
	RemRef_Matrix_7(arg_403_0);
	RemRef_CTRASpace(CS_0_0022);
	RemRef_CTRAErrorSpace(CS_0_0023);
}

struct PositiveDefiniteMatrix_4 *SystemModel_1_get_NoiseCovarian(struct SystemModel_1 *const self)
{
	struct PositiveDefiniteMatrix_4 *result = NULL;

	(void)Assign_PositiveDefiniteMatrix_4(&result, self->_processNoiseCovariance);
	return result;
}

void LinearAlgebra_MatrixMultiply_1(struct LinearAlgebra *const self, struct float64_t_1D_12 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_4 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_12 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)12) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)4) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)12) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)12) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)4) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)4) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)12) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)12) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_12 *MatrixMath_Multiply_3(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_12 *left, struct MatrixData_6 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_12 *matrixData = NULL;
	struct MatrixData_12 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_12 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_4 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_12 *array_2 = NULL;
	struct MatrixData_12 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == false);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Columns;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_12();
	MatrixData_12_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_12(&matrixData, matrixData_1);
	(void)Assign_MatrixData_12(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_12_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_6_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_12_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_1(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_12(&array, NULL);
	(void)Assign_float64_t_1D_4(&array_1, NULL);
	(void)Assign_float64_t_1D_12(&array_2, NULL);
	(void)Assign_MatrixData_12(&result, matrixData);
	RemRef_MatrixData_12(matrixData);
	return result;
}

void LinearAlgebra_MatrixMultiply_2(struct LinearAlgebra *const self, struct float64_t_1D_12 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_12 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_36 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)12) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)12) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)12) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)12) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)12) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)12) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)12) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)36) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_11 *MatrixMath_Multiply_4(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_12 *left, struct MatrixData_12 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_11 *matrixData = NULL;
	struct MatrixData_11 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_12 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_12 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_36 *array_2 = NULL;
	struct MatrixData_11 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == true);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Rows;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_11();
	MatrixData_11_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_11(&matrixData, matrixData_1);
	(void)Assign_MatrixData_11(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_12_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_12_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_11_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_2(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_12(&array, NULL);
	(void)Assign_float64_t_1D_12(&array_1, NULL);
	(void)Assign_float64_t_1D_36(&array_2, NULL);
	(void)Assign_MatrixData_11(&result, matrixData);
	RemRef_MatrixData_11(matrixData);
	return result;
}

struct MatrixData_11 *MatrixMath_Multiply_5(bool_t transposeFirst, bool_t transposeSecond, bool_t transposeThird, struct MatrixData_12 *first, struct MatrixData_6 *second, struct MatrixData_12 *third)
{
	struct MatrixData_12 *left = NULL;
	struct MatrixData_12 *matrixData = NULL;
	struct MatrixData_11 *result = NULL;
	struct MatrixData_11 *matrixData_1 = NULL;

	assert(transposeFirst == false);
	assert(transposeSecond == false);
	assert(transposeThird == true);
	if (!(first != NULL))
	{
		abort();
	}
	if (!(second != NULL))
	{
		abort();
	}
	if (!(third != NULL))
	{
		abort();
	}
	matrixData = MatrixMath_Multiply_3(transposeFirst, transposeSecond, first, second);
	(void)Assign_MatrixData_12(&left, matrixData);
	(void)Assign_MatrixData_12(&matrixData, NULL);
	matrixData_1 = MatrixMath_Multiply_4(false, transposeThird, left, third);
	(void)Assign_MatrixData_11(&result, matrixData_1);
	(void)Assign_MatrixData_11(&matrixData_1, NULL);
	RemRef_MatrixData_12(left);
	return result;
}

static float64_t MatrixData_11_GetValueFast(struct MatrixData_11 *const self, int32_t row, int32_t column)
{
	float64_t result = 0.0;
	struct float64_t_1D_36 *array = NULL;

	array = MatrixData_11_get_DataReference(self);
	result = array->Elements[(column * self->Rows) + row];
	(void)Assign_float64_t_1D_36(&array, NULL);
	return result;
}

float64_t MatrixData_11_get_Item(struct MatrixData_11 *const self, int32_t row, int32_t column)
{
	float64_t double_ = 0.0;

	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	double_ = MatrixData_11_GetValueFast(self, row, column);
	return double_;
}

int32_t Math_Sign(float64_t value)
{
	if (!(value >= 0.0))
	{
		return ((int32_t)-1);
	}
	if (!(value <= 0.0))
	{
		return ((int32_t)1);
	}
	if (!(value != 0.0))
	{
		return ((int32_t)0);
	}
	abort();
}

static void Matrix_6_set_UncheckeMatrixData(struct Matrix_6 *const self, struct MatrixData_11 *value)
{
	(void)Assign_MatrixData_11(&self->_matrix, value);
}

struct PositiveDefiniteMatrix_6 *PositiveDefiniteMatrix_8_Create(struct MatrixData_11 *matrix)
{
	struct PositiveDefiniteMatrix_6 *result = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix = NULL;

	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_6();
	PositiveDefiniteMatrix_6_ctor(positiveDefiniteMatrix);
	Matrix_6_set_UncheckeMatrixData(&positiveDefiniteMatrix->base.base, matrix);
	(void)Assign_PositiveDefiniteMatrix_6(&result, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix, NULL);
	return result;
}

struct PositiveDefiniteMatrix_6 *PositDefinMatri_8_CreatAndCorre(struct MatrixData_11 *matrix)
{
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	float64_t num = 0.0;
	float64_t num2 = 0.0;
	float64_t value = 0.0;
	struct PositiveDefiniteMatrix_6 *result = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix = NULL;

	i = ((int32_t)0);
	while (i < matrix->Rows)
	{
		float64_t double_ = 0.0;

		double_ = MatrixData_11_get_Item(matrix, i, i);
		if (!(double_ > 0.0))
		{
			MatrixData_11_set_Item(matrix, i, i, 4.94065645841247E-324);
		}
		j = ((int32_t)0);
		while (j < i)
		{
			float64_t double__1 = 0.0;
			float64_t double__2 = 0.0;
			float64_t double__3 = 0.0;
			float64_t double__4 = 0.0;
			float64_t double__5 = 0.0;
			float64_t double__6 = 0.0;

			double__1 = MatrixData_11_get_Item(matrix, i, j);
			double__2 = MatrixData_11_get_Item(matrix, j, i);
			num = (double__1 + double__2) / 2.0;
			double__3 = MatrixData_11_get_Item(matrix, i, i);
			double__4 = MatrixData_11_get_Item(matrix, j, j);
			double__5 = Math_Sqrt(double__3 * double__4);
			num2 = 1.0 * double__5;
			double__6 = Math_Abs(num);
			if (!(double__6 <= num2))
			{
				int32_t int32 = ((int32_t)0);
				float64_t double__7 = 0.0;

				int32 = Math_Sign(num);
				double__7 = (float64_t)int32;
				value = double__7 * num2;
			}
			else
			{
				value = num;
			}
			MatrixData_11_set_Item(matrix, i, j, value);
			MatrixData_11_set_Item(matrix, j, i, value);
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	positiveDefiniteMatrix = PositiveDefiniteMatrix_8_Create(matrix);
	(void)Assign_PositiveDefiniteMatrix_6(&result, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix, NULL);
	return result;
}

struct PositiveDefiniteMatrix_6 *SystemModel_3_get_Covariance(struct CTRAModel *const self)
{
	struct Matrix_7 *matrix = NULL;
	struct Matrix_7 *matrix_1 = NULL;
	struct CTRASpace *ctraSpace = NULL;
	struct TimeSpan timeSpan = { 0 };
	struct MatrixData_11 *matrix2 = NULL;
	struct MatrixData_12 *matrixData = NULL;
	struct PositiveDefiniteMatrix_4 *positiveDefiniteMatrix = NULL;
	struct MatrixData_6 *matrixData_1 = NULL;
	struct MatrixData_12 *matrixData_2 = NULL;
	struct MatrixData_11 *matrixData_3 = NULL;
	struct PositiveDefiniteMatrix_6 *result = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_1 = NULL;

	matrix_1 = New_Matrix_7();
	Matrix_7_ctor(matrix_1);
	(void)Assign_Matrix_7(&matrix, matrix_1);
	(void)Assign_Matrix_7(&matrix_1, NULL);
	ctraSpace = SystemModel_1_get_Condition(&self->base.base.base);
	timeSpan = SystemModel_1_get_TimeCondition(&self->base.base.base);
	CTRAModel_FillNoiseDiscreMatrix(self, ctraSpace, timeSpan, &matrix);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	matrixData = Matrix_7_get_MatrixData(matrix);
	positiveDefiniteMatrix = SystemModel_1_get_NoiseCovarian(&self->base.base.base);
	matrixData_1 = Matrix_4_get_MatrixData(&positiveDefiniteMatrix->base.base);
	matrixData_2 = Matrix_7_get_MatrixData(matrix);
	matrixData_3 = MatrixMath_Multiply_5(false, false, true, matrixData, matrixData_1, matrixData_2);
	(void)Assign_MatrixData_11(&matrix2, matrixData_3);
	(void)Assign_MatrixData_12(&matrixData, NULL);
	(void)Assign_PositiveDefiniteMatrix_4(&positiveDefiniteMatrix, NULL);
	(void)Assign_MatrixData_6(&matrixData_1, NULL);
	(void)Assign_MatrixData_12(&matrixData_2, NULL);
	(void)Assign_MatrixData_11(&matrixData_3, NULL);
	positiveDefiniteMatrix_1 = PositDefinMatri_8_CreatAndCorre(matrix2);
	(void)Assign_PositiveDefiniteMatrix_6(&result, positiveDefiniteMatrix_1);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_1, NULL);
	RemRef_Matrix_7(matrix);
	RemRef_MatrixData_11(matrix2);
	return result;
}

struct MatrixData_11 *MatrixMath_Add(struct MatrixData_11 *left, struct MatrixData_11 *right)
{
	struct MatrixData_11 *matrixData = NULL;
	struct MatrixData_11 *matrixData_1 = NULL;
	struct float64_t_1D_36 *dataReference = NULL;
	struct float64_t_1D_36 *array = NULL;
	struct float64_t_1D_36 *dataReference2 = NULL;
	struct float64_t_1D_36 *array_1 = NULL;
	struct float64_t_1D_36 *dataReference3 = NULL;
	struct float64_t_1D_36 *array_2 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_11 *result = NULL;

	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData_11();
	MatrixData_11_ctor(matrixData_1, left->Rows, right->Columns);
	(void)Assign_MatrixData_11(&matrixData, matrixData_1);
	(void)Assign_MatrixData_11(&matrixData_1, NULL);
	array = MatrixData_11_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_36(&dataReference, array);
	(void)Assign_float64_t_1D_36(&array, NULL);
	array_1 = MatrixData_11_get_DataReference(left);
	(void)Assign_float64_t_1D_36(&dataReference2, array_1);
	(void)Assign_float64_t_1D_36(&array_1, NULL);
	array_2 = MatrixData_11_get_DataReference(right);
	(void)Assign_float64_t_1D_36(&dataReference3, array_2);
	(void)Assign_float64_t_1D_36(&array_2, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)36))
	{
		dataReference->Elements[i] = dataReference2->Elements[i] + dataReference3->Elements[i];
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_11(&result, matrixData);
	RemRef_MatrixData_11(matrixData);
	RemRef_float64_t_1D_36(dataReference);
	RemRef_float64_t_1D_36(dataReference2);
	RemRef_float64_t_1D_36(dataReference3);
	return result;
	abort();
}

static struct CTRASpace *Object_MemberwiseClone_1(struct CTRASpace *const self)
{
	struct CTRASpace *result;

	result = New_CTRASpace();
	*result = *self;
	(&result->base.base.base)->ReferenceCount = ((int32_t)1);
	Clone_CTRASpace(result);
	return result;
}

static void MatrixData_9_ctor_1(struct MatrixData_9 *const self, struct float64_t_1D_6 *data, int32_t rows, int32_t columns, bool_t takeDataOwnership)
{
	assert(rows == ((int32_t)6));
	assert(columns == ((int32_t)1));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	if (!(data != NULL))
	{
		abort();
	}
	if (!!takeDataOwnership)
	{
		(void)Assign_float64_t_1D_6(&self->_data, data);
	}
	else
	{
		struct float64_t_1D_6 *array = NULL;

		array = New_float64_t_1D_6();
		(void)Assign_float64_t_1D_6(&self->_data, array);
		(void)Assign_float64_t_1D_6(&array, NULL);
		(void)memcpy(&self->_data->Elements, &data->Elements, sizeof(float64_t) * ((int32_t)6));
	}
	self->Rows = rows;
	self->Columns = columns;
}

struct MatrixData_9 *MatrixData_9_get_Copy(struct MatrixData_9 *const self)
{
	struct MatrixData_9 *result = NULL;
	struct MatrixData_9 *matrixData = NULL;

	matrixData = New_MatrixData_9();
	MatrixData_9_ctor_1(matrixData, self->_data, self->Rows, self->Columns, false);
	(void)Assign_MatrixData_9(&result, matrixData);
	(void)Assign_MatrixData_9(&matrixData, NULL);
	return result;
}

static struct CTRASpace *Space_5_ShallowCopy(struct CTRASpace *const self)
{
	struct CTRASpace *space = NULL;
	struct CTRASpace *ctraSpace = NULL;
	struct CTRASpace *result = NULL;

	ctraSpace = Object_MemberwiseClone_1(self);
	(void)Assign_CTRASpace(&space, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	if (!!((&self->base.base)->_vector != NULL))
	{
		struct CTRASpace *ctraSpace_1 = NULL;
		struct MatrixData_9 *matrixData = NULL;

		(void)Assign_CTRASpace(&ctraSpace_1, space);
		matrixData = MatrixData_9_get_Copy((&self->base.base)->_vector);
		(void)Assign_MatrixData_9(&(&ctraSpace_1->base.base)->_vector, matrixData);
		(void)Assign_CTRASpace(&ctraSpace_1, NULL);
		(void)Assign_MatrixData_9(&matrixData, NULL);
	}
	if (!!((&self->base.base)->_spaceInformationLock != NULL))
	{
		struct CTRASpace *ctraSpace_2 = NULL;
		struct Object *object = NULL;

		(void)Assign_CTRASpace(&ctraSpace_2, space);
		object = New_Object();
		Object_ctor(object);
		(void)Assign_Object(&(&ctraSpace_2->base.base)->_spaceInformationLock, object);
		(void)Assign_CTRASpace(&ctraSpace_2, NULL);
		(void)Assign_Object(&object, NULL);
	}
	(void)Assign_CTRASpace(&result, space);
	RemRef_CTRASpace(space);
	return result;
}

struct CTRASpace *SpaceExtensions_Clone_1(struct CTRASpace *space)
{
	struct CTRASpace *result = NULL;
	struct CTRASpace *ctraSpace = NULL;

	ctraSpace = Space_5_ShallowCopy(space);
	(void)Assign_CTRASpace(&result, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	return result;
}

static struct CTRAErrorSpace *SystemModel_1_get_Condition2(struct SystemModel_1 *const self)
{
	struct CTRAErrorSpace *result = NULL;

	(void)Assign_CTRAErrorSpace(&result, self->Condition2);
	return result;
}

static void Space_5_set_LastSetIndex(struct Space_5 *const self, struct Nullable value)
{
	self->LastSetIndex = value;
}

void MatrixData_9_set_Item(struct MatrixData_9 *const self, int32_t index, float64_t value)
{
	if (!((index >= ((int32_t)0)) && (index < ((int32_t)6))))
	{
		abort();
	}
	self->_data->Elements[index] = value;
}

void Space_5_set_Item(struct Space_5 *const self, int32_t index, float64_t value)
{
	struct Nullable nullable = { 0 };
	struct MatrixData_9 *matrixData = NULL;

	if (!((index < self->Dimensions) && (index >= ((int32_t)0))))
	{
		abort();
	}
	Nullable_ctor(&nullable, index);
	Space_5_set_LastSetIndex(self, nullable);
	matrixData = Space_5_get_MatrixData(self);
	MatrixData_9_set_Item(matrixData, index, value);
	(void)Assign_MatrixData_9(&matrixData, NULL);
}

void CTRASpace_set_X(struct CTRASpace *const self, float64_t value)
{
	Space_5_set_Item(&self->base.base, ((int32_t)0), value);
}

void CTRASpace_set_Y(struct CTRASpace *const self, float64_t value)
{
	Space_5_set_Item(&self->base.base, ((int32_t)1), value);
}

void CTRASpace_set_G(struct CTRASpace *const self, float64_t value)
{
	Space_5_set_Item(&self->base.base, ((int32_t)2), value);
}

void CTRASpace_set_V(struct CTRASpace *const self, float64_t value)
{
	Space_5_set_Item(&self->base.base, ((int32_t)3), value);
}

void CTRASpace_set_A(struct CTRASpace *const self, float64_t value)
{
	Space_5_set_Item(&self->base.base, ((int32_t)4), value);
}

void CTRASpace_set_W(struct CTRASpace *const self, float64_t value)
{
	Space_5_set_Item(&self->base.base, ((int32_t)5), value);
}

void CTRAModel_f(struct CTRAModel *const self, struct CTRASpace *state, struct TimeSpan deltaT, struct CTRAErrorSpace *processNoise, struct CTRASpace **predictedState)
{
	float64_t T = 0.0;
	float64_t double_ = 0.0;
	float64_t x = 0.0;
	float64_t double__1 = 0.0;
	float64_t y = 0.0;
	float64_t double__2 = 0.0;
	float64_t g = 0.0;
	float64_t double__3 = 0.0;
	float64_t v = 0.0;
	float64_t double__4 = 0.0;
	float64_t a = 0.0;
	float64_t double__5 = 0.0;
	float64_t w = 0.0;
	float64_t double__6 = 0.0;
	float64_t j = 0.0;
	float64_t double__7 = 0.0;
	float64_t alpha = 0.0;
	float64_t double__8 = 0.0;
	float64_t sinG = 0.0;
	float64_t double__9 = 0.0;
	float64_t cosG = 0.0;
	float64_t double__10 = 0.0;
	float64_t sin_1 = 0.0;
	float64_t double__11 = 0.0;
	float64_t cos_1 = 0.0;
	float64_t double__12 = 0.0;
	float64_t double__13 = 0.0;

	double_ = TimeSpan_get_TotalSeconds(&deltaT);
	T = double_;
	double__1 = CTRASpace_get_X(state);
	x = double__1;
	double__2 = CTRASpace_get_Y(state);
	y = double__2;
	double__3 = CTRASpace_get_G(state);
	g = double__3;
	double__4 = CTRASpace_get_V(state);
	v = double__4;
	double__5 = CTRASpace_get_A(state);
	a = double__5;
	double__6 = CTRASpace_get_W(state);
	w = double__6;
	double__7 = CTRAErrorSpace_get_J(processNoise);
	j = double__7;
	double__8 = CTRAErrorSpace_get_Alpha(processNoise);
	alpha = double__8;
	w = w + (alpha * T);
	double__9 = Math_Sin(g);
	sinG = double__9;
	double__10 = Math_Cos(g);
	cosG = double__10;
	double__11 = Math_Sin(g + (w * T));
	sin_1 = double__11;
	double__12 = Math_Cos(g + (w * T));
	cos_1 = double__12;
	double__13 = Math_Abs(cos_1 - cosG);
	if (!(double__13 >= 1E-07))
	{
		CTRASpace_set_X(*predictedState, x + (((((((j * T) * T) * T) / 6.0) + (((a * T) * T) / 2.0)) + (v * T)) * cosG));
		CTRASpace_set_Y(*predictedState, y + (((((((j * T) * T) * T) / 6.0) + (((a * T) * T) / 2.0)) + (v * T)) * sinG));
	}
	else
	{
		CTRASpace_set_X(*predictedState, ((x + ((((v * (sin_1 - sinG)) + ((a * T) * sin_1)) + ((((j / 2.0) * T) * T) * sin_1)) / w)) + (((a * (cos_1 - cosG)) + ((j * T) * cos_1)) / (w * w))) + ((j * (sinG - sin_1)) / ((w * w) * w)));
		CTRASpace_set_Y(*predictedState, ((y + ((((v * (cosG - cos_1)) - ((a * T) * cos_1)) - ((((j / 2.0) * T) * T) * cos_1)) / w)) + (((a * (sin_1 - sinG)) + ((j * T) * sin_1)) / (w * w))) + ((j * (cos_1 - cosG)) / ((w * w) * w)));
	}
	CTRASpace_set_G(*predictedState, g + (w * T));
	CTRASpace_set_V(*predictedState, (v + (a * T)) + (((0.5 * j) * T) * T));
	CTRASpace_set_A(*predictedState, a + (j * T));
	CTRASpace_set_W(*predictedState, w);
}

struct CTRASpace *SystemModel_1_get_Expectation(struct CTRAModel *const self)
{
	struct CTRASpace *result = NULL;
	struct CTRASpace *ctraSpace = NULL;
	struct CTRASpace *ctraSpace_1 = NULL;
	struct CTRASpace *ctraSpace_2 = NULL;
	struct TimeSpan timeSpan = { 0 };
	struct CTRAErrorSpace *ctraErrorSpace = NULL;
	struct CTRASpace *result_1 = NULL;

	ctraSpace = SystemModel_1_get_Condition(&self->base.base.base);
	ctraSpace_1 = SpaceExtensions_Clone_1(ctraSpace);
	(void)Assign_CTRASpace(&result, ctraSpace_1);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	(void)Assign_CTRASpace(&ctraSpace_1, NULL);
	ctraSpace_2 = SystemModel_1_get_Condition(&self->base.base.base);
	timeSpan = SystemModel_1_get_TimeCondition(&self->base.base.base);
	ctraErrorSpace = SystemModel_1_get_Condition2(&self->base.base.base);
	CTRAModel_f(self, ctraSpace_2, timeSpan, ctraErrorSpace, &result);
	(void)Assign_CTRASpace(&ctraSpace_2, NULL);
	(void)Assign_CTRAErrorSpace(&ctraErrorSpace, NULL);
	(void)Assign_CTRASpace(&result_1, result);
	RemRef_CTRASpace(result);
	return result_1;
}

static void Gaussian_4_ctor_2(struct Gaussian_4 *const self, bool_t noInitialization)
{
	struct CTRASpace *ctraSpace = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix = NULL;

	Object_ctor(&self->base);
	self->_dimensions = (&Gaussian_6_EmptySpace->base.base)->Dimensions;
	if (!!noInitialization)
	{
		return;
	}
	ctraSpace = New_CTRASpace();
	CTRASpace_ctor(ctraSpace);
	Gaussian_4_set_Expectation(self, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_6();
	PositiveDefiniteMatrix_6_ctor(positiveDefiniteMatrix);
	Gaussian_4_set_Covariance(self, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix, NULL);
}

struct Gaussian_4 *Gaussian_6_Create(struct CTRASpace *expectation, struct PositiveDefiniteMatrix_6 *covariance)
{
	struct Gaussian_4 *result = NULL;
	struct Gaussian_4 *gaussian = NULL;

	gaussian = New_Gaussian_4();
	Gaussian_4_ctor_2(gaussian, true);
	Gaussian_4_set_Expectation(gaussian, expectation);
	Gaussian_4_set_Covariance(gaussian, covariance);
	(void)Assign_Gaussian_4(&result, gaussian);
	(void)Assign_Gaussian_4(&gaussian, NULL);
	return result;
}

struct Gaussian_4 *EKF_PredictState(struct TimeSpan deltaT, struct Gaussian_4 *state, struct CTRAModel *systemModel)
{
	struct CTRASpace *ctraSpace = NULL;
	struct MatrixData_11 *copy = NULL;
	struct SquareMatrix_6 *squareMatrix = NULL;
	struct MatrixData_11 *matrixData = NULL;
	struct MatrixData_11 *matrixData_1 = NULL;
	struct MatrixData_11 *matrix = NULL;
	struct MatrixData_11 *matrixData_2 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix = NULL;
	struct MatrixData_11 *matrixData_3 = NULL;
	struct MatrixData_11 *matrixData_4 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_1 = NULL;
	struct MatrixData_11 *matrixData_5 = NULL;
	struct MatrixData_11 *matrixData_6 = NULL;
	struct PositiveDefiniteMatrix_6 *covariance = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_2 = NULL;
	struct Gaussian_4 *result = NULL;
	struct CTRASpace *ctraSpace_1 = NULL;
	struct Gaussian_4 *gaussian = NULL;

	ctraSpace = Gaussian_4_get_Expectation(state);
	SystemModel_1_set_Condition(&(*&systemModel)->base.base.base, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	SystemModel_1_set_TimeCondition(&(*&systemModel)->base.base.base, deltaT);
	squareMatrix = SystemModel_5_get_TransitMatrix(systemModel);
	matrixData = Matrix_6_get_MatrixData(&squareMatrix->base);
	matrixData_1 = MatrixData_11_get_Copy(matrixData);
	(void)Assign_MatrixData_11(&copy, matrixData_1);
	(void)Assign_SquareMatrix_6(&squareMatrix, NULL);
	(void)Assign_MatrixData_11(&matrixData, NULL);
	(void)Assign_MatrixData_11(&matrixData_1, NULL);
	(void)Assign_MatrixData_11(&matrixData_2, copy);
	positiveDefiniteMatrix = Gaussian_4_get_Covariance(state);
	matrixData_3 = Matrix_6_get_MatrixData(&positiveDefiniteMatrix->base.base);
	matrixData_4 = MatrixMath_Multiply_2(false, false, true, matrixData_2, matrixData_3, copy);
	positiveDefiniteMatrix_1 = SystemModel_3_get_Covariance(systemModel);
	matrixData_5 = Matrix_6_get_MatrixData(&positiveDefiniteMatrix_1->base.base);
	matrixData_6 = MatrixMath_Add(matrixData_4, matrixData_5);
	(void)Assign_MatrixData_11(&matrix, matrixData_6);
	(void)Assign_MatrixData_11(&matrixData_2, NULL);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix, NULL);
	(void)Assign_MatrixData_11(&matrixData_3, NULL);
	(void)Assign_MatrixData_11(&matrixData_4, NULL);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_1, NULL);
	(void)Assign_MatrixData_11(&matrixData_5, NULL);
	(void)Assign_MatrixData_11(&matrixData_6, NULL);
	positiveDefiniteMatrix_2 = PositDefinMatri_8_CreatAndCorre(matrix);
	(void)Assign_PositiveDefiniteMatrix_6(&covariance, positiveDefiniteMatrix_2);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_2, NULL);
	ctraSpace_1 = SystemModel_1_get_Expectation(systemModel);
	gaussian = Gaussian_6_Create(ctraSpace_1, covariance);
	(void)Assign_Gaussian_4(&result, gaussian);
	(void)Assign_CTRASpace(&ctraSpace_1, NULL);
	(void)Assign_Gaussian_4(&gaussian, NULL);
	RemRef_MatrixData_11(copy);
	RemRef_MatrixData_11(matrix);
	RemRef_PositiveDefiniteMatrix_6(covariance);
	return result;
}

float64_t Measure_get_Value(struct Measure *const self)
{
	return self->Value;
}

float64_t Measure_4_op_Implicit(struct Measure *measure)
{
	float64_t double_ = 0.0;

	double_ = Measure_get_Value(measure);
	return double_;
}

static void Space_1_set_LastSetIndex(struct Space_1 *const self, struct Nullable value)
{
	self->LastSetIndex = value;
}

struct MatrixData_3 *Space_1_get_MatrixData(struct Space_1 *const self)
{
	struct MatrixData_3 *result = NULL;

	(void)Assign_MatrixData_3(&result, self->_vector);
	return result;
}

void MatrixData_3_set_Item(struct MatrixData_3 *const self, int32_t index, float64_t value)
{
	if (!((index >= ((int32_t)0)) && (index < ((int32_t)1))))
	{
		abort();
	}
	self->_data->Elements[index] = value;
}

void Space_1_set_Item(struct Space_1 *const self, int32_t index, float64_t value)
{
	struct Nullable nullable = { 0 };
	struct MatrixData_3 *matrixData = NULL;

	if (!((index < self->Dimensions) && (index >= ((int32_t)0))))
	{
		abort();
	}
	Nullable_ctor(&nullable, index);
	Space_1_set_LastSetIndex(self, nullable);
	matrixData = Space_1_get_MatrixData(self);
	MatrixData_3_set_Item(matrixData, index, value);
	(void)Assign_MatrixData_3(&matrixData, NULL);
}

void VelocitySpace_set_V(struct VelocitySpace *const self, float64_t value)
{
	Space_1_set_Item(&self->base, ((int32_t)0), value);
}

static void RemRef_Matrix_8(struct Matrix_8 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Matrix_8.CurrentCount--;
		Res_Matrix_8.Next[Res_Matrix_8.CurrentCount] = self;
		Del_Matrix_8(self);
	}
}

struct Matrix_8 *New_Matrix_8(void)
{
	static struct Matrix_8 const Default_Matrix_8 = { 1 };
	struct Matrix_8 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Matrix_8.CurrentCount == RC_Matrix_8)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Matrix_8.Next[Res_Matrix_8.CurrentCount];
	Res_Matrix_8.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Matrix_8.MaximumCount = (Res_Matrix_8.CurrentCount > Res_Matrix_8.MaximumCount) ? Res_Matrix_8.CurrentCount : Res_Matrix_8.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Matrix_8;
	return instance;
}

struct Matrix_8 *Assign_Matrix_8(struct Matrix_8 **const left, struct Matrix_8 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Matrix_8(*left);
	*left = right;
	return right;
}

void Matrix_8_ctor(struct Matrix_8 *const self)
{
	struct CTRASpace *ctraSpace = NULL;
	struct VelocitySpace *velocitySpace = NULL;

	ctraSpace = New_CTRASpace();
	CTRASpace_ctor(ctraSpace);
	(void)Assign_CTRASpace(&self->EmptyRowSpace, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	velocitySpace = New_VelocitySpace();
	VelocitySpace_ctor(velocitySpace);
	(void)Assign_VelocitySpace(&self->EmptyColumnSpace, velocitySpace);
	(void)Assign_VelocitySpace(&velocitySpace, NULL);
	Object_ctor(&self->base);
	self->Columns = (&self->EmptyRowSpace->base.base)->Dimensions;
	self->Rows = (&self->EmptyColumnSpace->base)->Dimensions;
}

static struct CTRASpace *MeasurementModel_get_Condition(struct MeasurementModel *const self)
{
	struct CTRASpace *result = NULL;

	(void)Assign_CTRASpace(&result, self->Condition);
	return result;
}

static void Space_1_set_LastGetIndex(struct Space_1 *const self, struct Nullable value)
{
	self->LastGetIndex = value;
}

float64_t MatrixData_3_get_Item_1(struct MatrixData_3 *const self, int32_t index)
{
	if (!((index >= ((int32_t)0)) && (index < ((int32_t)1))))
	{
		abort();
	}
	return self->_data->Elements[index];
}

float64_t Space_1_get_Item(struct Space_1 *const self, int32_t index)
{
	struct Nullable nullable = { 0 };
	float64_t result = 0.0;
	struct MatrixData_3 *matrixData = NULL;
	float64_t double_ = 0.0;

	if (!((index < self->Dimensions) && (index >= ((int32_t)0))))
	{
		abort();
	}
	Nullable_ctor(&nullable, index);
	Space_1_set_LastGetIndex(self, nullable);
	matrixData = Space_1_get_MatrixData(self);
	double_ = MatrixData_3_get_Item_1(matrixData, index);
	result = double_;
	(void)Assign_MatrixData_3(&matrixData, NULL);
	return result;
}

float64_t VelocitySpace_get_V(struct VelocitySpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_1_get_Item(&self->base, ((int32_t)0));
	return double_;
}

float64_t VelocMeasuModel_get_VelociScale(struct VelocityMeasurementModel *const self)
{
	return self->VelocityScale;
}

static void RemRef_MatrixData_10(struct MatrixData_10 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_10.CurrentCount--;
		Res_MatrixData_10.Next[Res_MatrixData_10.CurrentCount] = self;
		Del_MatrixData_10(self);
	}
}

struct MatrixData_10 *New_MatrixData_10(void)
{
	static struct MatrixData_10 const Default_MatrixData_10 = { 1 };
	struct MatrixData_10 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_10.CurrentCount == RC_MatrixData_10)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_10.Next[Res_MatrixData_10.CurrentCount];
	Res_MatrixData_10.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_10.MaximumCount = (Res_MatrixData_10.CurrentCount > Res_MatrixData_10.MaximumCount) ? Res_MatrixData_10.CurrentCount : Res_MatrixData_10.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_10;
	return instance;
}

struct MatrixData_10 *Assign_MatrixData_10(struct MatrixData_10 **const left, struct MatrixData_10 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_10(*left);
	*left = right;
	return right;
}

void MatrixData_10_ctor(struct MatrixData_10 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_6 *array = NULL;

	assert(rows == ((int32_t)1));
	assert(columns == ((int32_t)6));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_6();
	(void)Assign_float64_t_1D_6(&self->_data, array);
	(void)Assign_float64_t_1D_6(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct MatrixData_10 *MatrixData_20_Zeros_10(int32_t rows, int32_t columns)
{
	struct MatrixData_10 *result = NULL;
	struct MatrixData_10 *matrixData = NULL;

	assert(rows == ((int32_t)1));
	assert(columns == ((int32_t)6));
	matrixData = New_MatrixData_10();
	MatrixData_10_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData_10(&result, matrixData);
	(void)Assign_MatrixData_10(&matrixData, NULL);
	return result;
}

struct MatrixData_10 *Matrix_8_get_MatrixData(struct Matrix_8 *const self)
{
	struct MatrixData_10 *result = NULL;

	if (!(self->_matrix != NULL))
	{
		struct MatrixData_10 *matrixData = NULL;

		matrixData = MatrixData_20_Zeros_10(self->Rows, self->Columns);
		(void)Assign_MatrixData_10(&self->_matrix, matrixData);
		(void)Assign_MatrixData_10(&matrixData, NULL);
	}
	(void)Assign_MatrixData_10(&result, self->_matrix);
	return result;
}

struct float64_t_1D_6 *MatrixData_10_get_DataReference(struct MatrixData_10 *const self)
{
	struct float64_t_1D_6 *result = NULL;

	(void)Assign_float64_t_1D_6(&result, self->_data);
	return result;
}

static void MatrixData_10_SetValueFast(struct MatrixData_10 *const self, float64_t value, int32_t row, int32_t column)
{
	struct float64_t_1D_6 *array = NULL;

	array = MatrixData_10_get_DataReference(self);
	array->Elements[(column * self->Rows) + row] = value;
	(void)Assign_float64_t_1D_6(&array, NULL);
}

void MatrixData_10_set_Item(struct MatrixData_10 *const self, int32_t row, int32_t column, float64_t value)
{
	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	MatrixData_10_SetValueFast(self, value, row, column);
}

static void Matrix_8_MatrixChanged(struct Matrix_8 *const self)
{
	(void)Assign_MatrixData(&self->CachedTranspose, NULL);
}

void Matrix_8_set_Item(struct Matrix_8 *const self, int32_t row, int32_t column, float64_t value)
{
	struct MatrixData_10 *matrixData = NULL;

	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	matrixData = Matrix_8_get_MatrixData(self);
	MatrixData_10_set_Item(matrixData, row, column, value);
	(void)Assign_MatrixData_10(&matrixData, NULL);
	Matrix_8_MatrixChanged(self);
}

void Matrix_8_set_Item_1(struct Matrix_8 *const self, float64_t row, float64_t column, float64_t value)
{
	Matrix_8_set_Item(self, (int32_t)row, (int32_t)column, value);
}

void VelocMeasuModel_FillTransMatrix(struct VelocityMeasurementModel *const self, struct Matrix_8 **H)
{
	struct Matrix_8 *arg_2E_0 = NULL;
	struct VelocitySpace *measureIdxs = NULL;
	float64_t arg_2E_1 = 0.0;
	float64_t double_ = 0.0;
	struct CTRASpace *stateIdxs = NULL;
	struct Matrix_8 *matrix = NULL;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;

	(void)Assign_Matrix_8(&arg_2E_0, *H);
	(void)Assign_VelocitySpace(&measureIdxs, VelociMeasurModel_1_MeasureIdxs);
	double_ = VelocitySpace_get_V(measureIdxs);
	arg_2E_1 = double_;
	(void)Assign_CTRASpace(&stateIdxs, VelocitMeasureModel_1_StateIdxs);
	(void)Assign_Matrix_8(&matrix, arg_2E_0);
	double__1 = arg_2E_1;
	double__2 = CTRASpace_get_V(stateIdxs);
	double__3 = VelocMeasuModel_get_VelociScale(self);
	Matrix_8_set_Item_1(matrix, double__1, double__2, double__3);
	(void)Assign_Matrix_8(&matrix, NULL);
	RemRef_Matrix_8(arg_2E_0);
	RemRef_VelocitySpace(measureIdxs);
	RemRef_CTRASpace(stateIdxs);
}

void MeasurModel_8_FillTransitMatrix(struct VelocityMeasurementModel *const self, struct CTRASpace *predictedStateExpectation, struct Matrix_8 **H)
{
	VelocMeasuModel_FillTransMatrix(self, H);
}

struct Matrix_8 *MeasurModel_4_get_TransitMatrix(struct VelocityMeasurementModel *const self)
{
	struct Matrix_8 *result = NULL;
	struct Matrix_8 *matrix = NULL;
	struct CTRASpace *ctraSpace = NULL;
	struct Matrix_8 *result_1 = NULL;

	matrix = New_Matrix_8();
	Matrix_8_ctor(matrix);
	(void)Assign_Matrix_8(&result, matrix);
	(void)Assign_Matrix_8(&matrix, NULL);
	ctraSpace = MeasurementModel_get_Condition(&self->base.base.base);
	MeasurModel_8_FillTransitMatrix(self, ctraSpace, &result);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	(void)Assign_Matrix_8(&result_1, result);
	RemRef_Matrix_8(result);
	return result_1;
}

void LinearAlgebra_MatrixMultiply_3(struct LinearAlgebra *const self, struct float64_t_1D_6 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_36 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_6 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)6) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)36) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)6) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)6) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)36) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)36) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)6) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)6) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_10 *MatrixMath_Multiply_6(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_10 *left, struct MatrixData_11 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_10 *matrixData = NULL;
	struct MatrixData_10 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_6 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_36 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_6 *array_2 = NULL;
	struct MatrixData_10 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == false);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Columns;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_10();
	MatrixData_10_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_10(&matrixData, matrixData_1);
	(void)Assign_MatrixData_10(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_10_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_11_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_10_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_3(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_6(&array, NULL);
	(void)Assign_float64_t_1D_36(&array_1, NULL);
	(void)Assign_float64_t_1D_6(&array_2, NULL);
	(void)Assign_MatrixData_10(&result, matrixData);
	RemRef_MatrixData_10(matrixData);
	return result;
}

void LinearAlgebra_MatrixMultiply_4(struct LinearAlgebra *const self, struct float64_t_1D_6 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_6 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_1 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)6) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)6) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)6) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)6) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)6) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)6) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)6) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)1) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_3 *MatrixMath_Multiply_7(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_10 *left, struct MatrixData_10 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_3 *matrixData = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_6 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_6 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_1 *array_2 = NULL;
	struct MatrixData_3 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == true);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Rows;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_3();
	MatrixData_3_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_3(&matrixData, matrixData_1);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_10_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_10_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_3_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_4(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_6(&array, NULL);
	(void)Assign_float64_t_1D_6(&array_1, NULL);
	(void)Assign_float64_t_1D_1(&array_2, NULL);
	(void)Assign_MatrixData_3(&result, matrixData);
	RemRef_MatrixData_3(matrixData);
	return result;
}

struct MatrixData_3 *MatrixMath_Multiply_8(bool_t transposeFirst, bool_t transposeSecond, bool_t transposeThird, struct MatrixData_10 *first, struct MatrixData_11 *second, struct MatrixData_10 *third)
{
	struct MatrixData_10 *left = NULL;
	struct MatrixData_10 *matrixData = NULL;
	struct MatrixData_3 *result = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;

	assert(transposeFirst == false);
	assert(transposeSecond == false);
	assert(transposeThird == true);
	if (!(first != NULL))
	{
		abort();
	}
	if (!(second != NULL))
	{
		abort();
	}
	if (!(third != NULL))
	{
		abort();
	}
	matrixData = MatrixMath_Multiply_6(transposeFirst, transposeSecond, first, second);
	(void)Assign_MatrixData_10(&left, matrixData);
	(void)Assign_MatrixData_10(&matrixData, NULL);
	matrixData_1 = MatrixMath_Multiply_7(false, transposeThird, left, third);
	(void)Assign_MatrixData_3(&result, matrixData_1);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
	RemRef_MatrixData_10(left);
	return result;
}

struct PositiveDefiniteMatrix *MeasuremModel_get_NoiseCovarian(struct MeasurementModel *const self)
{
	struct PositiveDefiniteMatrix *result = NULL;

	(void)Assign_PositiveDefiniteMatrix(&result, self->_measurementNoiseCovariance);
	return result;
}

struct PositiveDefiniteMatrix *MeasurementModel_get_Covariance(struct MeasurementModel *const self)
{
	struct PositiveDefiniteMatrix *result = NULL;
	struct PositiveDefiniteMatrix *positiveDefiniteMatrix = NULL;

	positiveDefiniteMatrix = MeasuremModel_get_NoiseCovarian(self);
	(void)Assign_PositiveDefiniteMatrix(&result, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix(&positiveDefiniteMatrix, NULL);
	return result;
}

struct MatrixData_3 *MatrixMath_Add_1(struct MatrixData_3 *left, struct MatrixData_3 *right)
{
	struct MatrixData_3 *matrixData = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;
	struct float64_t_1D_1 *dataReference = NULL;
	struct float64_t_1D_1 *array = NULL;
	struct float64_t_1D_1 *dataReference2 = NULL;
	struct float64_t_1D_1 *array_1 = NULL;
	struct float64_t_1D_1 *dataReference3 = NULL;
	struct float64_t_1D_1 *array_2 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_3 *result = NULL;
	struct MatrixData_3 *matrixData2 = NULL;
	struct MatrixData_3 *matrixData_2 = NULL;
	struct float64_t_1D_1 *dataReference4 = NULL;
	struct float64_t_1D_1 *array_3 = NULL;
	struct float64_t_1D_1 *dataReference5 = NULL;
	struct float64_t_1D_1 *array_4 = NULL;
	struct float64_t_1D_1 *dataReference6 = NULL;
	struct float64_t_1D_1 *array_5 = NULL;
	int32_t num = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	struct MatrixData_3 *matrixData3 = NULL;
	struct MatrixData_3 *matrixData_3 = NULL;
	struct float64_t_1D_1 *dataReference7 = NULL;
	struct float64_t_1D_1 *array_6 = NULL;
	struct float64_t_1D_1 *dataReference8 = NULL;
	struct float64_t_1D_1 *array_7 = NULL;
	struct float64_t_1D_1 *dataReference9 = NULL;
	struct float64_t_1D_1 *array_8 = NULL;
	int32_t num2 = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t m = ((int32_t)0);

	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData_3();
	MatrixData_3_ctor(matrixData_1, left->Rows, right->Columns);
	(void)Assign_MatrixData_3(&matrixData, matrixData_1);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
	array = MatrixData_3_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_1(&dataReference, array);
	(void)Assign_float64_t_1D_1(&array, NULL);
	array_1 = MatrixData_3_get_DataReference(left);
	(void)Assign_float64_t_1D_1(&dataReference2, array_1);
	(void)Assign_float64_t_1D_1(&array_1, NULL);
	array_2 = MatrixData_3_get_DataReference(right);
	(void)Assign_float64_t_1D_1(&dataReference3, array_2);
	(void)Assign_float64_t_1D_1(&array_2, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)1))
	{
		dataReference->Elements[i] = dataReference2->Elements[i] + dataReference3->Elements[i];
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_3(&result, matrixData);
	RemRef_MatrixData_3(matrixData);
	RemRef_float64_t_1D_1(dataReference);
	RemRef_float64_t_1D_1(dataReference2);
	RemRef_float64_t_1D_1(dataReference3);
	RemRef_MatrixData_3(matrixData2);
	RemRef_float64_t_1D_1(dataReference4);
	RemRef_float64_t_1D_1(dataReference5);
	RemRef_float64_t_1D_1(dataReference6);
	RemRef_MatrixData_3(matrixData3);
	RemRef_float64_t_1D_1(dataReference7);
	RemRef_float64_t_1D_1(dataReference8);
	RemRef_float64_t_1D_1(dataReference9);
	return result;
	matrixData_2 = New_MatrixData_3();
	MatrixData_3_ctor(matrixData_2, left->Rows, right->Columns);
	(void)Assign_MatrixData_3(&matrixData2, matrixData_2);
	(void)Assign_MatrixData_3(&matrixData_2, NULL);
	array_3 = MatrixData_3_get_DataReference(matrixData2);
	(void)Assign_float64_t_1D_1(&dataReference4, array_3);
	(void)Assign_float64_t_1D_1(&array_3, NULL);
	array_4 = MatrixData_3_get_DataReference(left);
	(void)Assign_float64_t_1D_1(&dataReference5, array_4);
	(void)Assign_float64_t_1D_1(&array_4, NULL);
	array_5 = MatrixData_3_get_DataReference(right);
	(void)Assign_float64_t_1D_1(&dataReference6, array_5);
	(void)Assign_float64_t_1D_1(&array_5, NULL);
	num = ((int32_t)0);
	j = ((int32_t)0);
	while (j < right->Columns)
	{
		k = ((int32_t)0);
		while (k < left->Rows)
		{
			dataReference4->Elements[num] = dataReference5->Elements[k] + dataReference6->Elements[num];
			num = num + ((int32_t)1);
			k = k + ((int32_t)1);
		}
		j = j + ((int32_t)1);
	}
	(void)Assign_MatrixData_3(&result, matrixData2);
	RemRef_MatrixData_3(matrixData);
	RemRef_float64_t_1D_1(dataReference);
	RemRef_float64_t_1D_1(dataReference2);
	RemRef_float64_t_1D_1(dataReference3);
	RemRef_MatrixData_3(matrixData2);
	RemRef_float64_t_1D_1(dataReference4);
	RemRef_float64_t_1D_1(dataReference5);
	RemRef_float64_t_1D_1(dataReference6);
	RemRef_MatrixData_3(matrixData3);
	RemRef_float64_t_1D_1(dataReference7);
	RemRef_float64_t_1D_1(dataReference8);
	RemRef_float64_t_1D_1(dataReference9);
	return result;
	matrixData_3 = New_MatrixData_3();
	MatrixData_3_ctor(matrixData_3, left->Rows, left->Columns);
	(void)Assign_MatrixData_3(&matrixData3, matrixData_3);
	(void)Assign_MatrixData_3(&matrixData_3, NULL);
	array_6 = MatrixData_3_get_DataReference(matrixData3);
	(void)Assign_float64_t_1D_1(&dataReference7, array_6);
	(void)Assign_float64_t_1D_1(&array_6, NULL);
	array_7 = MatrixData_3_get_DataReference(left);
	(void)Assign_float64_t_1D_1(&dataReference8, array_7);
	(void)Assign_float64_t_1D_1(&array_7, NULL);
	array_8 = MatrixData_3_get_DataReference(right);
	(void)Assign_float64_t_1D_1(&dataReference9, array_8);
	(void)Assign_float64_t_1D_1(&array_8, NULL);
	num2 = ((int32_t)0);
	l = ((int32_t)0);
	while (l < left->Columns)
	{
		m = ((int32_t)0);
		while (m < left->Rows)
		{
			dataReference7->Elements[num2] = dataReference8->Elements[num2] + dataReference9->Elements[m];
			num2 = num2 + ((int32_t)1);
			m = m + ((int32_t)1);
		}
		l = l + ((int32_t)1);
	}
	(void)Assign_MatrixData_3(&result, matrixData3);
	RemRef_MatrixData_3(matrixData);
	RemRef_float64_t_1D_1(dataReference);
	RemRef_float64_t_1D_1(dataReference2);
	RemRef_float64_t_1D_1(dataReference3);
	RemRef_MatrixData_3(matrixData2);
	RemRef_float64_t_1D_1(dataReference4);
	RemRef_float64_t_1D_1(dataReference5);
	RemRef_float64_t_1D_1(dataReference6);
	RemRef_MatrixData_3(matrixData3);
	RemRef_float64_t_1D_1(dataReference7);
	RemRef_float64_t_1D_1(dataReference8);
	RemRef_float64_t_1D_1(dataReference9);
	return result;
	abort();
}

void MatrixData_3_set_Item_1(struct MatrixData_3 *const self, int32_t row, int32_t column, float64_t value)
{
	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	MatrixData_3_SetValueFast(self, value, row, column);
}

void PositiveDefiniteMatrix_ctor_1(struct PositiveDefiniteMatrix *const self)
{
	SquareMatrix_ctor(&self->base);
}

struct PositiveDefiniteMatrix *PositiveDefiniteMatrix_9_Create(struct MatrixData_3 *matrix)
{
	struct PositiveDefiniteMatrix *result = NULL;
	struct PositiveDefiniteMatrix *positiveDefiniteMatrix = NULL;

	positiveDefiniteMatrix = New_PositiveDefiniteMatrix();
	PositiveDefiniteMatrix_ctor_1(positiveDefiniteMatrix);
	Matrix_set_UncheckedMatrixData(&positiveDefiniteMatrix->base.base, matrix);
	(void)Assign_PositiveDefiniteMatrix(&result, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix(&positiveDefiniteMatrix, NULL);
	return result;
}

struct PositiveDefiniteMatrix *PositDefinMatri_9_CreatAndCorre(struct MatrixData_3 *matrix)
{
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	float64_t num = 0.0;
	float64_t num2 = 0.0;
	float64_t value = 0.0;
	struct PositiveDefiniteMatrix *result = NULL;
	struct PositiveDefiniteMatrix *positiveDefiniteMatrix = NULL;

	i = ((int32_t)0);
	while (i < matrix->Rows)
	{
		float64_t double_ = 0.0;

		double_ = MatrixData_3_get_Item(matrix, i, i);
		if (!(double_ > 0.0))
		{
			MatrixData_3_set_Item_1(matrix, i, i, 4.94065645841247E-324);
		}
		j = ((int32_t)0);
		while (j < i)
		{
			float64_t double__1 = 0.0;
			float64_t double__2 = 0.0;
			float64_t double__3 = 0.0;
			float64_t double__4 = 0.0;
			float64_t double__5 = 0.0;
			float64_t double__6 = 0.0;

			double__1 = MatrixData_3_get_Item(matrix, i, j);
			double__2 = MatrixData_3_get_Item(matrix, j, i);
			num = (double__1 + double__2) / 2.0;
			double__3 = MatrixData_3_get_Item(matrix, i, i);
			double__4 = MatrixData_3_get_Item(matrix, j, j);
			double__5 = Math_Sqrt(double__3 * double__4);
			num2 = 1.0 * double__5;
			double__6 = Math_Abs(num);
			if (!(double__6 <= num2))
			{
				int32_t int32 = ((int32_t)0);
				float64_t double__7 = 0.0;

				int32 = Math_Sign(num);
				double__7 = (float64_t)int32;
				value = double__7 * num2;
			}
			else
			{
				value = num;
			}
			MatrixData_3_set_Item_1(matrix, i, j, value);
			MatrixData_3_set_Item_1(matrix, j, i, value);
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	positiveDefiniteMatrix = PositiveDefiniteMatrix_9_Create(matrix);
	(void)Assign_PositiveDefiniteMatrix(&result, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix(&positiveDefiniteMatrix, NULL);
	return result;
}

struct MatrixData_3 *MatrixMath_Multiply_9(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_10 *left, struct MatrixData_9 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_3 *matrixData = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_6 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_6 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_1 *array_2 = NULL;
	struct MatrixData_3 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == false);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Columns;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_3();
	MatrixData_3_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_3(&matrixData, matrixData_1);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_10_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_9_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_3_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_4(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_6(&array, NULL);
	(void)Assign_float64_t_1D_6(&array_1, NULL);
	(void)Assign_float64_t_1D_1(&array_2, NULL);
	(void)Assign_MatrixData_3(&result, matrixData);
	RemRef_MatrixData_3(matrixData);
	return result;
}

struct MatrixData_3 *MatrixMath_Multiply_10(struct MatrixData_10 *left, struct MatrixData_9 *right)
{
	struct MatrixData_3 *result = NULL;
	struct MatrixData_3 *matrixData = NULL;

	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	matrixData = MatrixMath_Multiply_9(false, false, left, right);
	(void)Assign_MatrixData_3(&result, matrixData);
	(void)Assign_MatrixData_3(&matrixData, NULL);
	return result;
}

void MeasurementModel_8_h(struct VelocityMeasurementModel *const self, struct CTRASpace *state, struct VelocitySpace **predictedMeasurement)
{
	struct Matrix_8 *matrix = NULL;
	struct Matrix_8 *matrix_1 = NULL;
	struct VelocitySpace **velocitySpace = NULL;
	struct MatrixData_10 *matrixData = NULL;
	struct MatrixData_9 *matrixData_1 = NULL;
	struct MatrixData_3 *matrixData_2 = NULL;

	matrix_1 = New_Matrix_8();
	Matrix_8_ctor(matrix_1);
	(void)Assign_Matrix_8(&matrix, matrix_1);
	(void)Assign_Matrix_8(&matrix_1, NULL);
	VelocMeasuModel_FillTransMatrix(self, &matrix);
	velocitySpace = predictedMeasurement;
	matrixData = Matrix_8_get_MatrixData(matrix);
	matrixData_1 = Space_5_get_MatrixData(&(*&state)->base.base);
	matrixData_2 = MatrixMath_Multiply_10(matrixData, matrixData_1);
	Space_1_set_MatrixData(&(*velocitySpace)->base, matrixData_2);
	(void)Assign_MatrixData_10(&matrixData, NULL);
	(void)Assign_MatrixData_9(&matrixData_1, NULL);
	(void)Assign_MatrixData_3(&matrixData_2, NULL);
	RemRef_Matrix_8(matrix);
}

struct VelocitySpace *MeasuremenModel_get_Expectation(struct VelocityMeasurementModel *const self)
{
	struct VelocitySpace *result = NULL;
	struct VelocitySpace *velocitySpace = NULL;
	struct CTRASpace *ctraSpace = NULL;
	struct VelocitySpace *result_1 = NULL;

	velocitySpace = New_VelocitySpace();
	VelocitySpace_ctor(velocitySpace);
	(void)Assign_VelocitySpace(&result, velocitySpace);
	(void)Assign_VelocitySpace(&velocitySpace, NULL);
	ctraSpace = MeasurementModel_get_Condition(&self->base.base.base);
	MeasurementModel_8_h(self, ctraSpace, &result);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	(void)Assign_VelocitySpace(&result_1, result);
	RemRef_VelocitySpace(result);
	return result_1;
}

static void Gaussian_7_cctor(void)
{
	struct VelocitySpace *velocitySpace = NULL;

	velocitySpace = New_VelocitySpace();
	VelocitySpace_ctor(velocitySpace);
	(void)Assign_VelocitySpace(&Gaussian_7_EmptySpace, velocitySpace);
	(void)Assign_VelocitySpace(&velocitySpace, NULL);
}

static void RemRef_Gaussian(struct Gaussian *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Gaussian.CurrentCount--;
		Res_Gaussian.Next[Res_Gaussian.CurrentCount] = self;
		Del_Gaussian(self);
	}
}

struct Gaussian *New_Gaussian(void)
{
	static struct Gaussian const Default_Gaussian = { 1 };
	struct Gaussian *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Gaussian.CurrentCount == RC_Gaussian)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Gaussian.Next[Res_Gaussian.CurrentCount];
	Res_Gaussian.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Gaussian.MaximumCount = (Res_Gaussian.CurrentCount > Res_Gaussian.MaximumCount) ? Res_Gaussian.CurrentCount : Res_Gaussian.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Gaussian;
	return instance;
}

struct Gaussian *Assign_Gaussian(struct Gaussian **const left, struct Gaussian *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Gaussian(*left);
	*left = right;
	return right;
}

static void Gaussian_set_Expectation(struct Gaussian *const self, struct VelocitySpace *value)
{
	(void)Assign_VelocitySpace(&self->Expectation, value);
}

static void Gaussian_ResetCachedValues(struct Gaussian *const self)
{
	struct Nullable_2 nullable = { 0 };

	self->NormalizationFactor = nullable;
}

static void Gaussian_set_Covariance(struct Gaussian *const self, struct PositiveDefiniteMatrix *value)
{
	Gaussian_ResetCachedValues(self);
	(void)Assign_PositiveDefiniteMatrix(&self->covariance, value);
}

static void Gaussian_ctor(struct Gaussian *const self, bool_t noInitialization)
{
	struct VelocitySpace *velocitySpace = NULL;
	struct PositiveDefiniteMatrix *positiveDefiniteMatrix = NULL;

	Object_ctor(&self->base);
	self->_dimensions = (&Gaussian_7_EmptySpace->base)->Dimensions;
	if (!!noInitialization)
	{
		return;
	}
	velocitySpace = New_VelocitySpace();
	VelocitySpace_ctor(velocitySpace);
	Gaussian_set_Expectation(self, velocitySpace);
	(void)Assign_VelocitySpace(&velocitySpace, NULL);
	positiveDefiniteMatrix = New_PositiveDefiniteMatrix();
	PositiveDefiniteMatrix_ctor_1(positiveDefiniteMatrix);
	Gaussian_set_Covariance(self, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix(&positiveDefiniteMatrix, NULL);
}

struct Gaussian *Gaussian_7_Create(struct VelocitySpace *expectation, struct PositiveDefiniteMatrix *covariance)
{
	struct Gaussian *result = NULL;
	struct Gaussian *gaussian = NULL;

	gaussian = New_Gaussian();
	Gaussian_ctor(gaussian, true);
	Gaussian_set_Expectation(gaussian, expectation);
	Gaussian_set_Covariance(gaussian, covariance);
	(void)Assign_Gaussian(&result, gaussian);
	(void)Assign_Gaussian(&gaussian, NULL);
	return result;
}

struct Gaussian *EKF_PredictMeasurement(struct Gaussian_4 *predictedState, struct VelocityMeasurementModel *measurementModel, struct Matrix_8 **transitionMatrix)
{
	struct CTRASpace *ctraSpace = NULL;
	struct Matrix_8 **matrix = NULL;
	struct Matrix_8 *matrix_1 = NULL;
	struct MatrixData_10 *matrixData = NULL;
	struct MatrixData_10 *matrixData_1 = NULL;
	struct MatrixData_3 *matrix_2 = NULL;
	struct MatrixData_10 *matrixData_2 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix = NULL;
	struct MatrixData_11 *matrixData_3 = NULL;
	struct MatrixData_3 *matrixData_4 = NULL;
	struct PositiveDefiniteMatrix *positiveDefiniteMatrix_1 = NULL;
	struct MatrixData_3 *matrixData_5 = NULL;
	struct MatrixData_3 *matrixData_6 = NULL;
	struct PositiveDefiniteMatrix *covariance = NULL;
	struct PositiveDefiniteMatrix *positiveDefiniteMatrix_2 = NULL;
	struct Gaussian *result = NULL;
	struct VelocitySpace *velocitySpace = NULL;
	struct Gaussian *gaussian = NULL;

	if (!(__ContrRunti_1_insidContrEvalua > ((int32_t)4)))
	{
		bool_t boolean = false;
		bool_t boolean_1 = false;

		__ContrRunti_1_insidContrEvalua = __ContrRunti_1_insidContrEvalua + ((int32_t)1);
		boolean = Object_2_ReferenceEquals(&predictedState->base, NULL);
		if (!!boolean)
		{
			abort();
		}
		boolean_1 = Object_2_ReferenceEquals(&measurementModel->base.base.base.base, NULL);
		if (!!boolean_1)
		{
			abort();
		}
		__ContrRunti_1_insidContrEvalua = __ContrRunti_1_insidContrEvalua - ((int32_t)1);
	}
	ctraSpace = Gaussian_4_get_Expectation(predictedState);
	MeasurementModel_set_Condition(&(*&measurementModel)->base.base.base, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	matrix = transitionMatrix;
	matrix_1 = MeasurModel_4_get_TransitMatrix(measurementModel);
	(void)Assign_Matrix_8(&*matrix, matrix_1);
	(void)Assign_Matrix_8(&matrix_1, NULL);
	matrixData_1 = Matrix_8_get_MatrixData(*transitionMatrix);
	(void)Assign_MatrixData_10(&matrixData, matrixData_1);
	(void)Assign_MatrixData_10(&matrixData_1, NULL);
	(void)Assign_MatrixData_10(&matrixData_2, matrixData);
	positiveDefiniteMatrix = Gaussian_4_get_Covariance(predictedState);
	matrixData_3 = Matrix_6_get_MatrixData(&positiveDefiniteMatrix->base.base);
	matrixData_4 = MatrixMath_Multiply_8(false, false, true, matrixData_2, matrixData_3, matrixData);
	positiveDefiniteMatrix_1 = MeasurementModel_get_Covariance(&(*&measurementModel)->base.base.base);
	matrixData_5 = Matrix_get_MatrixData(&positiveDefiniteMatrix_1->base.base);
	matrixData_6 = MatrixMath_Add_1(matrixData_4, matrixData_5);
	(void)Assign_MatrixData_3(&matrix_2, matrixData_6);
	(void)Assign_MatrixData_10(&matrixData_2, NULL);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix, NULL);
	(void)Assign_MatrixData_11(&matrixData_3, NULL);
	(void)Assign_MatrixData_3(&matrixData_4, NULL);
	(void)Assign_PositiveDefiniteMatrix(&positiveDefiniteMatrix_1, NULL);
	(void)Assign_MatrixData_3(&matrixData_5, NULL);
	(void)Assign_MatrixData_3(&matrixData_6, NULL);
	positiveDefiniteMatrix_2 = PositDefinMatri_9_CreatAndCorre(matrix_2);
	(void)Assign_PositiveDefiniteMatrix(&covariance, positiveDefiniteMatrix_2);
	(void)Assign_PositiveDefiniteMatrix(&positiveDefiniteMatrix_2, NULL);
	velocitySpace = MeasuremenModel_get_Expectation(measurementModel);
	gaussian = Gaussian_7_Create(velocitySpace, covariance);
	(void)Assign_Gaussian(&result, gaussian);
	(void)Assign_VelocitySpace(&velocitySpace, NULL);
	(void)Assign_Gaussian(&gaussian, NULL);
	RemRef_MatrixData_10(matrixData);
	RemRef_MatrixData_3(matrix_2);
	RemRef_PositiveDefiniteMatrix(covariance);
	return result;
}

struct PositiveDefiniteMatrix *Gaussian_get_Covariance(struct Gaussian *const self)
{
	struct PositiveDefiniteMatrix *result = NULL;

	Gaussian_ResetCachedValues(self);
	(void)Assign_PositiveDefiniteMatrix(&result, self->covariance);
	return result;
}

struct MatrixData_3 *MatrixData_20_Eye_2(int32_t rows, int32_t columns)
{
	struct MatrixData_3 *matrixData = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;
	int32_t num = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	struct MatrixData_3 *result = NULL;

	assert(rows == ((int32_t)1));
	assert(columns == ((int32_t)1));
	matrixData_1 = New_MatrixData_3();
	MatrixData_3_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_3(&matrixData, matrixData_1);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
	int32 = Math_Min(rows, columns);
	num = int32;
	i = ((int32_t)0);
	while (i < num)
	{
		MatrixData_3_SetValueFast(matrixData, 1.0, i, i);
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_3(&result, matrixData);
	RemRef_MatrixData_3(matrixData);
	return result;
}

struct MatrixData_3 *MatrixData_3_get_Copy(struct MatrixData_3 *const self)
{
	struct MatrixData_3 *result = NULL;
	struct MatrixData_3 *matrixData = NULL;

	matrixData = New_MatrixData_3();
	MatrixData_3_ctor_2(matrixData, self->_data, self->Rows, self->Columns, false);
	(void)Assign_MatrixData_3(&result, matrixData);
	(void)Assign_MatrixData_3(&matrixData, NULL);
	return result;
}

void LinearAlgebra_FactorLU(struct LinearAlgebra *const self, struct float64_t_1D_1 *a, int32_t rows, struct int32_t_1D_1 *pivotIndices)
{
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	float64_t num4 = 0.0;
	int32_t j = ((int32_t)0);
	float64_t num5 = 0.0;
	int32_t k = ((int32_t)0);
	float64_t num6 = 0.0;
	int32_t l = ((int32_t)0);
	int32_t expr_150_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t expr_187_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rows > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)1) % rows) != ((int32_t)0)))
	{
		abort();
	}
	num = ((int32_t)1) / rows;
	int32 = Math_Min(num, rows);
	num2 = int32;
	if (!(pivotIndices != NULL))
	{
		abort();
	}
	if (!(((int32_t)1) == num2))
	{
		abort();
	}
	i = ((int32_t)0);
	while (i < num2)
	{
		num3 = i;
		num4 = 0.0;
		j = i;
		while (j < num)
		{
			float64_t double_ = 0.0;

			double_ = Math_Abs(a->Elements[(i * rows) + j]);
			num5 = double_;
			if (!(num5 <= num4))
			{
				num4 = num5;
				num3 = j;
			}
			j = j + ((int32_t)1);
		}
		pivotIndices->Elements[i] = num3 + ((int32_t)1);
		if (!!(a->Elements[(i * rows) + num3] == 0.0))
		{
			abort();
		}
		if (!(num3 == i))
		{
			k = ((int32_t)0);
			while (k < num)
			{
				num6 = a->Elements[(k * rows) + num3];
				a->Elements[(k * rows) + num3] = a->Elements[(k * rows) + i];
				a->Elements[(k * rows) + i] = num6;
				k = k + ((int32_t)1);
			}
		}
		if (!(a->Elements[(i * rows) + i] == 1.0))
		{
			l = i + ((int32_t)1);
			while (l < rows)
			{
				expr_150_cp_1 = (i * rows) + l;
				a->Elements[expr_150_cp_1] = a->Elements[expr_150_cp_1] / a->Elements[(i * rows) + i];
				l = l + ((int32_t)1);
			}
		}
		m = i + ((int32_t)1);
		while (m < num)
		{
			n = i + ((int32_t)1);
			while (n < rows)
			{
				expr_187_cp_1 = (m * rows) + n;
				a->Elements[expr_187_cp_1] = a->Elements[expr_187_cp_1] - (a->Elements[(m * rows) + i] * a->Elements[(i * rows) + n]);
				n = n + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
}

static void LinearAlgebr_1_SolveUpperTriang(struct float64_t_1D_1 *a, int32_t lda, int32_t rank, struct float64_t_1D_1 *b, int32_t ldb, int32_t rightHandSides, bool_t ignoreDiagonal)
{
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t expr_23_cp_1 = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t expr_41_cp_1 = ((int32_t)0);

	i = ((int32_t)0);
	while (i < rightHandSides)
	{
		j = rank - ((int32_t)1);
		while (j >= ((int32_t)0))
		{
			if (!ignoreDiagonal)
			{
				expr_23_cp_1 = (i * ldb) + j;
				b->Elements[expr_23_cp_1] = b->Elements[expr_23_cp_1] / a->Elements[(j * lda) + j];
			}
			k = ((int32_t)0);
			while (k < j)
			{
				expr_41_cp_1 = (i * ldb) + k;
				b->Elements[expr_41_cp_1] = b->Elements[expr_41_cp_1] - (b->Elements[(i * ldb) + j] * a->Elements[(j * lda) + k]);
				k = k + ((int32_t)1);
			}
			j = j - ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
}

void LinearAlgebra_SolveLU(struct LinearAlgebra *const self, struct float64_t_1D_1 *a, int32_t rows, struct int32_t_1D_1 *pivotIndices, struct float64_t_1D_1 *b)
{
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t j = ((int32_t)0);
	float64_t num5 = 0.0;
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t expr_16A_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rows > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)1) % rows) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!!((((int32_t)1) % rows) != ((int32_t)0)))
	{
		abort();
	}
	num = ((int32_t)1) / rows;
	num2 = ((int32_t)1) / rows;
	int32 = Math_Min(num, rows);
	num3 = int32;
	if (!(pivotIndices != NULL))
	{
		abort();
	}
	if (!(((int32_t)1) == num3))
	{
		abort();
	}
	if (!(num <= rows))
	{
		abort();
	}
	i = ((int32_t)0);
	while (i < num3)
	{
		num4 = pivotIndices->Elements[i] - ((int32_t)1);
		if (!(num4 == i))
		{
			j = ((int32_t)0);
			while (j < num2)
			{
				num5 = b->Elements[(j * rows) + num4];
				b->Elements[(j * rows) + num4] = b->Elements[(j * rows) + i];
				b->Elements[(j * rows) + i] = num5;
				j = j + ((int32_t)1);
			}
		}
		i = i + ((int32_t)1);
	}
	k = ((int32_t)0);
	while (k < num2)
	{
		l = ((int32_t)0);
		while (l < num3)
		{
			m = l + ((int32_t)1);
			while (m < num3)
			{
				expr_16A_cp_1 = (k * rows) + m;
				b->Elements[expr_16A_cp_1] = b->Elements[expr_16A_cp_1] - (b->Elements[(k * rows) + l] * a->Elements[(l * rows) + m]);
				m = m + ((int32_t)1);
			}
			l = l + ((int32_t)1);
		}
		k = k + ((int32_t)1);
	}
	LinearAlgebr_1_SolveUpperTriang(a, rows, num3, b, rows, num2, false);
}

struct MatrixData_3 *MatrixMath_LinsolveSquare(struct MatrixData_3 *left, struct MatrixData_3 *right)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t rows = ((int32_t)0);
	struct MatrixData_3 *copy = NULL;
	struct MatrixData_3 *matrixData = NULL;
	struct int32_t_1D_1 *pivotIndices = NULL;
	struct int32_t_1D_1 *array = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_1 *array_1 = NULL;
	struct MatrixData_3 *copy2 = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra_1 = NULL;
	struct float64_t_1D_1 *array_2 = NULL;
	int32_t int32 = ((int32_t)0);
	struct int32_t_1D_1 *array_3 = NULL;
	struct float64_t_1D_1 *array_4 = NULL;
	struct MatrixData_3 *result = NULL;

	if (!(left != NULL))
	{
		abort();
	}
	boolean = MatrixData_3_get_IsEmpty(left);
	if (!(right != NULL))
	{
		abort();
	}
	boolean_1 = MatrixData_3_get_IsEmpty(right);
	rows = left->Rows;
	matrixData = MatrixData_3_get_Copy(left);
	(void)Assign_MatrixData_3(&copy, matrixData);
	(void)Assign_MatrixData_3(&matrixData, NULL);
	array = New_int32_t_1D_1();
	(void)Assign_int32_t_1D_1(&pivotIndices, array);
	(void)Assign_int32_t_1D_1(&array, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array_1 = MatrixData_3_get_DataReference(copy);
	LinearAlgebra_FactorLU(linearAlgebra, array_1, rows, pivotIndices);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_1(&array_1, NULL);
	matrixData_1 = MatrixData_3_get_Copy(right);
	(void)Assign_MatrixData_3(&copy2, matrixData_1);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra_1, MatrixMath_LinearAlgebra);
	array_2 = MatrixData_3_get_DataReference(copy);
	int32 = copy->Rows;
	(void)Assign_int32_t_1D_1(&array_3, pivotIndices);
	array_4 = MatrixData_3_get_DataReference(copy2);
	LinearAlgebra_SolveLU(linearAlgebra_1, array_2, int32, array_3, array_4);
	(void)Assign_LinearAlgebra(&linearAlgebra_1, NULL);
	(void)Assign_float64_t_1D_1(&array_2, NULL);
	(void)Assign_int32_t_1D_1(&array_3, NULL);
	(void)Assign_float64_t_1D_1(&array_4, NULL);
	(void)Assign_MatrixData_3(&result, copy2);
	RemRef_MatrixData_3(copy);
	RemRef_int32_t_1D_1(pivotIndices);
	RemRef_MatrixData_3(copy2);
	return result;
}

void LinearAlgebra_MatrixMultiply_5(struct LinearAlgebra *const self, struct float64_t_1D_36 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_6 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_6 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)36) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)6) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)36) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)36) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)6) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)6) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)36) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)6) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_9 *MatrixMath_Multiply_11(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_11 *left, struct MatrixData_10 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_9 *matrixData = NULL;
	struct MatrixData_9 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_36 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_6 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_6 *array_2 = NULL;
	struct MatrixData_9 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == true);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Rows;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_9();
	MatrixData_9_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_9(&matrixData, matrixData_1);
	(void)Assign_MatrixData_9(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_11_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_10_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_9_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_5(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_36(&array, NULL);
	(void)Assign_float64_t_1D_6(&array_1, NULL);
	(void)Assign_float64_t_1D_6(&array_2, NULL);
	(void)Assign_MatrixData_9(&result, matrixData);
	RemRef_MatrixData_9(matrixData);
	return result;
}

void LinearAlgebra_MatrixMultiply_6(struct LinearAlgebra *const self, struct float64_t_1D_6 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_1 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_6 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)6) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)1) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)6) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)6) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)1) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)1) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)6) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)6) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_9 *MatrixMath_Multiply_12(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_9 *left, struct MatrixData_3 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_9 *matrixData = NULL;
	struct MatrixData_9 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_6 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_1 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_6 *array_2 = NULL;
	struct MatrixData_9 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == false);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Columns;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_9();
	MatrixData_9_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_9(&matrixData, matrixData_1);
	(void)Assign_MatrixData_9(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_9_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_3_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_9_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_6(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_6(&array, NULL);
	(void)Assign_float64_t_1D_1(&array_1, NULL);
	(void)Assign_float64_t_1D_6(&array_2, NULL);
	(void)Assign_MatrixData_9(&result, matrixData);
	RemRef_MatrixData_9(matrixData);
	return result;
}

struct MatrixData_9 *MatrixMath_Multiply_13(bool_t transposeFirst, bool_t transposeSecond, bool_t transposeThird, struct MatrixData_11 *first, struct MatrixData_10 *second, struct MatrixData_3 *third)
{
	struct MatrixData_9 *left = NULL;
	struct MatrixData_9 *matrixData = NULL;
	struct MatrixData_9 *result = NULL;
	struct MatrixData_9 *matrixData_1 = NULL;

	assert(transposeFirst == false);
	assert(transposeSecond == true);
	assert(transposeThird == false);
	if (!(first != NULL))
	{
		abort();
	}
	if (!(second != NULL))
	{
		abort();
	}
	if (!(third != NULL))
	{
		abort();
	}
	matrixData = MatrixMath_Multiply_11(transposeFirst, transposeSecond, first, second);
	(void)Assign_MatrixData_9(&left, matrixData);
	(void)Assign_MatrixData_9(&matrixData, NULL);
	matrixData_1 = MatrixMath_Multiply_12(false, transposeThird, left, third);
	(void)Assign_MatrixData_9(&result, matrixData_1);
	(void)Assign_MatrixData_9(&matrixData_1, NULL);
	RemRef_MatrixData_9(left);
	return result;
}

struct VelocitySpace *Gaussian_get_Expectation(struct Gaussian *const self)
{
	struct VelocitySpace *result = NULL;

	(void)Assign_VelocitySpace(&result, self->Expectation);
	return result;
}

struct MatrixData_3 *MatrixMath_Subtract(struct MatrixData_3 *left, struct MatrixData_3 *right)
{
	struct MatrixData_3 *matrixData = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;
	struct float64_t_1D_1 *dataReference = NULL;
	struct float64_t_1D_1 *array = NULL;
	struct float64_t_1D_1 *dataReference2 = NULL;
	struct float64_t_1D_1 *array_1 = NULL;
	struct float64_t_1D_1 *dataReference3 = NULL;
	struct float64_t_1D_1 *array_2 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_3 *result = NULL;
	struct MatrixData_3 *matrixData2 = NULL;
	struct MatrixData_3 *matrixData_2 = NULL;
	struct float64_t_1D_1 *dataReference4 = NULL;
	struct float64_t_1D_1 *array_3 = NULL;
	struct float64_t_1D_1 *dataReference5 = NULL;
	struct float64_t_1D_1 *array_4 = NULL;
	struct float64_t_1D_1 *dataReference6 = NULL;
	struct float64_t_1D_1 *array_5 = NULL;
	int32_t num = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	struct MatrixData_3 *matrixData3 = NULL;
	struct MatrixData_3 *matrixData_3 = NULL;
	struct float64_t_1D_1 *dataReference7 = NULL;
	struct float64_t_1D_1 *array_6 = NULL;
	struct float64_t_1D_1 *dataReference8 = NULL;
	struct float64_t_1D_1 *array_7 = NULL;
	struct float64_t_1D_1 *dataReference9 = NULL;
	struct float64_t_1D_1 *array_8 = NULL;
	int32_t num2 = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t m = ((int32_t)0);

	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData_3();
	MatrixData_3_ctor(matrixData_1, left->Rows, right->Columns);
	(void)Assign_MatrixData_3(&matrixData, matrixData_1);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
	array = MatrixData_3_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_1(&dataReference, array);
	(void)Assign_float64_t_1D_1(&array, NULL);
	array_1 = MatrixData_3_get_DataReference(left);
	(void)Assign_float64_t_1D_1(&dataReference2, array_1);
	(void)Assign_float64_t_1D_1(&array_1, NULL);
	array_2 = MatrixData_3_get_DataReference(right);
	(void)Assign_float64_t_1D_1(&dataReference3, array_2);
	(void)Assign_float64_t_1D_1(&array_2, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)1))
	{
		dataReference->Elements[i] = dataReference2->Elements[i] - dataReference3->Elements[i];
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_3(&result, matrixData);
	RemRef_MatrixData_3(matrixData);
	RemRef_float64_t_1D_1(dataReference);
	RemRef_float64_t_1D_1(dataReference2);
	RemRef_float64_t_1D_1(dataReference3);
	RemRef_MatrixData_3(matrixData2);
	RemRef_float64_t_1D_1(dataReference4);
	RemRef_float64_t_1D_1(dataReference5);
	RemRef_float64_t_1D_1(dataReference6);
	RemRef_MatrixData_3(matrixData3);
	RemRef_float64_t_1D_1(dataReference7);
	RemRef_float64_t_1D_1(dataReference8);
	RemRef_float64_t_1D_1(dataReference9);
	return result;
	matrixData_2 = New_MatrixData_3();
	MatrixData_3_ctor(matrixData_2, left->Rows, right->Columns);
	(void)Assign_MatrixData_3(&matrixData2, matrixData_2);
	(void)Assign_MatrixData_3(&matrixData_2, NULL);
	array_3 = MatrixData_3_get_DataReference(matrixData2);
	(void)Assign_float64_t_1D_1(&dataReference4, array_3);
	(void)Assign_float64_t_1D_1(&array_3, NULL);
	array_4 = MatrixData_3_get_DataReference(left);
	(void)Assign_float64_t_1D_1(&dataReference5, array_4);
	(void)Assign_float64_t_1D_1(&array_4, NULL);
	array_5 = MatrixData_3_get_DataReference(right);
	(void)Assign_float64_t_1D_1(&dataReference6, array_5);
	(void)Assign_float64_t_1D_1(&array_5, NULL);
	num = ((int32_t)0);
	j = ((int32_t)0);
	while (j < right->Columns)
	{
		k = ((int32_t)0);
		while (k < left->Rows)
		{
			dataReference4->Elements[num] = dataReference5->Elements[k] - dataReference6->Elements[num];
			num = num + ((int32_t)1);
			k = k + ((int32_t)1);
		}
		j = j + ((int32_t)1);
	}
	(void)Assign_MatrixData_3(&result, matrixData2);
	RemRef_MatrixData_3(matrixData);
	RemRef_float64_t_1D_1(dataReference);
	RemRef_float64_t_1D_1(dataReference2);
	RemRef_float64_t_1D_1(dataReference3);
	RemRef_MatrixData_3(matrixData2);
	RemRef_float64_t_1D_1(dataReference4);
	RemRef_float64_t_1D_1(dataReference5);
	RemRef_float64_t_1D_1(dataReference6);
	RemRef_MatrixData_3(matrixData3);
	RemRef_float64_t_1D_1(dataReference7);
	RemRef_float64_t_1D_1(dataReference8);
	RemRef_float64_t_1D_1(dataReference9);
	return result;
	matrixData_3 = New_MatrixData_3();
	MatrixData_3_ctor(matrixData_3, left->Rows, left->Columns);
	(void)Assign_MatrixData_3(&matrixData3, matrixData_3);
	(void)Assign_MatrixData_3(&matrixData_3, NULL);
	array_6 = MatrixData_3_get_DataReference(matrixData3);
	(void)Assign_float64_t_1D_1(&dataReference7, array_6);
	(void)Assign_float64_t_1D_1(&array_6, NULL);
	array_7 = MatrixData_3_get_DataReference(left);
	(void)Assign_float64_t_1D_1(&dataReference8, array_7);
	(void)Assign_float64_t_1D_1(&array_7, NULL);
	array_8 = MatrixData_3_get_DataReference(right);
	(void)Assign_float64_t_1D_1(&dataReference9, array_8);
	(void)Assign_float64_t_1D_1(&array_8, NULL);
	num2 = ((int32_t)0);
	l = ((int32_t)0);
	while (l < left->Columns)
	{
		m = ((int32_t)0);
		while (m < left->Rows)
		{
			dataReference7->Elements[num2] = dataReference8->Elements[num2] - dataReference9->Elements[m];
			num2 = num2 + ((int32_t)1);
			m = m + ((int32_t)1);
		}
		l = l + ((int32_t)1);
	}
	(void)Assign_MatrixData_3(&result, matrixData3);
	RemRef_MatrixData_3(matrixData);
	RemRef_float64_t_1D_1(dataReference);
	RemRef_float64_t_1D_1(dataReference2);
	RemRef_float64_t_1D_1(dataReference3);
	RemRef_MatrixData_3(matrixData2);
	RemRef_float64_t_1D_1(dataReference4);
	RemRef_float64_t_1D_1(dataReference5);
	RemRef_float64_t_1D_1(dataReference6);
	RemRef_MatrixData_3(matrixData3);
	RemRef_float64_t_1D_1(dataReference7);
	RemRef_float64_t_1D_1(dataReference8);
	RemRef_float64_t_1D_1(dataReference9);
	return result;
	abort();
}

static struct float64_t_1D_1 *Space_1_Subtract(struct Space_1 *const self, struct Space_1 *other)
{
	struct float64_t_1D_1 *array = NULL;
	struct float64_t_1D_1 *array_1 = NULL;
	struct MatrixData_3 *matrixData = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;
	struct MatrixData_3 *matrixData_2 = NULL;
	struct MatrixData_3 *matrixData_3 = NULL;
	struct float64_t_1D_1 *array_2 = NULL;
	struct float64_t_1D_1 *result = NULL;

	array_1 = New_float64_t_1D_1();
	(void)Assign_float64_t_1D_1(&array, array_1);
	(void)Assign_float64_t_1D_1(&array_1, NULL);
	matrixData_1 = Space_1_get_MatrixData(self);
	matrixData_2 = Space_1_get_MatrixData(other);
	matrixData_3 = MatrixMath_Subtract(matrixData_1, matrixData_2);
	(void)Assign_MatrixData_3(&matrixData, matrixData_3);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
	(void)Assign_MatrixData_3(&matrixData_2, NULL);
	(void)Assign_MatrixData_3(&matrixData_3, NULL);
	array_2 = MatrixData_3_get_DataReference(matrixData);
	(void)memcpy(&array->Elements, &array_2->Elements, sizeof(float64_t) * ((int32_t)1));
	(void)Assign_float64_t_1D_1(&array_2, NULL);
	(void)Assign_float64_t_1D_1(&result, array);
	RemRef_float64_t_1D_1(array);
	RemRef_MatrixData_3(matrixData);
	return result;
}

struct float64_t_1D_1 *Space_6_op_Subtraction(struct Space_1 *left, struct Space_1 *right)
{
	struct float64_t_1D_1 *result = NULL;
	struct float64_t_1D_1 *array = NULL;

	array = Space_1_Subtract(left, right);
	(void)Assign_float64_t_1D_1(&result, array);
	(void)Assign_float64_t_1D_1(&array, NULL);
	return result;
}

static void MatrixData_3_ctor_3(struct MatrixData_3 *const self, struct float64_t_1D_1 *data, bool_t takeDataOwnership)
{
	int32_t arg_5F_1 = ((int32_t)0);

	Object_ctor(&self->base);
	if (!(data != NULL))
	{
		abort();
	}
	if (!!takeDataOwnership)
	{
		(void)Assign_float64_t_1D_1(&self->_data, data);
	}
	else
	{
		struct float64_t_1D_1 *array = NULL;

		array = New_float64_t_1D_1();
		(void)Assign_float64_t_1D_1(&self->_data, array);
		(void)Assign_float64_t_1D_1(&array, NULL);
		(void)memcpy(&self->_data->Elements, &data->Elements, sizeof(float64_t) * ((int32_t)1));
	}
	self->Rows = ((int32_t)1);
	arg_5F_1 = ((int32_t)1);
	self->Columns = arg_5F_1;
}

struct MatrixData_3 *MatrixData_20_Create(struct float64_t_1D_1 *data)
{
	struct MatrixData_3 *result = NULL;
	struct MatrixData_3 *matrixData = NULL;

	matrixData = New_MatrixData_3();
	MatrixData_3_ctor_3(matrixData, data, true);
	(void)Assign_MatrixData_3(&result, matrixData);
	(void)Assign_MatrixData_3(&matrixData, NULL);
	return result;
}

struct MatrixData_9 *MatrixMath_Add_2(struct MatrixData_9 *left, struct MatrixData_9 *right)
{
	struct MatrixData_9 *matrixData = NULL;
	struct MatrixData_9 *matrixData_1 = NULL;
	struct float64_t_1D_6 *dataReference = NULL;
	struct float64_t_1D_6 *array = NULL;
	struct float64_t_1D_6 *dataReference2 = NULL;
	struct float64_t_1D_6 *array_1 = NULL;
	struct float64_t_1D_6 *dataReference3 = NULL;
	struct float64_t_1D_6 *array_2 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_9 *result = NULL;
	struct MatrixData_9 *matrixData2 = NULL;
	struct MatrixData_9 *matrixData_2 = NULL;
	struct float64_t_1D_6 *dataReference4 = NULL;
	struct float64_t_1D_6 *array_3 = NULL;
	struct float64_t_1D_6 *dataReference5 = NULL;
	struct float64_t_1D_6 *array_4 = NULL;
	struct float64_t_1D_6 *dataReference6 = NULL;
	struct float64_t_1D_6 *array_5 = NULL;
	int32_t num = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	struct MatrixData_9 *matrixData3 = NULL;
	struct MatrixData_9 *matrixData_3 = NULL;
	struct float64_t_1D_6 *dataReference7 = NULL;
	struct float64_t_1D_6 *array_6 = NULL;
	struct float64_t_1D_6 *dataReference8 = NULL;
	struct float64_t_1D_6 *array_7 = NULL;
	struct float64_t_1D_6 *dataReference9 = NULL;
	struct float64_t_1D_6 *array_8 = NULL;
	int32_t num2 = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t m = ((int32_t)0);

	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData_9();
	MatrixData_9_ctor(matrixData_1, left->Rows, right->Columns);
	(void)Assign_MatrixData_9(&matrixData, matrixData_1);
	(void)Assign_MatrixData_9(&matrixData_1, NULL);
	array = MatrixData_9_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_6(&dataReference, array);
	(void)Assign_float64_t_1D_6(&array, NULL);
	array_1 = MatrixData_9_get_DataReference(left);
	(void)Assign_float64_t_1D_6(&dataReference2, array_1);
	(void)Assign_float64_t_1D_6(&array_1, NULL);
	array_2 = MatrixData_9_get_DataReference(right);
	(void)Assign_float64_t_1D_6(&dataReference3, array_2);
	(void)Assign_float64_t_1D_6(&array_2, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)6))
	{
		dataReference->Elements[i] = dataReference2->Elements[i] + dataReference3->Elements[i];
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_9(&result, matrixData);
	RemRef_MatrixData_9(matrixData);
	RemRef_float64_t_1D_6(dataReference);
	RemRef_float64_t_1D_6(dataReference2);
	RemRef_float64_t_1D_6(dataReference3);
	RemRef_MatrixData_9(matrixData2);
	RemRef_float64_t_1D_6(dataReference4);
	RemRef_float64_t_1D_6(dataReference5);
	RemRef_float64_t_1D_6(dataReference6);
	RemRef_MatrixData_9(matrixData3);
	RemRef_float64_t_1D_6(dataReference7);
	RemRef_float64_t_1D_6(dataReference8);
	RemRef_float64_t_1D_6(dataReference9);
	return result;
	matrixData_2 = New_MatrixData_9();
	MatrixData_9_ctor(matrixData_2, left->Rows, right->Columns);
	(void)Assign_MatrixData_9(&matrixData2, matrixData_2);
	(void)Assign_MatrixData_9(&matrixData_2, NULL);
	array_3 = MatrixData_9_get_DataReference(matrixData2);
	(void)Assign_float64_t_1D_6(&dataReference4, array_3);
	(void)Assign_float64_t_1D_6(&array_3, NULL);
	array_4 = MatrixData_9_get_DataReference(left);
	(void)Assign_float64_t_1D_6(&dataReference5, array_4);
	(void)Assign_float64_t_1D_6(&array_4, NULL);
	array_5 = MatrixData_9_get_DataReference(right);
	(void)Assign_float64_t_1D_6(&dataReference6, array_5);
	(void)Assign_float64_t_1D_6(&array_5, NULL);
	num = ((int32_t)0);
	j = ((int32_t)0);
	while (j < right->Columns)
	{
		k = ((int32_t)0);
		while (k < left->Rows)
		{
			dataReference4->Elements[num] = dataReference5->Elements[k] + dataReference6->Elements[num];
			num = num + ((int32_t)1);
			k = k + ((int32_t)1);
		}
		j = j + ((int32_t)1);
	}
	(void)Assign_MatrixData_9(&result, matrixData2);
	RemRef_MatrixData_9(matrixData);
	RemRef_float64_t_1D_6(dataReference);
	RemRef_float64_t_1D_6(dataReference2);
	RemRef_float64_t_1D_6(dataReference3);
	RemRef_MatrixData_9(matrixData2);
	RemRef_float64_t_1D_6(dataReference4);
	RemRef_float64_t_1D_6(dataReference5);
	RemRef_float64_t_1D_6(dataReference6);
	RemRef_MatrixData_9(matrixData3);
	RemRef_float64_t_1D_6(dataReference7);
	RemRef_float64_t_1D_6(dataReference8);
	RemRef_float64_t_1D_6(dataReference9);
	return result;
	matrixData_3 = New_MatrixData_9();
	MatrixData_9_ctor(matrixData_3, left->Rows, left->Columns);
	(void)Assign_MatrixData_9(&matrixData3, matrixData_3);
	(void)Assign_MatrixData_9(&matrixData_3, NULL);
	array_6 = MatrixData_9_get_DataReference(matrixData3);
	(void)Assign_float64_t_1D_6(&dataReference7, array_6);
	(void)Assign_float64_t_1D_6(&array_6, NULL);
	array_7 = MatrixData_9_get_DataReference(left);
	(void)Assign_float64_t_1D_6(&dataReference8, array_7);
	(void)Assign_float64_t_1D_6(&array_7, NULL);
	array_8 = MatrixData_9_get_DataReference(right);
	(void)Assign_float64_t_1D_6(&dataReference9, array_8);
	(void)Assign_float64_t_1D_6(&array_8, NULL);
	num2 = ((int32_t)0);
	l = ((int32_t)0);
	while (l < left->Columns)
	{
		m = ((int32_t)0);
		while (m < left->Rows)
		{
			dataReference7->Elements[num2] = dataReference8->Elements[num2] + dataReference9->Elements[m];
			num2 = num2 + ((int32_t)1);
			m = m + ((int32_t)1);
		}
		l = l + ((int32_t)1);
	}
	(void)Assign_MatrixData_9(&result, matrixData3);
	RemRef_MatrixData_9(matrixData);
	RemRef_float64_t_1D_6(dataReference);
	RemRef_float64_t_1D_6(dataReference2);
	RemRef_float64_t_1D_6(dataReference3);
	RemRef_MatrixData_9(matrixData2);
	RemRef_float64_t_1D_6(dataReference4);
	RemRef_float64_t_1D_6(dataReference5);
	RemRef_float64_t_1D_6(dataReference6);
	RemRef_MatrixData_9(matrixData3);
	RemRef_float64_t_1D_6(dataReference7);
	RemRef_float64_t_1D_6(dataReference8);
	RemRef_float64_t_1D_6(dataReference9);
	return result;
	abort();
}

void LinearAlgebra_MatrixMultiply_7(struct LinearAlgebra *const self, struct float64_t_1D_6 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_6 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_36 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)6) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)6) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)6) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)6) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)6) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)6) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)6) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)36) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_11 *MatrixMath_Multiply_14(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_9 *left, struct MatrixData_9 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_11 *matrixData = NULL;
	struct MatrixData_11 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_6 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_6 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_36 *array_2 = NULL;
	struct MatrixData_11 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == true);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Rows;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_11();
	MatrixData_11_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_11(&matrixData, matrixData_1);
	(void)Assign_MatrixData_11(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_9_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_9_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_11_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_7(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_6(&array, NULL);
	(void)Assign_float64_t_1D_6(&array_1, NULL);
	(void)Assign_float64_t_1D_36(&array_2, NULL);
	(void)Assign_MatrixData_11(&result, matrixData);
	RemRef_MatrixData_11(matrixData);
	return result;
}

struct MatrixData_11 *MatrixMath_Multiply_15(bool_t transposeFirst, bool_t transposeSecond, bool_t transposeThird, struct MatrixData_9 *first, struct MatrixData_3 *second, struct MatrixData_9 *third)
{
	struct MatrixData_9 *left = NULL;
	struct MatrixData_9 *matrixData = NULL;
	struct MatrixData_11 *result = NULL;
	struct MatrixData_11 *matrixData_1 = NULL;

	assert(transposeFirst == false);
	assert(transposeSecond == false);
	assert(transposeThird == true);
	if (!(first != NULL))
	{
		abort();
	}
	if (!(second != NULL))
	{
		abort();
	}
	if (!(third != NULL))
	{
		abort();
	}
	matrixData = MatrixMath_Multiply_12(transposeFirst, transposeSecond, first, second);
	(void)Assign_MatrixData_9(&left, matrixData);
	(void)Assign_MatrixData_9(&matrixData, NULL);
	matrixData_1 = MatrixMath_Multiply_14(false, transposeThird, left, third);
	(void)Assign_MatrixData_11(&result, matrixData_1);
	(void)Assign_MatrixData_11(&matrixData_1, NULL);
	RemRef_MatrixData_9(left);
	return result;
}

struct MatrixData_11 *MatrixMath_Subtract_1(struct MatrixData_11 *left, struct MatrixData_11 *right)
{
	struct MatrixData_11 *matrixData = NULL;
	struct MatrixData_11 *matrixData_1 = NULL;
	struct float64_t_1D_36 *dataReference = NULL;
	struct float64_t_1D_36 *array = NULL;
	struct float64_t_1D_36 *dataReference2 = NULL;
	struct float64_t_1D_36 *array_1 = NULL;
	struct float64_t_1D_36 *dataReference3 = NULL;
	struct float64_t_1D_36 *array_2 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_11 *result = NULL;

	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData_11();
	MatrixData_11_ctor(matrixData_1, left->Rows, right->Columns);
	(void)Assign_MatrixData_11(&matrixData, matrixData_1);
	(void)Assign_MatrixData_11(&matrixData_1, NULL);
	array = MatrixData_11_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_36(&dataReference, array);
	(void)Assign_float64_t_1D_36(&array, NULL);
	array_1 = MatrixData_11_get_DataReference(left);
	(void)Assign_float64_t_1D_36(&dataReference2, array_1);
	(void)Assign_float64_t_1D_36(&array_1, NULL);
	array_2 = MatrixData_11_get_DataReference(right);
	(void)Assign_float64_t_1D_36(&dataReference3, array_2);
	(void)Assign_float64_t_1D_36(&array_2, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)36))
	{
		dataReference->Elements[i] = dataReference2->Elements[i] - dataReference3->Elements[i];
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_11(&result, matrixData);
	RemRef_MatrixData_11(matrixData);
	RemRef_float64_t_1D_36(dataReference);
	RemRef_float64_t_1D_36(dataReference2);
	RemRef_float64_t_1D_36(dataReference3);
	return result;
	abort();
}

void Space_6_Create(struct CTRASpace **space, struct MatrixData_9 *vector)
{
	struct CTRASpace **ctraSpace = NULL;
	struct CTRASpace *ctraSpace_1 = NULL;

	ctraSpace = space;
	ctraSpace_1 = New_CTRASpace();
	CTRASpace_ctor(ctraSpace_1);
	(void)Assign_CTRASpace(&*ctraSpace, ctraSpace_1);
	(void)Assign_CTRASpace(&ctraSpace_1, NULL);
	(void)Assign_MatrixData_9(&(&(*space)->base.base)->_vector, vector);
}

struct CTRASpace *Space_6_Create_1(struct MatrixData_9 *vector)
{
	struct CTRASpace *result = NULL;
	struct CTRASpace *result_1 = NULL;

	Space_6_Create(&result, vector);
	(void)Assign_CTRASpace(&result_1, result);
	RemRef_CTRASpace(result);
	return result_1;
}

struct MatrixData_9 *MatrixMath_Subtract_2(struct MatrixData_9 *left, struct MatrixData_9 *right)
{
	struct MatrixData_9 *matrixData = NULL;
	struct MatrixData_9 *matrixData_1 = NULL;
	struct float64_t_1D_6 *dataReference = NULL;
	struct float64_t_1D_6 *array = NULL;
	struct float64_t_1D_6 *dataReference2 = NULL;
	struct float64_t_1D_6 *array_1 = NULL;
	struct float64_t_1D_6 *dataReference3 = NULL;
	struct float64_t_1D_6 *array_2 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_9 *result = NULL;
	struct MatrixData_9 *matrixData2 = NULL;
	struct MatrixData_9 *matrixData_2 = NULL;
	struct float64_t_1D_6 *dataReference4 = NULL;
	struct float64_t_1D_6 *array_3 = NULL;
	struct float64_t_1D_6 *dataReference5 = NULL;
	struct float64_t_1D_6 *array_4 = NULL;
	struct float64_t_1D_6 *dataReference6 = NULL;
	struct float64_t_1D_6 *array_5 = NULL;
	int32_t num = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	struct MatrixData_9 *matrixData3 = NULL;
	struct MatrixData_9 *matrixData_3 = NULL;
	struct float64_t_1D_6 *dataReference7 = NULL;
	struct float64_t_1D_6 *array_6 = NULL;
	struct float64_t_1D_6 *dataReference8 = NULL;
	struct float64_t_1D_6 *array_7 = NULL;
	struct float64_t_1D_6 *dataReference9 = NULL;
	struct float64_t_1D_6 *array_8 = NULL;
	int32_t num2 = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t m = ((int32_t)0);

	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData_9();
	MatrixData_9_ctor(matrixData_1, left->Rows, right->Columns);
	(void)Assign_MatrixData_9(&matrixData, matrixData_1);
	(void)Assign_MatrixData_9(&matrixData_1, NULL);
	array = MatrixData_9_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_6(&dataReference, array);
	(void)Assign_float64_t_1D_6(&array, NULL);
	array_1 = MatrixData_9_get_DataReference(left);
	(void)Assign_float64_t_1D_6(&dataReference2, array_1);
	(void)Assign_float64_t_1D_6(&array_1, NULL);
	array_2 = MatrixData_9_get_DataReference(right);
	(void)Assign_float64_t_1D_6(&dataReference3, array_2);
	(void)Assign_float64_t_1D_6(&array_2, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)6))
	{
		dataReference->Elements[i] = dataReference2->Elements[i] - dataReference3->Elements[i];
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_9(&result, matrixData);
	RemRef_MatrixData_9(matrixData);
	RemRef_float64_t_1D_6(dataReference);
	RemRef_float64_t_1D_6(dataReference2);
	RemRef_float64_t_1D_6(dataReference3);
	RemRef_MatrixData_9(matrixData2);
	RemRef_float64_t_1D_6(dataReference4);
	RemRef_float64_t_1D_6(dataReference5);
	RemRef_float64_t_1D_6(dataReference6);
	RemRef_MatrixData_9(matrixData3);
	RemRef_float64_t_1D_6(dataReference7);
	RemRef_float64_t_1D_6(dataReference8);
	RemRef_float64_t_1D_6(dataReference9);
	return result;
	matrixData_2 = New_MatrixData_9();
	MatrixData_9_ctor(matrixData_2, left->Rows, right->Columns);
	(void)Assign_MatrixData_9(&matrixData2, matrixData_2);
	(void)Assign_MatrixData_9(&matrixData_2, NULL);
	array_3 = MatrixData_9_get_DataReference(matrixData2);
	(void)Assign_float64_t_1D_6(&dataReference4, array_3);
	(void)Assign_float64_t_1D_6(&array_3, NULL);
	array_4 = MatrixData_9_get_DataReference(left);
	(void)Assign_float64_t_1D_6(&dataReference5, array_4);
	(void)Assign_float64_t_1D_6(&array_4, NULL);
	array_5 = MatrixData_9_get_DataReference(right);
	(void)Assign_float64_t_1D_6(&dataReference6, array_5);
	(void)Assign_float64_t_1D_6(&array_5, NULL);
	num = ((int32_t)0);
	j = ((int32_t)0);
	while (j < right->Columns)
	{
		k = ((int32_t)0);
		while (k < left->Rows)
		{
			dataReference4->Elements[num] = dataReference5->Elements[k] - dataReference6->Elements[num];
			num = num + ((int32_t)1);
			k = k + ((int32_t)1);
		}
		j = j + ((int32_t)1);
	}
	(void)Assign_MatrixData_9(&result, matrixData2);
	RemRef_MatrixData_9(matrixData);
	RemRef_float64_t_1D_6(dataReference);
	RemRef_float64_t_1D_6(dataReference2);
	RemRef_float64_t_1D_6(dataReference3);
	RemRef_MatrixData_9(matrixData2);
	RemRef_float64_t_1D_6(dataReference4);
	RemRef_float64_t_1D_6(dataReference5);
	RemRef_float64_t_1D_6(dataReference6);
	RemRef_MatrixData_9(matrixData3);
	RemRef_float64_t_1D_6(dataReference7);
	RemRef_float64_t_1D_6(dataReference8);
	RemRef_float64_t_1D_6(dataReference9);
	return result;
	matrixData_3 = New_MatrixData_9();
	MatrixData_9_ctor(matrixData_3, left->Rows, left->Columns);
	(void)Assign_MatrixData_9(&matrixData3, matrixData_3);
	(void)Assign_MatrixData_9(&matrixData_3, NULL);
	array_6 = MatrixData_9_get_DataReference(matrixData3);
	(void)Assign_float64_t_1D_6(&dataReference7, array_6);
	(void)Assign_float64_t_1D_6(&array_6, NULL);
	array_7 = MatrixData_9_get_DataReference(left);
	(void)Assign_float64_t_1D_6(&dataReference8, array_7);
	(void)Assign_float64_t_1D_6(&array_7, NULL);
	array_8 = MatrixData_9_get_DataReference(right);
	(void)Assign_float64_t_1D_6(&dataReference9, array_8);
	(void)Assign_float64_t_1D_6(&array_8, NULL);
	num2 = ((int32_t)0);
	l = ((int32_t)0);
	while (l < left->Columns)
	{
		m = ((int32_t)0);
		while (m < left->Rows)
		{
			dataReference7->Elements[num2] = dataReference8->Elements[num2] - dataReference9->Elements[m];
			num2 = num2 + ((int32_t)1);
			m = m + ((int32_t)1);
		}
		l = l + ((int32_t)1);
	}
	(void)Assign_MatrixData_9(&result, matrixData3);
	RemRef_MatrixData_9(matrixData);
	RemRef_float64_t_1D_6(dataReference);
	RemRef_float64_t_1D_6(dataReference2);
	RemRef_float64_t_1D_6(dataReference3);
	RemRef_MatrixData_9(matrixData2);
	RemRef_float64_t_1D_6(dataReference4);
	RemRef_float64_t_1D_6(dataReference5);
	RemRef_float64_t_1D_6(dataReference6);
	RemRef_MatrixData_9(matrixData3);
	RemRef_float64_t_1D_6(dataReference7);
	RemRef_float64_t_1D_6(dataReference8);
	RemRef_float64_t_1D_6(dataReference9);
	return result;
	abort();
}

static struct float64_t_1D_6 *Space_5_Subtract(struct Space_5 *const self, struct Space_5 *other)
{
	struct float64_t_1D_6 *array = NULL;
	struct float64_t_1D_6 *array_1 = NULL;
	struct MatrixData_9 *matrixData = NULL;
	struct MatrixData_9 *matrixData_1 = NULL;
	struct MatrixData_9 *matrixData_2 = NULL;
	struct MatrixData_9 *matrixData_3 = NULL;
	struct float64_t_1D_6 *array_2 = NULL;
	struct float64_t_1D_6 *result = NULL;

	array_1 = New_float64_t_1D_6();
	(void)Assign_float64_t_1D_6(&array, array_1);
	(void)Assign_float64_t_1D_6(&array_1, NULL);
	matrixData_1 = Space_5_get_MatrixData(self);
	matrixData_2 = Space_5_get_MatrixData(other);
	matrixData_3 = MatrixMath_Subtract_2(matrixData_1, matrixData_2);
	(void)Assign_MatrixData_9(&matrixData, matrixData_3);
	(void)Assign_MatrixData_9(&matrixData_1, NULL);
	(void)Assign_MatrixData_9(&matrixData_2, NULL);
	(void)Assign_MatrixData_9(&matrixData_3, NULL);
	array_2 = MatrixData_9_get_DataReference(matrixData);
	(void)memcpy(&array->Elements, &array_2->Elements, sizeof(float64_t) * ((int32_t)6));
	(void)Assign_float64_t_1D_6(&array_2, NULL);
	(void)Assign_float64_t_1D_6(&result, array);
	RemRef_float64_t_1D_6(array);
	RemRef_MatrixData_9(matrixData);
	return result;
}

float64_t Math_Floor(float64_t d)
{
	return (float64_t)floor(d);
}

float64_t Math_1_Modulus(float64_t numerator, float64_t denumerator)
{
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;

	if (!(denumerator != 0.0))
	{
		abort();
	}
	double_ = numerator;
	double__1 = denumerator;
	double__2 = Math_Floor(numerator / denumerator);
	return double_ - (double__1 * double__2);
}

static struct float64_t_1D_6 *AngularSpace_2_Subtract(struct AngularSpace_2 *const self, struct Space_5 *other)
{
	struct float64_t_1D_6 *array = NULL;
	struct float64_t_1D_6 *array_1 = NULL;
	struct int32_t_1D_1 *angularDimensionsIndices = NULL;
	struct int32_t_1D_1 *array_2 = NULL;
	int32_t i = ((int32_t)0);
	int32_t num = ((int32_t)0);
	struct float64_t_1D_6 *result = NULL;

	array_1 = Space_5_Subtract(&self->base, other);
	(void)Assign_float64_t_1D_6(&array, array_1);
	(void)Assign_float64_t_1D_6(&array_1, NULL);
	array_2 = AnguSpace_2_get_AngulDimenIndic(self);
	(void)Assign_int32_t_1D_1(&angularDimensionsIndices, array_2);
	(void)Assign_int32_t_1D_1(&array_2, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)1))
	{
		struct float64_t_1D_6 *array_3 = NULL;
		int32_t int32 = ((int32_t)0);
		float64_t double_ = 0.0;

		num = angularDimensionsIndices->Elements[i];
		(void)Assign_float64_t_1D_6(&array_3, array);
		int32 = num;
		double_ = Math_1_Modulus(array->Elements[num] + 3.1415926535897931, 6.2831853071795862);
		array_3->Elements[int32] = double_ - 3.1415926535897931;
		(void)Assign_float64_t_1D_6(&array_3, NULL);
		i = i + ((int32_t)1);
	}
	(void)Assign_float64_t_1D_6(&result, array);
	RemRef_float64_t_1D_6(array);
	RemRef_int32_t_1D_1(angularDimensionsIndices);
	return result;
}

struct float64_t_1D_6 *Space_6_op_Subtraction_1(struct AngularSpace_2 *left, struct Space_5 *right)
{
	struct float64_t_1D_6 *result = NULL;
	struct float64_t_1D_6 *array = NULL;

	array = AngularSpace_2_Subtract(left, right);
	(void)Assign_float64_t_1D_6(&result, array);
	(void)Assign_float64_t_1D_6(&array, NULL);
	return result;
}

struct CTRASpace *SpaceExtensions_FitToDomain(struct CTRASpace *space)
{
	struct float64_t_1D_6 *array = NULL;
	struct CTRASpace *ctraSpace = NULL;
	struct CTRASpace *ctraSpace_1 = NULL;
	struct float64_t_1D_6 *array_1 = NULL;
	struct MatrixData_9 *matrixData = NULL;
	struct MatrixData_9 *matrixData_1 = NULL;
	struct float64_t_1D_6 *array_2 = NULL;
	struct float64_t_1D_6 *array_3 = NULL;
	struct CTRASpace *result = NULL;
	struct CTRASpace *ctraSpace_2 = NULL;
	struct CTRASpace *result_1 = NULL;

	(void)Assign_CTRASpace(&ctraSpace, space);
	ctraSpace_1 = New_CTRASpace();
	CTRASpace_ctor(ctraSpace_1);
	array_1 = Space_6_op_Subtraction_1(&ctraSpace->base, &ctraSpace_1->base.base);
	(void)Assign_float64_t_1D_6(&array, array_1);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	(void)Assign_CTRASpace(&ctraSpace_1, NULL);
	(void)Assign_float64_t_1D_6(&array_1, NULL);
	matrixData_1 = New_MatrixData_9();
	MatrixData_9_ctor(matrixData_1, (&space->base.base)->Dimensions, ((int32_t)1));
	(void)Assign_MatrixData_9(&matrixData, matrixData_1);
	(void)Assign_MatrixData_9(&matrixData_1, NULL);
	(void)Assign_float64_t_1D_6(&array_2, array);
	array_3 = MatrixData_9_get_DataReference(matrixData);
	(void)memcpy(&array_3->Elements, &array_2->Elements, sizeof(float64_t) * ((int32_t)6));
	(void)Assign_float64_t_1D_6(&array_2, NULL);
	(void)Assign_float64_t_1D_6(&array_3, NULL);
	ctraSpace_2 = New_CTRASpace();
	CTRASpace_ctor(ctraSpace_2);
	(void)Assign_CTRASpace(&result, ctraSpace_2);
	(void)Assign_CTRASpace(&ctraSpace_2, NULL);
	Space_5_set_MatrixData(&(*&result)->base.base, matrixData);
	(void)Assign_CTRASpace(&result_1, result);
	RemRef_float64_t_1D_6(array);
	RemRef_MatrixData_9(matrixData);
	RemRef_CTRASpace(result);
	return result_1;
}

struct Gaussian_4 *EKF_Update(struct Gaussian_4 *predictedState, struct Gaussian *predictedMeasurement, struct VelocitySpace *measurement, struct Matrix_8 *transitionMatrix)
{
	struct MatrixData_3 *matrixData = NULL;
	struct PositiveDefiniteMatrix *positiveDefiniteMatrix = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;
	struct MatrixData_9 *matrixData2 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_1 = NULL;
	struct MatrixData_11 *matrixData_2 = NULL;
	struct MatrixData_10 *matrixData_3 = NULL;
	struct MatrixData_3 *matrixData_4 = NULL;
	struct MatrixData_3 *matrixData_5 = NULL;
	struct MatrixData_3 *matrixData_6 = NULL;
	struct MatrixData_9 *matrixData_7 = NULL;
	struct MatrixData_3 *right = NULL;
	struct VelocitySpace *velocitySpace = NULL;
	struct VelocitySpace *velocitySpace_1 = NULL;
	struct float64_t_1D_1 *array = NULL;
	struct MatrixData_3 *matrixData_8 = NULL;
	struct CTRASpace *expectation = NULL;
	struct CTRASpace *ctraSpace = NULL;
	struct MatrixData_9 *vector = NULL;
	struct MatrixData_9 *matrixData_9 = NULL;
	struct MatrixData_9 *matrixData_10 = NULL;
	struct MatrixData_9 *matrixData_11 = NULL;
	struct MatrixData_11 *matrix = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_2 = NULL;
	struct MatrixData_11 *matrixData_12 = NULL;
	struct MatrixData_11 *matrixData_13 = NULL;
	struct MatrixData_11 *matrixData_14 = NULL;
	struct CTRASpace *expectation2 = NULL;
	struct CTRASpace *ctraSpace_1 = NULL;
	struct CTRASpace *ctraSpace_2 = NULL;
	struct PositiveDefiniteMatrix_6 *covariance = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_3 = NULL;
	struct Gaussian_4 *result = NULL;
	struct Gaussian_4 *gaussian = NULL;

	positiveDefiniteMatrix = Gaussian_get_Covariance(predictedMeasurement);
	matrixData_1 = Matrix_get_MatrixData(&positiveDefiniteMatrix->base.base);
	(void)Assign_MatrixData_3(&matrixData, matrixData_1);
	(void)Assign_PositiveDefiniteMatrix(&positiveDefiniteMatrix, NULL);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
	positiveDefiniteMatrix_1 = Gaussian_4_get_Covariance(predictedState);
	matrixData_2 = Matrix_6_get_MatrixData(&positiveDefiniteMatrix_1->base.base);
	matrixData_3 = Matrix_8_get_MatrixData(transitionMatrix);
	(void)Assign_MatrixData_3(&matrixData_4, matrixData);
	matrixData_5 = MatrixData_20_Eye_2(matrixData->Rows, matrixData->Columns);
	matrixData_6 = MatrixMath_LinsolveSquare(matrixData_4, matrixData_5);
	matrixData_7 = MatrixMath_Multiply_13(false, true, false, matrixData_2, matrixData_3, matrixData_6);
	(void)Assign_MatrixData_9(&matrixData2, matrixData_7);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_1, NULL);
	(void)Assign_MatrixData_11(&matrixData_2, NULL);
	(void)Assign_MatrixData_10(&matrixData_3, NULL);
	(void)Assign_MatrixData_3(&matrixData_4, NULL);
	(void)Assign_MatrixData_3(&matrixData_5, NULL);
	(void)Assign_MatrixData_3(&matrixData_6, NULL);
	(void)Assign_MatrixData_9(&matrixData_7, NULL);
	(void)Assign_VelocitySpace(&velocitySpace, measurement);
	velocitySpace_1 = Gaussian_get_Expectation(predictedMeasurement);
	array = Space_6_op_Subtraction(&velocitySpace->base, &velocitySpace_1->base);
	matrixData_8 = MatrixData_20_Create(array);
	(void)Assign_MatrixData_3(&right, matrixData_8);
	(void)Assign_VelocitySpace(&velocitySpace, NULL);
	(void)Assign_VelocitySpace(&velocitySpace_1, NULL);
	(void)Assign_float64_t_1D_1(&array, NULL);
	(void)Assign_MatrixData_3(&matrixData_8, NULL);
	ctraSpace = Gaussian_4_get_Expectation(predictedState);
	(void)Assign_CTRASpace(&expectation, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	matrixData_9 = Space_5_get_MatrixData(&(*&expectation)->base.base);
	matrixData_10 = MatrixMath_Multiply_12(false, false, matrixData2, right);
	matrixData_11 = MatrixMath_Add_2(matrixData_9, matrixData_10);
	(void)Assign_MatrixData_9(&vector, matrixData_11);
	(void)Assign_MatrixData_9(&matrixData_9, NULL);
	(void)Assign_MatrixData_9(&matrixData_10, NULL);
	(void)Assign_MatrixData_9(&matrixData_11, NULL);
	positiveDefiniteMatrix_2 = Gaussian_4_get_Covariance(predictedState);
	matrixData_12 = Matrix_6_get_MatrixData(&positiveDefiniteMatrix_2->base.base);
	matrixData_13 = MatrixMath_Multiply_15(false, false, true, matrixData2, matrixData, matrixData2);
	matrixData_14 = MatrixMath_Subtract_1(matrixData_12, matrixData_13);
	(void)Assign_MatrixData_11(&matrix, matrixData_14);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_2, NULL);
	(void)Assign_MatrixData_11(&matrixData_12, NULL);
	(void)Assign_MatrixData_11(&matrixData_13, NULL);
	(void)Assign_MatrixData_11(&matrixData_14, NULL);
	ctraSpace_1 = Space_6_Create_1(vector);
	ctraSpace_2 = SpaceExtensions_FitToDomain(ctraSpace_1);
	(void)Assign_CTRASpace(&expectation2, ctraSpace_2);
	(void)Assign_CTRASpace(&ctraSpace_1, NULL);
	(void)Assign_CTRASpace(&ctraSpace_2, NULL);
	positiveDefiniteMatrix_3 = PositDefinMatri_8_CreatAndCorre(matrix);
	(void)Assign_PositiveDefiniteMatrix_6(&covariance, positiveDefiniteMatrix_3);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_3, NULL);
	gaussian = Gaussian_6_Create(expectation2, covariance);
	(void)Assign_Gaussian_4(&result, gaussian);
	(void)Assign_Gaussian_4(&gaussian, NULL);
	RemRef_MatrixData_3(matrixData);
	RemRef_MatrixData_9(matrixData2);
	RemRef_MatrixData_3(right);
	RemRef_CTRASpace(expectation);
	RemRef_MatrixData_9(vector);
	RemRef_MatrixData_11(matrix);
	RemRef_CTRASpace(expectation2);
	RemRef_PositiveDefiniteMatrix_6(covariance);
	return result;
}

struct Gaussian_4 *EKF_Update_1(struct Gaussian_4 *predictedState, struct VelocitySpace *measurement, struct VelocityMeasurementModel *measurementModel)
{
	struct Matrix_8 *transitionMatrix = NULL;
	struct Gaussian *predictedMeasurement = NULL;
	struct Gaussian *gaussian = NULL;
	struct Gaussian_4 *result = NULL;
	struct Gaussian_4 *gaussian_1 = NULL;

	gaussian = EKF_PredictMeasurement(predictedState, measurementModel, &transitionMatrix);
	(void)Assign_Gaussian(&predictedMeasurement, gaussian);
	(void)Assign_Gaussian(&gaussian, NULL);
	gaussian_1 = EKF_Update(predictedState, predictedMeasurement, measurement, transitionMatrix);
	(void)Assign_Gaussian_4(&result, gaussian_1);
	(void)Assign_Gaussian_4(&gaussian_1, NULL);
	RemRef_Matrix_8(transitionMatrix);
	RemRef_Gaussian(predictedMeasurement);
	return result;
}

void EgoMotionFilter_FilterVelocity(struct EgoMotionFilter *const self, struct DateTime time_1, struct Measure_2 *velocity)
{
	bool_t s__LockTaken0 = false;
	struct Object *CS_2_0000 = NULL;
	struct Object *object = NULL;
	struct EgoMotionFilter *egoMotionFilter = NULL;
	bool_t boolean = false;
	struct EgoMotionFilter *egoMotionFilter_1 = NULL;
	struct TimeSpan deltaT = { 0 };
	struct DateTime dateTime = { 0 };
	struct DateTime dateTime_1 = { 0 };
	struct TimeSpan timeSpan = { 0 };
	struct Gaussian_4 *predictedSpace = NULL;
	struct Gaussian_4 *gaussian = NULL;
	struct VelocitySpace *measurement = NULL;
	struct VelocitySpace *velocitySpace = NULL;
	float64_t double_ = 0.0;
	struct Gaussian_4 *gaussian_1 = NULL;
	struct Nullable_1 nullable = { 0 };

	s__LockTaken0 = false;
	(void)Assign_Object(&object, Assign_Object(&CS_2_0000, self->_stateLock));
	s__LockTaken0 = true;
	(void)Assign_Object(&object, NULL);
	(void)Assign_EgoMotionFilter(&egoMotionFilter, self);
	boolean = Nullable_1_get_HasValue(&egoMotionFilter->_lastCorrectionTime);
	if (!boolean)
	{
		struct Nullable_1 nullable_1 = { 0 };

		Nullable_1_ctor(&nullable_1, time_1);
		self->_lastCorrectionTime = nullable_1;
	}
	dateTime = time_1;
	(void)Assign_EgoMotionFilter(&egoMotionFilter_1, self);
	dateTime_1 = Nullable_1_get_Value(&egoMotionFilter_1->_lastCorrectionTime);
	timeSpan = DateTime_1_op_Subtraction(dateTime, dateTime_1);
	deltaT = timeSpan;
	gaussian = EKF_PredictState(deltaT, self->_state, self->_systemModel);
	(void)Assign_Gaussian_4(&predictedSpace, gaussian);
	(void)Assign_Gaussian_4(&gaussian, NULL);
	velocitySpace = New_VelocitySpace();
	VelocitySpace_ctor(velocitySpace);
	double_ = Measure_4_op_Implicit(&velocity->base);
	VelocitySpace_set_V(velocitySpace, double_);
	(void)Assign_VelocitySpace(&measurement, velocitySpace);
	(void)Assign_VelocitySpace(&velocitySpace, NULL);
	gaussian_1 = EKF_Update_1(predictedSpace, measurement, self->_velocityMeasurementModel);
	(void)Assign_Gaussian_4(&self->_state, gaussian_1);
	(void)Assign_Gaussian_4(&gaussian_1, NULL);
	Nullable_1_ctor(&nullable, time_1);
	self->_lastCorrectionTime = nullable;
	self->_isVelocityFiltered = true;
	RemRef_Object(CS_2_0000);
	RemRef_EgoMotionFilter(egoMotionFilter);
	RemRef_EgoMotionFilter(egoMotionFilter_1);
	RemRef_Gaussian_4(predictedSpace);
	RemRef_VelocitySpace(measurement);
}

void Tracking_ProcessVelocity(struct Tracking *const self, struct DateTime time_1, struct Measure_2 *velocity)
{
	EgoMotionFilter_FilterVelocity(self->_egoMotionFilter, time_1, velocity);
}

float64_t Measure_1_get_Value(struct Measure_1 *const self)
{
	return self->Value;
}

float64_t Measure_5_op_Implicit(struct Measure_1 *measure)
{
	float64_t double_ = 0.0;

	double_ = Measure_1_get_Value(measure);
	return double_;
}

void YawRateSpace_set_W(struct YawRateSpace *const self, float64_t value)
{
	Space_1_set_Item(&self->base, ((int32_t)0), value);
}

static void RemRef_Matrix_9(struct Matrix_9 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Matrix_9.CurrentCount--;
		Res_Matrix_9.Next[Res_Matrix_9.CurrentCount] = self;
		Del_Matrix_9(self);
	}
}

struct Matrix_9 *New_Matrix_9(void)
{
	static struct Matrix_9 const Default_Matrix_9 = { 1 };
	struct Matrix_9 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Matrix_9.CurrentCount == RC_Matrix_9)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Matrix_9.Next[Res_Matrix_9.CurrentCount];
	Res_Matrix_9.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Matrix_9.MaximumCount = (Res_Matrix_9.CurrentCount > Res_Matrix_9.MaximumCount) ? Res_Matrix_9.CurrentCount : Res_Matrix_9.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Matrix_9;
	return instance;
}

struct Matrix_9 *Assign_Matrix_9(struct Matrix_9 **const left, struct Matrix_9 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Matrix_9(*left);
	*left = right;
	return right;
}

void Matrix_9_ctor(struct Matrix_9 *const self)
{
	struct CTRASpace *ctraSpace = NULL;
	struct YawRateSpace *yawRateSpace = NULL;

	ctraSpace = New_CTRASpace();
	CTRASpace_ctor(ctraSpace);
	(void)Assign_CTRASpace(&self->EmptyRowSpace, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	yawRateSpace = New_YawRateSpace();
	YawRateSpace_ctor(yawRateSpace);
	(void)Assign_YawRateSpace(&self->EmptyColumnSpace, yawRateSpace);
	(void)Assign_YawRateSpace(&yawRateSpace, NULL);
	Object_ctor(&self->base);
	self->Columns = (&self->EmptyRowSpace->base.base)->Dimensions;
	self->Rows = (&self->EmptyColumnSpace->base)->Dimensions;
}

static struct CTRASpace *MeasuremenModel_1_get_Condition(struct MeasurementModel_1 *const self)
{
	struct CTRASpace *result = NULL;

	(void)Assign_CTRASpace(&result, self->Condition);
	return result;
}

float64_t YawRateSpace_get_W(struct YawRateSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_1_get_Item(&self->base, ((int32_t)0));
	return double_;
}

struct MatrixData_10 *Matrix_9_get_MatrixData(struct Matrix_9 *const self)
{
	struct MatrixData_10 *result = NULL;

	if (!(self->_matrix != NULL))
	{
		struct MatrixData_10 *matrixData = NULL;

		matrixData = MatrixData_20_Zeros_10(self->Rows, self->Columns);
		(void)Assign_MatrixData_10(&self->_matrix, matrixData);
		(void)Assign_MatrixData_10(&matrixData, NULL);
	}
	(void)Assign_MatrixData_10(&result, self->_matrix);
	return result;
}

static void Matrix_9_MatrixChanged(struct Matrix_9 *const self)
{
	(void)Assign_MatrixData(&self->CachedTranspose, NULL);
}

void Matrix_9_set_Item(struct Matrix_9 *const self, int32_t row, int32_t column, float64_t value)
{
	struct MatrixData_10 *matrixData = NULL;

	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	matrixData = Matrix_9_get_MatrixData(self);
	MatrixData_10_set_Item(matrixData, row, column, value);
	(void)Assign_MatrixData_10(&matrixData, NULL);
	Matrix_9_MatrixChanged(self);
}

void Matrix_9_set_Item_1(struct Matrix_9 *const self, float64_t row, float64_t column, float64_t value)
{
	Matrix_9_set_Item(self, (int32_t)row, (int32_t)column, value);
}

void YawRateMeasModel_FillTransMatri(struct YawRateMeasurementModel *const self, struct CTRASpace *predictedStateExpectation, struct Matrix_9 **H)
{
	struct Matrix_9 *arg_31_0 = NULL;
	struct YawRateSpace *measureIdxs = NULL;
	float64_t arg_31_1 = 0.0;
	float64_t double_ = 0.0;
	struct CTRASpace *stateIdxs = NULL;
	struct Matrix_9 *matrix = NULL;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;

	(void)Assign_Matrix_9(&arg_31_0, *H);
	(void)Assign_YawRateSpace(&measureIdxs, YawRateMeasurModel_1_MeasurIdxs);
	double_ = YawRateSpace_get_W(measureIdxs);
	arg_31_1 = double_;
	(void)Assign_CTRASpace(&stateIdxs, YawRateMeasureModel_1_StateIdxs);
	(void)Assign_Matrix_9(&matrix, arg_31_0);
	double__1 = arg_31_1;
	double__2 = CTRASpace_get_W(stateIdxs);
	Matrix_9_set_Item_1(matrix, double__1, double__2, 1.0);
	(void)Assign_Matrix_9(&matrix, NULL);
	RemRef_Matrix_9(arg_31_0);
	RemRef_YawRateSpace(measureIdxs);
	RemRef_CTRASpace(stateIdxs);
}

struct Matrix_9 *MeasurModel_5_get_TransitMatrix(struct YawRateMeasurementModel *const self)
{
	struct Matrix_9 *result = NULL;
	struct Matrix_9 *matrix = NULL;
	struct CTRASpace *ctraSpace = NULL;
	struct Matrix_9 *result_1 = NULL;

	matrix = New_Matrix_9();
	Matrix_9_ctor(matrix);
	(void)Assign_Matrix_9(&result, matrix);
	(void)Assign_Matrix_9(&matrix, NULL);
	ctraSpace = MeasuremenModel_1_get_Condition(&self->base.base);
	YawRateMeasModel_FillTransMatri(self, ctraSpace, &result);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	(void)Assign_Matrix_9(&result_1, result);
	RemRef_Matrix_9(result);
	return result_1;
}

struct PositiveDefiniteMatrix_1 *MeasureModel_1_get_NoiseCovaria(struct MeasurementModel_1 *const self)
{
	struct PositiveDefiniteMatrix_1 *result = NULL;

	(void)Assign_PositiveDefiniteMatrix_1(&result, self->_measurementNoiseCovariance);
	return result;
}

struct PositiveDefiniteMatrix_1 *MeasuremeModel_1_get_Covariance(struct MeasurementModel_1 *const self)
{
	struct PositiveDefiniteMatrix_1 *result = NULL;
	struct PositiveDefiniteMatrix_1 *positiveDefiniteMatrix = NULL;

	positiveDefiniteMatrix = MeasureModel_1_get_NoiseCovaria(self);
	(void)Assign_PositiveDefiniteMatrix_1(&result, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_1(&positiveDefiniteMatrix, NULL);
	return result;
}

void PositiveDefiniteMatrix_1_ctor_1(struct PositiveDefiniteMatrix_1 *const self)
{
	SquareMatrix_1_ctor(&self->base);
}

struct PositiveDefiniteMatrix_1 *PositivDefiniteMatrix_10_Create(struct MatrixData_3 *matrix)
{
	struct PositiveDefiniteMatrix_1 *result = NULL;
	struct PositiveDefiniteMatrix_1 *positiveDefiniteMatrix = NULL;

	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_1();
	PositiveDefiniteMatrix_1_ctor_1(positiveDefiniteMatrix);
	Matrix_1_set_UncheckeMatrixData(&positiveDefiniteMatrix->base.base, matrix);
	(void)Assign_PositiveDefiniteMatrix_1(&result, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_1(&positiveDefiniteMatrix, NULL);
	return result;
}

struct PositiveDefiniteMatrix_1 *PosiDefinMatri_10_CreatAndCorre(struct MatrixData_3 *matrix)
{
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	float64_t num = 0.0;
	float64_t num2 = 0.0;
	float64_t value = 0.0;
	struct PositiveDefiniteMatrix_1 *result = NULL;
	struct PositiveDefiniteMatrix_1 *positiveDefiniteMatrix = NULL;

	i = ((int32_t)0);
	while (i < matrix->Rows)
	{
		float64_t double_ = 0.0;

		double_ = MatrixData_3_get_Item(matrix, i, i);
		if (!(double_ > 0.0))
		{
			MatrixData_3_set_Item_1(matrix, i, i, 4.94065645841247E-324);
		}
		j = ((int32_t)0);
		while (j < i)
		{
			float64_t double__1 = 0.0;
			float64_t double__2 = 0.0;
			float64_t double__3 = 0.0;
			float64_t double__4 = 0.0;
			float64_t double__5 = 0.0;
			float64_t double__6 = 0.0;

			double__1 = MatrixData_3_get_Item(matrix, i, j);
			double__2 = MatrixData_3_get_Item(matrix, j, i);
			num = (double__1 + double__2) / 2.0;
			double__3 = MatrixData_3_get_Item(matrix, i, i);
			double__4 = MatrixData_3_get_Item(matrix, j, j);
			double__5 = Math_Sqrt(double__3 * double__4);
			num2 = 1.0 * double__5;
			double__6 = Math_Abs(num);
			if (!(double__6 <= num2))
			{
				int32_t int32 = ((int32_t)0);
				float64_t double__7 = 0.0;

				int32 = Math_Sign(num);
				double__7 = (float64_t)int32;
				value = double__7 * num2;
			}
			else
			{
				value = num;
			}
			MatrixData_3_set_Item_1(matrix, i, j, value);
			MatrixData_3_set_Item_1(matrix, j, i, value);
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	positiveDefiniteMatrix = PositivDefiniteMatrix_10_Create(matrix);
	(void)Assign_PositiveDefiniteMatrix_1(&result, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_1(&positiveDefiniteMatrix, NULL);
	return result;
}

float64_t YawRateMeasMode_get_YawRateBias(struct YawRateMeasurementModel *const self)
{
	return self->YawRateBias;
}

void YawRateMeasurementModel_h(struct YawRateMeasurementModel *const self, struct CTRASpace *state, struct YawRateSpace **predictedMeasurement)
{
	struct YawRateSpace **yawRateSpace = NULL;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;

	yawRateSpace = predictedMeasurement;
	double_ = CTRASpace_get_W(state);
	double__1 = YawRateMeasMode_get_YawRateBias(self);
	YawRateSpace_set_W(*yawRateSpace, double_ + double__1);
}

struct YawRateSpace *MeasuremeModel_1_get_Expectatio(struct YawRateMeasurementModel *const self)
{
	struct YawRateSpace *result = NULL;
	struct YawRateSpace *yawRateSpace = NULL;
	struct CTRASpace *ctraSpace = NULL;
	struct YawRateSpace *result_1 = NULL;

	yawRateSpace = New_YawRateSpace();
	YawRateSpace_ctor(yawRateSpace);
	(void)Assign_YawRateSpace(&result, yawRateSpace);
	(void)Assign_YawRateSpace(&yawRateSpace, NULL);
	ctraSpace = MeasuremenModel_1_get_Condition(&self->base.base);
	YawRateMeasurementModel_h(self, ctraSpace, &result);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	(void)Assign_YawRateSpace(&result_1, result);
	RemRef_YawRateSpace(result);
	return result_1;
}

static void Gaussian_8_cctor(void)
{
	struct YawRateSpace *yawRateSpace = NULL;

	yawRateSpace = New_YawRateSpace();
	YawRateSpace_ctor(yawRateSpace);
	(void)Assign_YawRateSpace(&Gaussian_8_EmptySpace, yawRateSpace);
	(void)Assign_YawRateSpace(&yawRateSpace, NULL);
}

static void RemRef_Gaussian_1(struct Gaussian_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Gaussian_1.CurrentCount--;
		Res_Gaussian_1.Next[Res_Gaussian_1.CurrentCount] = self;
		Del_Gaussian_1(self);
	}
}

struct Gaussian_1 *New_Gaussian_1(void)
{
	static struct Gaussian_1 const Default_Gaussian_1 = { 1 };
	struct Gaussian_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Gaussian_1.CurrentCount == RC_Gaussian_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Gaussian_1.Next[Res_Gaussian_1.CurrentCount];
	Res_Gaussian_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Gaussian_1.MaximumCount = (Res_Gaussian_1.CurrentCount > Res_Gaussian_1.MaximumCount) ? Res_Gaussian_1.CurrentCount : Res_Gaussian_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Gaussian_1;
	return instance;
}

struct Gaussian_1 *Assign_Gaussian_1(struct Gaussian_1 **const left, struct Gaussian_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Gaussian_1(*left);
	*left = right;
	return right;
}

static void Gaussian_1_set_Expectation(struct Gaussian_1 *const self, struct YawRateSpace *value)
{
	(void)Assign_YawRateSpace(&self->Expectation, value);
}

static void Gaussian_1_ResetCachedValues(struct Gaussian_1 *const self)
{
	struct Nullable_2 nullable = { 0 };

	self->NormalizationFactor = nullable;
}

static void Gaussian_1_set_Covariance(struct Gaussian_1 *const self, struct PositiveDefiniteMatrix_1 *value)
{
	Gaussian_1_ResetCachedValues(self);
	(void)Assign_PositiveDefiniteMatrix_1(&self->covariance, value);
}

static void Gaussian_1_ctor(struct Gaussian_1 *const self, bool_t noInitialization)
{
	struct YawRateSpace *yawRateSpace = NULL;
	struct PositiveDefiniteMatrix_1 *positiveDefiniteMatrix = NULL;

	Object_ctor(&self->base);
	self->_dimensions = (&Gaussian_8_EmptySpace->base)->Dimensions;
	if (!!noInitialization)
	{
		return;
	}
	yawRateSpace = New_YawRateSpace();
	YawRateSpace_ctor(yawRateSpace);
	Gaussian_1_set_Expectation(self, yawRateSpace);
	(void)Assign_YawRateSpace(&yawRateSpace, NULL);
	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_1();
	PositiveDefiniteMatrix_1_ctor_1(positiveDefiniteMatrix);
	Gaussian_1_set_Covariance(self, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_1(&positiveDefiniteMatrix, NULL);
}

struct Gaussian_1 *Gaussian_8_Create(struct YawRateSpace *expectation, struct PositiveDefiniteMatrix_1 *covariance)
{
	struct Gaussian_1 *result = NULL;
	struct Gaussian_1 *gaussian = NULL;

	gaussian = New_Gaussian_1();
	Gaussian_1_ctor(gaussian, true);
	Gaussian_1_set_Expectation(gaussian, expectation);
	Gaussian_1_set_Covariance(gaussian, covariance);
	(void)Assign_Gaussian_1(&result, gaussian);
	(void)Assign_Gaussian_1(&gaussian, NULL);
	return result;
}

struct Gaussian_1 *EKF_PredictMeasurement_1(struct Gaussian_4 *predictedState, struct YawRateMeasurementModel *measurementModel, struct Matrix_9 **transitionMatrix)
{
	struct CTRASpace *ctraSpace = NULL;
	struct Matrix_9 **matrix = NULL;
	struct Matrix_9 *matrix_1 = NULL;
	struct MatrixData_10 *matrixData = NULL;
	struct MatrixData_10 *matrixData_1 = NULL;
	struct MatrixData_3 *matrix_2 = NULL;
	struct MatrixData_10 *matrixData_2 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix = NULL;
	struct MatrixData_11 *matrixData_3 = NULL;
	struct MatrixData_3 *matrixData_4 = NULL;
	struct PositiveDefiniteMatrix_1 *positiveDefiniteMatrix_1 = NULL;
	struct MatrixData_3 *matrixData_5 = NULL;
	struct MatrixData_3 *matrixData_6 = NULL;
	struct PositiveDefiniteMatrix_1 *covariance = NULL;
	struct PositiveDefiniteMatrix_1 *positiveDefiniteMatrix_2 = NULL;
	struct Gaussian_1 *result = NULL;
	struct YawRateSpace *yawRateSpace = NULL;
	struct Gaussian_1 *gaussian = NULL;

	if (!(__ContrRunti_1_insidContrEvalua > ((int32_t)4)))
	{
		bool_t boolean = false;
		bool_t boolean_1 = false;

		__ContrRunti_1_insidContrEvalua = __ContrRunti_1_insidContrEvalua + ((int32_t)1);
		boolean = Object_2_ReferenceEquals(&predictedState->base, NULL);
		if (!!boolean)
		{
			abort();
		}
		boolean_1 = Object_2_ReferenceEquals(&measurementModel->base.base.base, NULL);
		if (!!boolean_1)
		{
			abort();
		}
		__ContrRunti_1_insidContrEvalua = __ContrRunti_1_insidContrEvalua - ((int32_t)1);
	}
	ctraSpace = Gaussian_4_get_Expectation(predictedState);
	MeasuremenModel_1_set_Condition(&(*&measurementModel)->base.base, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	matrix = transitionMatrix;
	matrix_1 = MeasurModel_5_get_TransitMatrix(measurementModel);
	(void)Assign_Matrix_9(&*matrix, matrix_1);
	(void)Assign_Matrix_9(&matrix_1, NULL);
	matrixData_1 = Matrix_9_get_MatrixData(*transitionMatrix);
	(void)Assign_MatrixData_10(&matrixData, matrixData_1);
	(void)Assign_MatrixData_10(&matrixData_1, NULL);
	(void)Assign_MatrixData_10(&matrixData_2, matrixData);
	positiveDefiniteMatrix = Gaussian_4_get_Covariance(predictedState);
	matrixData_3 = Matrix_6_get_MatrixData(&positiveDefiniteMatrix->base.base);
	matrixData_4 = MatrixMath_Multiply_8(false, false, true, matrixData_2, matrixData_3, matrixData);
	positiveDefiniteMatrix_1 = MeasuremeModel_1_get_Covariance(&(*&measurementModel)->base.base);
	matrixData_5 = Matrix_1_get_MatrixData(&positiveDefiniteMatrix_1->base.base);
	matrixData_6 = MatrixMath_Add_1(matrixData_4, matrixData_5);
	(void)Assign_MatrixData_3(&matrix_2, matrixData_6);
	(void)Assign_MatrixData_10(&matrixData_2, NULL);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix, NULL);
	(void)Assign_MatrixData_11(&matrixData_3, NULL);
	(void)Assign_MatrixData_3(&matrixData_4, NULL);
	(void)Assign_PositiveDefiniteMatrix_1(&positiveDefiniteMatrix_1, NULL);
	(void)Assign_MatrixData_3(&matrixData_5, NULL);
	(void)Assign_MatrixData_3(&matrixData_6, NULL);
	positiveDefiniteMatrix_2 = PosiDefinMatri_10_CreatAndCorre(matrix_2);
	(void)Assign_PositiveDefiniteMatrix_1(&covariance, positiveDefiniteMatrix_2);
	(void)Assign_PositiveDefiniteMatrix_1(&positiveDefiniteMatrix_2, NULL);
	yawRateSpace = MeasuremeModel_1_get_Expectatio(measurementModel);
	gaussian = Gaussian_8_Create(yawRateSpace, covariance);
	(void)Assign_Gaussian_1(&result, gaussian);
	(void)Assign_YawRateSpace(&yawRateSpace, NULL);
	(void)Assign_Gaussian_1(&gaussian, NULL);
	RemRef_MatrixData_10(matrixData);
	RemRef_MatrixData_3(matrix_2);
	RemRef_PositiveDefiniteMatrix_1(covariance);
	return result;
}

struct PositiveDefiniteMatrix_1 *Gaussian_1_get_Covariance(struct Gaussian_1 *const self)
{
	struct PositiveDefiniteMatrix_1 *result = NULL;

	Gaussian_1_ResetCachedValues(self);
	(void)Assign_PositiveDefiniteMatrix_1(&result, self->covariance);
	return result;
}

struct YawRateSpace *Gaussian_1_get_Expectation(struct Gaussian_1 *const self)
{
	struct YawRateSpace *result = NULL;

	(void)Assign_YawRateSpace(&result, self->Expectation);
	return result;
}

struct Gaussian_4 *EKF_Update_2(struct Gaussian_4 *predictedState, struct Gaussian_1 *predictedMeasurement, struct YawRateSpace *measurement, struct Matrix_9 *transitionMatrix)
{
	struct MatrixData_3 *matrixData = NULL;
	struct PositiveDefiniteMatrix_1 *positiveDefiniteMatrix = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;
	struct MatrixData_9 *matrixData2 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_1 = NULL;
	struct MatrixData_11 *matrixData_2 = NULL;
	struct MatrixData_10 *matrixData_3 = NULL;
	struct MatrixData_3 *matrixData_4 = NULL;
	struct MatrixData_3 *matrixData_5 = NULL;
	struct MatrixData_3 *matrixData_6 = NULL;
	struct MatrixData_9 *matrixData_7 = NULL;
	struct MatrixData_3 *right = NULL;
	struct YawRateSpace *yawRateSpace = NULL;
	struct YawRateSpace *yawRateSpace_1 = NULL;
	struct float64_t_1D_1 *array = NULL;
	struct MatrixData_3 *matrixData_8 = NULL;
	struct CTRASpace *expectation = NULL;
	struct CTRASpace *ctraSpace = NULL;
	struct MatrixData_9 *vector = NULL;
	struct MatrixData_9 *matrixData_9 = NULL;
	struct MatrixData_9 *matrixData_10 = NULL;
	struct MatrixData_9 *matrixData_11 = NULL;
	struct MatrixData_11 *matrix = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_2 = NULL;
	struct MatrixData_11 *matrixData_12 = NULL;
	struct MatrixData_11 *matrixData_13 = NULL;
	struct MatrixData_11 *matrixData_14 = NULL;
	struct CTRASpace *expectation2 = NULL;
	struct CTRASpace *ctraSpace_1 = NULL;
	struct CTRASpace *ctraSpace_2 = NULL;
	struct PositiveDefiniteMatrix_6 *covariance = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_3 = NULL;
	struct Gaussian_4 *result = NULL;
	struct Gaussian_4 *gaussian = NULL;

	positiveDefiniteMatrix = Gaussian_1_get_Covariance(predictedMeasurement);
	matrixData_1 = Matrix_1_get_MatrixData(&positiveDefiniteMatrix->base.base);
	(void)Assign_MatrixData_3(&matrixData, matrixData_1);
	(void)Assign_PositiveDefiniteMatrix_1(&positiveDefiniteMatrix, NULL);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
	positiveDefiniteMatrix_1 = Gaussian_4_get_Covariance(predictedState);
	matrixData_2 = Matrix_6_get_MatrixData(&positiveDefiniteMatrix_1->base.base);
	matrixData_3 = Matrix_9_get_MatrixData(transitionMatrix);
	(void)Assign_MatrixData_3(&matrixData_4, matrixData);
	matrixData_5 = MatrixData_20_Eye_2(matrixData->Rows, matrixData->Columns);
	matrixData_6 = MatrixMath_LinsolveSquare(matrixData_4, matrixData_5);
	matrixData_7 = MatrixMath_Multiply_13(false, true, false, matrixData_2, matrixData_3, matrixData_6);
	(void)Assign_MatrixData_9(&matrixData2, matrixData_7);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_1, NULL);
	(void)Assign_MatrixData_11(&matrixData_2, NULL);
	(void)Assign_MatrixData_10(&matrixData_3, NULL);
	(void)Assign_MatrixData_3(&matrixData_4, NULL);
	(void)Assign_MatrixData_3(&matrixData_5, NULL);
	(void)Assign_MatrixData_3(&matrixData_6, NULL);
	(void)Assign_MatrixData_9(&matrixData_7, NULL);
	(void)Assign_YawRateSpace(&yawRateSpace, measurement);
	yawRateSpace_1 = Gaussian_1_get_Expectation(predictedMeasurement);
	array = Space_6_op_Subtraction(&yawRateSpace->base, &yawRateSpace_1->base);
	matrixData_8 = MatrixData_20_Create(array);
	(void)Assign_MatrixData_3(&right, matrixData_8);
	(void)Assign_YawRateSpace(&yawRateSpace, NULL);
	(void)Assign_YawRateSpace(&yawRateSpace_1, NULL);
	(void)Assign_float64_t_1D_1(&array, NULL);
	(void)Assign_MatrixData_3(&matrixData_8, NULL);
	ctraSpace = Gaussian_4_get_Expectation(predictedState);
	(void)Assign_CTRASpace(&expectation, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	matrixData_9 = Space_5_get_MatrixData(&(*&expectation)->base.base);
	matrixData_10 = MatrixMath_Multiply_12(false, false, matrixData2, right);
	matrixData_11 = MatrixMath_Add_2(matrixData_9, matrixData_10);
	(void)Assign_MatrixData_9(&vector, matrixData_11);
	(void)Assign_MatrixData_9(&matrixData_9, NULL);
	(void)Assign_MatrixData_9(&matrixData_10, NULL);
	(void)Assign_MatrixData_9(&matrixData_11, NULL);
	positiveDefiniteMatrix_2 = Gaussian_4_get_Covariance(predictedState);
	matrixData_12 = Matrix_6_get_MatrixData(&positiveDefiniteMatrix_2->base.base);
	matrixData_13 = MatrixMath_Multiply_15(false, false, true, matrixData2, matrixData, matrixData2);
	matrixData_14 = MatrixMath_Subtract_1(matrixData_12, matrixData_13);
	(void)Assign_MatrixData_11(&matrix, matrixData_14);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_2, NULL);
	(void)Assign_MatrixData_11(&matrixData_12, NULL);
	(void)Assign_MatrixData_11(&matrixData_13, NULL);
	(void)Assign_MatrixData_11(&matrixData_14, NULL);
	ctraSpace_1 = Space_6_Create_1(vector);
	ctraSpace_2 = SpaceExtensions_FitToDomain(ctraSpace_1);
	(void)Assign_CTRASpace(&expectation2, ctraSpace_2);
	(void)Assign_CTRASpace(&ctraSpace_1, NULL);
	(void)Assign_CTRASpace(&ctraSpace_2, NULL);
	positiveDefiniteMatrix_3 = PositDefinMatri_8_CreatAndCorre(matrix);
	(void)Assign_PositiveDefiniteMatrix_6(&covariance, positiveDefiniteMatrix_3);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_3, NULL);
	gaussian = Gaussian_6_Create(expectation2, covariance);
	(void)Assign_Gaussian_4(&result, gaussian);
	(void)Assign_Gaussian_4(&gaussian, NULL);
	RemRef_MatrixData_3(matrixData);
	RemRef_MatrixData_9(matrixData2);
	RemRef_MatrixData_3(right);
	RemRef_CTRASpace(expectation);
	RemRef_MatrixData_9(vector);
	RemRef_MatrixData_11(matrix);
	RemRef_CTRASpace(expectation2);
	RemRef_PositiveDefiniteMatrix_6(covariance);
	return result;
}

struct Gaussian_4 *EKF_Update_3(struct Gaussian_4 *predictedState, struct YawRateSpace *measurement, struct YawRateMeasurementModel *measurementModel)
{
	struct Matrix_9 *transitionMatrix = NULL;
	struct Gaussian_1 *predictedMeasurement = NULL;
	struct Gaussian_1 *gaussian = NULL;
	struct Gaussian_4 *result = NULL;
	struct Gaussian_4 *gaussian_1 = NULL;

	gaussian = EKF_PredictMeasurement_1(predictedState, measurementModel, &transitionMatrix);
	(void)Assign_Gaussian_1(&predictedMeasurement, gaussian);
	(void)Assign_Gaussian_1(&gaussian, NULL);
	gaussian_1 = EKF_Update_2(predictedState, predictedMeasurement, measurement, transitionMatrix);
	(void)Assign_Gaussian_4(&result, gaussian_1);
	(void)Assign_Gaussian_4(&gaussian_1, NULL);
	RemRef_Matrix_9(transitionMatrix);
	RemRef_Gaussian_1(predictedMeasurement);
	return result;
}

void EgoMotionFilter_FilterYawRate(struct EgoMotionFilter *const self, struct DateTime time_1, struct Measure_3 *yawRate)
{
	bool_t s__LockTaken2 = false;
	struct Object *CS_2_0000 = NULL;
	struct Object *object = NULL;
	struct EgoMotionFilter *egoMotionFilter = NULL;
	bool_t boolean = false;
	struct EgoMotionFilter *egoMotionFilter_1 = NULL;
	struct TimeSpan deltaT = { 0 };
	struct DateTime dateTime = { 0 };
	struct DateTime dateTime_1 = { 0 };
	struct TimeSpan timeSpan = { 0 };
	struct Gaussian_4 *predictedSpace = NULL;
	struct Gaussian_4 *gaussian = NULL;
	struct YawRateSpace *measurement = NULL;
	struct YawRateSpace *yawRateSpace = NULL;
	float64_t double_ = 0.0;
	struct Gaussian_4 *gaussian_1 = NULL;
	struct Nullable_1 nullable = { 0 };

	s__LockTaken2 = false;
	(void)Assign_Object(&object, Assign_Object(&CS_2_0000, self->_stateLock));
	s__LockTaken2 = true;
	(void)Assign_Object(&object, NULL);
	(void)Assign_EgoMotionFilter(&egoMotionFilter, self);
	boolean = Nullable_1_get_HasValue(&egoMotionFilter->_lastCorrectionTime);
	if (!boolean)
	{
		struct Nullable_1 nullable_1 = { 0 };

		Nullable_1_ctor(&nullable_1, time_1);
		self->_lastCorrectionTime = nullable_1;
	}
	dateTime = time_1;
	(void)Assign_EgoMotionFilter(&egoMotionFilter_1, self);
	dateTime_1 = Nullable_1_get_Value(&egoMotionFilter_1->_lastCorrectionTime);
	timeSpan = DateTime_1_op_Subtraction(dateTime, dateTime_1);
	deltaT = timeSpan;
	gaussian = EKF_PredictState(deltaT, self->_state, self->_systemModel);
	(void)Assign_Gaussian_4(&predictedSpace, gaussian);
	(void)Assign_Gaussian_4(&gaussian, NULL);
	yawRateSpace = New_YawRateSpace();
	YawRateSpace_ctor(yawRateSpace);
	double_ = Measure_5_op_Implicit(&yawRate->base);
	YawRateSpace_set_W(yawRateSpace, double_);
	(void)Assign_YawRateSpace(&measurement, yawRateSpace);
	(void)Assign_YawRateSpace(&yawRateSpace, NULL);
	gaussian_1 = EKF_Update_3(predictedSpace, measurement, self->_yawRateMeasurementModel);
	(void)Assign_Gaussian_4(&self->_state, gaussian_1);
	(void)Assign_Gaussian_4(&gaussian_1, NULL);
	Nullable_1_ctor(&nullable, time_1);
	self->_lastCorrectionTime = nullable;
	self->_isYawRateFiltered = true;
	RemRef_Object(CS_2_0000);
	RemRef_EgoMotionFilter(egoMotionFilter);
	RemRef_EgoMotionFilter(egoMotionFilter_1);
	RemRef_Gaussian_4(predictedSpace);
	RemRef_YawRateSpace(measurement);
}

void Tracking_ProcessYawRate(struct Tracking *const self, struct DateTime time_1, struct Measure_3 *yawRate)
{
	EgoMotionFilter_FilterYawRate(self->_egoMotionFilter, time_1, yawRate);
}

static void RemRef_StaticListFactory_1(struct StaticListFactory_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListFactory_1.CurrentCount--;
		Res_StaticListFactory_1.Next[Res_StaticListFactory_1.CurrentCount] = self;
		Del_StaticListFactory_1(self);
	}
}

struct StaticListFactory_1 *New_StaticListFactory_1(void)
{
	static struct StaticListFactory_1 const Default_StaticListFactory_1 = { 1 };
	struct StaticListFactory_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListFactory_1.CurrentCount == RC_StaticListFactory_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListFactory_1.Next[Res_StaticListFactory_1.CurrentCount];
	Res_StaticListFactory_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListFactory_1.MaximumCount = (Res_StaticListFactory_1.CurrentCount > Res_StaticListFactory_1.MaximumCount) ? Res_StaticListFactory_1.CurrentCount : Res_StaticListFactory_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListFactory_1;
	return instance;
}

struct StaticListFactory_1 *Assign_StaticListFactory_1(struct StaticListFactory_1 **const left, struct StaticListFactory_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListFactory_1(*left);
	*left = right;
	return right;
}

void StaticListFactory_1_ctor(struct StaticListFactory_1 *const self, int32_t maximumCount)
{
	assert(maximumCount == ((int32_t)50));
	Object_ctor(&self->base);
	self->_maximumCount = maximumCount;
}

static void RemRef_StatIPDATracCollFactProv(struct StatiIPDATrackColleFactorProvid *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StatIPDATracColleFactoProvi.CurrentCount--;
		Res_StatIPDATracColleFactoProvi.Next[Res_StatIPDATracColleFactoProvi.CurrentCount] = self;
		Del_StatIPDATracColleFactoProvi(self);
	}
}

struct StatiIPDATrackColleFactorProvid *New_StatIPDATracColleFactoProvi(void)
{
	static struct StatiIPDATrackColleFactorProvid const Defa_StatIPDATracCollFactoProvi = { 1 };
	struct StatiIPDATrackColleFactorProvid *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StatIPDATracColleFactoProvi.CurrentCount == RC_StatIPDATrackColleFactoProvi)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StatIPDATracColleFactoProvi.Next[Res_StatIPDATracColleFactoProvi.CurrentCount];
	Res_StatIPDATracColleFactoProvi.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StatIPDATracColleFactoProvi.MaximumCount = (Res_StatIPDATracColleFactoProvi.CurrentCount > Res_StatIPDATracColleFactoProvi.MaximumCount) ? Res_StatIPDATracColleFactoProvi.CurrentCount : Res_StatIPDATracColleFactoProvi.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Defa_StatIPDATracCollFactoProvi;
	return instance;
}

struct StatiIPDATrackColleFactorProvid *Assi_StatIPDATracCollFactoProvi(struct StatiIPDATrackColleFactorProvid **const left, struct StatiIPDATrackColleFactorProvid *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StatIPDATracCollFactProv(*left);
	*left = right;
	return right;
}

static void RemRef_StaticListFactory_2(struct StaticListFactory_2 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListFactory_2.CurrentCount--;
		Res_StaticListFactory_2.Next[Res_StaticListFactory_2.CurrentCount] = self;
		Del_StaticListFactory_2(self);
	}
}

struct StaticListFactory_2 *New_StaticListFactory_2(void)
{
	static struct StaticListFactory_2 const Default_StaticListFactory_2 = { 1 };
	struct StaticListFactory_2 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListFactory_2.CurrentCount == RC_StaticListFactory_2)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListFactory_2.Next[Res_StaticListFactory_2.CurrentCount];
	Res_StaticListFactory_2.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListFactory_2.MaximumCount = (Res_StaticListFactory_2.CurrentCount > Res_StaticListFactory_2.MaximumCount) ? Res_StaticListFactory_2.CurrentCount : Res_StaticListFactory_2.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListFactory_2;
	return instance;
}

struct StaticListFactory_2 *Assign_StaticListFactory_2(struct StaticListFactory_2 **const left, struct StaticListFactory_2 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListFactory_2(*left);
	*left = right;
	return right;
}

void StaticListFactory_2_ctor(struct StaticListFactory_2 *const self, int32_t maximumCount)
{
	assert(maximumCount == ((int32_t)41));
	Object_ctor(&self->base);
	self->_maximumCount = maximumCount;
}

static void RemRef_StaticListFactory_3(struct StaticListFactory_3 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListFactory_3.CurrentCount--;
		Res_StaticListFactory_3.Next[Res_StaticListFactory_3.CurrentCount] = self;
		Del_StaticListFactory_3(self);
	}
}

struct StaticListFactory_3 *New_StaticListFactory_3(void)
{
	static struct StaticListFactory_3 const Default_StaticListFactory_3 = { 1 };
	struct StaticListFactory_3 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListFactory_3.CurrentCount == RC_StaticListFactory_3)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListFactory_3.Next[Res_StaticListFactory_3.CurrentCount];
	Res_StaticListFactory_3.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListFactory_3.MaximumCount = (Res_StaticListFactory_3.CurrentCount > Res_StaticListFactory_3.MaximumCount) ? Res_StaticListFactory_3.CurrentCount : Res_StaticListFactory_3.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListFactory_3;
	return instance;
}

struct StaticListFactory_3 *Assign_StaticListFactory_3(struct StaticListFactory_3 **const left, struct StaticListFactory_3 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListFactory_3(*left);
	*left = right;
	return right;
}

void StaticListFactory_3_ctor(struct StaticListFactory_3 *const self, int32_t maximumCount)
{
	assert(maximumCount == ((int32_t)1));
	Object_ctor(&self->base);
	self->_maximumCount = maximumCount;
}

static void RemRef_StaticAssociTableFactory(struct StaticAssociationTableFactory *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticAssociatiTableFactory.CurrentCount--;
		Res_StaticAssociatiTableFactory.Next[Res_StaticAssociatiTableFactory.CurrentCount] = self;
		Del_StaticAssociatiTableFactory(self);
	}
}

struct StaticAssociationTableFactory *New_StaticAssociatiTableFactory(void)
{
	static struct StaticAssociationTableFactory const Defaul_StaticAssociTableFactory = { 1 };
	struct StaticAssociationTableFactory *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticAssociatiTableFactory.CurrentCount == RC_StaticAssociatioTableFactory)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticAssociatiTableFactory.Next[Res_StaticAssociatiTableFactory.CurrentCount];
	Res_StaticAssociatiTableFactory.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticAssociatiTableFactory.MaximumCount = (Res_StaticAssociatiTableFactory.CurrentCount > Res_StaticAssociatiTableFactory.MaximumCount) ? Res_StaticAssociatiTableFactory.CurrentCount : Res_StaticAssociatiTableFactory.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Defaul_StaticAssociTableFactory;
	return instance;
}

struct StaticAssociationTableFactory *Assign_StaticAssociTableFactory(struct StaticAssociationTableFactory **const left, struct StaticAssociationTableFactory *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticAssociTableFactory(*left);
	*left = right;
	return right;
}

void StaticAssociatTableFactory_ctor(struct StaticAssociationTableFactory *const self, int32_t maximumRows, int32_t maximumColumns)
{
	assert(maximumRows == ((int32_t)15));
	assert(maximumColumns == ((int32_t)40));
	Object_ctor(&self->base);
	self->_maximumRows = maximumRows;
	self->_maximumColumns = maximumColumns;
}

static void RemRef_StaticListFactory_4(struct StaticListFactory_4 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListFactory_4.CurrentCount--;
		Res_StaticListFactory_4.Next[Res_StaticListFactory_4.CurrentCount] = self;
		Del_StaticListFactory_4(self);
	}
}

struct StaticListFactory_4 *New_StaticListFactory_4(void)
{
	static struct StaticListFactory_4 const Default_StaticListFactory_4 = { 1 };
	struct StaticListFactory_4 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListFactory_4.CurrentCount == RC_StaticListFactory_4)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListFactory_4.Next[Res_StaticListFactory_4.CurrentCount];
	Res_StaticListFactory_4.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListFactory_4.MaximumCount = (Res_StaticListFactory_4.CurrentCount > Res_StaticListFactory_4.MaximumCount) ? Res_StaticListFactory_4.CurrentCount : Res_StaticListFactory_4.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListFactory_4;
	return instance;
}

struct StaticListFactory_4 *Assign_StaticListFactory_4(struct StaticListFactory_4 **const left, struct StaticListFactory_4 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListFactory_4(*left);
	*left = right;
	return right;
}

void StaticListFactory_4_ctor(struct StaticListFactory_4 *const self, int32_t maximumCount)
{
	assert(maximumCount == ((int32_t)15));
	Object_ctor(&self->base);
	self->_maximumCount = maximumCount;
}

static void RemRef_StaticListFactory_5(struct StaticListFactory_5 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListFactory_5.CurrentCount--;
		Res_StaticListFactory_5.Next[Res_StaticListFactory_5.CurrentCount] = self;
		Del_StaticListFactory_5(self);
	}
}

struct StaticListFactory_5 *New_StaticListFactory_5(void)
{
	static struct StaticListFactory_5 const Default_StaticListFactory_5 = { 1 };
	struct StaticListFactory_5 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListFactory_5.CurrentCount == RC_StaticListFactory_5)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListFactory_5.Next[Res_StaticListFactory_5.CurrentCount];
	Res_StaticListFactory_5.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListFactory_5.MaximumCount = (Res_StaticListFactory_5.CurrentCount > Res_StaticListFactory_5.MaximumCount) ? Res_StaticListFactory_5.CurrentCount : Res_StaticListFactory_5.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListFactory_5;
	return instance;
}

struct StaticListFactory_5 *Assign_StaticListFactory_5(struct StaticListFactory_5 **const left, struct StaticListFactory_5 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListFactory_5(*left);
	*left = right;
	return right;
}

void StaticListFactory_5_ctor(struct StaticListFactory_5 *const self, int32_t maximumCount)
{
	assert(maximumCount == ((int32_t)40));
	Object_ctor(&self->base);
	self->_maximumCount = maximumCount;
}

void StatIPDATracCollFactoProvi_ctor(struct StatiIPDATrackColleFactorProvid *const self, int32_t maximumTrackCount, int32_t maximumMeasurementCount)
{
	struct StaticListFactory_2 *staticListFactory = NULL;
	struct StaticListFactory_3 *staticListFactory_1 = NULL;
	struct StaticAssociationTableFactory *staticAssociationTableFactory = NULL;
	struct StaticListFactory_4 *staticListFactory_2 = NULL;
	struct StaticListFactory_5 *staticListFactory_3 = NULL;

	assert(maximumTrackCount == ((int32_t)15));
	assert(maximumMeasurementCount == ((int32_t)40));
	Object_ctor(&self->base);
	staticListFactory = New_StaticListFactory_2();
	StaticListFactory_2_ctor(staticListFactory, maximumMeasurementCount + ((int32_t)1));
	(void)Assign_StaticListFactory_2(&self->_hypothesisListFactory, staticListFactory);
	(void)Assign_StaticListFactory_2(&staticListFactory, NULL);
	staticListFactory_1 = New_StaticListFactory_3();
	StaticListFactory_3_ctor(staticListFactory_1, ((int32_t)1));
	(void)Assign_StaticListFactory_3(&self->_trueElementsListFactory, staticListFactory_1);
	(void)Assign_StaticListFactory_3(&staticListFactory_1, NULL);
	staticAssociationTableFactory = New_StaticAssociatiTableFactory();
	StaticAssociatTableFactory_ctor(staticAssociationTableFactory, maximumTrackCount, maximumMeasurementCount);
	(void)Assign_StaticAssociTableFactory(&self->_associationTableFactory, staticAssociationTableFactory);
	(void)Assign_StaticAssociTableFactory(&staticAssociationTableFactory, NULL);
	staticListFactory_2 = New_StaticListFactory_4();
	StaticListFactory_4_ctor(staticListFactory_2, maximumTrackCount);
	(void)Assign_StaticListFactory_4(&self->_trackListFactory, staticListFactory_2);
	(void)Assign_StaticListFactory_4(&staticListFactory_2, NULL);
	staticListFactory_3 = New_StaticListFactory_5();
	StaticListFactory_5_ctor(staticListFactory_3, maximumMeasurementCount);
	(void)Assign_StaticListFactory_5(&self->_measurementListFactory, staticListFactory_3);
	(void)Assign_StaticListFactory_5(&staticListFactory_3, NULL);
}

struct MobilEyeParameters *SensorProper_get_MobilEyeParame(struct SensorProperties *const self)
{
	struct MobilEyeParameters *arg_18_0 = NULL;
	struct MobilEyeParameters *result = NULL;

	if (!(Assign_MobilEyeParameters(&arg_18_0, self->_mobilEyeParameters) != NULL))
	{
		struct MobilEyeParameters *mobilEyeParameters = NULL;

		mobilEyeParameters = SensProp_1_GetDefaMobilEyeParam();
		(void)Assign_MobilEyeParameters(&arg_18_0, Assign_MobilEyeParameters(&self->_mobilEyeParameters, mobilEyeParameters));
		(void)Assign_MobilEyeParameters(&mobilEyeParameters, NULL);
	}
	(void)Assign_MobilEyeParameters(&result, arg_18_0);
	RemRef_MobilEyeParameters(arg_18_0);
	return result;
}

bool_t EgoMotionFilter_get_IsStable(struct EgoMotionFilter *const self)
{
	if (!!self->_isVelocityFiltered)
	{
		return self->_isYawRateFiltered;
	}
	return false;
}

static bool_t Matri_6_get_InterMatrixIsInitia(struct Matrix_6 *const self)
{
	return self->_matrix != NULL;
}

static struct MatrixData_11 *Matrix_6_get_UncheckeMatrixData(struct Matrix_6 *const self)
{
	struct MatrixData_11 *result = NULL;

	(void)Assign_MatrixData_11(&result, self->_matrix);
	return result;
}

struct PositiveDefiniteMatrix_6 *PositiveDefiniteMatrix_6_Clone(struct PositiveDefiniteMatrix_6 *const self)
{
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_1 = NULL;
	bool_t boolean = false;
	struct PositiveDefiniteMatrix_6 *result = NULL;

	positiveDefiniteMatrix_1 = New_PositiveDefiniteMatrix_6();
	PositiveDefiniteMatrix_6_ctor(positiveDefiniteMatrix_1);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix, positiveDefiniteMatrix_1);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_1, NULL);
	boolean = Matri_6_get_InterMatrixIsInitia(&self->base.base);
	if (!!boolean)
	{
		struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_2 = NULL;
		struct MatrixData_11 *matrixData = NULL;
		struct MatrixData_11 *matrixData_1 = NULL;

		(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_2, positiveDefiniteMatrix);
		matrixData = Matrix_6_get_UncheckeMatrixData(&self->base.base);
		matrixData_1 = MatrixData_11_get_Copy(matrixData);
		Matrix_6_set_UncheckeMatrixData(&positiveDefiniteMatrix_2->base.base, matrixData_1);
		(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_2, NULL);
		(void)Assign_MatrixData_11(&matrixData, NULL);
		(void)Assign_MatrixData_11(&matrixData_1, NULL);
	}
	(void)Assign_PositiveDefiniteMatrix_6(&result, positiveDefiniteMatrix);
	RemRef_PositiveDefiniteMatrix_6(positiveDefiniteMatrix);
	return result;
}

void Gaussian_4_ctor_1(struct Gaussian_4 *const self, struct CTRASpace *expectation, struct PositiveDefiniteMatrix_6 *covariance)
{
	struct CTRASpace *ctraSpace = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix = NULL;

	Object_ctor(&self->base);
	self->_dimensions = (&Gaussian_6_EmptySpace->base.base)->Dimensions;
	ctraSpace = SpaceExtensions_Clone_1(expectation);
	Gaussian_4_set_Expectation(self, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	positiveDefiniteMatrix = PositiveDefiniteMatrix_6_Clone(covariance);
	Gaussian_4_set_Covariance(self, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix, NULL);
}

struct Gaussian_4 *Gaussian_4_Clone(struct Gaussian_4 *const self)
{
	struct Gaussian_4 *result = NULL;
	struct CTRASpace *ctraSpace = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix = NULL;
	struct Gaussian_4 *gaussian = NULL;

	ctraSpace = Gaussian_4_get_Expectation(self);
	positiveDefiniteMatrix = Gaussian_4_get_Covariance(self);
	gaussian = New_Gaussian_4();
	Gaussian_4_ctor_1(gaussian, ctraSpace, positiveDefiniteMatrix);
	(void)Assign_Gaussian_4(&result, gaussian);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix, NULL);
	(void)Assign_Gaussian_4(&gaussian, NULL);
	return result;
}

static void EgoMotionFilter_ResetPosition(struct EgoMotionFilter *const self)
{
	struct CTRASpace *ctraSpace = NULL;
	struct CTRASpace *ctraSpace_1 = NULL;
	struct CTRASpace *ctraSpace_2 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_1 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_2 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_3 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_4 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_5 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_6 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_7 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_8 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_9 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_10 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_11 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_12 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_13 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_14 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_15 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_16 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_17 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_18 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_19 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_20 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_21 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_22 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_23 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_24 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_25 = NULL;
	struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix_26 = NULL;

	ctraSpace = Gaussian_4_get_Expectation(self->_state);
	CTRASpace_set_X(ctraSpace, 0.0);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	ctraSpace_1 = Gaussian_4_get_Expectation(self->_state);
	CTRASpace_set_Y(ctraSpace_1, 0.0);
	(void)Assign_CTRASpace(&ctraSpace_1, NULL);
	ctraSpace_2 = Gaussian_4_get_Expectation(self->_state);
	CTRASpace_set_G(ctraSpace_2, 0.0);
	(void)Assign_CTRASpace(&ctraSpace_2, NULL);
	positiveDefiniteMatrix = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix, ((int32_t)0), ((int32_t)0), 0.0001);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix, NULL);
	positiveDefiniteMatrix_1 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_1, ((int32_t)0), ((int32_t)1), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_1, NULL);
	positiveDefiniteMatrix_2 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_2, ((int32_t)0), ((int32_t)2), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_2, NULL);
	positiveDefiniteMatrix_3 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_3, ((int32_t)0), ((int32_t)3), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_3, NULL);
	positiveDefiniteMatrix_4 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_4, ((int32_t)0), ((int32_t)4), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_4, NULL);
	positiveDefiniteMatrix_5 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_5, ((int32_t)0), ((int32_t)5), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_5, NULL);
	positiveDefiniteMatrix_6 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_6, ((int32_t)1), ((int32_t)0), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_6, NULL);
	positiveDefiniteMatrix_7 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_7, ((int32_t)1), ((int32_t)1), 0.0001);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_7, NULL);
	positiveDefiniteMatrix_8 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_8, ((int32_t)1), ((int32_t)2), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_8, NULL);
	positiveDefiniteMatrix_9 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_9, ((int32_t)1), ((int32_t)3), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_9, NULL);
	positiveDefiniteMatrix_10 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_10, ((int32_t)1), ((int32_t)4), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_10, NULL);
	positiveDefiniteMatrix_11 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_11, ((int32_t)1), ((int32_t)5), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_11, NULL);
	positiveDefiniteMatrix_12 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_12, ((int32_t)2), ((int32_t)0), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_12, NULL);
	positiveDefiniteMatrix_13 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_13, ((int32_t)2), ((int32_t)1), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_13, NULL);
	positiveDefiniteMatrix_14 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_14, ((int32_t)2), ((int32_t)2), 1E-06);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_14, NULL);
	positiveDefiniteMatrix_15 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_15, ((int32_t)2), ((int32_t)3), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_15, NULL);
	positiveDefiniteMatrix_16 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_16, ((int32_t)2), ((int32_t)4), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_16, NULL);
	positiveDefiniteMatrix_17 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_17, ((int32_t)2), ((int32_t)5), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_17, NULL);
	positiveDefiniteMatrix_18 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_18, ((int32_t)3), ((int32_t)0), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_18, NULL);
	positiveDefiniteMatrix_19 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_19, ((int32_t)3), ((int32_t)1), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_19, NULL);
	positiveDefiniteMatrix_20 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_20, ((int32_t)3), ((int32_t)2), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_20, NULL);
	positiveDefiniteMatrix_21 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_21, ((int32_t)4), ((int32_t)0), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_21, NULL);
	positiveDefiniteMatrix_22 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_22, ((int32_t)4), ((int32_t)1), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_22, NULL);
	positiveDefiniteMatrix_23 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_23, ((int32_t)4), ((int32_t)2), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_23, NULL);
	positiveDefiniteMatrix_24 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_24, ((int32_t)5), ((int32_t)0), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_24, NULL);
	positiveDefiniteMatrix_25 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_25, ((int32_t)5), ((int32_t)1), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_25, NULL);
	positiveDefiniteMatrix_26 = Gaussian_4_get_Covariance(self->_state);
	PositivDefinitMatrix_6_set_Item(positiveDefiniteMatrix_26, ((int32_t)5), ((int32_t)2), 0.0);
	(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix_26, NULL);
}

struct Gaussian_4 *EgoMotionFilter_PredicXAndReset(struct EgoMotionFilter *const self, struct DateTime time_1)
{
	struct EgoMotionFilter *egoMotionFilter = NULL;
	bool_t boolean = false;
	struct Gaussian_4 *result = NULL;
	bool_t boolean_1 = false;
	bool_t boolean_2 = false;
	bool_t s__LockTaken5 = false;
	struct Object *CS_2_0001 = NULL;
	struct Object *object = NULL;
	struct EgoMotionFilter *egoMotionFilter_1 = NULL;
	struct TimeSpan deltaT = { 0 };
	struct DateTime dateTime = { 0 };
	struct DateTime dateTime_1 = { 0 };
	struct TimeSpan timeSpan = { 0 };
	struct Gaussian_4 *result_1 = NULL;
	struct Gaussian_4 *gaussian = NULL;
	struct Gaussian_4 *gaussian_1 = NULL;
	struct Nullable_1 nullable = { 0 };
	struct Gaussian_4 *CS_1_0000 = NULL;

	boolean_1 = EgoMotionFilter_get_IsStable(self);
	if (boolean_1 == true)
	{
		(void)Assign_EgoMotionFilter(&egoMotionFilter, self);
		boolean = Nullable_1_get_HasValue(&egoMotionFilter->_lastCorrectionTime);
		boolean_2 = boolean;
	}
	else
	{
		boolean_2 = false;
	}
	if (!boolean_2)
	{
		struct CTRASpace *ctraSpace = NULL;
		struct PositiveDefiniteMatrix_6 *positiveDefiniteMatrix = NULL;
		struct Gaussian_4 *gaussian_2 = NULL;

		ctraSpace = Gaussian_4_get_Expectation(self->_state);
		positiveDefiniteMatrix = Gaussian_4_get_Covariance(self->_state);
		gaussian_2 = New_Gaussian_4();
		Gaussian_4_ctor_1(gaussian_2, ctraSpace, positiveDefiniteMatrix);
		(void)Assign_Gaussian_4(&result, gaussian_2);
		(void)Assign_CTRASpace(&ctraSpace, NULL);
		(void)Assign_PositiveDefiniteMatrix_6(&positiveDefiniteMatrix, NULL);
		(void)Assign_Gaussian_4(&gaussian_2, NULL);
		RemRef_EgoMotionFilter(egoMotionFilter);
		RemRef_Object(CS_2_0001);
		RemRef_EgoMotionFilter(egoMotionFilter_1);
		RemRef_Gaussian_4(result_1);
		RemRef_Gaussian_4(CS_1_0000);
		return result;
	}
	s__LockTaken5 = false;
	(void)Assign_Object(&object, Assign_Object(&CS_2_0001, self->_stateLock));
	s__LockTaken5 = true;
	(void)Assign_Object(&object, NULL);
	dateTime = time_1;
	(void)Assign_EgoMotionFilter(&egoMotionFilter_1, self);
	dateTime_1 = Nullable_1_get_Value(&egoMotionFilter_1->_lastCorrectionTime);
	timeSpan = DateTime_1_op_Subtraction(dateTime, dateTime_1);
	deltaT = timeSpan;
	gaussian = EKF_PredictState(deltaT, self->_state, self->_systemModel);
	(void)Assign_Gaussian_4(&result_1, gaussian);
	(void)Assign_Gaussian_4(&gaussian, NULL);
	gaussian_1 = Gaussian_4_Clone(result_1);
	(void)Assign_Gaussian_4(&self->_state, gaussian_1);
	(void)Assign_Gaussian_4(&gaussian_1, NULL);
	Nullable_1_ctor(&nullable, time_1);
	self->_lastCorrectionTime = nullable;
	EgoMotionFilter_ResetPosition(self);
	(void)Assign_Gaussian_4(&CS_1_0000, result_1);
	(void)Assign_Gaussian_4(&result, CS_1_0000);
	RemRef_EgoMotionFilter(egoMotionFilter);
	RemRef_Object(CS_2_0001);
	RemRef_EgoMotionFilter(egoMotionFilter_1);
	RemRef_Gaussian_4(result_1);
	RemRef_Gaussian_4(CS_1_0000);
	return result;
}

bool_t DateTime_1_op_LessThan(struct DateTime t1, struct DateTime t2)
{
	int64_t int64 = ((int64_t)0);
	int64_t int64_1 = ((int64_t)0);

	int64 = DateTime_get_InternalTicks(&t1);
	int64_1 = DateTime_get_InternalTicks(&t2);
	return int64 < int64_1;
}

struct StaticListFactory_4 *StIPDATrColFacPro_get_TraLisFac(struct StatiIPDATrackColleFactorProvid *const self)
{
	struct StaticListFactory_4 *result = NULL;

	(void)Assign_StaticListFactory_4(&result, self->_trackListFactory);
	return result;
}

int32_t StatiListFacto_4_get_MaximCount(struct StaticListFactory_4 *const self)
{
	return self->_maximumCount;
}

static void RemRef_StaticList_23(struct StaticList_23 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_23.CurrentCount--;
		Res_StaticList_23.Next[Res_StaticList_23.CurrentCount] = self;
		Del_StaticList_23(self);
	}
}

struct StaticList_23 *New_StaticList_23(void)
{
	static struct StaticList_23 const Default_StaticList_23 = { 1 };
	struct StaticList_23 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_23.CurrentCount == RC_StaticList_23)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_23.Next[Res_StaticList_23.CurrentCount];
	Res_StaticList_23.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_23.MaximumCount = (Res_StaticList_23.CurrentCount > Res_StaticList_23.MaximumCount) ? Res_StaticList_23.CurrentCount : Res_StaticList_23.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_23;
	return instance;
}

struct StaticList_23 *Assign_StaticList_23(struct StaticList_23 **const left, struct StaticList_23 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_23(*left);
	*left = right;
	return right;
}

static void Del_Gaussian_5_1D_15(struct Gaussian_5_1D_15 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)15);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_Gaussian_5(self->Elements[i]);
	}
}

static void RemRef_Gaussian_5_1D_15(struct Gaussian_5_1D_15 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Gaussian_5_1D_15.CurrentCount--;
		Res_Gaussian_5_1D_15.Next[Res_Gaussian_5_1D_15.CurrentCount] = self;
		Del_Gaussian_5_1D_15(self);
	}
}

struct Gaussian_5_1D_15 *New_Gaussian_5_1D_15(void)
{
	static struct Gaussian_5_1D_15 const Default_Gaussian_5_1D_15 = { 1 };
	struct Gaussian_5_1D_15 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Gaussian_5_1D_15.CurrentCount == RC_Gaussian_5_1D_15)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Gaussian_5_1D_15.Next[Res_Gaussian_5_1D_15.CurrentCount];
	Res_Gaussian_5_1D_15.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Gaussian_5_1D_15.MaximumCount = (Res_Gaussian_5_1D_15.CurrentCount > Res_Gaussian_5_1D_15.MaximumCount) ? Res_Gaussian_5_1D_15.CurrentCount : Res_Gaussian_5_1D_15.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Gaussian_5_1D_15;
	return instance;
}

struct Gaussian_5_1D_15 *Assign_Gaussian_5_1D_15(struct Gaussian_5_1D_15 **const left, struct Gaussian_5_1D_15 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Gaussian_5_1D_15(*left);
	*left = right;
	return right;
}

void StaticList_23_ctor(struct StaticList_23 *const self, int32_t maximumCount)
{
	struct Gaussian_5_1D_15 *array = NULL;

	assert(maximumCount == ((int32_t)15));
	Object_ctor(&self->base);
	array = New_Gaussian_5_1D_15();
	(void)Assign_Gaussian_5_1D_15(&self->_items, array);
	(void)Assign_Gaussian_5_1D_15(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_23 *StaticListFactor_4_CreateInstan(struct StaticListFactory_4 *const self, int32_t capacity)
{
	struct StaticList_23 *result = NULL;
	struct StaticList_23 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_4_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_23();
	StaticList_23_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_23(&result, staticList);
	(void)Assign_StaticList_23(&staticList, NULL);
	return result;
}

static void RemRef_StaticList_20(struct StaticList_20 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_20.CurrentCount--;
		Res_StaticList_20.Next[Res_StaticList_20.CurrentCount] = self;
		Del_StaticList_20(self);
	}
}

struct StaticList_20 *New_StaticList_20(void)
{
	static struct StaticList_20 const Default_StaticList_20 = { 1 };
	struct StaticList_20 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_20.CurrentCount == RC_StaticList_20)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_20.Next[Res_StaticList_20.CurrentCount];
	Res_StaticList_20.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_20.MaximumCount = (Res_StaticList_20.CurrentCount > Res_StaticList_20.MaximumCount) ? Res_StaticList_20.CurrentCount : Res_StaticList_20.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_20;
	return instance;
}

struct StaticList_20 *Assign_StaticList_20(struct StaticList_20 **const left, struct StaticList_20 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_20(*left);
	*left = right;
	return right;
}

static void RemRef_Gaussian_2(struct Gaussian_2 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Gaussian_2.CurrentCount--;
		Res_Gaussian_2.Next[Res_Gaussian_2.CurrentCount] = self;
		Del_Gaussian_2(self);
	}
}

struct Gaussian_2 *New_Gaussian_2(void)
{
	static struct Gaussian_2 const Default_Gaussian_2 = { 1 };
	struct Gaussian_2 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Gaussian_2.CurrentCount == RC_Gaussian_2)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Gaussian_2.Next[Res_Gaussian_2.CurrentCount];
	Res_Gaussian_2.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Gaussian_2.MaximumCount = (Res_Gaussian_2.CurrentCount > Res_Gaussian_2.MaximumCount) ? Res_Gaussian_2.CurrentCount : Res_Gaussian_2.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Gaussian_2;
	return instance;
}

struct Gaussian_2 *Assign_Gaussian_2(struct Gaussian_2 **const left, struct Gaussian_2 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Gaussian_2(*left);
	*left = right;
	return right;
}

static void Del_Gaussian_2_1D_15(struct Gaussian_2_1D_15 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)15);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_Gaussian_2(self->Elements[i]);
	}
}

static void RemRef_Gaussian_2_1D_15(struct Gaussian_2_1D_15 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Gaussian_2_1D_15.CurrentCount--;
		Res_Gaussian_2_1D_15.Next[Res_Gaussian_2_1D_15.CurrentCount] = self;
		Del_Gaussian_2_1D_15(self);
	}
}

struct Gaussian_2_1D_15 *New_Gaussian_2_1D_15(void)
{
	static struct Gaussian_2_1D_15 const Default_Gaussian_2_1D_15 = { 1 };
	struct Gaussian_2_1D_15 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Gaussian_2_1D_15.CurrentCount == RC_Gaussian_2_1D_15)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Gaussian_2_1D_15.Next[Res_Gaussian_2_1D_15.CurrentCount];
	Res_Gaussian_2_1D_15.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Gaussian_2_1D_15.MaximumCount = (Res_Gaussian_2_1D_15.CurrentCount > Res_Gaussian_2_1D_15.MaximumCount) ? Res_Gaussian_2_1D_15.CurrentCount : Res_Gaussian_2_1D_15.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Gaussian_2_1D_15;
	return instance;
}

struct Gaussian_2_1D_15 *Assign_Gaussian_2_1D_15(struct Gaussian_2_1D_15 **const left, struct Gaussian_2_1D_15 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Gaussian_2_1D_15(*left);
	*left = right;
	return right;
}

void StaticList_20_ctor(struct StaticList_20 *const self, int32_t maximumCount)
{
	struct Gaussian_2_1D_15 *array = NULL;

	assert(maximumCount == ((int32_t)15));
	Object_ctor(&self->base);
	array = New_Gaussian_2_1D_15();
	(void)Assign_Gaussian_2_1D_15(&self->_items, array);
	(void)Assign_Gaussian_2_1D_15(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_20 *StatiListFactor_4_CreateInstan(struct StaticListFactory_4 *const self, int32_t capacity)
{
	struct StaticList_20 *result = NULL;
	struct StaticList_20 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_4_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_20();
	StaticList_20_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_20(&result, staticList);
	(void)Assign_StaticList_20(&staticList, NULL);
	return result;
}

static void RemRef_StaticList_16(struct StaticList_16 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_16.CurrentCount--;
		Res_StaticList_16.Next[Res_StaticList_16.CurrentCount] = self;
		Del_StaticList_16(self);
	}
}

struct StaticList_16 *New_StaticList_16(void)
{
	static struct StaticList_16 const Default_StaticList_16 = { 1 };
	struct StaticList_16 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_16.CurrentCount == RC_StaticList_16)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_16.Next[Res_StaticList_16.CurrentCount];
	Res_StaticList_16.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_16.MaximumCount = (Res_StaticList_16.CurrentCount > Res_StaticList_16.MaximumCount) ? Res_StaticList_16.CurrentCount : Res_StaticList_16.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_16;
	return instance;
}

struct StaticList_16 *Assign_StaticList_16(struct StaticList_16 **const left, struct StaticList_16 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_16(*left);
	*left = right;
	return right;
}

static void RemRef_Matrix_11(struct Matrix_11 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Matrix_11.CurrentCount--;
		Res_Matrix_11.Next[Res_Matrix_11.CurrentCount] = self;
		Del_Matrix_11(self);
	}
}

struct Matrix_11 *New_Matrix_11(void)
{
	static struct Matrix_11 const Default_Matrix_11 = { 1 };
	struct Matrix_11 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Matrix_11.CurrentCount == RC_Matrix_11)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Matrix_11.Next[Res_Matrix_11.CurrentCount];
	Res_Matrix_11.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Matrix_11.MaximumCount = (Res_Matrix_11.CurrentCount > Res_Matrix_11.MaximumCount) ? Res_Matrix_11.CurrentCount : Res_Matrix_11.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Matrix_11;
	return instance;
}

struct Matrix_11 *Assign_Matrix_11(struct Matrix_11 **const left, struct Matrix_11 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Matrix_11(*left);
	*left = right;
	return right;
}

static void Del_Matrix_11_1D_15(struct Matrix_11_1D_15 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)15);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_Matrix_11(self->Elements[i]);
	}
}

static void RemRef_Matrix_11_1D_15(struct Matrix_11_1D_15 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Matrix_11_1D_15.CurrentCount--;
		Res_Matrix_11_1D_15.Next[Res_Matrix_11_1D_15.CurrentCount] = self;
		Del_Matrix_11_1D_15(self);
	}
}

struct Matrix_11_1D_15 *New_Matrix_11_1D_15(void)
{
	static struct Matrix_11_1D_15 const Default_Matrix_11_1D_15 = { 1 };
	struct Matrix_11_1D_15 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Matrix_11_1D_15.CurrentCount == RC_Matrix_11_1D_15)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Matrix_11_1D_15.Next[Res_Matrix_11_1D_15.CurrentCount];
	Res_Matrix_11_1D_15.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Matrix_11_1D_15.MaximumCount = (Res_Matrix_11_1D_15.CurrentCount > Res_Matrix_11_1D_15.MaximumCount) ? Res_Matrix_11_1D_15.CurrentCount : Res_Matrix_11_1D_15.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Matrix_11_1D_15;
	return instance;
}

struct Matrix_11_1D_15 *Assign_Matrix_11_1D_15(struct Matrix_11_1D_15 **const left, struct Matrix_11_1D_15 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Matrix_11_1D_15(*left);
	*left = right;
	return right;
}

void StaticList_16_ctor(struct StaticList_16 *const self, int32_t maximumCount)
{
	struct Matrix_11_1D_15 *array = NULL;

	assert(maximumCount == ((int32_t)15));
	Object_ctor(&self->base);
	array = New_Matrix_11_1D_15();
	(void)Assign_Matrix_11_1D_15(&self->_items, array);
	(void)Assign_Matrix_11_1D_15(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_16 *StatiListFacto_4_CreateInstan(struct StaticListFactory_4 *const self, int32_t capacity)
{
	struct StaticList_16 *result = NULL;
	struct StaticList_16 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_4_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_16();
	StaticList_16_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_16(&result, staticList);
	(void)Assign_StaticList_16(&staticList, NULL);
	return result;
}

static void RemRef_StaticList_26(struct StaticList_26 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_26.CurrentCount--;
		Res_StaticList_26.Next[Res_StaticList_26.CurrentCount] = self;
		Del_StaticList_26(self);
	}
}

struct StaticList_26 *New_StaticList_26(void)
{
	static struct StaticList_26 const Default_StaticList_26 = { 1 };
	struct StaticList_26 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_26.CurrentCount == RC_StaticList_26)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_26.Next[Res_StaticList_26.CurrentCount];
	Res_StaticList_26.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_26.MaximumCount = (Res_StaticList_26.CurrentCount > Res_StaticList_26.MaximumCount) ? Res_StaticList_26.CurrentCount : Res_StaticList_26.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_26;
	return instance;
}

struct StaticList_26 *Assign_StaticList_26(struct StaticList_26 **const left, struct StaticList_26 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_26(*left);
	*left = right;
	return right;
}

static void Del_Existence_1D_15(struct Existence_1D_15 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)15);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_Existence(self->Elements[i]);
	}
}

static void RemRef_Existence_1D_15(struct Existence_1D_15 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Existence_1D_15.CurrentCount--;
		Res_Existence_1D_15.Next[Res_Existence_1D_15.CurrentCount] = self;
		Del_Existence_1D_15(self);
	}
}

struct Existence_1D_15 *New_Existence_1D_15(void)
{
	static struct Existence_1D_15 const Default_Existence_1D_15 = { 1 };
	struct Existence_1D_15 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Existence_1D_15.CurrentCount == RC_Existence_1D_15)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Existence_1D_15.Next[Res_Existence_1D_15.CurrentCount];
	Res_Existence_1D_15.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Existence_1D_15.MaximumCount = (Res_Existence_1D_15.CurrentCount > Res_Existence_1D_15.MaximumCount) ? Res_Existence_1D_15.CurrentCount : Res_Existence_1D_15.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Existence_1D_15;
	return instance;
}

struct Existence_1D_15 *Assign_Existence_1D_15(struct Existence_1D_15 **const left, struct Existence_1D_15 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Existence_1D_15(*left);
	*left = right;
	return right;
}

void StaticList_26_ctor(struct StaticList_26 *const self, int32_t maximumCount)
{
	struct Existence_1D_15 *array = NULL;

	assert(maximumCount == ((int32_t)15));
	Object_ctor(&self->base);
	array = New_Existence_1D_15();
	(void)Assign_Existence_1D_15(&self->_items, array);
	(void)Assign_Existence_1D_15(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_26 *StatiListFacto_4_CreateInstan_1(struct StaticListFactory_4 *const self, int32_t capacity)
{
	struct StaticList_26 *result = NULL;
	struct StaticList_26 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_4_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_26();
	StaticList_26_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_26(&result, staticList);
	(void)Assign_StaticList_26(&staticList, NULL);
	return result;
}

static void RemRef_StaticList_22(struct StaticList_22 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_22.CurrentCount--;
		Res_StaticList_22.Next[Res_StaticList_22.CurrentCount] = self;
		Del_StaticList_22(self);
	}
}

struct StaticList_22 *New_StaticList_22(void)
{
	static struct StaticList_22 const Default_StaticList_22 = { 1 };
	struct StaticList_22 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_22.CurrentCount == RC_StaticList_22)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_22.Next[Res_StaticList_22.CurrentCount];
	Res_StaticList_22.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_22.MaximumCount = (Res_StaticList_22.CurrentCount > Res_StaticList_22.MaximumCount) ? Res_StaticList_22.CurrentCount : Res_StaticList_22.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_22;
	return instance;
}

struct StaticList_22 *Assign_StaticList_22(struct StaticList_22 **const left, struct StaticList_22 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_22(*left);
	*left = right;
	return right;
}

static void RemRef_MarginalizedEvaluable(struct MarginalizedEvaluable *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MarginalizedEvaluable.CurrentCount--;
		Res_MarginalizedEvaluable.Next[Res_MarginalizedEvaluable.CurrentCount] = self;
		Del_MarginalizedEvaluable(self);
	}
}

struct MarginalizedEvaluable *New_MarginalizedEvaluable(void)
{
	static struct MarginalizedEvaluable const Default_MarginalizedEvaluable = { 1 };
	struct MarginalizedEvaluable *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MarginalizedEvaluable.CurrentCount == RC_MarginalizedEvaluable)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MarginalizedEvaluable.Next[Res_MarginalizedEvaluable.CurrentCount];
	Res_MarginalizedEvaluable.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MarginalizedEvaluable.MaximumCount = (Res_MarginalizedEvaluable.CurrentCount > Res_MarginalizedEvaluable.MaximumCount) ? Res_MarginalizedEvaluable.CurrentCount : Res_MarginalizedEvaluable.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MarginalizedEvaluable;
	return instance;
}

struct MarginalizedEvaluable *Assign_MarginalizedEvaluable(struct MarginalizedEvaluable **const left, struct MarginalizedEvaluable *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MarginalizedEvaluable(*left);
	*left = right;
	return right;
}

static void Del_MarginalizedEvaluable_1D_15(struct MarginalizedEvaluable_1D_15 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)15);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_MarginalizedEvaluable(self->Elements[i]);
	}
}

static void RemRef_MarginaliEvaluable_1D_15(struct MarginalizedEvaluable_1D_15 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MarginalizedEvaluable_1D_15.CurrentCount--;
		Res_MarginalizedEvaluable_1D_15.Next[Res_MarginalizedEvaluable_1D_15.CurrentCount] = self;
		Del_MarginalizedEvaluable_1D_15(self);
	}
}

struct MarginalizedEvaluable_1D_15 *New_MarginalizedEvaluable_1D_15(void)
{
	static struct MarginalizedEvaluable_1D_15 const Default_MarginalEvaluable_1D_15 = { 1 };
	struct MarginalizedEvaluable_1D_15 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MarginalizedEvaluable_1D_15.CurrentCount == RC_MarginalizedEvaluable_1D_15)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MarginalizedEvaluable_1D_15.Next[Res_MarginalizedEvaluable_1D_15.CurrentCount];
	Res_MarginalizedEvaluable_1D_15.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MarginalizedEvaluable_1D_15.MaximumCount = (Res_MarginalizedEvaluable_1D_15.CurrentCount > Res_MarginalizedEvaluable_1D_15.MaximumCount) ? Res_MarginalizedEvaluable_1D_15.CurrentCount : Res_MarginalizedEvaluable_1D_15.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MarginalEvaluable_1D_15;
	return instance;
}

struct MarginalizedEvaluable_1D_15 *Assign_MarginaliEvaluable_1D_15(struct MarginalizedEvaluable_1D_15 **const left, struct MarginalizedEvaluable_1D_15 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MarginaliEvaluable_1D_15(*left);
	*left = right;
	return right;
}

void StaticList_22_ctor(struct StaticList_22 *const self, int32_t maximumCount)
{
	struct MarginalizedEvaluable_1D_15 *array = NULL;

	assert(maximumCount == ((int32_t)15));
	Object_ctor(&self->base);
	array = New_MarginalizedEvaluable_1D_15();
	(void)Assign_MarginaliEvaluable_1D_15(&self->_items, array);
	(void)Assign_MarginaliEvaluable_1D_15(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_22 *StatiListFacto_4_CreateInstan_2(struct StaticListFactory_4 *const self, int32_t capacity)
{
	struct StaticList_22 *result = NULL;
	struct StaticList_22 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_4_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_22();
	StaticList_22_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_22(&result, staticList);
	(void)Assign_StaticList_22(&staticList, NULL);
	return result;
}

float64_t Tracking_get_ProcessNoiseSigmaA(struct Tracking *const self)
{
	return self->ProcessNoiseSigmaA;
}

float64_t Tracki_get_ProcesNoiseSigmaJerk(struct Tracking *const self)
{
	return self->ProcessNoiseSigmaJerk;
}

float64_t Tracking_get_ProcessNoiseSigmaW(struct Tracking *const self)
{
	return self->ProcessNoiseSigmaW;
}

static void RemRef_PositiveDefiniteMatrix_2(struct PositiveDefiniteMatrix_2 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base)->ReferenceCount--;
	if ((&self->base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_PositiveDefiniteMatrix_2.CurrentCount--;
		Res_PositiveDefiniteMatrix_2.Next[Res_PositiveDefiniteMatrix_2.CurrentCount] = self;
		Del_PositiveDefiniteMatrix_2(self);
	}
}

struct PositiveDefiniteMatrix_2 *New_PositiveDefiniteMatrix_2(void)
{
	static struct PositiveDefiniteMatrix_2 const Default_PositivDefiniteMatrix_2 = { 1 };
	struct PositiveDefiniteMatrix_2 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_PositiveDefiniteMatrix_2.CurrentCount == RC_PositiveDefiniteMatrix_2)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_PositiveDefiniteMatrix_2.Next[Res_PositiveDefiniteMatrix_2.CurrentCount];
	Res_PositiveDefiniteMatrix_2.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_PositiveDefiniteMatrix_2.MaximumCount = (Res_PositiveDefiniteMatrix_2.CurrentCount > Res_PositiveDefiniteMatrix_2.MaximumCount) ? Res_PositiveDefiniteMatrix_2.CurrentCount : Res_PositiveDefiniteMatrix_2.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_PositivDefiniteMatrix_2;
	return instance;
}

struct PositiveDefiniteMatrix_2 *Assign_PositiveDefiniteMatrix_2(struct PositiveDefiniteMatrix_2 **const left, struct PositiveDefiniteMatrix_2 *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base)->ReferenceCount++;
	}
	RemRef_PositiveDefiniteMatrix_2(*left);
	*left = right;
	return right;
}

static void RemRef_CAErrorSpace(struct CAErrorSpace *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_CAErrorSpace.CurrentCount--;
		Res_CAErrorSpace.Next[Res_CAErrorSpace.CurrentCount] = self;
		Del_CAErrorSpace(self);
	}
}

struct CAErrorSpace *New_CAErrorSpace(void)
{
	static struct CAErrorSpace const Default_CAErrorSpace = { 1 };
	struct CAErrorSpace *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_CAErrorSpace.CurrentCount == RC_CAErrorSpace)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_CAErrorSpace.Next[Res_CAErrorSpace.CurrentCount];
	Res_CAErrorSpace.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_CAErrorSpace.MaximumCount = (Res_CAErrorSpace.CurrentCount > Res_CAErrorSpace.MaximumCount) ? Res_CAErrorSpace.CurrentCount : Res_CAErrorSpace.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_CAErrorSpace;
	return instance;
}

struct CAErrorSpace *Assign_CAErrorSpace(struct CAErrorSpace **const left, struct CAErrorSpace *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_CAErrorSpace(*left);
	*left = right;
	return right;
}

void CAErrorSpace_ctor(struct CAErrorSpace *const self)
{
	Space_2_ctor(&self->base, ((int32_t)3));
}

void Matrix_2_ctor(struct Matrix_2 *const self)
{
	struct CAErrorSpace *caErrorSpace = NULL;
	struct CAErrorSpace *caErrorSpace_1 = NULL;

	caErrorSpace = New_CAErrorSpace();
	CAErrorSpace_ctor(caErrorSpace);
	(void)Assign_CAErrorSpace(&self->EmptyRowSpace, caErrorSpace);
	(void)Assign_CAErrorSpace(&caErrorSpace, NULL);
	caErrorSpace_1 = New_CAErrorSpace();
	CAErrorSpace_ctor(caErrorSpace_1);
	(void)Assign_CAErrorSpace(&self->EmptyColumnSpace, caErrorSpace_1);
	(void)Assign_CAErrorSpace(&caErrorSpace_1, NULL);
	Object_ctor(&self->base);
	self->Columns = (&self->EmptyRowSpace->base)->Dimensions;
	self->Rows = (&self->EmptyColumnSpace->base)->Dimensions;
}

void SquareMatrix_2_ctor(struct SquareMatrix_2 *const self)
{
	struct CAErrorSpace *caErrorSpace = NULL;

	caErrorSpace = New_CAErrorSpace();
	CAErrorSpace_ctor(caErrorSpace);
	(void)Assign_CAErrorSpace(&self->EmptySpace, caErrorSpace);
	(void)Assign_CAErrorSpace(&caErrorSpace, NULL);
	Matrix_2_ctor(&self->base);
	self->Dimensions = (&self->base)->Rows;
}

static void RemRef_MatrixData_13(struct MatrixData_13 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_13.CurrentCount--;
		Res_MatrixData_13.Next[Res_MatrixData_13.CurrentCount] = self;
		Del_MatrixData_13(self);
	}
}

struct MatrixData_13 *New_MatrixData_13(void)
{
	static struct MatrixData_13 const Default_MatrixData_13 = { 1 };
	struct MatrixData_13 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_13.CurrentCount == RC_MatrixData_13)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_13.Next[Res_MatrixData_13.CurrentCount];
	Res_MatrixData_13.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_13.MaximumCount = (Res_MatrixData_13.CurrentCount > Res_MatrixData_13.MaximumCount) ? Res_MatrixData_13.CurrentCount : Res_MatrixData_13.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_13;
	return instance;
}

struct MatrixData_13 *Assign_MatrixData_13(struct MatrixData_13 **const left, struct MatrixData_13 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_13(*left);
	*left = right;
	return right;
}

static void Del_float64_t_1D_9(struct float64_t_1D_9 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_1D_9(struct float64_t_1D_9 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_1D_9.CurrentCount--;
		Res_float64_t_1D_9.Next[Res_float64_t_1D_9.CurrentCount] = self;
		Del_float64_t_1D_9(self);
	}
}

struct float64_t_1D_9 *New_float64_t_1D_9(void)
{
	static struct float64_t_1D_9 const Default_float64_t_1D_9 = { 1 };
	struct float64_t_1D_9 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_1D_9.CurrentCount == RC_float64_t_1D_9)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_1D_9.Next[Res_float64_t_1D_9.CurrentCount];
	Res_float64_t_1D_9.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_1D_9.MaximumCount = (Res_float64_t_1D_9.CurrentCount > Res_float64_t_1D_9.MaximumCount) ? Res_float64_t_1D_9.CurrentCount : Res_float64_t_1D_9.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_1D_9;
	return instance;
}

struct float64_t_1D_9 *Assign_float64_t_1D_9(struct float64_t_1D_9 **const left, struct float64_t_1D_9 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_1D_9(*left);
	*left = right;
	return right;
}

void MatrixData_13_ctor(struct MatrixData_13 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_9 *array = NULL;

	assert(rows == ((int32_t)3));
	assert(columns == ((int32_t)3));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_9();
	(void)Assign_float64_t_1D_9(&self->_data, array);
	(void)Assign_float64_t_1D_9(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct float64_t_1D_9 *MatrixData_13_get_DataReference(struct MatrixData_13 *const self)
{
	struct float64_t_1D_9 *result = NULL;

	(void)Assign_float64_t_1D_9(&result, self->_data);
	return result;
}

static void MatrixData_13_SetValueFast(struct MatrixData_13 *const self, float64_t value, int32_t row, int32_t column)
{
	struct float64_t_1D_9 *array = NULL;

	array = MatrixData_13_get_DataReference(self);
	array->Elements[(column * self->Rows) + row] = value;
	(void)Assign_float64_t_1D_9(&array, NULL);
}

struct MatrixData_13 *MatrixData_20_Diag_3(struct float64_t_1D_3 *diagonalElements)
{
	struct MatrixData_13 *matrixData = NULL;
	struct MatrixData_13 *matrixData_1 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_13 *result = NULL;

	if (!(diagonalElements != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData_13();
	MatrixData_13_ctor(matrixData_1, ((int32_t)3), ((int32_t)3));
	(void)Assign_MatrixData_13(&matrixData, matrixData_1);
	(void)Assign_MatrixData_13(&matrixData_1, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)3))
	{
		MatrixData_13_SetValueFast(matrixData, diagonalElements->Elements[i], i, i);
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_13(&result, matrixData);
	RemRef_MatrixData_13(matrixData);
	return result;
}

static void Matrix_2_set_UncheckeMatrixData(struct Matrix_2 *const self, struct MatrixData_13 *value)
{
	(void)Assign_MatrixData_13(&self->_matrix, value);
}

static void Matrix_2_CheckMatrix(struct Matrix_2 *const self)
{
	struct float64_t_1D_9 *dataReference = NULL;
	struct float64_t_1D_9 *array = NULL;
	int32_t i = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);

	array = MatrixData_13_get_DataReference(self->_matrix);
	(void)Assign_float64_t_1D_9(&dataReference, array);
	(void)Assign_float64_t_1D_9(&array, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)9))
	{
		bool_t boolean = false;

		boolean = Double_IsNaN(dataReference->Elements[i]);
		if (!!boolean)
		{
			num = i / self->Rows;
			num2 = i - (num * self->Rows);
			abort();
		}
		i = i + ((int32_t)1);
	}
	RemRef_float64_t_1D_9(dataReference);
}

struct MatrixData_13 *MatrixData_20_Zeros_11(int32_t rows, int32_t columns)
{
	struct MatrixData_13 *result = NULL;
	struct MatrixData_13 *matrixData = NULL;

	assert(rows == ((int32_t)3));
	assert(columns == ((int32_t)3));
	matrixData = New_MatrixData_13();
	MatrixData_13_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData_13(&result, matrixData);
	(void)Assign_MatrixData_13(&matrixData, NULL);
	return result;
}

struct MatrixData_13 *Matrix_2_get_MatrixData(struct Matrix_2 *const self)
{
	struct MatrixData_13 *result = NULL;

	if (!(self->_matrix != NULL))
	{
		struct MatrixData_13 *matrixData = NULL;

		matrixData = MatrixData_20_Zeros_11(self->Rows, self->Columns);
		(void)Assign_MatrixData_13(&self->_matrix, matrixData);
		(void)Assign_MatrixData_13(&matrixData, NULL);
	}
	(void)Assign_MatrixData_13(&result, self->_matrix);
	return result;
}

static void SquareMatrix_2_CheckMatrix(struct SquareMatrix_2 *const self)
{
	struct MatrixData_13 *matrixData = NULL;
	int32_t int32 = ((int32_t)0);
	struct MatrixData_13 *matrixData_1 = NULL;

	Matrix_2_CheckMatrix(&self->base);
	matrixData = Matrix_2_get_MatrixData(&self->base);
	int32 = matrixData->Rows;
	matrixData_1 = Matrix_2_get_MatrixData(&self->base);
	(void)Assign_MatrixData_13(&matrixData, NULL);
	(void)Assign_MatrixData_13(&matrixData_1, NULL);
}

bool_t MatrixData_13_get_IsZero(struct MatrixData_13 *const self)
{
	struct float64_t_1D_9 *data = NULL;
	int32_t i = ((int32_t)0);
	float64_t num = 0.0;

	(void)Assign_float64_t_1D_9(&data, self->_data);
	i = ((int32_t)0);
	while (i < ((int32_t)9))
	{
		num = data->Elements[i];
		if (!(num == 0.0))
		{
			RemRef_float64_t_1D_9(data);
			return false;
		}
		i = i + ((int32_t)1);
	}
	RemRef_float64_t_1D_9(data);
	return true;
}

bool_t Matrix_2_get_IsZero(struct Matrix_2 *const self)
{
	bool_t result = false;
	struct MatrixData_13 *matrixData = NULL;
	bool_t boolean = false;

	matrixData = Matrix_2_get_MatrixData(self);
	boolean = MatrixData_13_get_IsZero(matrixData);
	result = boolean;
	(void)Assign_MatrixData_13(&matrixData, NULL);
	return result;
}

static float64_t MatrixData_13_GetValueFast(struct MatrixData_13 *const self, int32_t row, int32_t column)
{
	float64_t result = 0.0;
	struct float64_t_1D_9 *array = NULL;

	array = MatrixData_13_get_DataReference(self);
	result = array->Elements[(column * self->Rows) + row];
	(void)Assign_float64_t_1D_9(&array, NULL);
	return result;
}

float64_t MatrixData_13_get_Item(struct MatrixData_13 *const self, int32_t row, int32_t column)
{
	float64_t double_ = 0.0;

	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	double_ = MatrixData_13_GetValueFast(self, row, column);
	return double_;
}

static float64_t Matrix_2_UncheckedGet(struct Matrix_2 *const self, int32_t row, int32_t column)
{
	float64_t result = 0.0;
	struct MatrixData_13 *matrixData = NULL;
	float64_t double_ = 0.0;

	matrixData = Matrix_2_get_MatrixData(self);
	double_ = MatrixData_13_get_Item(matrixData, row, column);
	result = double_;
	(void)Assign_MatrixData_13(&matrixData, NULL);
	return result;
}

static struct MatrixData_13 *Matrix_2_get_UncheckeMatrixData(struct Matrix_2 *const self)
{
	struct MatrixData_13 *result = NULL;

	(void)Assign_MatrixData_13(&result, self->_matrix);
	return result;
}

bool_t MatrixData_13_get_IsEmpty(struct MatrixData_13 *const self)
{
	return ((int32_t)9) == ((int32_t)0);
}

void LinearAlgebra_FactorCholesky_3(struct LinearAlgebra *const self, struct float64_t_1D_9 *a, int32_t rows)
{
	int32_t num = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	float64_t num2 = 0.0;
	int32_t k = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rows > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)9) % rows) != ((int32_t)0)))
	{
		abort();
	}
	num = ((int32_t)9) / rows;
	if (!(num == rows))
	{
		abort();
	}
	i = ((int32_t)0);
	while (i < num)
	{
		j = ((int32_t)0);
		while (j <= i)
		{
			num2 = a->Elements[(i * rows) + j];
			k = ((int32_t)0);
			while (k < j)
			{
				num2 = num2 - (a->Elements[(i * rows) + k] * a->Elements[(j * rows) + k]);
				k = k + ((int32_t)1);
			}
			if (!(j >= i))
			{
				a->Elements[(i * rows) + j] = num2 / a->Elements[(j * rows) + j];
			}
			else
			{
				struct float64_t_1D_9 *array = NULL;
				int32_t int32 = ((int32_t)0);
				float64_t double_ = 0.0;

				if (!!(num2 <= 0.0))
				{
					abort();
				}
				(void)Assign_float64_t_1D_9(&array, a);
				int32 = (i * rows) + i;
				double_ = Math_Sqrt(num2);
				array->Elements[int32] = double_;
				(void)Assign_float64_t_1D_9(&array, NULL);
			}
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
}

struct MatrixData_13 *MatrixMath_Chol_3(struct MatrixData_13 *matrix)
{
	bool_t boolean = false;
	struct MatrixData_13 *matrixData = NULL;
	struct MatrixData_13 *matrixData_1 = NULL;
	struct float64_t_1D_9 *dataReference = NULL;
	struct float64_t_1D_9 *array = NULL;
	struct float64_t_1D_9 *dataReference2 = NULL;
	struct float64_t_1D_9 *array_1 = NULL;
	int32_t i = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t j = ((int32_t)0);
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_9 *array_2 = NULL;
	struct MatrixData_13 *result = NULL;

	if (!(matrix != NULL))
	{
		abort();
	}
	boolean = MatrixData_13_get_IsEmpty(matrix);
	matrixData_1 = New_MatrixData_13();
	MatrixData_13_ctor(matrixData_1, matrix->Rows, matrix->Columns);
	(void)Assign_MatrixData_13(&matrixData, matrixData_1);
	(void)Assign_MatrixData_13(&matrixData_1, NULL);
	array = MatrixData_13_get_DataReference(matrix);
	(void)Assign_float64_t_1D_9(&dataReference, array);
	(void)Assign_float64_t_1D_9(&array, NULL);
	array_1 = MatrixData_13_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_9(&dataReference2, array_1);
	(void)Assign_float64_t_1D_9(&array_1, NULL);
	i = ((int32_t)0);
	while (i < matrixData->Columns)
	{
		num = i * matrix->Rows;
		j = i;
		while (j >= ((int32_t)3))
		{
			dataReference2->Elements[num] = dataReference->Elements[num];
			dataReference2->Elements[num + ((int32_t)1)] = dataReference->Elements[num + ((int32_t)1)];
			dataReference2->Elements[num + ((int32_t)2)] = dataReference->Elements[num + ((int32_t)2)];
			dataReference2->Elements[num + ((int32_t)3)] = dataReference->Elements[num + ((int32_t)3)];
			j = j - ((int32_t)4);
			num = num + ((int32_t)4);
		}
		while (j >= ((int32_t)1))
		{
			dataReference2->Elements[num] = dataReference->Elements[num];
			dataReference2->Elements[num + ((int32_t)1)] = dataReference->Elements[num + ((int32_t)1)];
			j = j - ((int32_t)2);
			num = num + ((int32_t)2);
		}
		while (j >= ((int32_t)0))
		{
			dataReference2->Elements[num] = dataReference->Elements[num];
			j = j - ((int32_t)1);
			num = num + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array_2 = MatrixData_13_get_DataReference(matrixData);
	LinearAlgebra_FactorCholesky_3(linearAlgebra, array_2, matrixData->Rows);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_9(&array_2, NULL);
	(void)Assign_MatrixData_13(&result, matrixData);
	RemRef_MatrixData_13(matrixData);
	RemRef_float64_t_1D_9(dataReference);
	RemRef_float64_t_1D_9(dataReference2);
	return result;
}

static void PositDefiniMatrix_2_CheckMatrix(struct PositiveDefiniteMatrix_2 *const self)
{
	bool_t boolean = false;
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	struct MatrixData_13 *matrixData = NULL;
	struct MatrixData_13 *matrixData_1 = NULL;

	SquareMatrix_2_CheckMatrix(&self->base);
	boolean = Matrix_2_get_IsZero(&self->base.base);
	if (!!boolean)
	{
		return;
	}
	i = ((int32_t)0);
	while (i < (&self->base.base)->Rows)
	{
		j = ((int32_t)0);
		while (j < i)
		{
			float64_t double_ = 0.0;
			float64_t double__1 = 0.0;
			int32_t int32 = ((int32_t)0);

			double_ = Matrix_2_UncheckedGet(&self->base.base, i, j);
			double__1 = Matrix_2_UncheckedGet(&self->base.base, j, i);
			int32 = FloatCompare_Compare(double_, double__1);
			if (!!(int32 != ((int32_t)0)))
			{
				abort();
			}
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	matrixData = Matrix_2_get_UncheckeMatrixData(&self->base.base);
	matrixData_1 = MatrixMath_Chol_3(matrixData);
	(void)Assign_MatrixData_13(&matrixData, NULL);
	(void)Assign_MatrixData_13(&matrixData_1, NULL);
}

void SquareMatrix_2_ctor_1(struct PositiveDefiniteMatrix_2 *const self, struct float64_t_1D_3 *mainDiagonal)
{
	struct MatrixData_13 *matrixData = NULL;

	SquareMatrix_2_ctor(&self->base);
	matrixData = MatrixData_20_Diag_3(mainDiagonal);
	Matrix_2_set_UncheckeMatrixData(&self->base.base, matrixData);
	(void)Assign_MatrixData_13(&matrixData, NULL);
	PositDefiniMatrix_2_CheckMatrix(self);
}

void PositiveDefiniteMatrix_2_ctor(struct PositiveDefiniteMatrix_2 *const self, struct float64_t_1D_3 *mainDiagonal)
{
	SquareMatrix_2_ctor_1(self, mainDiagonal);
}

struct float64_t_1D_3 *MatrixData_4_get_DataReference(struct MatrixData_4 *const self)
{
	struct float64_t_1D_3 *result = NULL;

	(void)Assign_float64_t_1D_3(&result, self->_data);
	return result;
}

struct MatrixData_4 *MatrixData_20_Vec_5(int32_t start, int32_t end)
{
	int32_t num = ((int32_t)0);
	struct MatrixData_4 *matrixData = NULL;
	struct MatrixData_4 *matrixData_1 = NULL;
	struct float64_t_1D_3 *dataReference = NULL;
	struct float64_t_1D_3 *array = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_4 *result = NULL;

	assert(start == ((int32_t)0));
	assert(end == ((int32_t)2));
	num = (end - start) + ((int32_t)1);
	matrixData_1 = New_MatrixData_4();
	MatrixData_4_ctor(matrixData_1, num, ((int32_t)1));
	(void)Assign_MatrixData_4(&matrixData, matrixData_1);
	(void)Assign_MatrixData_4(&matrixData_1, NULL);
	array = MatrixData_4_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_3(&dataReference, array);
	(void)Assign_float64_t_1D_3(&array, NULL);
	i = ((int32_t)0);
	while (i < num)
	{
		dataReference->Elements[i] = (float64_t)(start + i);
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_4(&result, matrixData);
	RemRef_MatrixData_4(matrixData);
	RemRef_float64_t_1D_3(dataReference);
	return result;
}

void Space_2_set_MatrixData(struct Space_2 *const self, struct MatrixData_4 *value)
{
	if (!(value != NULL))
	{
		abort();
	}
	(void)Assign_MatrixData_4(&self->_vector, value);
}

struct CAErrorSpace *Space_6_GetIndices_7(void)
{
	struct CAErrorSpace *tSpace = NULL;
	struct CAErrorSpace *caErrorSpace = NULL;
	struct MatrixData_4 *matrixData = NULL;
	struct CAErrorSpace *result = NULL;

	caErrorSpace = New_CAErrorSpace();
	CAErrorSpace_ctor(caErrorSpace);
	(void)Assign_CAErrorSpace(&tSpace, caErrorSpace);
	(void)Assign_CAErrorSpace(&caErrorSpace, NULL);
	matrixData = MatrixData_20_Vec_5(((int32_t)0), (&tSpace->base)->Dimensions - ((int32_t)1));
	Space_2_set_MatrixData(&(*&tSpace)->base, matrixData);
	(void)Assign_MatrixData_4(&matrixData, NULL);
	(void)Assign_CAErrorSpace(&result, tSpace);
	RemRef_CAErrorSpace(tSpace);
	return result;
}

static void CAModel_1_cctor(void)
{
	struct CAErrorSpace *caErrorSpace = NULL;
	struct CASpace *caSpace = NULL;
	struct CAErrorSpace *caErrorSpace_1 = NULL;

	caErrorSpace = New_CAErrorSpace();
	CAErrorSpace_ctor(caErrorSpace);
	(void)Assign_CAErrorSpace(&CAModel_1_ZeroProcessNoise, caErrorSpace);
	(void)Assign_CAErrorSpace(&caErrorSpace, NULL);
	caSpace = Space_6_GetIndices();
	(void)Assign_CASpace(&CAModel_1_S, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	caErrorSpace_1 = Space_6_GetIndices_7();
	(void)Assign_CAErrorSpace(&CAModel_1_N, caErrorSpace_1);
	(void)Assign_CAErrorSpace(&caErrorSpace_1, NULL);
}

static void RemRef_CAModel(struct CAModel *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base.base)->ReferenceCount--;
	if ((&self->base.base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_CAModel.CurrentCount--;
		Res_CAModel.Next[Res_CAModel.CurrentCount] = self;
		Del_CAModel(self);
	}
}

struct CAModel *New_CAModel(void)
{
	static struct CAModel const Default_CAModel = { 1 };
	struct CAModel *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_CAModel.CurrentCount == RC_CAModel)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_CAModel.Next[Res_CAModel.CurrentCount];
	Res_CAModel.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_CAModel.MaximumCount = (Res_CAModel.CurrentCount > Res_CAModel.MaximumCount) ? Res_CAModel.CurrentCount : Res_CAModel.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_CAModel;
	return instance;
}

struct CAModel *Assign_CAModel(struct CAModel **const left, struct CAModel *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base.base)->ReferenceCount++;
	}
	RemRef_CAModel(*left);
	*left = right;
	return right;
}

void SystemModel_set_Condition(struct SystemModel *const self, struct CASpace *value)
{
	(void)Assign_CASpace(&self->Condition, value);
}

void SystemModel_set_Condition2(struct SystemModel *const self, struct CAErrorSpace *value)
{
	(void)Assign_CAErrorSpace(&self->Condition2, value);
}

void SystemModel_set_TimeCondition(struct SystemModel *const self, struct TimeSpan value)
{
	self->TimeCondition = value;
}

static void SystemModel_ctor(struct SystemModel *const self, struct PositiveDefiniteMatrix_2 *processNoiseCovariance)
{
	struct CASpace *caSpace = NULL;
	struct CAErrorSpace *caErrorSpace = NULL;

	if (!(processNoiseCovariance != NULL))
	{
		abort();
	}
	Object_ctor(&self->base);
	caSpace = New_CASpace();
	CASpace_ctor(caSpace);
	SystemModel_set_Condition(self, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	caErrorSpace = New_CAErrorSpace();
	CAErrorSpace_ctor(caErrorSpace);
	SystemModel_set_Condition2(self, caErrorSpace);
	(void)Assign_CAErrorSpace(&caErrorSpace, NULL);
	SystemModel_set_TimeCondition(self, TimeSpan_1_Zero);
	(void)Assign_PositiveDefiniteMatrix_2(&self->_processNoiseCovariance, processNoiseCovariance);
}

static void SystemModel_2_ctor(struct SystemModel_2 *const self, struct PositiveDefiniteMatrix_2 *processNoiseCovariance)
{
	SystemModel_ctor(&self->base, processNoiseCovariance);
}

static void SystemModel_4_ctor(struct SystemModel_4 *const self, struct PositiveDefiniteMatrix_2 *processNoiseCovariance)
{
	SystemModel_2_ctor(&self->base, processNoiseCovariance);
}

void CAModel_ctor(struct CAModel *const self, struct PositiveDefiniteMatrix_2 *processNoiseCovariance)
{
	SystemModel_4_ctor(&self->base, processNoiseCovariance);
}

static struct CAModel *Tracking_GetSystemModel(struct Tracking *const self)
{
	struct CAModel *result = NULL;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	float64_t double__5 = 0.0;
	float64_t double__6 = 0.0;
	float64_t double__7 = 0.0;
	struct float64_t_1D_3 *array = NULL;
	struct PositiveDefiniteMatrix_2 *positiveDefiniteMatrix = NULL;
	struct CAModel *caModel = NULL;

	double_ = Tracking_get_ProcessNoiseSigmaA(self);
	double__1 = Tracking_get_ProcessNoiseSigmaA(self);
	double__2 = double_ * double__1;
	double__3 = Tracki_get_ProcesNoiseSigmaJerk(self);
	double__4 = Tracki_get_ProcesNoiseSigmaJerk(self);
	double__5 = double__3 * double__4;
	double__6 = Tracking_get_ProcessNoiseSigmaW(self);
	double__7 = Tracking_get_ProcessNoiseSigmaW(self);
	array = New_float64_t_1D_3();
	array->Elements[((int32_t)0)] = double__2;
	array->Elements[((int32_t)1)] = double__5;
	array->Elements[((int32_t)2)] = double__6 * double__7;
	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_2();
	PositiveDefiniteMatrix_2_ctor(positiveDefiniteMatrix, array);
	caModel = New_CAModel();
	CAModel_ctor(caModel, positiveDefiniteMatrix);
	(void)Assign_CAModel(&result, caModel);
	(void)Assign_float64_t_1D_3(&array, NULL);
	(void)Assign_PositiveDefiniteMatrix_2(&positiveDefiniteMatrix, NULL);
	(void)Assign_CAModel(&caModel, NULL);
	return result;
}

float64_t Trackin_get_ProcessNoiseExisten(struct Tracking *const self)
{
	return self->ProcessNoiseExistence;
}

static void RemRef_PersistenceModel(struct PersistenceModel *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_PersistenceModel.CurrentCount--;
		Res_PersistenceModel.Next[Res_PersistenceModel.CurrentCount] = self;
		Del_PersistenceModel(self);
	}
}

struct PersistenceModel *New_PersistenceModel(void)
{
	static struct PersistenceModel const Default_PersistenceModel = { 1 };
	struct PersistenceModel *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_PersistenceModel.CurrentCount == RC_PersistenceModel)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_PersistenceModel.Next[Res_PersistenceModel.CurrentCount];
	Res_PersistenceModel.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_PersistenceModel.MaximumCount = (Res_PersistenceModel.CurrentCount > Res_PersistenceModel.MaximumCount) ? Res_PersistenceModel.CurrentCount : Res_PersistenceModel.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_PersistenceModel;
	return instance;
}

struct PersistenceModel *Assign_PersistenceModel(struct PersistenceModel **const left, struct PersistenceModel *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_PersistenceModel(*left);
	*left = right;
	return right;
}

void PersiModel_set_ExistProcesNoise(struct PersistenceModel *const self, float64_t value)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	bool_t boolean_2 = false;

	boolean_1 = value >= 0.0;
	if (boolean_1 == true)
	{
		boolean = Double_IsNaN(value);
		boolean_2 = !boolean;
	}
	else
	{
		boolean_2 = false;
	}
	if (!boolean_2)
	{
		abort();
	}
	self->_existenceProcessNoise = value;
}

void PersistenceModel_ctor(struct PersistenceModel *const self, float64_t existenceProcessNoise)
{
	Object_ctor(&self->base);
	PersiModel_set_ExistProcesNoise(self, existenceProcessNoise);
}

void PersisteModel_set_TimeCondition(struct PersistenceModel *const self, struct TimeSpan value)
{
	self->TimeCondition = value;
}

float64_t Tracking_get_GateProbability(struct Tracking *const self)
{
	return self->_gateProbability;
}

static void RemRef_MobilEyeDetectionModel(struct MobilEyeDetectionModel *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base)->ReferenceCount--;
	if ((&self->base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_MobilEyeDetectionModel.CurrentCount--;
		Res_MobilEyeDetectionModel.Next[Res_MobilEyeDetectionModel.CurrentCount] = self;
		Del_MobilEyeDetectionModel(self);
	}
}

struct MobilEyeDetectionModel *New_MobilEyeDetectionModel(void)
{
	static struct MobilEyeDetectionModel const Default_MobilEyeDetectionModel = { 1 };
	struct MobilEyeDetectionModel *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MobilEyeDetectionModel.CurrentCount == RC_MobilEyeDetectionModel)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MobilEyeDetectionModel.Next[Res_MobilEyeDetectionModel.CurrentCount];
	Res_MobilEyeDetectionModel.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MobilEyeDetectionModel.MaximumCount = (Res_MobilEyeDetectionModel.CurrentCount > Res_MobilEyeDetectionModel.MaximumCount) ? Res_MobilEyeDetectionModel.CurrentCount : Res_MobilEyeDetectionModel.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MobilEyeDetectionModel;
	return instance;
}

struct MobilEyeDetectionModel *Assign_MobilEyeDetectionModel(struct MobilEyeDetectionModel **const left, struct MobilEyeDetectionModel *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base)->ReferenceCount++;
	}
	RemRef_MobilEyeDetectionModel(*left);
	*left = right;
	return right;
}

void DetectionModel_set_Condition(struct DetectionModel *const self, struct MobilEyeSpace *value)
{
	(void)Assign_MobilEyeSpace(&self->Condition, value);
}

static void DetectionModel_ctor(struct DetectionModel *const self)
{
	struct MobilEyeSpace *mobilEyeSpace = NULL;

	Object_ctor(&self->base);
	mobilEyeSpace = New_MobilEyeSpace();
	MobilEyeSpace_ctor(mobilEyeSpace);
	DetectionModel_set_Condition(self, mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
}

void SinglDetectModel_set_GateProbab(struct SingleDetectionModel *const self, float64_t value)
{
	if (!((value >= 0.0) && (value <= 1.0)))
	{
		abort();
	}
	self->_gateProbability = value;
}

static void SingleDetectionModel_ctor(struct SingleDetectionModel *const self, float64_t gateProbability)
{
	DetectionModel_ctor(&self->base);
	SinglDetectModel_set_GateProbab(self, gateProbability);
}

void MobilEyeDetectionModel_ctor(struct MobilEyeDetectionModel *const self, struct MobilEyeParameters *parameters, float64_t gateProbability)
{
	SingleDetectionModel_ctor(&self->base, gateProbability);
	(void)Assign_MobilEyeParameters(&self->_parameters, parameters);
}

static void RemRef_EgoMotionCompensation(struct EgoMotionCompensation *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_EgoMotionCompensation.CurrentCount--;
		Res_EgoMotionCompensation.Next[Res_EgoMotionCompensation.CurrentCount] = self;
		Del_EgoMotionCompensation(self);
	}
}

struct EgoMotionCompensation *New_EgoMotionCompensation(void)
{
	static struct EgoMotionCompensation const Default_EgoMotionCompensation = { 1 };
	struct EgoMotionCompensation *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_EgoMotionCompensation.CurrentCount == RC_EgoMotionCompensation)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_EgoMotionCompensation.Next[Res_EgoMotionCompensation.CurrentCount];
	Res_EgoMotionCompensation.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_EgoMotionCompensation.MaximumCount = (Res_EgoMotionCompensation.CurrentCount > Res_EgoMotionCompensation.MaximumCount) ? Res_EgoMotionCompensation.CurrentCount : Res_EgoMotionCompensation.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_EgoMotionCompensation;
	return instance;
}

struct EgoMotionCompensation *Assign_EgoMotionCompensation(struct EgoMotionCompensation **const left, struct EgoMotionCompensation *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_EgoMotionCompensation(*left);
	*left = right;
	return right;
}

void EgoMotionCompensation_ctor(struct EgoMotionCompensation *const self)
{
	Object_ctor(&self->base);
}

void EgoMotionCompensa_set_Condition(struct EgoMotionCompensation *const self, struct CASpace *value)
{
	(void)Assign_CASpace(&self->Condition, value);
}

void EgoMotionCompensa_set_Conditio2(struct EgoMotionCompensation *const self, struct CTRASpace *value)
{
	(void)Assign_CTRASpace(&self->Condition2, value);
}

struct CASpace *EgoMotionCompensa_get_Condition(struct EgoMotionCompensation *const self)
{
	struct CASpace *result = NULL;

	(void)Assign_CASpace(&result, self->Condition);
	return result;
}

float64_t CVSpace_get_X(struct CVSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_get_Item(&self->base.base, ((int32_t)0));
	return double_;
}

struct CTRASpace *EgoMotionCompensa_get_Conditio2(struct EgoMotionCompensation *const self)
{
	struct CTRASpace *result = NULL;

	(void)Assign_CTRASpace(&result, self->Condition2);
	return result;
}

float64_t CVSpace_get_Y(struct CVSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_get_Item(&self->base.base, ((int32_t)1));
	return double_;
}

void CVSpace_set_X(struct CVSpace *const self, float64_t value)
{
	Space_set_Item(&self->base.base, ((int32_t)0), value);
}

void CVSpace_set_Y(struct CVSpace *const self, float64_t value)
{
	Space_set_Item(&self->base.base, ((int32_t)1), value);
}

float64_t CVSpace_get_G(struct CVSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_get_Item(&self->base.base, ((int32_t)2));
	return double_;
}

void CVSpace_set_G(struct CVSpace *const self, float64_t value)
{
	Space_set_Item(&self->base.base, ((int32_t)2), value);
}

struct CASpace *EgoMotionCompensa_get_Expectati(struct EgoMotionCompensation *const self)
{
	struct CASpace *result = NULL;
	struct CASpace *caSpace = NULL;
	struct CASpace *caSpace_1 = NULL;
	struct CASpace *condition = NULL;
	struct CASpace *caSpace_2 = NULL;
	float64_t arg_36_0 = 0.0;
	float64_t double_ = 0.0;
	struct CTRASpace *condition2 = NULL;
	struct CTRASpace *ctraSpace = NULL;
	float64_t arg_50_0 = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	struct CTRASpace *condition3 = NULL;
	struct CTRASpace *ctraSpace_1 = NULL;
	float64_t arg_97_0 = 0.0;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	float64_t double__5 = 0.0;
	struct CASpace *condition4 = NULL;
	struct CASpace *caSpace_3 = NULL;
	float64_t arg_7B_0 = 0.0;
	float64_t double__6 = 0.0;
	struct CTRASpace *condition5 = NULL;
	struct CTRASpace *ctraSpace_2 = NULL;
	float64_t arg_96_0 = 0.0;
	float64_t double__7 = 0.0;
	float64_t double__8 = 0.0;
	struct CTRASpace *condition6 = NULL;
	struct CTRASpace *ctraSpace_3 = NULL;
	float64_t double__9 = 0.0;
	float64_t double__10 = 0.0;
	float64_t double__11 = 0.0;
	float64_t double__12 = 0.0;
	struct CASpace *condition7 = NULL;
	struct CASpace *caSpace_4 = NULL;
	float64_t arg_CF_0 = 0.0;
	float64_t double__13 = 0.0;
	struct CTRASpace *condition8 = NULL;
	struct CTRASpace *ctraSpace_4 = NULL;
	float64_t arg_EB_0 = 0.0;
	float64_t double__14 = 0.0;
	float64_t double__15 = 0.0;
	struct CTRASpace *condition9 = NULL;
	struct CTRASpace *ctraSpace_5 = NULL;
	float64_t arg_132_0 = 0.0;
	float64_t double__16 = 0.0;
	float64_t double__17 = 0.0;
	float64_t double__18 = 0.0;
	struct CASpace *condition10 = NULL;
	struct CASpace *caSpace_5 = NULL;
	float64_t arg_116_0 = 0.0;
	float64_t double__19 = 0.0;
	struct CTRASpace *condition11 = NULL;
	struct CTRASpace *ctraSpace_6 = NULL;
	float64_t arg_131_0 = 0.0;
	float64_t double__20 = 0.0;
	float64_t double__21 = 0.0;
	struct CTRASpace *condition12 = NULL;
	struct CTRASpace *ctraSpace_7 = NULL;
	float64_t double__22 = 0.0;
	float64_t double__23 = 0.0;
	float64_t double__24 = 0.0;
	float64_t double__25 = 0.0;
	struct CASpace *condition13 = NULL;
	struct CASpace *caSpace_6 = NULL;
	float64_t arg_16A_0 = 0.0;
	float64_t double__26 = 0.0;
	struct CTRASpace *condition14 = NULL;
	struct CTRASpace *ctraSpace_8 = NULL;
	float64_t double__27 = 0.0;
	float64_t double__28 = 0.0;
	struct CASpace *result_1 = NULL;

	caSpace = EgoMotionCompensa_get_Condition(self);
	caSpace_1 = SpaceExtensions_Clone(caSpace);
	(void)Assign_CASpace(&result, caSpace_1);
	(void)Assign_CASpace(&caSpace, NULL);
	(void)Assign_CASpace(&caSpace_1, NULL);
	caSpace_2 = EgoMotionCompensa_get_Condition(self);
	(void)Assign_CASpace(&condition, caSpace_2);
	(void)Assign_CASpace(&caSpace_2, NULL);
	double_ = CVSpace_get_X(&(*&condition)->base);
	arg_36_0 = double_;
	ctraSpace = EgoMotionCompensa_get_Conditio2(self);
	(void)Assign_CTRASpace(&condition2, ctraSpace);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	double__1 = arg_36_0;
	double__2 = CTRASpace_get_X(condition2);
	arg_50_0 = double__1 - double__2;
	ctraSpace_1 = EgoMotionCompensa_get_Conditio2(self);
	(void)Assign_CTRASpace(&condition3, ctraSpace_1);
	(void)Assign_CTRASpace(&ctraSpace_1, NULL);
	double__3 = arg_50_0;
	double__4 = CTRASpace_get_G(condition3);
	double__5 = Math_Cos(double__4);
	arg_97_0 = double__3 * double__5;
	caSpace_3 = EgoMotionCompensa_get_Condition(self);
	(void)Assign_CASpace(&condition4, caSpace_3);
	(void)Assign_CASpace(&caSpace_3, NULL);
	double__6 = CVSpace_get_Y(&(*&condition4)->base);
	arg_7B_0 = double__6;
	ctraSpace_2 = EgoMotionCompensa_get_Conditio2(self);
	(void)Assign_CTRASpace(&condition5, ctraSpace_2);
	(void)Assign_CTRASpace(&ctraSpace_2, NULL);
	double__7 = arg_7B_0;
	double__8 = CTRASpace_get_Y(condition5);
	arg_96_0 = double__7 - double__8;
	ctraSpace_3 = EgoMotionCompensa_get_Conditio2(self);
	(void)Assign_CTRASpace(&condition6, ctraSpace_3);
	(void)Assign_CTRASpace(&ctraSpace_3, NULL);
	double__9 = arg_97_0;
	double__10 = arg_96_0;
	double__11 = CTRASpace_get_G(condition6);
	double__12 = Math_Sin(double__11);
	CVSpace_set_X(&(*&result)->base, double__9 + (double__10 * double__12));
	caSpace_4 = EgoMotionCompensa_get_Condition(self);
	(void)Assign_CASpace(&condition7, caSpace_4);
	(void)Assign_CASpace(&caSpace_4, NULL);
	double__13 = CVSpace_get_X(&(*&condition7)->base);
	arg_CF_0 = double__13;
	ctraSpace_4 = EgoMotionCompensa_get_Conditio2(self);
	(void)Assign_CTRASpace(&condition8, ctraSpace_4);
	(void)Assign_CTRASpace(&ctraSpace_4, NULL);
	double__14 = arg_CF_0;
	double__15 = CTRASpace_get_X(condition8);
	arg_EB_0 = -(double__14 - double__15);
	ctraSpace_5 = EgoMotionCompensa_get_Conditio2(self);
	(void)Assign_CTRASpace(&condition9, ctraSpace_5);
	(void)Assign_CTRASpace(&ctraSpace_5, NULL);
	double__16 = arg_EB_0;
	double__17 = CTRASpace_get_G(condition9);
	double__18 = Math_Sin(double__17);
	arg_132_0 = double__16 * double__18;
	caSpace_5 = EgoMotionCompensa_get_Condition(self);
	(void)Assign_CASpace(&condition10, caSpace_5);
	(void)Assign_CASpace(&caSpace_5, NULL);
	double__19 = CVSpace_get_Y(&(*&condition10)->base);
	arg_116_0 = double__19;
	ctraSpace_6 = EgoMotionCompensa_get_Conditio2(self);
	(void)Assign_CTRASpace(&condition11, ctraSpace_6);
	(void)Assign_CTRASpace(&ctraSpace_6, NULL);
	double__20 = arg_116_0;
	double__21 = CTRASpace_get_Y(condition11);
	arg_131_0 = double__20 - double__21;
	ctraSpace_7 = EgoMotionCompensa_get_Conditio2(self);
	(void)Assign_CTRASpace(&condition12, ctraSpace_7);
	(void)Assign_CTRASpace(&ctraSpace_7, NULL);
	double__22 = arg_132_0;
	double__23 = arg_131_0;
	double__24 = CTRASpace_get_G(condition12);
	double__25 = Math_Cos(double__24);
	CVSpace_set_Y(&(*&result)->base, double__22 + (double__23 * double__25));
	caSpace_6 = EgoMotionCompensa_get_Condition(self);
	(void)Assign_CASpace(&condition13, caSpace_6);
	(void)Assign_CASpace(&caSpace_6, NULL);
	double__26 = CVSpace_get_G(&(*&condition13)->base);
	arg_16A_0 = double__26;
	ctraSpace_8 = EgoMotionCompensa_get_Conditio2(self);
	(void)Assign_CTRASpace(&condition14, ctraSpace_8);
	(void)Assign_CTRASpace(&ctraSpace_8, NULL);
	double__27 = arg_16A_0;
	double__28 = CTRASpace_get_G(condition14);
	CVSpace_set_G(&(*&result)->base, double__27 - double__28);
	(void)Assign_CASpace(&result_1, result);
	RemRef_CASpace(result);
	RemRef_CASpace(condition);
	RemRef_CTRASpace(condition2);
	RemRef_CTRASpace(condition3);
	RemRef_CASpace(condition4);
	RemRef_CTRASpace(condition5);
	RemRef_CTRASpace(condition6);
	RemRef_CASpace(condition7);
	RemRef_CTRASpace(condition8);
	RemRef_CTRASpace(condition9);
	RemRef_CASpace(condition10);
	RemRef_CTRASpace(condition11);
	RemRef_CTRASpace(condition12);
	RemRef_CASpace(condition13);
	RemRef_CTRASpace(condition14);
	return result_1;
}

void LinearAlgebra_MatrixMultiply_8(struct LinearAlgebra *const self, struct float64_t_1D_25 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_25 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_25 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)25) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)25) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)25) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)25) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)25) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)25) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)25) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)25) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_2 *MatrixMath_Multiply_16(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_2 *left, struct MatrixData_2 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_25 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_25 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_25 *array_2 = NULL;
	struct MatrixData_2 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == false);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Columns;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_2();
	MatrixData_2_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_2(&matrixData, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_2_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_2_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_2_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_8(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_25(&array, NULL);
	(void)Assign_float64_t_1D_25(&array_1, NULL);
	(void)Assign_float64_t_1D_25(&array_2, NULL);
	(void)Assign_MatrixData_2(&result, matrixData);
	RemRef_MatrixData_2(matrixData);
	return result;
}

struct MatrixData_2 *MatrixMath_Multiply_17(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_2 *left, struct MatrixData_2 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_25 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_25 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_25 *array_2 = NULL;
	struct MatrixData_2 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == true);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Rows;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_2();
	MatrixData_2_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_2(&matrixData, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_2_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_2_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_2_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_8(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_25(&array, NULL);
	(void)Assign_float64_t_1D_25(&array_1, NULL);
	(void)Assign_float64_t_1D_25(&array_2, NULL);
	(void)Assign_MatrixData_2(&result, matrixData);
	RemRef_MatrixData_2(matrixData);
	return result;
}

struct MatrixData_2 *MatrixMath_Multiply_18(bool_t transposeFirst, bool_t transposeSecond, bool_t transposeThird, struct MatrixData_2 *first, struct MatrixData_2 *second, struct MatrixData_2 *third)
{
	struct MatrixData_2 *left = NULL;
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *result = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;

	assert(transposeFirst == false);
	assert(transposeSecond == false);
	assert(transposeThird == true);
	if (!(first != NULL))
	{
		abort();
	}
	if (!(second != NULL))
	{
		abort();
	}
	if (!(third != NULL))
	{
		abort();
	}
	matrixData = MatrixMath_Multiply_16(transposeFirst, transposeSecond, first, second);
	(void)Assign_MatrixData_2(&left, matrixData);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	matrixData_1 = MatrixMath_Multiply_17(false, transposeThird, left, third);
	(void)Assign_MatrixData_2(&result, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	RemRef_MatrixData_2(left);
	return result;
}

struct PositiveDefiniteMatrix_7 *PositivDefiniteMatrix_11_Create(struct MatrixData_2 *matrix)
{
	struct PositiveDefiniteMatrix_7 *result = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix = NULL;

	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_7();
	PositiveDefiniteMatrix_7_ctor_1(positiveDefiniteMatrix);
	Matrix_10_set_UncheckMatrixData(&positiveDefiniteMatrix->base.base, matrix);
	(void)Assign_PositiveDefiniteMatrix_7(&result, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix, NULL);
	return result;
}

static void Gaussian_5_ctor_2(struct Gaussian_5 *const self, bool_t noInitialization)
{
	struct CASpace *caSpace = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix = NULL;

	Object_ctor(&self->base);
	self->_dimensions = (&Gaussian_9_EmptySpace->base.base.base)->Dimensions;
	if (!!noInitialization)
	{
		return;
	}
	caSpace = New_CASpace();
	CASpace_ctor(caSpace);
	Gaussian_5_set_Expectation(self, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_7();
	PositiveDefiniteMatrix_7_ctor_1(positiveDefiniteMatrix);
	Gaussian_5_set_Covariance(self, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix, NULL);
}

struct Gaussian_5 *Gaussian_9_Create(struct CASpace *expectation, struct PositiveDefiniteMatrix_7 *covariance)
{
	struct Gaussian_5 *result = NULL;
	struct Gaussian_5 *gaussian = NULL;

	gaussian = New_Gaussian_5();
	Gaussian_5_ctor_2(gaussian, true);
	Gaussian_5_set_Expectation(gaussian, expectation);
	Gaussian_5_set_Covariance(gaussian, covariance);
	(void)Assign_Gaussian_5(&result, gaussian);
	(void)Assign_Gaussian_5(&gaussian, NULL);
	return result;
}

struct Gaussian_5 *CreateExtensions_Marginalize(struct EgoMotionCompensation *egoMotionCompensation, struct GaussianTrack *track, struct Gaussian_4 *egoMotionState)
{
	struct EgoMotionCompensation *egoMotionCompensation_1 = NULL;
	struct Gaussian_5 *gaussian = NULL;
	struct CASpace *caSpace = NULL;
	struct EgoMotionCompensation *egoMotionCompensation_2 = NULL;
	struct CTRASpace *ctraSpace = NULL;
	struct CASpace *expectation = NULL;
	struct CASpace *caSpace_1 = NULL;
	struct CTRASpace *CS_0_0000 = NULL;
	struct CTRASpace *ctraSpace_1 = NULL;
	float64_t cos_1 = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	struct CTRASpace *CS_0_0001 = NULL;
	struct CTRASpace *ctraSpace_2 = NULL;
	float64_t sin_1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	int32_t dimensions = ((int32_t)0);
	struct Gaussian_5 *gaussian_1 = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix = NULL;
	struct MatrixData_2 *transitionMatrix = NULL;
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *covariance = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	struct Gaussian_5 *gaussian_2 = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_1 = NULL;
	struct MatrixData_2 *matrixData_2 = NULL;
	struct MatrixData_2 *matrixData_3 = NULL;
	struct Gaussian_5 *result = NULL;
	struct CASpace *caSpace_2 = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_2 = NULL;
	struct Gaussian_5 *gaussian_3 = NULL;

	(void)Assign_EgoMotionCompensation(&egoMotionCompensation_1, egoMotionCompensation);
	gaussian = GaussianTrack_get_State(track);
	caSpace = Gaussian_5_get_Expectation(gaussian);
	EgoMotionCompensa_set_Condition(egoMotionCompensation_1, caSpace);
	(void)Assign_EgoMotionCompensation(&egoMotionCompensation_1, NULL);
	(void)Assign_Gaussian_5(&gaussian, NULL);
	(void)Assign_CASpace(&caSpace, NULL);
	(void)Assign_EgoMotionCompensation(&egoMotionCompensation_2, egoMotionCompensation);
	ctraSpace = Gaussian_4_get_Expectation(egoMotionState);
	EgoMotionCompensa_set_Conditio2(egoMotionCompensation_2, ctraSpace);
	(void)Assign_EgoMotionCompensation(&egoMotionCompensation_2, NULL);
	(void)Assign_CTRASpace(&ctraSpace, NULL);
	caSpace_1 = EgoMotionCompensa_get_Expectati(egoMotionCompensation);
	(void)Assign_CASpace(&expectation, caSpace_1);
	(void)Assign_CASpace(&caSpace_1, NULL);
	ctraSpace_1 = Gaussian_4_get_Expectation(egoMotionState);
	(void)Assign_CTRASpace(&CS_0_0000, ctraSpace_1);
	(void)Assign_CTRASpace(&ctraSpace_1, NULL);
	double_ = CTRASpace_get_G(CS_0_0000);
	double__1 = Math_Cos(double_);
	cos_1 = double__1;
	ctraSpace_2 = Gaussian_4_get_Expectation(egoMotionState);
	(void)Assign_CTRASpace(&CS_0_0001, ctraSpace_2);
	(void)Assign_CTRASpace(&ctraSpace_2, NULL);
	double__2 = CTRASpace_get_G(CS_0_0001);
	double__3 = Math_Sin(double__2);
	sin_1 = double__3;
	gaussian_1 = GaussianTrack_get_State(track);
	positiveDefiniteMatrix = Gaussian_5_get_Covariance(gaussian_1);
	dimensions = (&positiveDefiniteMatrix->base.base)->Columns;
	(void)Assign_Gaussian_5(&gaussian_1, NULL);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix, NULL);
	matrixData = New_MatrixData_2();
	MatrixData_2_ctor(matrixData, dimensions, dimensions);
	(void)Assign_MatrixData_2(&transitionMatrix, matrixData);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	MatrixData_2_set_Item(transitionMatrix, ((int32_t)0), ((int32_t)0), cos_1);
	MatrixData_2_set_Item(transitionMatrix, ((int32_t)0), ((int32_t)1), sin_1);
	MatrixData_2_set_Item(transitionMatrix, ((int32_t)1), ((int32_t)0), -sin_1);
	MatrixData_2_set_Item(transitionMatrix, ((int32_t)1), ((int32_t)1), cos_1);
	MatrixData_2_set_Item(transitionMatrix, ((int32_t)2), ((int32_t)2), 1.0);
	MatrixData_2_set_Item(transitionMatrix, ((int32_t)3), ((int32_t)3), 1.0);
	MatrixData_2_set_Item(transitionMatrix, ((int32_t)4), ((int32_t)4), 1.0);
	(void)Assign_MatrixData_2(&matrixData_1, transitionMatrix);
	gaussian_2 = GaussianTrack_get_State(track);
	positiveDefiniteMatrix_1 = Gaussian_5_get_Covariance(gaussian_2);
	matrixData_2 = Matrix_10_get_MatrixData(&positiveDefiniteMatrix_1->base.base);
	matrixData_3 = MatrixMath_Multiply_18(false, false, true, matrixData_1, matrixData_2, transitionMatrix);
	(void)Assign_MatrixData_2(&covariance, matrixData_3);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	(void)Assign_Gaussian_5(&gaussian_2, NULL);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_1, NULL);
	(void)Assign_MatrixData_2(&matrixData_2, NULL);
	(void)Assign_MatrixData_2(&matrixData_3, NULL);
	(void)Assign_CASpace(&caSpace_2, expectation);
	positiveDefiniteMatrix_2 = PositivDefiniteMatrix_11_Create(covariance);
	gaussian_3 = Gaussian_9_Create(caSpace_2, positiveDefiniteMatrix_2);
	(void)Assign_Gaussian_5(&result, gaussian_3);
	(void)Assign_CASpace(&caSpace_2, NULL);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_2, NULL);
	(void)Assign_Gaussian_5(&gaussian_3, NULL);
	RemRef_CASpace(expectation);
	RemRef_CTRASpace(CS_0_0000);
	RemRef_CTRASpace(CS_0_0001);
	RemRef_MatrixData_2(transitionMatrix);
	RemRef_MatrixData_2(covariance);
	return result;
}

static void RemRef_SquareMatrix_7(struct SquareMatrix_7 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_SquareMatrix_7.CurrentCount--;
		Res_SquareMatrix_7.Next[Res_SquareMatrix_7.CurrentCount] = self;
		Del_SquareMatrix_7(self);
	}
}

struct SquareMatrix_7 *New_SquareMatrix_7(void)
{
	static struct SquareMatrix_7 const Default_SquareMatrix_7 = { 1 };
	struct SquareMatrix_7 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_SquareMatrix_7.CurrentCount == RC_SquareMatrix_7)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_SquareMatrix_7.Next[Res_SquareMatrix_7.CurrentCount];
	Res_SquareMatrix_7.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_SquareMatrix_7.MaximumCount = (Res_SquareMatrix_7.CurrentCount > Res_SquareMatrix_7.MaximumCount) ? Res_SquareMatrix_7.CurrentCount : Res_SquareMatrix_7.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_SquareMatrix_7;
	return instance;
}

struct SquareMatrix_7 *Assign_SquareMatrix_7(struct SquareMatrix_7 **const left, struct SquareMatrix_7 *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_SquareMatrix_7(*left);
	*left = right;
	return right;
}

static void Matrix_10_MatrixChanged(struct Matrix_10 *const self)
{
	(void)Assign_MatrixData(&self->CachedTranspose, NULL);
}

static void SquareMatrix_7_MatrixChanged(struct SquareMatrix_7 *const self)
{
	struct Nullable_2 nullable = { 0 };

	Matrix_10_MatrixChanged(&self->base);
	self->CachedDeterminant = nullable;
}

void Matrix_10_set_MatrixData(struct SquareMatrix_7 *const self, struct MatrixData_2 *value)
{
	struct MatrixData_2 *matrix = NULL;

	if (!(value != NULL))
	{
		abort();
	}
	(void)Assign_MatrixData_2(&matrix, (&self->base)->_matrix);
	(void)Assign_MatrixData_2(&(&self->base)->_matrix, value);
	SquareMatrix_7_CheckMatrix(self);
	SquareMatrix_7_MatrixChanged(self);
	RemRef_MatrixData_2(matrix);
}

struct SquareMatrix_7 *SquareMatrix_9_Eye(void)
{
	struct SquareMatrix_7 *squareMatrix = NULL;
	struct SquareMatrix_7 *squareMatrix_1 = NULL;
	struct SquareMatrix_7 *squareMatrix_2 = NULL;
	struct MatrixData_2 *matrixData = NULL;
	struct SquareMatrix_7 *result = NULL;

	squareMatrix_1 = New_SquareMatrix_7();
	SquareMatrix_7_ctor(squareMatrix_1);
	(void)Assign_SquareMatrix_7(&squareMatrix, squareMatrix_1);
	(void)Assign_SquareMatrix_7(&squareMatrix_1, NULL);
	(void)Assign_SquareMatrix_7(&squareMatrix_2, squareMatrix);
	matrixData = MatrixData_20_Eye(squareMatrix->Dimensions, squareMatrix->Dimensions);
	Matrix_10_set_MatrixData(squareMatrix_2, matrixData);
	(void)Assign_SquareMatrix_7(&squareMatrix_2, NULL);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	(void)Assign_SquareMatrix_7(&result, squareMatrix);
	RemRef_SquareMatrix_7(squareMatrix);
	return result;
}

static struct CASpace *SystemModel_get_Condition(struct SystemModel *const self)
{
	struct CASpace *result = NULL;

	(void)Assign_CASpace(&result, self->Condition);
	return result;
}

static struct TimeSpan SystemModel_get_TimeCondition(struct SystemModel *const self)
{
	return self->TimeCondition;
}

void Matrix_10_set_Item(struct SquareMatrix_7 *const self, int32_t row, int32_t column, float64_t value)
{
	struct MatrixData_2 *matrixData = NULL;

	if (!((row >= ((int32_t)0)) && (row < (&self->base)->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < (&self->base)->Columns)))
	{
		abort();
	}
	matrixData = Matrix_10_get_MatrixData(&self->base);
	MatrixData_2_set_Item(matrixData, row, column, value);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	SquareMatrix_7_MatrixChanged(self);
}

void Matrix_10_set_Item_1(struct SquareMatrix_7 *const self, float64_t row, float64_t column, float64_t value)
{
	Matrix_10_set_Item(self, (int32_t)row, (int32_t)column, value);
}

void CAModel_FillTransitionMatrix(struct CAModel *const self, struct CASpace *stateExpectation, struct TimeSpan deltaT, struct SquareMatrix_7 **F)
{
	float64_t T = 0.0;
	float64_t double_ = 0.0;
	float64_t sinG = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t cosG = 0.0;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	float64_t v = 0.0;
	float64_t double__5 = 0.0;
	float64_t a = 0.0;
	float64_t double__6 = 0.0;
	struct SquareMatrix_7 *arg_7E_0 = NULL;
	struct CASpace *CS_0_0000 = NULL;
	float64_t arg_7E_1 = 0.0;
	float64_t double__7 = 0.0;
	struct CASpace *CS_0_0001 = NULL;
	struct SquareMatrix_7 *squareMatrix = NULL;
	float64_t double__8 = 0.0;
	float64_t double__9 = 0.0;
	struct SquareMatrix_7 *arg_C4_0 = NULL;
	struct CASpace *CS_0_0002 = NULL;
	float64_t arg_C4_1 = 0.0;
	float64_t double__10 = 0.0;
	struct CASpace *CS_0_0003 = NULL;
	struct SquareMatrix_7 *squareMatrix_1 = NULL;
	float64_t double__11 = 0.0;
	float64_t double__12 = 0.0;
	struct SquareMatrix_7 *arg_F6_0 = NULL;
	struct CASpace *CS_0_0004 = NULL;
	float64_t arg_F6_1 = 0.0;
	float64_t double__13 = 0.0;
	struct CASpace *CS_0_0005 = NULL;
	struct SquareMatrix_7 *squareMatrix_2 = NULL;
	float64_t double__14 = 0.0;
	float64_t double__15 = 0.0;
	struct SquareMatrix_7 *arg_134_0 = NULL;
	struct CASpace *CS_0_0006 = NULL;
	float64_t arg_134_1 = 0.0;
	float64_t double__16 = 0.0;
	struct CASpace *CS_0_0007 = NULL;
	struct SquareMatrix_7 *squareMatrix_3 = NULL;
	float64_t double__17 = 0.0;
	float64_t double__18 = 0.0;
	struct SquareMatrix_7 *arg_16C_0 = NULL;
	struct CASpace *CS_0_0008 = NULL;
	float64_t arg_16C_1 = 0.0;
	float64_t double__19 = 0.0;
	struct CASpace *CS_0_0009 = NULL;
	struct SquareMatrix_7 *squareMatrix_4 = NULL;
	float64_t double__20 = 0.0;
	float64_t double__21 = 0.0;
	struct SquareMatrix_7 *arg_1B1_0 = NULL;
	struct CASpace *CS_0_0010 = NULL;
	float64_t arg_1B1_1 = 0.0;
	float64_t double__22 = 0.0;
	struct CASpace *CS_0_0011 = NULL;
	struct SquareMatrix_7 *squareMatrix_5 = NULL;
	float64_t double__23 = 0.0;
	float64_t double__24 = 0.0;
	struct SquareMatrix_7 *arg_1E3_0 = NULL;
	struct CASpace *CS_0_0012 = NULL;
	float64_t arg_1E3_1 = 0.0;
	float64_t double__25 = 0.0;
	struct CASpace *CS_0_0013 = NULL;
	struct SquareMatrix_7 *squareMatrix_6 = NULL;
	float64_t double__26 = 0.0;
	float64_t double__27 = 0.0;
	struct SquareMatrix_7 *arg_221_0 = NULL;
	struct CASpace *CS_0_0014 = NULL;
	float64_t arg_221_1 = 0.0;
	float64_t double__28 = 0.0;
	struct CASpace *CS_0_0015 = NULL;
	struct SquareMatrix_7 *squareMatrix_7 = NULL;
	float64_t double__29 = 0.0;
	float64_t double__30 = 0.0;
	struct SquareMatrix_7 *arg_259_0 = NULL;
	struct CASpace *CS_0_0016 = NULL;
	float64_t arg_259_1 = 0.0;
	float64_t double__31 = 0.0;
	struct CASpace *CS_0_0017 = NULL;
	struct SquareMatrix_7 *squareMatrix_8 = NULL;
	float64_t double__32 = 0.0;
	float64_t double__33 = 0.0;
	struct SquareMatrix_7 *arg_291_0 = NULL;
	struct CASpace *CS_0_0018 = NULL;
	float64_t arg_291_1 = 0.0;
	float64_t double__34 = 0.0;
	struct CASpace *CS_0_0019 = NULL;
	struct SquareMatrix_7 *squareMatrix_9 = NULL;
	float64_t double__35 = 0.0;
	float64_t double__36 = 0.0;
	struct SquareMatrix_7 *arg_2C1_0 = NULL;
	struct CASpace *CS_0_0020 = NULL;
	float64_t arg_2C1_1 = 0.0;
	float64_t double__37 = 0.0;
	struct CASpace *CS_0_0021 = NULL;
	struct SquareMatrix_7 *squareMatrix_10 = NULL;
	float64_t double__38 = 0.0;
	float64_t double__39 = 0.0;
	struct SquareMatrix_7 *arg_2F9_0 = NULL;
	struct CASpace *CS_0_0022 = NULL;
	float64_t arg_2F9_1 = 0.0;
	float64_t double__40 = 0.0;
	struct CASpace *CS_0_0023 = NULL;
	struct SquareMatrix_7 *squareMatrix_11 = NULL;
	float64_t double__41 = 0.0;
	float64_t double__42 = 0.0;

	double_ = TimeSpan_get_TotalSeconds(&deltaT);
	T = double_;
	double__1 = CVSpace_get_G(&(*&stateExpectation)->base);
	double__2 = Math_Sin(double__1);
	sinG = double__2;
	double__3 = CVSpace_get_G(&(*&stateExpectation)->base);
	double__4 = Math_Cos(double__3);
	cosG = double__4;
	double__5 = CVSpace_get_V(&(*&stateExpectation)->base);
	v = double__5;
	double__6 = CASpace_get_A(stateExpectation);
	a = double__6;
	(void)Assign_SquareMatrix_7(&arg_7E_0, *F);
	(void)Assign_CASpace(&CS_0_0000, CAModel_1_S);
	double__7 = CVSpace_get_X(&(*&CS_0_0000)->base);
	arg_7E_1 = double__7;
	(void)Assign_CASpace(&CS_0_0001, CAModel_1_S);
	(void)Assign_SquareMatrix_7(&squareMatrix, arg_7E_0);
	double__8 = arg_7E_1;
	double__9 = CVSpace_get_X(&(*&CS_0_0001)->base);
	Matrix_10_set_Item_1(squareMatrix, double__8, double__9, 1.0);
	(void)Assign_SquareMatrix_7(&squareMatrix, NULL);
	(void)Assign_SquareMatrix_7(&arg_C4_0, *F);
	(void)Assign_CASpace(&CS_0_0002, CAModel_1_S);
	double__10 = CVSpace_get_X(&(*&CS_0_0002)->base);
	arg_C4_1 = double__10;
	(void)Assign_CASpace(&CS_0_0003, CAModel_1_S);
	(void)Assign_SquareMatrix_7(&squareMatrix_1, arg_C4_0);
	double__11 = arg_C4_1;
	double__12 = CVSpace_get_G(&(*&CS_0_0003)->base);
	Matrix_10_set_Item_1(squareMatrix_1, double__11, double__12, -((T * v) + (((a / 2.0) * T) * T)) * sinG);
	(void)Assign_SquareMatrix_7(&squareMatrix_1, NULL);
	(void)Assign_SquareMatrix_7(&arg_F6_0, *F);
	(void)Assign_CASpace(&CS_0_0004, CAModel_1_S);
	double__13 = CVSpace_get_X(&(*&CS_0_0004)->base);
	arg_F6_1 = double__13;
	(void)Assign_CASpace(&CS_0_0005, CAModel_1_S);
	(void)Assign_SquareMatrix_7(&squareMatrix_2, arg_F6_0);
	double__14 = arg_F6_1;
	double__15 = CVSpace_get_V(&(*&CS_0_0005)->base);
	Matrix_10_set_Item_1(squareMatrix_2, double__14, double__15, T * cosG);
	(void)Assign_SquareMatrix_7(&squareMatrix_2, NULL);
	(void)Assign_SquareMatrix_7(&arg_134_0, *F);
	(void)Assign_CASpace(&CS_0_0006, CAModel_1_S);
	double__16 = CVSpace_get_X(&(*&CS_0_0006)->base);
	arg_134_1 = double__16;
	(void)Assign_CASpace(&CS_0_0007, CAModel_1_S);
	(void)Assign_SquareMatrix_7(&squareMatrix_3, arg_134_0);
	double__17 = arg_134_1;
	double__18 = CASpace_get_A(CS_0_0007);
	Matrix_10_set_Item_1(squareMatrix_3, double__17, double__18, ((T * T) / 2.0) * cosG);
	(void)Assign_SquareMatrix_7(&squareMatrix_3, NULL);
	(void)Assign_SquareMatrix_7(&arg_16C_0, *F);
	(void)Assign_CASpace(&CS_0_0008, CAModel_1_S);
	double__19 = CVSpace_get_Y(&(*&CS_0_0008)->base);
	arg_16C_1 = double__19;
	(void)Assign_CASpace(&CS_0_0009, CAModel_1_S);
	(void)Assign_SquareMatrix_7(&squareMatrix_4, arg_16C_0);
	double__20 = arg_16C_1;
	double__21 = CVSpace_get_Y(&(*&CS_0_0009)->base);
	Matrix_10_set_Item_1(squareMatrix_4, double__20, double__21, 1.0);
	(void)Assign_SquareMatrix_7(&squareMatrix_4, NULL);
	(void)Assign_SquareMatrix_7(&arg_1B1_0, *F);
	(void)Assign_CASpace(&CS_0_0010, CAModel_1_S);
	double__22 = CVSpace_get_Y(&(*&CS_0_0010)->base);
	arg_1B1_1 = double__22;
	(void)Assign_CASpace(&CS_0_0011, CAModel_1_S);
	(void)Assign_SquareMatrix_7(&squareMatrix_5, arg_1B1_0);
	double__23 = arg_1B1_1;
	double__24 = CVSpace_get_G(&(*&CS_0_0011)->base);
	Matrix_10_set_Item_1(squareMatrix_5, double__23, double__24, ((T * v) + (((a / 2.0) * T) * T)) * cosG);
	(void)Assign_SquareMatrix_7(&squareMatrix_5, NULL);
	(void)Assign_SquareMatrix_7(&arg_1E3_0, *F);
	(void)Assign_CASpace(&CS_0_0012, CAModel_1_S);
	double__25 = CVSpace_get_Y(&(*&CS_0_0012)->base);
	arg_1E3_1 = double__25;
	(void)Assign_CASpace(&CS_0_0013, CAModel_1_S);
	(void)Assign_SquareMatrix_7(&squareMatrix_6, arg_1E3_0);
	double__26 = arg_1E3_1;
	double__27 = CVSpace_get_V(&(*&CS_0_0013)->base);
	Matrix_10_set_Item_1(squareMatrix_6, double__26, double__27, T * sinG);
	(void)Assign_SquareMatrix_7(&squareMatrix_6, NULL);
	(void)Assign_SquareMatrix_7(&arg_221_0, *F);
	(void)Assign_CASpace(&CS_0_0014, CAModel_1_S);
	double__28 = CVSpace_get_Y(&(*&CS_0_0014)->base);
	arg_221_1 = double__28;
	(void)Assign_CASpace(&CS_0_0015, CAModel_1_S);
	(void)Assign_SquareMatrix_7(&squareMatrix_7, arg_221_0);
	double__29 = arg_221_1;
	double__30 = CASpace_get_A(CS_0_0015);
	Matrix_10_set_Item_1(squareMatrix_7, double__29, double__30, ((T * T) / 2.0) * sinG);
	(void)Assign_SquareMatrix_7(&squareMatrix_7, NULL);
	(void)Assign_SquareMatrix_7(&arg_259_0, *F);
	(void)Assign_CASpace(&CS_0_0016, CAModel_1_S);
	double__31 = CVSpace_get_G(&(*&CS_0_0016)->base);
	arg_259_1 = double__31;
	(void)Assign_CASpace(&CS_0_0017, CAModel_1_S);
	(void)Assign_SquareMatrix_7(&squareMatrix_8, arg_259_0);
	double__32 = arg_259_1;
	double__33 = CVSpace_get_G(&(*&CS_0_0017)->base);
	Matrix_10_set_Item_1(squareMatrix_8, double__32, double__33, 1.0);
	(void)Assign_SquareMatrix_7(&squareMatrix_8, NULL);
	(void)Assign_SquareMatrix_7(&arg_291_0, *F);
	(void)Assign_CASpace(&CS_0_0018, CAModel_1_S);
	double__34 = CVSpace_get_V(&(*&CS_0_0018)->base);
	arg_291_1 = double__34;
	(void)Assign_CASpace(&CS_0_0019, CAModel_1_S);
	(void)Assign_SquareMatrix_7(&squareMatrix_9, arg_291_0);
	double__35 = arg_291_1;
	double__36 = CVSpace_get_V(&(*&CS_0_0019)->base);
	Matrix_10_set_Item_1(squareMatrix_9, double__35, double__36, 1.0);
	(void)Assign_SquareMatrix_7(&squareMatrix_9, NULL);
	(void)Assign_SquareMatrix_7(&arg_2C1_0, *F);
	(void)Assign_CASpace(&CS_0_0020, CAModel_1_S);
	double__37 = CVSpace_get_V(&(*&CS_0_0020)->base);
	arg_2C1_1 = double__37;
	(void)Assign_CASpace(&CS_0_0021, CAModel_1_S);
	(void)Assign_SquareMatrix_7(&squareMatrix_10, arg_2C1_0);
	double__38 = arg_2C1_1;
	double__39 = CASpace_get_A(CS_0_0021);
	Matrix_10_set_Item_1(squareMatrix_10, double__38, double__39, T);
	(void)Assign_SquareMatrix_7(&squareMatrix_10, NULL);
	(void)Assign_SquareMatrix_7(&arg_2F9_0, *F);
	(void)Assign_CASpace(&CS_0_0022, CAModel_1_S);
	double__40 = CASpace_get_A(CS_0_0022);
	arg_2F9_1 = double__40;
	(void)Assign_CASpace(&CS_0_0023, CAModel_1_S);
	(void)Assign_SquareMatrix_7(&squareMatrix_11, arg_2F9_0);
	double__41 = arg_2F9_1;
	double__42 = CASpace_get_A(CS_0_0023);
	Matrix_10_set_Item_1(squareMatrix_11, double__41, double__42, 1.0);
	(void)Assign_SquareMatrix_7(&squareMatrix_11, NULL);
	RemRef_SquareMatrix_7(arg_7E_0);
	RemRef_CASpace(CS_0_0000);
	RemRef_CASpace(CS_0_0001);
	RemRef_SquareMatrix_7(arg_C4_0);
	RemRef_CASpace(CS_0_0002);
	RemRef_CASpace(CS_0_0003);
	RemRef_SquareMatrix_7(arg_F6_0);
	RemRef_CASpace(CS_0_0004);
	RemRef_CASpace(CS_0_0005);
	RemRef_SquareMatrix_7(arg_134_0);
	RemRef_CASpace(CS_0_0006);
	RemRef_CASpace(CS_0_0007);
	RemRef_SquareMatrix_7(arg_16C_0);
	RemRef_CASpace(CS_0_0008);
	RemRef_CASpace(CS_0_0009);
	RemRef_SquareMatrix_7(arg_1B1_0);
	RemRef_CASpace(CS_0_0010);
	RemRef_CASpace(CS_0_0011);
	RemRef_SquareMatrix_7(arg_1E3_0);
	RemRef_CASpace(CS_0_0012);
	RemRef_CASpace(CS_0_0013);
	RemRef_SquareMatrix_7(arg_221_0);
	RemRef_CASpace(CS_0_0014);
	RemRef_CASpace(CS_0_0015);
	RemRef_SquareMatrix_7(arg_259_0);
	RemRef_CASpace(CS_0_0016);
	RemRef_CASpace(CS_0_0017);
	RemRef_SquareMatrix_7(arg_291_0);
	RemRef_CASpace(CS_0_0018);
	RemRef_CASpace(CS_0_0019);
	RemRef_SquareMatrix_7(arg_2C1_0);
	RemRef_CASpace(CS_0_0020);
	RemRef_CASpace(CS_0_0021);
	RemRef_SquareMatrix_7(arg_2F9_0);
	RemRef_CASpace(CS_0_0022);
	RemRef_CASpace(CS_0_0023);
}

struct SquareMatrix_7 *SystemModel_4_get_TransitMatrix(struct CAModel *const self)
{
	struct SquareMatrix_7 *result = NULL;
	struct SquareMatrix_7 *squareMatrix = NULL;
	struct CASpace *caSpace = NULL;
	struct TimeSpan timeSpan = { 0 };
	struct SquareMatrix_7 *result_1 = NULL;

	squareMatrix = SquareMatrix_9_Eye();
	(void)Assign_SquareMatrix_7(&result, squareMatrix);
	(void)Assign_SquareMatrix_7(&squareMatrix, NULL);
	caSpace = SystemModel_get_Condition(&self->base.base.base);
	timeSpan = SystemModel_get_TimeCondition(&self->base.base.base);
	CAModel_FillTransitionMatrix(self, caSpace, timeSpan, &result);
	(void)Assign_CASpace(&caSpace, NULL);
	(void)Assign_SquareMatrix_7(&result_1, result);
	RemRef_SquareMatrix_7(result);
	return result_1;
}

static void RemRef_Matrix_12(struct Matrix_12 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Matrix_12.CurrentCount--;
		Res_Matrix_12.Next[Res_Matrix_12.CurrentCount] = self;
		Del_Matrix_12(self);
	}
}

struct Matrix_12 *New_Matrix_12(void)
{
	static struct Matrix_12 const Default_Matrix_12 = { 1 };
	struct Matrix_12 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Matrix_12.CurrentCount == RC_Matrix_12)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Matrix_12.Next[Res_Matrix_12.CurrentCount];
	Res_Matrix_12.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Matrix_12.MaximumCount = (Res_Matrix_12.CurrentCount > Res_Matrix_12.MaximumCount) ? Res_Matrix_12.CurrentCount : Res_Matrix_12.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Matrix_12;
	return instance;
}

struct Matrix_12 *Assign_Matrix_12(struct Matrix_12 **const left, struct Matrix_12 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Matrix_12(*left);
	*left = right;
	return right;
}

void Matrix_12_ctor(struct Matrix_12 *const self)
{
	struct CAErrorSpace *caErrorSpace = NULL;
	struct CASpace *caSpace = NULL;

	caErrorSpace = New_CAErrorSpace();
	CAErrorSpace_ctor(caErrorSpace);
	(void)Assign_CAErrorSpace(&self->EmptyRowSpace, caErrorSpace);
	(void)Assign_CAErrorSpace(&caErrorSpace, NULL);
	caSpace = New_CASpace();
	CASpace_ctor(caSpace);
	(void)Assign_CASpace(&self->EmptyColumnSpace, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	Object_ctor(&self->base);
	self->Columns = (&self->EmptyRowSpace->base)->Dimensions;
	self->Rows = (&self->EmptyColumnSpace->base.base.base)->Dimensions;
}

static void Space_2_set_LastGetIndex(struct Space_2 *const self, struct Nullable value)
{
	self->LastGetIndex = value;
}

struct MatrixData_4 *Space_2_get_MatrixData(struct Space_2 *const self)
{
	struct MatrixData_4 *result = NULL;

	(void)Assign_MatrixData_4(&result, self->_vector);
	return result;
}

float64_t MatrixData_4_get_Item(struct MatrixData_4 *const self, int32_t index)
{
	if (!((index >= ((int32_t)0)) && (index < ((int32_t)3))))
	{
		abort();
	}
	return self->_data->Elements[index];
}

float64_t Space_2_get_Item(struct Space_2 *const self, int32_t index)
{
	struct Nullable nullable = { 0 };
	float64_t result = 0.0;
	struct MatrixData_4 *matrixData = NULL;
	float64_t double_ = 0.0;

	if (!((index < self->Dimensions) && (index >= ((int32_t)0))))
	{
		abort();
	}
	Nullable_ctor(&nullable, index);
	Space_2_set_LastGetIndex(self, nullable);
	matrixData = Space_2_get_MatrixData(self);
	double_ = MatrixData_4_get_Item(matrixData, index);
	result = double_;
	(void)Assign_MatrixData_4(&matrixData, NULL);
	return result;
}

float64_t CAErrorSpace_get_A(struct CAErrorSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_2_get_Item(&self->base, ((int32_t)0));
	return double_;
}

static void Del_float64_t_1D_15(struct float64_t_1D_15 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_1D_15(struct float64_t_1D_15 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_1D_15.CurrentCount--;
		Res_float64_t_1D_15.Next[Res_float64_t_1D_15.CurrentCount] = self;
		Del_float64_t_1D_15(self);
	}
}

struct float64_t_1D_15 *New_float64_t_1D_15(void)
{
	static struct float64_t_1D_15 const Default_float64_t_1D_15 = { 1 };
	struct float64_t_1D_15 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_1D_15.CurrentCount == RC_float64_t_1D_15)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_1D_15.Next[Res_float64_t_1D_15.CurrentCount];
	Res_float64_t_1D_15.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_1D_15.MaximumCount = (Res_float64_t_1D_15.CurrentCount > Res_float64_t_1D_15.MaximumCount) ? Res_float64_t_1D_15.CurrentCount : Res_float64_t_1D_15.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_1D_15;
	return instance;
}

struct float64_t_1D_15 *Assign_float64_t_1D_15(struct float64_t_1D_15 **const left, struct float64_t_1D_15 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_1D_15(*left);
	*left = right;
	return right;
}

static void RemRef_MatrixData_14(struct MatrixData_14 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_14.CurrentCount--;
		Res_MatrixData_14.Next[Res_MatrixData_14.CurrentCount] = self;
		Del_MatrixData_14(self);
	}
}

struct MatrixData_14 *New_MatrixData_14(void)
{
	static struct MatrixData_14 const Default_MatrixData_14 = { 1 };
	struct MatrixData_14 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_14.CurrentCount == RC_MatrixData_14)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_14.Next[Res_MatrixData_14.CurrentCount];
	Res_MatrixData_14.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_14.MaximumCount = (Res_MatrixData_14.CurrentCount > Res_MatrixData_14.MaximumCount) ? Res_MatrixData_14.CurrentCount : Res_MatrixData_14.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_14;
	return instance;
}

struct MatrixData_14 *Assign_MatrixData_14(struct MatrixData_14 **const left, struct MatrixData_14 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_14(*left);
	*left = right;
	return right;
}

void MatrixData_14_ctor(struct MatrixData_14 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_15 *array = NULL;

	assert(rows == ((int32_t)5));
	assert(columns == ((int32_t)3));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_15();
	(void)Assign_float64_t_1D_15(&self->_data, array);
	(void)Assign_float64_t_1D_15(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct MatrixData_14 *MatrixData_20_Zeros_12(int32_t rows, int32_t columns)
{
	struct MatrixData_14 *result = NULL;
	struct MatrixData_14 *matrixData = NULL;

	assert(rows == ((int32_t)5));
	assert(columns == ((int32_t)3));
	matrixData = New_MatrixData_14();
	MatrixData_14_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData_14(&result, matrixData);
	(void)Assign_MatrixData_14(&matrixData, NULL);
	return result;
}

struct MatrixData_14 *Matrix_12_get_MatrixData(struct Matrix_12 *const self)
{
	struct MatrixData_14 *result = NULL;

	if (!(self->_matrix != NULL))
	{
		struct MatrixData_14 *matrixData = NULL;

		matrixData = MatrixData_20_Zeros_12(self->Rows, self->Columns);
		(void)Assign_MatrixData_14(&self->_matrix, matrixData);
		(void)Assign_MatrixData_14(&matrixData, NULL);
	}
	(void)Assign_MatrixData_14(&result, self->_matrix);
	return result;
}

struct float64_t_1D_15 *MatrixData_14_get_DataReference(struct MatrixData_14 *const self)
{
	struct float64_t_1D_15 *result = NULL;

	(void)Assign_float64_t_1D_15(&result, self->_data);
	return result;
}

static void MatrixData_14_SetValueFast(struct MatrixData_14 *const self, float64_t value, int32_t row, int32_t column)
{
	struct float64_t_1D_15 *array = NULL;

	array = MatrixData_14_get_DataReference(self);
	array->Elements[(column * self->Rows) + row] = value;
	(void)Assign_float64_t_1D_15(&array, NULL);
}

void MatrixData_14_set_Item(struct MatrixData_14 *const self, int32_t row, int32_t column, float64_t value)
{
	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	MatrixData_14_SetValueFast(self, value, row, column);
}

static void Matrix_12_MatrixChanged(struct Matrix_12 *const self)
{
	(void)Assign_MatrixData(&self->CachedTranspose, NULL);
}

void Matrix_12_set_Item(struct Matrix_12 *const self, int32_t row, int32_t column, float64_t value)
{
	struct MatrixData_14 *matrixData = NULL;

	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	matrixData = Matrix_12_get_MatrixData(self);
	MatrixData_14_set_Item(matrixData, row, column, value);
	(void)Assign_MatrixData_14(&matrixData, NULL);
	Matrix_12_MatrixChanged(self);
}

void Matrix_12_set_Item_1(struct Matrix_12 *const self, float64_t row, float64_t column, float64_t value)
{
	Matrix_12_set_Item(self, (int32_t)row, (int32_t)column, value);
}

float64_t CAErrorSpace_get_J(struct CAErrorSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_2_get_Item(&self->base, ((int32_t)1));
	return double_;
}

float64_t CAErrorSpace_get_W(struct CAErrorSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_2_get_Item(&self->base, ((int32_t)2));
	return double_;
}

void CAModel_FillNoiseDiscretiMatrix(struct CAModel *const self, struct CASpace *stateExpectation, struct TimeSpan deltaT, struct Matrix_12 **G)
{
	float64_t T = 0.0;
	float64_t double_ = 0.0;
	float64_t TSquared = 0.0;
	float64_t g = 0.0;
	float64_t double__1 = 0.0;
	float64_t sinG = 0.0;
	float64_t double__2 = 0.0;
	float64_t cosG = 0.0;
	float64_t double__3 = 0.0;
	struct Matrix_12 *arg_61_0 = NULL;
	struct CASpace *CS_0_0000 = NULL;
	float64_t arg_61_1 = 0.0;
	float64_t double__4 = 0.0;
	struct CAErrorSpace *CS_0_0001 = NULL;
	struct Matrix_12 *matrix = NULL;
	float64_t double__5 = 0.0;
	float64_t double__6 = 0.0;
	struct Matrix_12 *arg_A0_0 = NULL;
	struct CASpace *CS_0_0002 = NULL;
	float64_t arg_A0_1 = 0.0;
	float64_t double__7 = 0.0;
	struct CAErrorSpace *CS_0_0003 = NULL;
	struct Matrix_12 *matrix_1 = NULL;
	float64_t double__8 = 0.0;
	float64_t double__9 = 0.0;
	struct Matrix_12 *arg_DC_0 = NULL;
	struct CASpace *CS_0_0004 = NULL;
	float64_t arg_DC_1 = 0.0;
	float64_t double__10 = 0.0;
	struct CAErrorSpace *CS_0_0005 = NULL;
	struct Matrix_12 *matrix_2 = NULL;
	float64_t double__11 = 0.0;
	float64_t double__12 = 0.0;
	struct Matrix_12 *arg_11A_0 = NULL;
	struct CASpace *CS_0_0006 = NULL;
	float64_t arg_11A_1 = 0.0;
	float64_t double__13 = 0.0;
	struct CAErrorSpace *CS_0_0007 = NULL;
	struct Matrix_12 *matrix_3 = NULL;
	float64_t double__14 = 0.0;
	float64_t double__15 = 0.0;
	struct Matrix_12 *arg_14A_0 = NULL;
	struct CASpace *CS_0_0008 = NULL;
	float64_t arg_14A_1 = 0.0;
	float64_t double__16 = 0.0;
	struct CAErrorSpace *CS_0_0009 = NULL;
	struct Matrix_12 *matrix_4 = NULL;
	float64_t double__17 = 0.0;
	float64_t double__18 = 0.0;
	struct Matrix_12 *arg_17A_0 = NULL;
	struct CASpace *CS_0_0010 = NULL;
	float64_t arg_17A_1 = 0.0;
	float64_t double__19 = 0.0;
	struct CAErrorSpace *CS_0_0011 = NULL;
	struct Matrix_12 *matrix_5 = NULL;
	float64_t double__20 = 0.0;
	float64_t double__21 = 0.0;
	struct Matrix_12 *arg_1B4_0 = NULL;
	struct CASpace *CS_0_0012 = NULL;
	float64_t arg_1B4_1 = 0.0;
	float64_t double__22 = 0.0;
	struct CAErrorSpace *CS_0_0013 = NULL;
	struct Matrix_12 *matrix_6 = NULL;
	float64_t double__23 = 0.0;
	float64_t double__24 = 0.0;
	struct Matrix_12 *arg_1EC_0 = NULL;
	struct CASpace *CS_0_0014 = NULL;
	float64_t arg_1EC_1 = 0.0;
	float64_t double__25 = 0.0;
	struct CAErrorSpace *CS_0_0015 = NULL;
	struct Matrix_12 *matrix_7 = NULL;
	float64_t double__26 = 0.0;
	float64_t double__27 = 0.0;
	struct Matrix_12 *arg_21C_0 = NULL;
	struct CASpace *CS_0_0016 = NULL;
	float64_t arg_21C_1 = 0.0;
	float64_t double__28 = 0.0;
	struct CAErrorSpace *CS_0_0017 = NULL;
	struct Matrix_12 *matrix_8 = NULL;
	float64_t double__29 = 0.0;
	float64_t double__30 = 0.0;

	double_ = TimeSpan_get_TotalSeconds(&deltaT);
	T = double_;
	TSquared = T * T;
	double__1 = CVSpace_get_G(&(*&stateExpectation)->base);
	g = double__1;
	double__2 = Math_Sin(g);
	sinG = double__2;
	double__3 = Math_Cos(g);
	cosG = double__3;
	(void)Assign_Matrix_12(&arg_61_0, *G);
	(void)Assign_CASpace(&CS_0_0000, CAModel_1_S);
	double__4 = CVSpace_get_X(&(*&CS_0_0000)->base);
	arg_61_1 = double__4;
	(void)Assign_CAErrorSpace(&CS_0_0001, CAModel_1_N);
	(void)Assign_Matrix_12(&matrix, arg_61_0);
	double__5 = arg_61_1;
	double__6 = CAErrorSpace_get_A(CS_0_0001);
	Matrix_12_set_Item_1(matrix, double__5, double__6, (TSquared * cosG) / 2.0);
	(void)Assign_Matrix_12(&matrix, NULL);
	(void)Assign_Matrix_12(&arg_A0_0, *G);
	(void)Assign_CASpace(&CS_0_0002, CAModel_1_S);
	double__7 = CVSpace_get_X(&(*&CS_0_0002)->base);
	arg_A0_1 = double__7;
	(void)Assign_CAErrorSpace(&CS_0_0003, CAModel_1_N);
	(void)Assign_Matrix_12(&matrix_1, arg_A0_0);
	double__8 = arg_A0_1;
	double__9 = CAErrorSpace_get_J(CS_0_0003);
	Matrix_12_set_Item_1(matrix_1, double__8, double__9, ((T * TSquared) * cosG) / 6.0);
	(void)Assign_Matrix_12(&matrix_1, NULL);
	(void)Assign_Matrix_12(&arg_DC_0, *G);
	(void)Assign_CASpace(&CS_0_0004, CAModel_1_S);
	double__10 = CVSpace_get_Y(&(*&CS_0_0004)->base);
	arg_DC_1 = double__10;
	(void)Assign_CAErrorSpace(&CS_0_0005, CAModel_1_N);
	(void)Assign_Matrix_12(&matrix_2, arg_DC_0);
	double__11 = arg_DC_1;
	double__12 = CAErrorSpace_get_A(CS_0_0005);
	Matrix_12_set_Item_1(matrix_2, double__11, double__12, (TSquared * sinG) / 2.0);
	(void)Assign_Matrix_12(&matrix_2, NULL);
	(void)Assign_Matrix_12(&arg_11A_0, *G);
	(void)Assign_CASpace(&CS_0_0006, CAModel_1_S);
	double__13 = CVSpace_get_Y(&(*&CS_0_0006)->base);
	arg_11A_1 = double__13;
	(void)Assign_CAErrorSpace(&CS_0_0007, CAModel_1_N);
	(void)Assign_Matrix_12(&matrix_3, arg_11A_0);
	double__14 = arg_11A_1;
	double__15 = CAErrorSpace_get_J(CS_0_0007);
	Matrix_12_set_Item_1(matrix_3, double__14, double__15, ((T * TSquared) * sinG) / 6.0);
	(void)Assign_Matrix_12(&matrix_3, NULL);
	(void)Assign_Matrix_12(&arg_14A_0, *G);
	(void)Assign_CASpace(&CS_0_0008, CAModel_1_S);
	double__16 = CVSpace_get_G(&(*&CS_0_0008)->base);
	arg_14A_1 = double__16;
	(void)Assign_CAErrorSpace(&CS_0_0009, CAModel_1_N);
	(void)Assign_Matrix_12(&matrix_4, arg_14A_0);
	double__17 = arg_14A_1;
	double__18 = CAErrorSpace_get_W(CS_0_0009);
	Matrix_12_set_Item_1(matrix_4, double__17, double__18, T);
	(void)Assign_Matrix_12(&matrix_4, NULL);
	(void)Assign_Matrix_12(&arg_17A_0, *G);
	(void)Assign_CASpace(&CS_0_0010, CAModel_1_S);
	double__19 = CVSpace_get_V(&(*&CS_0_0010)->base);
	arg_17A_1 = double__19;
	(void)Assign_CAErrorSpace(&CS_0_0011, CAModel_1_N);
	(void)Assign_Matrix_12(&matrix_5, arg_17A_0);
	double__20 = arg_17A_1;
	double__21 = CAErrorSpace_get_A(CS_0_0011);
	Matrix_12_set_Item_1(matrix_5, double__20, double__21, T);
	(void)Assign_Matrix_12(&matrix_5, NULL);
	(void)Assign_Matrix_12(&arg_1B4_0, *G);
	(void)Assign_CASpace(&CS_0_0012, CAModel_1_S);
	double__22 = CVSpace_get_V(&(*&CS_0_0012)->base);
	arg_1B4_1 = double__22;
	(void)Assign_CAErrorSpace(&CS_0_0013, CAModel_1_N);
	(void)Assign_Matrix_12(&matrix_6, arg_1B4_0);
	double__23 = arg_1B4_1;
	double__24 = CAErrorSpace_get_J(CS_0_0013);
	Matrix_12_set_Item_1(matrix_6, double__23, double__24, TSquared / 2.0);
	(void)Assign_Matrix_12(&matrix_6, NULL);
	(void)Assign_Matrix_12(&arg_1EC_0, *G);
	(void)Assign_CASpace(&CS_0_0014, CAModel_1_S);
	double__25 = CASpace_get_A(CS_0_0014);
	arg_1EC_1 = double__25;
	(void)Assign_CAErrorSpace(&CS_0_0015, CAModel_1_N);
	(void)Assign_Matrix_12(&matrix_7, arg_1EC_0);
	double__26 = arg_1EC_1;
	double__27 = CAErrorSpace_get_A(CS_0_0015);
	Matrix_12_set_Item_1(matrix_7, double__26, double__27, 1.0);
	(void)Assign_Matrix_12(&matrix_7, NULL);
	(void)Assign_Matrix_12(&arg_21C_0, *G);
	(void)Assign_CASpace(&CS_0_0016, CAModel_1_S);
	double__28 = CASpace_get_A(CS_0_0016);
	arg_21C_1 = double__28;
	(void)Assign_CAErrorSpace(&CS_0_0017, CAModel_1_N);
	(void)Assign_Matrix_12(&matrix_8, arg_21C_0);
	double__29 = arg_21C_1;
	double__30 = CAErrorSpace_get_J(CS_0_0017);
	Matrix_12_set_Item_1(matrix_8, double__29, double__30, T);
	(void)Assign_Matrix_12(&matrix_8, NULL);
	RemRef_Matrix_12(arg_61_0);
	RemRef_CASpace(CS_0_0000);
	RemRef_CAErrorSpace(CS_0_0001);
	RemRef_Matrix_12(arg_A0_0);
	RemRef_CASpace(CS_0_0002);
	RemRef_CAErrorSpace(CS_0_0003);
	RemRef_Matrix_12(arg_DC_0);
	RemRef_CASpace(CS_0_0004);
	RemRef_CAErrorSpace(CS_0_0005);
	RemRef_Matrix_12(arg_11A_0);
	RemRef_CASpace(CS_0_0006);
	RemRef_CAErrorSpace(CS_0_0007);
	RemRef_Matrix_12(arg_14A_0);
	RemRef_CASpace(CS_0_0008);
	RemRef_CAErrorSpace(CS_0_0009);
	RemRef_Matrix_12(arg_17A_0);
	RemRef_CASpace(CS_0_0010);
	RemRef_CAErrorSpace(CS_0_0011);
	RemRef_Matrix_12(arg_1B4_0);
	RemRef_CASpace(CS_0_0012);
	RemRef_CAErrorSpace(CS_0_0013);
	RemRef_Matrix_12(arg_1EC_0);
	RemRef_CASpace(CS_0_0014);
	RemRef_CAErrorSpace(CS_0_0015);
	RemRef_Matrix_12(arg_21C_0);
	RemRef_CASpace(CS_0_0016);
	RemRef_CAErrorSpace(CS_0_0017);
}

struct PositiveDefiniteMatrix_2 *SystemModel_get_NoiseCovariance(struct SystemModel *const self)
{
	struct PositiveDefiniteMatrix_2 *result = NULL;

	(void)Assign_PositiveDefiniteMatrix_2(&result, self->_processNoiseCovariance);
	return result;
}

void LinearAlgebra_MatrixMultiply_9(struct LinearAlgebra *const self, struct float64_t_1D_15 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_9 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_15 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)15) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)9) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)15) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)15) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)9) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)9) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)15) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)15) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_14 *MatrixMath_Multiply_19(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_14 *left, struct MatrixData_13 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_14 *matrixData = NULL;
	struct MatrixData_14 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_15 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_9 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_15 *array_2 = NULL;
	struct MatrixData_14 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == false);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Columns;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_14();
	MatrixData_14_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_14(&matrixData, matrixData_1);
	(void)Assign_MatrixData_14(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_14_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_13_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_14_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_9(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_15(&array, NULL);
	(void)Assign_float64_t_1D_9(&array_1, NULL);
	(void)Assign_float64_t_1D_15(&array_2, NULL);
	(void)Assign_MatrixData_14(&result, matrixData);
	RemRef_MatrixData_14(matrixData);
	return result;
}

void LinearAlgebra_MatrixMultiply_10(struct LinearAlgebra *const self, struct float64_t_1D_15 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_15 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_25 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)15) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)15) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)15) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)15) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)15) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)15) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)15) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)25) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_2 *MatrixMath_Multiply_20(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_14 *left, struct MatrixData_14 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_15 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_15 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_25 *array_2 = NULL;
	struct MatrixData_2 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == true);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Rows;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_2();
	MatrixData_2_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_2(&matrixData, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_14_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_14_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_2_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_10(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_15(&array, NULL);
	(void)Assign_float64_t_1D_15(&array_1, NULL);
	(void)Assign_float64_t_1D_25(&array_2, NULL);
	(void)Assign_MatrixData_2(&result, matrixData);
	RemRef_MatrixData_2(matrixData);
	return result;
}

struct MatrixData_2 *MatrixMath_Multiply_21(bool_t transposeFirst, bool_t transposeSecond, bool_t transposeThird, struct MatrixData_14 *first, struct MatrixData_13 *second, struct MatrixData_14 *third)
{
	struct MatrixData_14 *left = NULL;
	struct MatrixData_14 *matrixData = NULL;
	struct MatrixData_2 *result = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;

	assert(transposeFirst == false);
	assert(transposeSecond == false);
	assert(transposeThird == true);
	if (!(first != NULL))
	{
		abort();
	}
	if (!(second != NULL))
	{
		abort();
	}
	if (!(third != NULL))
	{
		abort();
	}
	matrixData = MatrixMath_Multiply_19(transposeFirst, transposeSecond, first, second);
	(void)Assign_MatrixData_14(&left, matrixData);
	(void)Assign_MatrixData_14(&matrixData, NULL);
	matrixData_1 = MatrixMath_Multiply_20(false, transposeThird, left, third);
	(void)Assign_MatrixData_2(&result, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	RemRef_MatrixData_14(left);
	return result;
}

struct PositiveDefiniteMatrix_7 *PosiDefinMatri_11_CreatAndCorre(struct MatrixData_2 *matrix)
{
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	float64_t num = 0.0;
	float64_t num2 = 0.0;
	float64_t value = 0.0;
	struct PositiveDefiniteMatrix_7 *result = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix = NULL;

	i = ((int32_t)0);
	while (i < matrix->Rows)
	{
		float64_t double_ = 0.0;

		double_ = MatrixData_2_get_Item(matrix, i, i);
		if (!(double_ > 0.0))
		{
			MatrixData_2_set_Item(matrix, i, i, 4.94065645841247E-324);
		}
		j = ((int32_t)0);
		while (j < i)
		{
			float64_t double__1 = 0.0;
			float64_t double__2 = 0.0;
			float64_t double__3 = 0.0;
			float64_t double__4 = 0.0;
			float64_t double__5 = 0.0;
			float64_t double__6 = 0.0;

			double__1 = MatrixData_2_get_Item(matrix, i, j);
			double__2 = MatrixData_2_get_Item(matrix, j, i);
			num = (double__1 + double__2) / 2.0;
			double__3 = MatrixData_2_get_Item(matrix, i, i);
			double__4 = MatrixData_2_get_Item(matrix, j, j);
			double__5 = Math_Sqrt(double__3 * double__4);
			num2 = 1.0 * double__5;
			double__6 = Math_Abs(num);
			if (!(double__6 <= num2))
			{
				int32_t int32 = ((int32_t)0);
				float64_t double__7 = 0.0;

				int32 = Math_Sign(num);
				double__7 = (float64_t)int32;
				value = double__7 * num2;
			}
			else
			{
				value = num;
			}
			MatrixData_2_set_Item(matrix, i, j, value);
			MatrixData_2_set_Item(matrix, j, i, value);
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	positiveDefiniteMatrix = PositivDefiniteMatrix_11_Create(matrix);
	(void)Assign_PositiveDefiniteMatrix_7(&result, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix, NULL);
	return result;
}

struct PositiveDefiniteMatrix_7 *SystemModel_2_get_Covariance(struct CAModel *const self)
{
	struct Matrix_12 *matrix = NULL;
	struct Matrix_12 *matrix_1 = NULL;
	struct CASpace *caSpace = NULL;
	struct TimeSpan timeSpan = { 0 };
	struct MatrixData_2 *matrix2 = NULL;
	struct MatrixData_14 *matrixData = NULL;
	struct PositiveDefiniteMatrix_2 *positiveDefiniteMatrix = NULL;
	struct MatrixData_13 *matrixData_1 = NULL;
	struct MatrixData_14 *matrixData_2 = NULL;
	struct MatrixData_2 *matrixData_3 = NULL;
	struct PositiveDefiniteMatrix_7 *result = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_1 = NULL;

	matrix_1 = New_Matrix_12();
	Matrix_12_ctor(matrix_1);
	(void)Assign_Matrix_12(&matrix, matrix_1);
	(void)Assign_Matrix_12(&matrix_1, NULL);
	caSpace = SystemModel_get_Condition(&self->base.base.base);
	timeSpan = SystemModel_get_TimeCondition(&self->base.base.base);
	CAModel_FillNoiseDiscretiMatrix(self, caSpace, timeSpan, &matrix);
	(void)Assign_CASpace(&caSpace, NULL);
	matrixData = Matrix_12_get_MatrixData(matrix);
	positiveDefiniteMatrix = SystemModel_get_NoiseCovariance(&self->base.base.base);
	matrixData_1 = Matrix_2_get_MatrixData(&positiveDefiniteMatrix->base.base);
	matrixData_2 = Matrix_12_get_MatrixData(matrix);
	matrixData_3 = MatrixMath_Multiply_21(false, false, true, matrixData, matrixData_1, matrixData_2);
	(void)Assign_MatrixData_2(&matrix2, matrixData_3);
	(void)Assign_MatrixData_14(&matrixData, NULL);
	(void)Assign_PositiveDefiniteMatrix_2(&positiveDefiniteMatrix, NULL);
	(void)Assign_MatrixData_13(&matrixData_1, NULL);
	(void)Assign_MatrixData_14(&matrixData_2, NULL);
	(void)Assign_MatrixData_2(&matrixData_3, NULL);
	positiveDefiniteMatrix_1 = PosiDefinMatri_11_CreatAndCorre(matrix2);
	(void)Assign_PositiveDefiniteMatrix_7(&result, positiveDefiniteMatrix_1);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_1, NULL);
	RemRef_Matrix_12(matrix);
	RemRef_MatrixData_2(matrix2);
	return result;
}

struct MatrixData_2 *MatrixMath_Add_3(struct MatrixData_2 *left, struct MatrixData_2 *right)
{
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	struct float64_t_1D_25 *dataReference = NULL;
	struct float64_t_1D_25 *array = NULL;
	struct float64_t_1D_25 *dataReference2 = NULL;
	struct float64_t_1D_25 *array_1 = NULL;
	struct float64_t_1D_25 *dataReference3 = NULL;
	struct float64_t_1D_25 *array_2 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_2 *result = NULL;

	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData_2();
	MatrixData_2_ctor(matrixData_1, left->Rows, right->Columns);
	(void)Assign_MatrixData_2(&matrixData, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	array = MatrixData_2_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_25(&dataReference, array);
	(void)Assign_float64_t_1D_25(&array, NULL);
	array_1 = MatrixData_2_get_DataReference(left);
	(void)Assign_float64_t_1D_25(&dataReference2, array_1);
	(void)Assign_float64_t_1D_25(&array_1, NULL);
	array_2 = MatrixData_2_get_DataReference(right);
	(void)Assign_float64_t_1D_25(&dataReference3, array_2);
	(void)Assign_float64_t_1D_25(&array_2, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)25))
	{
		dataReference->Elements[i] = dataReference2->Elements[i] + dataReference3->Elements[i];
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_2(&result, matrixData);
	RemRef_MatrixData_2(matrixData);
	RemRef_float64_t_1D_25(dataReference);
	RemRef_float64_t_1D_25(dataReference2);
	RemRef_float64_t_1D_25(dataReference3);
	return result;
	abort();
}

static struct CAErrorSpace *SystemModel_get_Condition2(struct SystemModel *const self)
{
	struct CAErrorSpace *result = NULL;

	(void)Assign_CAErrorSpace(&result, self->Condition2);
	return result;
}

void CASpace_set_A(struct CASpace *const self, float64_t value)
{
	Space_set_Item(&self->base.base.base, ((int32_t)4), value);
}

void CVSpace_set_V(struct CVSpace *const self, float64_t value)
{
	Space_set_Item(&self->base.base, ((int32_t)3), value);
}

void CAModel_f(struct CAModel *const self, struct CASpace *state, struct TimeSpan deltaT, struct CAErrorSpace *processNoise, struct CASpace **predictedState)
{
	float64_t T = 0.0;
	float64_t double_ = 0.0;
	float64_t TSquared = 0.0;
	float64_t x = 0.0;
	float64_t double__1 = 0.0;
	float64_t y = 0.0;
	float64_t double__2 = 0.0;
	float64_t g = 0.0;
	float64_t double__3 = 0.0;
	float64_t v = 0.0;
	float64_t double__4 = 0.0;
	float64_t j = 0.0;
	float64_t double__5 = 0.0;
	float64_t w = 0.0;
	float64_t double__6 = 0.0;
	float64_t a = 0.0;
	float64_t double__7 = 0.0;
	float64_t double__8 = 0.0;
	float64_t gNew = 0.0;
	float64_t sinG = 0.0;
	float64_t double__9 = 0.0;
	float64_t cosG = 0.0;
	float64_t double__10 = 0.0;
	float64_t sinGNew = 0.0;
	float64_t cosGNew = 0.0;
	float64_t wSquared = 0.0;
	float64_t twoTimesWCubed = 0.0;
	float64_t double__11 = 0.0;
	float64_t delta = 0.0;

	double_ = TimeSpan_get_TotalSeconds(&deltaT);
	T = double_;
	TSquared = T * T;
	double__1 = CVSpace_get_X(&(*&state)->base);
	x = double__1;
	double__2 = CVSpace_get_Y(&(*&state)->base);
	y = double__2;
	double__3 = CVSpace_get_G(&(*&state)->base);
	g = double__3;
	double__4 = CVSpace_get_V(&(*&state)->base);
	v = double__4;
	double__5 = CAErrorSpace_get_J(processNoise);
	j = double__5;
	double__6 = CAErrorSpace_get_W(processNoise);
	w = double__6;
	double__7 = CASpace_get_A(state);
	double__8 = CAErrorSpace_get_A(processNoise);
	a = double__7 + double__8;
	CASpace_set_A(*predictedState, a + (T * j));
	gNew = g + (T * w);
	CVSpace_set_G(&(*predictedState)->base, gNew);
	CVSpace_set_V(&(*predictedState)->base, (v + (T * a)) + ((TSquared * j) / 2.0));
	double__9 = Math_Sin(g);
	sinG = double__9;
	double__10 = Math_Cos(g);
	cosG = double__10;
	double__11 = Math_Abs(w);
	if (!(double__11 <= 1E-05))
	{
		float64_t double__12 = 0.0;
		float64_t double__13 = 0.0;

		double__12 = Math_Sin(gNew);
		sinGNew = double__12;
		double__13 = Math_Cos(gNew);
		cosGNew = double__13;
		wSquared = w * w;
		twoTimesWCubed = ((2.0 * w) * w) * w;
		CVSpace_set_X(&(*predictedState)->base, ((x + ((j * ((((2.0 * sinG) - (2.0 * sinGNew)) + ((wSquared * TSquared) * sinGNew)) + (((2.0 * w) * T) * cosGNew))) / twoTimesWCubed)) + ((a * ((cosGNew - cosG) + ((w * T) * sinGNew))) / wSquared)) + ((v * (sinGNew - sinG)) / w));
		CVSpace_set_Y(&(*predictedState)->base, ((y + ((j * ((((2.0 * cosGNew) - (2.0 * cosG)) - ((wSquared * TSquared) * cosGNew)) + (((2.0 * w) * T) * sinGNew))) / twoTimesWCubed)) + ((a * ((sinGNew - sinG) - ((w * T) * cosGNew))) / wSquared)) - ((v * (cosGNew - cosG)) / w));
		return;
	}
	delta = ((((T * TSquared) * j) / 6.0) + ((TSquared * a) / 2.0)) + (T * v);
	CVSpace_set_X(&(*predictedState)->base, x + (delta * cosG));
	CVSpace_set_Y(&(*predictedState)->base, y + (delta * sinG));
}

struct CASpace *SystemModel_get_Expectation(struct CAModel *const self)
{
	struct CASpace *result = NULL;
	struct CASpace *caSpace = NULL;
	struct CASpace *caSpace_1 = NULL;
	struct CASpace *caSpace_2 = NULL;
	struct TimeSpan timeSpan = { 0 };
	struct CAErrorSpace *caErrorSpace = NULL;
	struct CASpace *result_1 = NULL;

	caSpace = SystemModel_get_Condition(&self->base.base.base);
	caSpace_1 = SpaceExtensions_Clone(caSpace);
	(void)Assign_CASpace(&result, caSpace_1);
	(void)Assign_CASpace(&caSpace, NULL);
	(void)Assign_CASpace(&caSpace_1, NULL);
	caSpace_2 = SystemModel_get_Condition(&self->base.base.base);
	timeSpan = SystemModel_get_TimeCondition(&self->base.base.base);
	caErrorSpace = SystemModel_get_Condition2(&self->base.base.base);
	CAModel_f(self, caSpace_2, timeSpan, caErrorSpace, &result);
	(void)Assign_CASpace(&caSpace_2, NULL);
	(void)Assign_CAErrorSpace(&caErrorSpace, NULL);
	(void)Assign_CASpace(&result_1, result);
	RemRef_CASpace(result);
	return result_1;
}

struct Gaussian_5 *EKF_PredictState_1(struct TimeSpan deltaT, struct Gaussian_5 *state, struct CAModel *systemModel)
{
	struct CASpace *caSpace = NULL;
	struct MatrixData_2 *copy = NULL;
	struct SquareMatrix_7 *squareMatrix = NULL;
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	struct MatrixData_2 *matrix = NULL;
	struct MatrixData_2 *matrixData_2 = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix = NULL;
	struct MatrixData_2 *matrixData_3 = NULL;
	struct MatrixData_2 *matrixData_4 = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_1 = NULL;
	struct MatrixData_2 *matrixData_5 = NULL;
	struct MatrixData_2 *matrixData_6 = NULL;
	struct PositiveDefiniteMatrix_7 *covariance = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_2 = NULL;
	struct Gaussian_5 *result = NULL;
	struct CASpace *caSpace_1 = NULL;
	struct Gaussian_5 *gaussian = NULL;

	caSpace = Gaussian_5_get_Expectation(state);
	SystemModel_set_Condition(&(*&systemModel)->base.base.base, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	SystemModel_set_TimeCondition(&(*&systemModel)->base.base.base, deltaT);
	squareMatrix = SystemModel_4_get_TransitMatrix(systemModel);
	matrixData = Matrix_10_get_MatrixData(&squareMatrix->base);
	matrixData_1 = MatrixData_2_get_Copy(matrixData);
	(void)Assign_MatrixData_2(&copy, matrixData_1);
	(void)Assign_SquareMatrix_7(&squareMatrix, NULL);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	(void)Assign_MatrixData_2(&matrixData_2, copy);
	positiveDefiniteMatrix = Gaussian_5_get_Covariance(state);
	matrixData_3 = Matrix_10_get_MatrixData(&positiveDefiniteMatrix->base.base);
	matrixData_4 = MatrixMath_Multiply_18(false, false, true, matrixData_2, matrixData_3, copy);
	positiveDefiniteMatrix_1 = SystemModel_2_get_Covariance(systemModel);
	matrixData_5 = Matrix_10_get_MatrixData(&positiveDefiniteMatrix_1->base.base);
	matrixData_6 = MatrixMath_Add_3(matrixData_4, matrixData_5);
	(void)Assign_MatrixData_2(&matrix, matrixData_6);
	(void)Assign_MatrixData_2(&matrixData_2, NULL);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix, NULL);
	(void)Assign_MatrixData_2(&matrixData_3, NULL);
	(void)Assign_MatrixData_2(&matrixData_4, NULL);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_1, NULL);
	(void)Assign_MatrixData_2(&matrixData_5, NULL);
	(void)Assign_MatrixData_2(&matrixData_6, NULL);
	positiveDefiniteMatrix_2 = PosiDefinMatri_11_CreatAndCorre(matrix);
	(void)Assign_PositiveDefiniteMatrix_7(&covariance, positiveDefiniteMatrix_2);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_2, NULL);
	caSpace_1 = SystemModel_get_Expectation(systemModel);
	gaussian = Gaussian_9_Create(caSpace_1, covariance);
	(void)Assign_Gaussian_5(&result, gaussian);
	(void)Assign_CASpace(&caSpace_1, NULL);
	(void)Assign_Gaussian_5(&gaussian, NULL);
	RemRef_MatrixData_2(copy);
	RemRef_MatrixData_2(matrix);
	RemRef_PositiveDefiniteMatrix_7(covariance);
	return result;
}

int32_t StaticList_23_get_Count(struct StaticList_23 *const self)
{
	return self->Count;
}

static void StaticList_23_CheckCount(struct StaticList_23 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_23_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_23_set_Count(struct StaticList_23 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_23_Add(struct StaticList_23 *const self, struct Gaussian_5 *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_23_CheckCount(self);
	int32 = StaticList_23_get_Count(self);
	count = int32;
	(void)Assign_Gaussian_5(&self->_items->Elements[count], value);
	int32_1 = StaticList_23_get_Count(self);
	StaticList_23_set_Count(self, int32_1 + ((int32_t)1));
}

struct ExistenceSpace *TwoPointDistri_get_SuccesSample(struct TwoPointDistribution *const self)
{
	struct ExistenceSpace *result = NULL;

	(void)Assign_ExistenceSpace(&result, self->SuccessSample);
	return result;
}

struct ExistenceSpace *TwoPointDistri_get_FailurSample(struct TwoPointDistribution *const self)
{
	struct ExistenceSpace *result = NULL;

	(void)Assign_ExistenceSpace(&result, self->FailureSample);
	return result;
}

static void TwoPointDistribution_1_cctor(void)
{
}

static void RemRef_TwoPointDistribution(struct TwoPointDistribution *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_TwoPointDistribution.CurrentCount--;
		Res_TwoPointDistribution.Next[Res_TwoPointDistribution.CurrentCount] = self;
		Del_TwoPointDistribution(self);
	}
}

struct TwoPointDistribution *New_TwoPointDistribution(void)
{
	static struct TwoPointDistribution const Default_TwoPointDistribution = { 1 };
	struct TwoPointDistribution *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_TwoPointDistribution.CurrentCount == RC_TwoPointDistribution)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_TwoPointDistribution.Next[Res_TwoPointDistribution.CurrentCount];
	Res_TwoPointDistribution.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_TwoPointDistribution.MaximumCount = (Res_TwoPointDistribution.CurrentCount > Res_TwoPointDistribution.MaximumCount) ? Res_TwoPointDistribution.CurrentCount : Res_TwoPointDistribution.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_TwoPointDistribution;
	return instance;
}

struct TwoPointDistribution *Assign_TwoPointDistribution(struct TwoPointDistribution **const left, struct TwoPointDistribution *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_TwoPointDistribution(*left);
	*left = right;
	return right;
}

struct TwoPointDistribution *TwoPointDistribution_Clone(struct TwoPointDistribution *const self)
{
	struct TwoPointDistribution *twoPointDistribution = NULL;
	struct ExistenceSpace *existenceSpace = NULL;
	struct ExistenceSpace *existenceSpace_1 = NULL;
	struct TwoPointDistribution *twoPointDistribution_1 = NULL;
	struct StaticList_15 *staticList = NULL;
	struct SampleProbabilityPair_2 *sampleProbabilityPair = NULL;
	struct StaticList_15 *staticList_1 = NULL;
	struct SampleProbabilityPair_2 *sampleProbabilityPair_1 = NULL;
	float64_t double_ = 0.0;
	struct StaticList_15 *staticList_2 = NULL;
	struct SampleProbabilityPair_2 *sampleProbabilityPair_2 = NULL;
	struct StaticList_15 *staticList_3 = NULL;
	struct SampleProbabilityPair_2 *sampleProbabilityPair_3 = NULL;
	float64_t double__1 = 0.0;
	struct TwoPointDistribution *result = NULL;

	existenceSpace = TwoPointDistri_get_SuccesSample(self);
	existenceSpace_1 = TwoPointDistri_get_FailurSample(self);
	twoPointDistribution_1 = New_TwoPointDistribution();
	TwoPointDistribution_ctor(twoPointDistribution_1, existenceSpace, existenceSpace_1);
	twoPointDistribution_1->_useLogOdds = self->_useLogOdds;
	twoPointDistribution_1->_logOdds = self->_logOdds;
	(void)Assign_TwoPointDistribution(&twoPointDistribution, twoPointDistribution_1);
	(void)Assign_ExistenceSpace(&existenceSpace, NULL);
	(void)Assign_ExistenceSpace(&existenceSpace_1, NULL);
	(void)Assign_TwoPointDistribution(&twoPointDistribution_1, NULL);
	staticList = SampleSet_2_get_Samples(&twoPointDistribution->base);
	sampleProbabilityPair = StaticList_15_get_Item(staticList, ((int32_t)0));
	staticList_1 = SampleSet_2_get_Samples(&self->base);
	sampleProbabilityPair_1 = StaticList_15_get_Item(staticList_1, ((int32_t)0));
	double_ = SampleProbabiPair_2_get_Probabi(sampleProbabilityPair_1);
	SampleProbabiPair_2_set_Probabi(sampleProbabilityPair, double_);
	(void)Assign_StaticList_15(&staticList, NULL);
	(void)Assign_SampleProbabilityPair_2(&sampleProbabilityPair, NULL);
	(void)Assign_StaticList_15(&staticList_1, NULL);
	(void)Assign_SampleProbabilityPair_2(&sampleProbabilityPair_1, NULL);
	staticList_2 = SampleSet_2_get_Samples(&twoPointDistribution->base);
	sampleProbabilityPair_2 = StaticList_15_get_Item(staticList_2, ((int32_t)1));
	staticList_3 = SampleSet_2_get_Samples(&self->base);
	sampleProbabilityPair_3 = StaticList_15_get_Item(staticList_3, ((int32_t)1));
	double__1 = SampleProbabiPair_2_get_Probabi(sampleProbabilityPair_3);
	SampleProbabiPair_2_set_Probabi(sampleProbabilityPair_2, double__1);
	(void)Assign_StaticList_15(&staticList_2, NULL);
	(void)Assign_SampleProbabilityPair_2(&sampleProbabilityPair_2, NULL);
	(void)Assign_StaticList_15(&staticList_3, NULL);
	(void)Assign_SampleProbabilityPair_2(&sampleProbabilityPair_3, NULL);
	(void)Assign_TwoPointDistribution(&result, twoPointDistribution);
	RemRef_TwoPointDistribution(twoPointDistribution);
	return result;
}

void PersistenceModel_set_Condition(struct PersistenceModel *const self, struct ExistenceSpace *value)
{
	(void)Assign_ExistenceSpace(&self->Condition, value);
}

static struct ExistenceSpace *PersistenceModel_get_Condition(struct PersistenceModel *const self)
{
	struct ExistenceSpace *result = NULL;

	(void)Assign_ExistenceSpace(&result, self->Condition);
	return result;
}

static void RemRef_Type(struct Type *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_Type.CurrentCount--;
		Res_Type.Next[Res_Type.CurrentCount] = self;
		Del_Type(self);
	}
}

struct Type *New_Type(void)
{
	static struct Type const Default_Type = { 1 };
	struct Type *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Type.CurrentCount == RC_Type)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Type.Next[Res_Type.CurrentCount];
	Res_Type.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Type.MaximumCount = (Res_Type.CurrentCount > Res_Type.MaximumCount) ? Res_Type.CurrentCount : Res_Type.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Type;
	return instance;
}

struct Type *Assign_Type(struct Type **const left, struct Type *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_Type(*left);
	*left = right;
	return right;
}

struct Type *Object_GetType(struct ExistenceSpace *const self)
{
	struct Type *result;

	result = New_Type();
	Object_ctor(&result->base.base);
	result->_id = ((int32_t)-1922618379);
	return result;
}

bool_t Type_1_op_Inequality(struct Type *left, struct Type *right)
{
	if (left == right)
	{
		return false;
	}
	if ((left == NULL) || (right == NULL))
	{
		return true;
	}
	return left->_id != right->_id;
}

bool_t float64_t_Equals(float64_t *const self, float64_t obj)
{
	bool_t boolean = false;

	if (!(obj != *self))
	{
		return true;
	}
	boolean = Double_IsNaN(obj);
	if (!!boolean)
	{
		bool_t boolean_1 = false;

		boolean_1 = Double_IsNaN(*self);
		return boolean_1;
	}
	return false;
}

bool_t MatrixData_3_Equals(struct MatrixData_3 *const self, struct MatrixData_3 *other)
{
	bool_t boolean = false;
	bool_t arg_3B_0 = false;
	bool_t flag = false;
	bool_t flag2 = false;
	struct float64_t_1D_1 *array = NULL;
	int32_t int32 = ((int32_t)0);
	struct float64_t_1D_1 *array_1 = NULL;
	bool_t result = false;
	int32_t i = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);
	struct float64_t_1D_1 *array_2 = NULL;

	if (!(other != NULL))
	{
		return false;
	}
	boolean = Object_2_ReferenceEquals(&self->base, &other->base);
	if (!!boolean)
	{
		return true;
	}
	arg_3B_0 = self->Columns == other->Columns;
	flag = arg_3B_0;
	array = MatrixData_3_get_DataReference(self);
	int32 = ((int32_t)1);
	array_1 = MatrixData_3_get_DataReference(other);
	flag2 = int32 == ((int32_t)1);
	(void)Assign_float64_t_1D_1(&array, NULL);
	(void)Assign_float64_t_1D_1(&array_1, NULL);
	result = true;
	i = ((int32_t)0);
	int32_1 = i;
	array_2 = MatrixData_3_get_DataReference(self);
	while (int32_1 < ((int32_t)1))
	{
		struct float64_t_1D_1 *array_3 = NULL;
		float64_t double_ = 0.0;
		struct float64_t_1D_1 *array_4 = NULL;
		bool_t boolean_1 = false;

		(void)Assign_float64_t_1D_1(&array_2, NULL);
		array_3 = MatrixData_3_get_DataReference(self);
		double_ = array_3->Elements[i];
		array_4 = MatrixData_3_get_DataReference(other);
		boolean_1 = float64_t_Equals(&double_, array_4->Elements[i]);
		if (!boolean_1)
		{
			(void)Assign_float64_t_1D_1(&array_3, NULL);
			(void)Assign_float64_t_1D_1(&array_4, NULL);
			result = false;
		}
		else
		{
			(void)Assign_float64_t_1D_1(&array_3, NULL);
			(void)Assign_float64_t_1D_1(&array_4, NULL);
		}
		i = i + ((int32_t)1);
		int32_1 = i;
		array_2 = MatrixData_3_get_DataReference(self);
	}
	(void)Assign_float64_t_1D_1(&array_2, NULL);
	return result;
	return false;
}

bool_t Space_1_Equals(struct ExistenceSpace *const self, struct ExistenceSpace *other)
{
	struct Type *type = NULL;
	struct Type *type_1 = NULL;
	bool_t boolean = false;
	bool_t boolean_1 = false;
	bool_t boolean_2 = false;
	bool_t boolean_3 = false;
	bool_t boolean_4 = false;
	bool_t boolean_5 = false;
	bool_t boolean_6 = false;
	bool_t boolean_7 = false;
	bool_t boolean_8 = false;
	bool_t boolean_9 = false;
	bool_t result = false;
	struct MatrixData_3 *matrixData = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;
	bool_t boolean_10 = false;

	boolean_1 = Object_2_ReferenceEquals(&other->base.base.base, NULL);
	boolean_2 = !boolean_1;
	boolean_3 = boolean_2;
	if (boolean_3 == true)
	{
		type = Object_GetType(other);
		type_1 = Object_GetType(self);
		boolean = Type_1_op_Inequality(type, type_1);
		boolean_4 = !boolean;
	}
	else
	{
		boolean_4 = false;
	}
	if (!boolean_4)
	{
		if (boolean_3 == true)
		{
			(void)Assign_Type(&type, NULL);
			(void)Assign_Type(&type_1, NULL);
		}
		return false;
	}
	else
	{
		if (boolean_3 == true)
		{
			(void)Assign_Type(&type, NULL);
			(void)Assign_Type(&type_1, NULL);
		}
	}
	boolean_5 = Object_2_ReferenceEquals(&other->base.base.base, &self->base.base.base);
	if (!!boolean_5)
	{
		return true;
	}
	boolean_7 = Object_2_ReferenceEquals(&(&self->base.base)->_vector->base, NULL);
	boolean_8 = !boolean_7;
	if (boolean_8 == false)
	{
		boolean_6 = Object_2_ReferenceEquals(&(&other->base.base)->_vector->base, NULL);
		boolean_9 = !boolean_6;
	}
	else
	{
		boolean_9 = true;
	}
	if (!boolean_9)
	{
		return (&self->base.base)->Dimensions == (&other->base.base)->Dimensions;
	}
	matrixData = Space_1_get_MatrixData(&self->base.base);
	matrixData_1 = Space_1_get_MatrixData(&other->base.base);
	boolean_10 = MatrixData_3_Equals(matrixData, matrixData_1);
	result = boolean_10;
	(void)Assign_MatrixData_3(&matrixData, NULL);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
	return result;
}

bool_t Space_6_op_Equality(struct ExistenceSpace *left, struct ExistenceSpace *right)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;

	boolean = Object_2_ReferenceEquals(&left->base.base.base, NULL);
	if (!!boolean)
	{
		bool_t boolean_2 = false;

		boolean_2 = Object_2_ReferenceEquals(&right->base.base.base, NULL);
		return boolean_2;
	}
	boolean_1 = Space_1_Equals(left, right);
	return boolean_1;
}

float64_t PersiModel_get_ExistProcesNoise(struct PersistenceModel *const self)
{
	return self->_existenceProcessNoise;
}

static struct TimeSpan PersisteModel_get_TimeCondition(struct PersistenceModel *const self)
{
	return self->TimeCondition;
}

float64_t PersistenceModel_Evaluate(struct PersistenceModel *const self, struct ExistenceSpace *sample)
{
	struct ExistenceSpace *existenceSpace = NULL;
	struct ExistenceSpace *existenceSpace_1 = NULL;
	bool_t boolean = false;
	float64_t double_ = 0.0;
	struct TimeSpan timeSpan = { 0 };
	float64_t double__1 = 0.0;

	(void)Assign_ExistenceSpace(&existenceSpace, sample);
	existenceSpace_1 = PersistenceModel_get_Condition(self);
	boolean = Space_6_op_Equality(existenceSpace, existenceSpace_1);
	if (!!boolean)
	{
		float64_t double__2 = 0.0;
		struct TimeSpan timeSpan_1 = { 0 };
		float64_t double__3 = 0.0;

		(void)Assign_ExistenceSpace(&existenceSpace, NULL);
		(void)Assign_ExistenceSpace(&existenceSpace_1, NULL);
		double__2 = PersiModel_get_ExistProcesNoise(self);
		timeSpan_1 = PersisteModel_get_TimeCondition(self);
		double__3 = TimeSpan_get_TotalSeconds(&timeSpan_1);
		return 1.0 + (double__2 * double__3);
	}
	else
	{
		(void)Assign_ExistenceSpace(&existenceSpace, NULL);
		(void)Assign_ExistenceSpace(&existenceSpace_1, NULL);
	}
	double_ = PersiModel_get_ExistProcesNoise(self);
	timeSpan = PersisteModel_get_TimeCondition(self);
	double__1 = TimeSpan_get_TotalSeconds(&timeSpan);
	return double_ * double__1;
}

void BayesFilter_Predict(struct TwoPointDistribution **state, struct PersistenceModel *systemModel)
{
	struct ExistenceSpace *existenceSpace = NULL;
	float64_t num = 0.0;
	struct ExistenceSpace *existenceSpace_1 = NULL;
	float64_t double_ = 0.0;
	float64_t num2 = 0.0;
	struct ExistenceSpace *existenceSpace_2 = NULL;
	float64_t double__1 = 0.0;
	float64_t num3 = 0.0;
	struct ExistenceSpace *existenceSpace_3 = NULL;
	float64_t num4 = 0.0;
	struct ExistenceSpace *existenceSpace_4 = NULL;
	float64_t double__2 = 0.0;
	float64_t num5 = 0.0;
	struct ExistenceSpace *existenceSpace_5 = NULL;
	float64_t double__3 = 0.0;
	float64_t num6 = 0.0;
	float64_t num7 = 0.0;
	float64_t arg_10F_0 = 0.0;
	float64_t num8 = 0.0;
	float64_t arg_140_0 = 0.0;
	float64_t num9 = 0.0;
	float64_t num10 = 0.0;
	float64_t arg_182_0 = 0.0;
	float64_t arg_1B3_0 = 0.0;
	float64_t double__4 = 0.0;

	existenceSpace = TwoPointDistri_get_SuccesSample(*state);
	PersistenceModel_set_Condition(systemModel, existenceSpace);
	(void)Assign_ExistenceSpace(&existenceSpace, NULL);
	existenceSpace_1 = TwoPointDistri_get_SuccesSample(*state);
	double_ = PersistenceModel_Evaluate(systemModel, existenceSpace_1);
	num = double_;
	(void)Assign_ExistenceSpace(&existenceSpace_1, NULL);
	existenceSpace_2 = TwoPointDistri_get_FailurSample(*state);
	double__1 = PersistenceModel_Evaluate(systemModel, existenceSpace_2);
	num2 = double__1;
	(void)Assign_ExistenceSpace(&existenceSpace_2, NULL);
	if (!((num + num2) == 1.0))
	{
		num3 = num + num2;
		num = num / num3;
		num2 = num2 / num3;
	}
	existenceSpace_3 = TwoPointDistri_get_FailurSample(*state);
	PersistenceModel_set_Condition(systemModel, existenceSpace_3);
	(void)Assign_ExistenceSpace(&existenceSpace_3, NULL);
	existenceSpace_4 = TwoPointDistri_get_SuccesSample(*state);
	double__2 = PersistenceModel_Evaluate(systemModel, existenceSpace_4);
	num4 = double__2;
	(void)Assign_ExistenceSpace(&existenceSpace_4, NULL);
	existenceSpace_5 = TwoPointDistri_get_FailurSample(*state);
	double__3 = PersistenceModel_Evaluate(systemModel, existenceSpace_5);
	num5 = double__3;
	(void)Assign_ExistenceSpace(&existenceSpace_5, NULL);
	if (!((num4 + num5) == 1.0))
	{
		num6 = num4 + num5;
		num4 = num4 / num6;
		num5 = num5 / num6;
	}
	double__4 = TwoPointDistributio_get_LogOdds(*state);
	if (!(double__4 < 0.0))
	{
		float64_t double__5 = 0.0;
		float64_t double__6 = 0.0;

		double__5 = TwoPointDistributio_get_LogOdds(*state);
		double__6 = Math_Exp(-double__5);
		num7 = double__6;
		if (!(num == 0.0))
		{
			float64_t double__7 = 0.0;

			double__7 = Math_Log(num + (num4 * num7));
			arg_10F_0 = double__7;
		}
		else
		{
			float64_t double__8 = 0.0;
			float64_t double__9 = 0.0;

			double__8 = Math_Log(num4);
			double__9 = TwoPointDistributio_get_LogOdds(*state);
			arg_10F_0 = double__8 - double__9;
		}
		num8 = arg_10F_0;
		if (!(num2 == 0.0))
		{
			float64_t double__10 = 0.0;

			double__10 = Math_Log(num2 + (num5 * num7));
			arg_140_0 = double__10;
		}
		else
		{
			float64_t double__11 = 0.0;
			float64_t double__12 = 0.0;

			double__11 = Math_Log(num5);
			double__12 = TwoPointDistributio_get_LogOdds(*state);
			arg_140_0 = double__11 - double__12;
		}
		num9 = arg_140_0;
	}
	else
	{
		float64_t double__13 = 0.0;
		float64_t double__14 = 0.0;

		double__13 = TwoPointDistributio_get_LogOdds(*state);
		double__14 = Math_Exp(double__13);
		num10 = double__14;
		if (!(num4 == 0.0))
		{
			float64_t double__15 = 0.0;

			double__15 = Math_Log(num4 + (num * num10));
			arg_182_0 = double__15;
		}
		else
		{
			float64_t double__16 = 0.0;
			float64_t double__17 = 0.0;

			double__16 = Math_Log(num);
			double__17 = TwoPointDistributio_get_LogOdds(*state);
			arg_182_0 = double__16 + double__17;
		}
		num8 = arg_182_0;
		if (!(num5 == 0.0))
		{
			float64_t double__18 = 0.0;

			double__18 = Math_Log(num5 + (num2 * num10));
			arg_1B3_0 = double__18;
		}
		else
		{
			float64_t double__19 = 0.0;
			float64_t double__20 = 0.0;

			double__19 = Math_Log(num2);
			double__20 = TwoPointDistributio_get_LogOdds(*state);
			arg_1B3_0 = double__19 + double__20;
		}
		num9 = arg_1B3_0;
	}
	TwoPointDistributio_set_LogOdds(*state, num8 - num9);
}

struct TwoPointDistribution *BayesFilter_Predict_1(struct TwoPointDistribution *state, struct PersistenceModel *systemModel)
{
	struct TwoPointDistribution *result = NULL;
	struct TwoPointDistribution *twoPointDistribution = NULL;
	struct TwoPointDistribution *result_1 = NULL;

	twoPointDistribution = TwoPointDistribution_Clone(state);
	(void)Assign_TwoPointDistribution(&result, twoPointDistribution);
	(void)Assign_TwoPointDistribution(&twoPointDistribution, NULL);
	BayesFilter_Predict(&result, systemModel);
	(void)Assign_TwoPointDistribution(&result_1, result);
	RemRef_TwoPointDistribution(result);
	return result_1;
}

int32_t StaticList_26_get_Count(struct StaticList_26 *const self)
{
	return self->Count;
}

static void StaticList_26_CheckCount(struct StaticList_26 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_26_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_26_set_Count(struct StaticList_26 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_26_Add(struct StaticList_26 *const self, struct Existence *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_26_CheckCount(self);
	int32 = StaticList_26_get_Count(self);
	count = int32;
	(void)Assign_Existence(&self->_items->Elements[count], value);
	int32_1 = StaticList_26_get_Count(self);
	StaticList_26_set_Count(self, int32_1 + ((int32_t)1));
}

static void MobilEyeMeasuremenModel_1_cctor(void)
{
	struct CASpace *caSpace = NULL;

	caSpace = Space_6_GetIndices();
	(void)Assign_CASpace(&MobilEyeMeasuModel_1_StateIndic, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
}

static void RemRef_MobilEyeMeasurementModel(struct MobilEyeMeasurementModel *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base.base)->ReferenceCount--;
	if ((&self->base.base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_MobilEyeMeasurementModel.CurrentCount--;
		Res_MobilEyeMeasurementModel.Next[Res_MobilEyeMeasurementModel.CurrentCount] = self;
		Del_MobilEyeMeasurementModel(self);
	}
}

struct MobilEyeMeasurementModel *New_MobilEyeMeasurementModel(void)
{
	static struct MobilEyeMeasurementModel const Default_MobilEyeMeasuremenModel = { 1 };
	struct MobilEyeMeasurementModel *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MobilEyeMeasurementModel.CurrentCount == RC_MobilEyeMeasurementModel)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MobilEyeMeasurementModel.Next[Res_MobilEyeMeasurementModel.CurrentCount];
	Res_MobilEyeMeasurementModel.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MobilEyeMeasurementModel.MaximumCount = (Res_MobilEyeMeasurementModel.CurrentCount > Res_MobilEyeMeasurementModel.MaximumCount) ? Res_MobilEyeMeasurementModel.CurrentCount : Res_MobilEyeMeasurementModel.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MobilEyeMeasuremenModel;
	return instance;
}

struct MobilEyeMeasurementModel *Assign_MobilEyeMeasurementModel(struct MobilEyeMeasurementModel **const left, struct MobilEyeMeasurementModel *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base.base)->ReferenceCount++;
	}
	RemRef_MobilEyeMeasurementModel(*left);
	*left = right;
	return right;
}

struct float64_t_1D_4 *MobiEyePara_get_NoiseMatriDiago(struct MobilEyeParameters *const self)
{
	struct float64_t_1D_4 *result = NULL;

	(void)Assign_float64_t_1D_4(&result, self->_noiseMatrixDiagonal);
	return result;
}

static void RemRef_PositiveDefiniteMatrix_3(struct PositiveDefiniteMatrix_3 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base)->ReferenceCount--;
	if ((&self->base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_PositiveDefiniteMatrix_3.CurrentCount--;
		Res_PositiveDefiniteMatrix_3.Next[Res_PositiveDefiniteMatrix_3.CurrentCount] = self;
		Del_PositiveDefiniteMatrix_3(self);
	}
}

struct PositiveDefiniteMatrix_3 *New_PositiveDefiniteMatrix_3(void)
{
	static struct PositiveDefiniteMatrix_3 const Default_PositivDefiniteMatrix_3 = { 1 };
	struct PositiveDefiniteMatrix_3 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_PositiveDefiniteMatrix_3.CurrentCount == RC_PositiveDefiniteMatrix_3)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_PositiveDefiniteMatrix_3.Next[Res_PositiveDefiniteMatrix_3.CurrentCount];
	Res_PositiveDefiniteMatrix_3.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_PositiveDefiniteMatrix_3.MaximumCount = (Res_PositiveDefiniteMatrix_3.CurrentCount > Res_PositiveDefiniteMatrix_3.MaximumCount) ? Res_PositiveDefiniteMatrix_3.CurrentCount : Res_PositiveDefiniteMatrix_3.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_PositivDefiniteMatrix_3;
	return instance;
}

struct PositiveDefiniteMatrix_3 *Assign_PositiveDefiniteMatrix_3(struct PositiveDefiniteMatrix_3 **const left, struct PositiveDefiniteMatrix_3 *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base)->ReferenceCount++;
	}
	RemRef_PositiveDefiniteMatrix_3(*left);
	*left = right;
	return right;
}

void Matrix_3_ctor(struct Matrix_3 *const self)
{
	struct MobilEyeSpace *mobilEyeSpace = NULL;
	struct MobilEyeSpace *mobilEyeSpace_1 = NULL;

	mobilEyeSpace = New_MobilEyeSpace();
	MobilEyeSpace_ctor(mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&self->EmptyRowSpace, mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
	mobilEyeSpace_1 = New_MobilEyeSpace();
	MobilEyeSpace_ctor(mobilEyeSpace_1);
	(void)Assign_MobilEyeSpace(&self->EmptyColumnSpace, mobilEyeSpace_1);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace_1, NULL);
	Object_ctor(&self->base);
	self->Columns = (&self->EmptyRowSpace->base)->Dimensions;
	self->Rows = (&self->EmptyColumnSpace->base)->Dimensions;
}

void SquareMatrix_3_ctor(struct SquareMatrix_3 *const self)
{
	struct MobilEyeSpace *mobilEyeSpace = NULL;

	mobilEyeSpace = New_MobilEyeSpace();
	MobilEyeSpace_ctor(mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&self->EmptySpace, mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
	Matrix_3_ctor(&self->base);
	self->Dimensions = (&self->base)->Rows;
}

static void RemRef_MatrixData_15(struct MatrixData_15 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_15.CurrentCount--;
		Res_MatrixData_15.Next[Res_MatrixData_15.CurrentCount] = self;
		Del_MatrixData_15(self);
	}
}

struct MatrixData_15 *New_MatrixData_15(void)
{
	static struct MatrixData_15 const Default_MatrixData_15 = { 1 };
	struct MatrixData_15 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_15.CurrentCount == RC_MatrixData_15)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_15.Next[Res_MatrixData_15.CurrentCount];
	Res_MatrixData_15.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_15.MaximumCount = (Res_MatrixData_15.CurrentCount > Res_MatrixData_15.MaximumCount) ? Res_MatrixData_15.CurrentCount : Res_MatrixData_15.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_15;
	return instance;
}

struct MatrixData_15 *Assign_MatrixData_15(struct MatrixData_15 **const left, struct MatrixData_15 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_15(*left);
	*left = right;
	return right;
}

static void Del_float64_t_1D_16(struct float64_t_1D_16 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_1D_16(struct float64_t_1D_16 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_1D_16.CurrentCount--;
		Res_float64_t_1D_16.Next[Res_float64_t_1D_16.CurrentCount] = self;
		Del_float64_t_1D_16(self);
	}
}

struct float64_t_1D_16 *New_float64_t_1D_16(void)
{
	static struct float64_t_1D_16 const Default_float64_t_1D_16 = { 1 };
	struct float64_t_1D_16 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_1D_16.CurrentCount == RC_float64_t_1D_16)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_1D_16.Next[Res_float64_t_1D_16.CurrentCount];
	Res_float64_t_1D_16.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_1D_16.MaximumCount = (Res_float64_t_1D_16.CurrentCount > Res_float64_t_1D_16.MaximumCount) ? Res_float64_t_1D_16.CurrentCount : Res_float64_t_1D_16.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_1D_16;
	return instance;
}

struct float64_t_1D_16 *Assign_float64_t_1D_16(struct float64_t_1D_16 **const left, struct float64_t_1D_16 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_1D_16(*left);
	*left = right;
	return right;
}

void MatrixData_15_ctor(struct MatrixData_15 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_16 *array = NULL;

	assert(rows == ((int32_t)4));
	assert(columns == ((int32_t)4));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_16();
	(void)Assign_float64_t_1D_16(&self->_data, array);
	(void)Assign_float64_t_1D_16(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct float64_t_1D_16 *MatrixData_15_get_DataReference(struct MatrixData_15 *const self)
{
	struct float64_t_1D_16 *result = NULL;

	(void)Assign_float64_t_1D_16(&result, self->_data);
	return result;
}

static void MatrixData_15_SetValueFast(struct MatrixData_15 *const self, float64_t value, int32_t row, int32_t column)
{
	struct float64_t_1D_16 *array = NULL;

	array = MatrixData_15_get_DataReference(self);
	array->Elements[(column * self->Rows) + row] = value;
	(void)Assign_float64_t_1D_16(&array, NULL);
}

struct MatrixData_15 *MatrixData_20_Diag_4(struct float64_t_1D_4 *diagonalElements)
{
	struct MatrixData_15 *matrixData = NULL;
	struct MatrixData_15 *matrixData_1 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_15 *result = NULL;

	if (!(diagonalElements != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData_15();
	MatrixData_15_ctor(matrixData_1, ((int32_t)4), ((int32_t)4));
	(void)Assign_MatrixData_15(&matrixData, matrixData_1);
	(void)Assign_MatrixData_15(&matrixData_1, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)4))
	{
		MatrixData_15_SetValueFast(matrixData, diagonalElements->Elements[i], i, i);
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_15(&result, matrixData);
	RemRef_MatrixData_15(matrixData);
	return result;
}

static void Matrix_3_set_UncheckeMatrixData(struct Matrix_3 *const self, struct MatrixData_15 *value)
{
	(void)Assign_MatrixData_15(&self->_matrix, value);
}

static void Matrix_3_CheckMatrix(struct Matrix_3 *const self)
{
	struct float64_t_1D_16 *dataReference = NULL;
	struct float64_t_1D_16 *array = NULL;
	int32_t i = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);

	array = MatrixData_15_get_DataReference(self->_matrix);
	(void)Assign_float64_t_1D_16(&dataReference, array);
	(void)Assign_float64_t_1D_16(&array, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)16))
	{
		bool_t boolean = false;

		boolean = Double_IsNaN(dataReference->Elements[i]);
		if (!!boolean)
		{
			num = i / self->Rows;
			num2 = i - (num * self->Rows);
			abort();
		}
		i = i + ((int32_t)1);
	}
	RemRef_float64_t_1D_16(dataReference);
}

struct MatrixData_15 *MatrixData_20_Zeros_13(int32_t rows, int32_t columns)
{
	struct MatrixData_15 *result = NULL;
	struct MatrixData_15 *matrixData = NULL;

	assert(rows == ((int32_t)4));
	assert(columns == ((int32_t)4));
	matrixData = New_MatrixData_15();
	MatrixData_15_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData_15(&result, matrixData);
	(void)Assign_MatrixData_15(&matrixData, NULL);
	return result;
}

struct MatrixData_15 *Matrix_3_get_MatrixData(struct Matrix_3 *const self)
{
	struct MatrixData_15 *result = NULL;

	if (!(self->_matrix != NULL))
	{
		struct MatrixData_15 *matrixData = NULL;

		matrixData = MatrixData_20_Zeros_13(self->Rows, self->Columns);
		(void)Assign_MatrixData_15(&self->_matrix, matrixData);
		(void)Assign_MatrixData_15(&matrixData, NULL);
	}
	(void)Assign_MatrixData_15(&result, self->_matrix);
	return result;
}

static void SquareMatrix_3_CheckMatrix(struct SquareMatrix_3 *const self)
{
	struct MatrixData_15 *matrixData = NULL;
	int32_t int32 = ((int32_t)0);
	struct MatrixData_15 *matrixData_1 = NULL;

	Matrix_3_CheckMatrix(&self->base);
	matrixData = Matrix_3_get_MatrixData(&self->base);
	int32 = matrixData->Rows;
	matrixData_1 = Matrix_3_get_MatrixData(&self->base);
	(void)Assign_MatrixData_15(&matrixData, NULL);
	(void)Assign_MatrixData_15(&matrixData_1, NULL);
}

bool_t MatrixData_15_get_IsZero(struct MatrixData_15 *const self)
{
	struct float64_t_1D_16 *data = NULL;
	int32_t i = ((int32_t)0);
	float64_t num = 0.0;

	(void)Assign_float64_t_1D_16(&data, self->_data);
	i = ((int32_t)0);
	while (i < ((int32_t)16))
	{
		num = data->Elements[i];
		if (!(num == 0.0))
		{
			RemRef_float64_t_1D_16(data);
			return false;
		}
		i = i + ((int32_t)1);
	}
	RemRef_float64_t_1D_16(data);
	return true;
}

bool_t Matrix_3_get_IsZero(struct Matrix_3 *const self)
{
	bool_t result = false;
	struct MatrixData_15 *matrixData = NULL;
	bool_t boolean = false;

	matrixData = Matrix_3_get_MatrixData(self);
	boolean = MatrixData_15_get_IsZero(matrixData);
	result = boolean;
	(void)Assign_MatrixData_15(&matrixData, NULL);
	return result;
}

static float64_t MatrixData_15_GetValueFast(struct MatrixData_15 *const self, int32_t row, int32_t column)
{
	float64_t result = 0.0;
	struct float64_t_1D_16 *array = NULL;

	array = MatrixData_15_get_DataReference(self);
	result = array->Elements[(column * self->Rows) + row];
	(void)Assign_float64_t_1D_16(&array, NULL);
	return result;
}

float64_t MatrixData_15_get_Item(struct MatrixData_15 *const self, int32_t row, int32_t column)
{
	float64_t double_ = 0.0;

	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	double_ = MatrixData_15_GetValueFast(self, row, column);
	return double_;
}

static float64_t Matrix_3_UncheckedGet(struct Matrix_3 *const self, int32_t row, int32_t column)
{
	float64_t result = 0.0;
	struct MatrixData_15 *matrixData = NULL;
	float64_t double_ = 0.0;

	matrixData = Matrix_3_get_MatrixData(self);
	double_ = MatrixData_15_get_Item(matrixData, row, column);
	result = double_;
	(void)Assign_MatrixData_15(&matrixData, NULL);
	return result;
}

static struct MatrixData_15 *Matrix_3_get_UncheckeMatrixData(struct Matrix_3 *const self)
{
	struct MatrixData_15 *result = NULL;

	(void)Assign_MatrixData_15(&result, self->_matrix);
	return result;
}

bool_t MatrixData_15_get_IsEmpty(struct MatrixData_15 *const self)
{
	return ((int32_t)16) == ((int32_t)0);
}

void LinearAlgebra_FactorCholesky_4(struct LinearAlgebra *const self, struct float64_t_1D_16 *a, int32_t rows)
{
	int32_t num = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	float64_t num2 = 0.0;
	int32_t k = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rows > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)16) % rows) != ((int32_t)0)))
	{
		abort();
	}
	num = ((int32_t)16) / rows;
	if (!(num == rows))
	{
		abort();
	}
	i = ((int32_t)0);
	while (i < num)
	{
		j = ((int32_t)0);
		while (j <= i)
		{
			num2 = a->Elements[(i * rows) + j];
			k = ((int32_t)0);
			while (k < j)
			{
				num2 = num2 - (a->Elements[(i * rows) + k] * a->Elements[(j * rows) + k]);
				k = k + ((int32_t)1);
			}
			if (!(j >= i))
			{
				a->Elements[(i * rows) + j] = num2 / a->Elements[(j * rows) + j];
			}
			else
			{
				struct float64_t_1D_16 *array = NULL;
				int32_t int32 = ((int32_t)0);
				float64_t double_ = 0.0;

				if (!!(num2 <= 0.0))
				{
					abort();
				}
				(void)Assign_float64_t_1D_16(&array, a);
				int32 = (i * rows) + i;
				double_ = Math_Sqrt(num2);
				array->Elements[int32] = double_;
				(void)Assign_float64_t_1D_16(&array, NULL);
			}
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
}

struct MatrixData_15 *MatrixMath_Chol_4(struct MatrixData_15 *matrix)
{
	bool_t boolean = false;
	struct MatrixData_15 *matrixData = NULL;
	struct MatrixData_15 *matrixData_1 = NULL;
	struct float64_t_1D_16 *dataReference = NULL;
	struct float64_t_1D_16 *array = NULL;
	struct float64_t_1D_16 *dataReference2 = NULL;
	struct float64_t_1D_16 *array_1 = NULL;
	int32_t i = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t j = ((int32_t)0);
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_16 *array_2 = NULL;
	struct MatrixData_15 *result = NULL;

	if (!(matrix != NULL))
	{
		abort();
	}
	boolean = MatrixData_15_get_IsEmpty(matrix);
	matrixData_1 = New_MatrixData_15();
	MatrixData_15_ctor(matrixData_1, matrix->Rows, matrix->Columns);
	(void)Assign_MatrixData_15(&matrixData, matrixData_1);
	(void)Assign_MatrixData_15(&matrixData_1, NULL);
	array = MatrixData_15_get_DataReference(matrix);
	(void)Assign_float64_t_1D_16(&dataReference, array);
	(void)Assign_float64_t_1D_16(&array, NULL);
	array_1 = MatrixData_15_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_16(&dataReference2, array_1);
	(void)Assign_float64_t_1D_16(&array_1, NULL);
	i = ((int32_t)0);
	while (i < matrixData->Columns)
	{
		num = i * matrix->Rows;
		j = i;
		while (j >= ((int32_t)3))
		{
			dataReference2->Elements[num] = dataReference->Elements[num];
			dataReference2->Elements[num + ((int32_t)1)] = dataReference->Elements[num + ((int32_t)1)];
			dataReference2->Elements[num + ((int32_t)2)] = dataReference->Elements[num + ((int32_t)2)];
			dataReference2->Elements[num + ((int32_t)3)] = dataReference->Elements[num + ((int32_t)3)];
			j = j - ((int32_t)4);
			num = num + ((int32_t)4);
		}
		while (j >= ((int32_t)1))
		{
			dataReference2->Elements[num] = dataReference->Elements[num];
			dataReference2->Elements[num + ((int32_t)1)] = dataReference->Elements[num + ((int32_t)1)];
			j = j - ((int32_t)2);
			num = num + ((int32_t)2);
		}
		while (j >= ((int32_t)0))
		{
			dataReference2->Elements[num] = dataReference->Elements[num];
			j = j - ((int32_t)1);
			num = num + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array_2 = MatrixData_15_get_DataReference(matrixData);
	LinearAlgebra_FactorCholesky_4(linearAlgebra, array_2, matrixData->Rows);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_16(&array_2, NULL);
	(void)Assign_MatrixData_15(&result, matrixData);
	RemRef_MatrixData_15(matrixData);
	RemRef_float64_t_1D_16(dataReference);
	RemRef_float64_t_1D_16(dataReference2);
	return result;
}

static void PositDefiniMatrix_3_CheckMatrix(struct PositiveDefiniteMatrix_3 *const self)
{
	bool_t boolean = false;
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	struct MatrixData_15 *matrixData = NULL;
	struct MatrixData_15 *matrixData_1 = NULL;

	SquareMatrix_3_CheckMatrix(&self->base);
	boolean = Matrix_3_get_IsZero(&self->base.base);
	if (!!boolean)
	{
		return;
	}
	i = ((int32_t)0);
	while (i < (&self->base.base)->Rows)
	{
		j = ((int32_t)0);
		while (j < i)
		{
			float64_t double_ = 0.0;
			float64_t double__1 = 0.0;
			int32_t int32 = ((int32_t)0);

			double_ = Matrix_3_UncheckedGet(&self->base.base, i, j);
			double__1 = Matrix_3_UncheckedGet(&self->base.base, j, i);
			int32 = FloatCompare_Compare(double_, double__1);
			if (!!(int32 != ((int32_t)0)))
			{
				abort();
			}
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	matrixData = Matrix_3_get_UncheckeMatrixData(&self->base.base);
	matrixData_1 = MatrixMath_Chol_4(matrixData);
	(void)Assign_MatrixData_15(&matrixData, NULL);
	(void)Assign_MatrixData_15(&matrixData_1, NULL);
}

void SquareMatrix_3_ctor_1(struct PositiveDefiniteMatrix_3 *const self, struct float64_t_1D_4 *mainDiagonal)
{
	struct MatrixData_15 *matrixData = NULL;

	SquareMatrix_3_ctor(&self->base);
	matrixData = MatrixData_20_Diag_4(mainDiagonal);
	Matrix_3_set_UncheckeMatrixData(&self->base.base, matrixData);
	(void)Assign_MatrixData_15(&matrixData, NULL);
	PositDefiniMatrix_3_CheckMatrix(self);
}

void PositiveDefiniteMatrix_3_ctor(struct PositiveDefiniteMatrix_3 *const self, struct float64_t_1D_4 *mainDiagonal)
{
	SquareMatrix_3_ctor_1(self, mainDiagonal);
}

void MeasuremenModel_2_set_Condition(struct MeasurementModel_2 *const self, struct CASpace *value)
{
	(void)Assign_CASpace(&self->Condition, value);
}

static void MeasurementModel_2_ctor(struct MeasurementModel_2 *const self, struct PositiveDefiniteMatrix_3 *measurementNoiseCovariance)
{
	struct CASpace *caSpace = NULL;

	if (!(measurementNoiseCovariance != NULL))
	{
		abort();
	}
	Object_ctor(&self->base);
	caSpace = New_CASpace();
	CASpace_ctor(caSpace);
	MeasuremenModel_2_set_Condition(self, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	(void)Assign_PositiveDefiniteMatrix_3(&self->_measurementNoiseCovariance, measurementNoiseCovariance);
}

static void MeasurementModel_6_ctor(struct MeasurementModel_6 *const self, struct PositiveDefiniteMatrix_3 *measurementNoiseCovariance)
{
	MeasurementModel_2_ctor(&self->base, measurementNoiseCovariance);
}

static void CarteMeasuModel_set_SensoParame(struct CartesianMeasurementModel *const self, struct MobilEyeParameters *value)
{
	(void)Assign_MobilEyeParameters(&self->SensorParameters, value);
}

struct MobilEyeParameters *CarteMeasuModel_get_SensoParame(struct CartesianMeasurementModel *const self)
{
	struct MobilEyeParameters *result = NULL;

	(void)Assign_MobilEyeParameters(&result, self->SensorParameters);
	return result;
}

float64_t MobilEyeParameter_get_RotationZ(struct MobilEyeParameters *const self)
{
	return self->RotationZ;
}

static void CartesianMeasurementModel_ctor(struct CartesianMeasurementModel *const self, struct MobilEyeParameters *sensorParameters)
{
	struct float64_t_1D_4 *array = NULL;
	struct PositiveDefiniteMatrix_3 *positiveDefiniteMatrix = NULL;
	struct MobilEyeParameters *CS_0_0000 = NULL;
	struct MobilEyeParameters *mobilEyeParameters = NULL;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	struct MobilEyeParameters *CS_0_0001 = NULL;
	struct MobilEyeParameters *mobilEyeParameters_1 = NULL;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;

	array = MobiEyePara_get_NoiseMatriDiago(sensorParameters);
	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_3();
	PositiveDefiniteMatrix_3_ctor(positiveDefiniteMatrix, array);
	MeasurementModel_6_ctor(&self->base, positiveDefiniteMatrix);
	(void)Assign_float64_t_1D_4(&array, NULL);
	(void)Assign_PositiveDefiniteMatrix_3(&positiveDefiniteMatrix, NULL);
	CarteMeasuModel_set_SensoParame(self, sensorParameters);
	mobilEyeParameters = CarteMeasuModel_get_SensoParame(self);
	(void)Assign_MobilEyeParameters(&CS_0_0000, mobilEyeParameters);
	(void)Assign_MobilEyeParameters(&mobilEyeParameters, NULL);
	double_ = MobilEyeParameter_get_RotationZ(CS_0_0000);
	double__1 = Math_Cos(-double_);
	self->CosRotZ = double__1;
	mobilEyeParameters_1 = CarteMeasuModel_get_SensoParame(self);
	(void)Assign_MobilEyeParameters(&CS_0_0001, mobilEyeParameters_1);
	(void)Assign_MobilEyeParameters(&mobilEyeParameters_1, NULL);
	double__2 = MobilEyeParameter_get_RotationZ(CS_0_0001);
	double__3 = Math_Sin(-double__2);
	self->SinRotZ = double__3;
	RemRef_MobilEyeParameters(CS_0_0000);
	RemRef_MobilEyeParameters(CS_0_0001);
}

void CartesMeasureModel_set_Conditi2(struct CartesianMeasurementModel *const self, float64_t value)
{
	self->Condition2 = value;
}

void CartesMeasurModel_set_EgoVeloci(struct CartesianMeasurementModel *const self, float64_t value)
{
	CartesMeasureModel_set_Conditi2(self, value);
}

static void MobiEyeMeasModel_set_EgoYawRate(struct MobilEyeMeasurementModel *const self, float64_t value)
{
	self->EgoYawRate = value;
}

float64_t MobilEyeParameters_get_SigmaX(struct MobilEyeParameters *const self)
{
	return self->_sigmaX;
}

float64_t Math_Max_1(float64_t val1, float64_t val2)
{
	bool_t boolean = false;

	if (!(val1 <= val2))
	{
		return val1;
	}
	boolean = Double_IsNaN(val1);
	if (!!boolean)
	{
		return val1;
	}
	return val2;
}

struct PositiveDefiniteMatrix_3 *MeasureModel_2_get_NoiseCovaria(struct MeasurementModel_2 *const self)
{
	struct PositiveDefiniteMatrix_3 *result = NULL;

	(void)Assign_PositiveDefiniteMatrix_3(&result, self->_measurementNoiseCovariance);
	return result;
}

void MatrixData_15_set_Item(struct MatrixData_15 *const self, int32_t row, int32_t column, float64_t value)
{
	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	MatrixData_15_SetValueFast(self, value, row, column);
}

static void Matrix_3_MatrixChanged(struct Matrix_3 *const self)
{
	(void)Assign_MatrixData(&self->CachedTranspose, NULL);
}

static void SquareMatrix_3_MatrixChanged(struct SquareMatrix_3 *const self)
{
	struct Nullable_2 nullable = { 0 };

	Matrix_3_MatrixChanged(&self->base);
	self->CachedDeterminant = nullable;
}

static void PositDefinMatrix_3_MatrixChange(struct PositiveDefiniteMatrix_3 *const self)
{
	SquareMatrix_3_MatrixChanged(&self->base);
	(void)Assign_MatrixData_15(&self->CachedCholeskyDecomposition, NULL);
	(void)Assign_MatrixData_15(&self->CachedInverse, NULL);
}

void PositivDefinitMatrix_3_set_Item(struct PositiveDefiniteMatrix_3 *const self, int32_t row, int32_t column, float64_t value)
{
	struct MatrixData_15 *matrixData = NULL;
	struct MatrixData_15 *matrixData_1 = NULL;

	if (!((row >= ((int32_t)0)) && (row < (&self->base.base)->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < (&self->base.base)->Columns)))
	{
		abort();
	}
	matrixData = Matrix_3_get_MatrixData(&self->base.base);
	MatrixData_15_set_Item(matrixData, row, column, value);
	(void)Assign_MatrixData_15(&matrixData, NULL);
	matrixData_1 = Matrix_3_get_MatrixData(&self->base.base);
	MatrixData_15_set_Item(matrixData_1, column, row, value);
	(void)Assign_MatrixData_15(&matrixData_1, NULL);
	PositDefinMatrix_3_MatrixChange(self);
}

void MobilEyeMeasurementModel_ctor(struct MobilEyeMeasurementModel *const self, struct MobilEyeParameters *sensorParameters, struct CTRASpace *egoMotionExpectation, struct CASpace *predictedState)
{
	struct MobilEyeSpace *mobilEyeSpace = NULL;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t sigmaX = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	float64_t double__5 = 0.0;
	struct PositiveDefiniteMatrix_3 *positiveDefiniteMatrix = NULL;

	mobilEyeSpace = Space_6_GetIndices_2();
	(void)Assign_MobilEyeSpace(&self->_measurementIndices, mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
	CartesianMeasurementModel_ctor(&self->base, sensorParameters);
	double_ = CTRASpace_get_V(egoMotionExpectation);
	CartesMeasurModel_set_EgoVeloci(&self->base, double_);
	double__1 = CTRASpace_get_W(egoMotionExpectation);
	MobiEyeMeasModel_set_EgoYawRate(self, double__1);
	double__2 = CVSpace_get_X(&predictedState->base);
	double__3 = double__2 * 0.1;
	double__4 = MobilEyeParameters_get_SigmaX(sensorParameters);
	double__5 = Math_Max_1(double__3, double__4);
	sigmaX = double__5;
	positiveDefiniteMatrix = MeasureModel_2_get_NoiseCovaria(&self->base.base.base);
	PositivDefinitMatrix_3_set_Item(positiveDefiniteMatrix, ((int32_t)0), ((int32_t)0), sigmaX * sigmaX);
	(void)Assign_PositiveDefiniteMatrix_3(&positiveDefiniteMatrix, NULL);
}

void Matrix_11_ctor(struct Matrix_11 *const self)
{
	struct CASpace *caSpace = NULL;
	struct MobilEyeSpace *mobilEyeSpace = NULL;

	caSpace = New_CASpace();
	CASpace_ctor(caSpace);
	(void)Assign_CASpace(&self->EmptyRowSpace, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	mobilEyeSpace = New_MobilEyeSpace();
	MobilEyeSpace_ctor(mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&self->EmptyColumnSpace, mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
	Object_ctor(&self->base);
	self->Columns = (&self->EmptyRowSpace->base.base.base)->Dimensions;
	self->Rows = (&self->EmptyColumnSpace->base)->Dimensions;
}

static struct CASpace *MeasuremenModel_2_get_Condition(struct MeasurementModel_2 *const self)
{
	struct CASpace *result = NULL;

	(void)Assign_CASpace(&result, self->Condition);
	return result;
}

static void Space_3_set_LastGetIndex(struct Space_3 *const self, struct Nullable value)
{
	self->LastGetIndex = value;
}

struct MatrixData_5 *Space_3_get_MatrixData(struct Space_3 *const self)
{
	struct MatrixData_5 *result = NULL;

	(void)Assign_MatrixData_5(&result, self->_vector);
	return result;
}

float64_t MatrixData_5_get_Item(struct MatrixData_5 *const self, int32_t index)
{
	if (!((index >= ((int32_t)0)) && (index < ((int32_t)4))))
	{
		abort();
	}
	return self->_data->Elements[index];
}

float64_t Space_3_get_Item(struct Space_3 *const self, int32_t index)
{
	struct Nullable nullable = { 0 };
	float64_t result = 0.0;
	struct MatrixData_5 *matrixData = NULL;
	float64_t double_ = 0.0;

	if (!((index < self->Dimensions) && (index >= ((int32_t)0))))
	{
		abort();
	}
	Nullable_ctor(&nullable, index);
	Space_3_set_LastGetIndex(self, nullable);
	matrixData = Space_3_get_MatrixData(self);
	double_ = MatrixData_5_get_Item(matrixData, index);
	result = double_;
	(void)Assign_MatrixData_5(&matrixData, NULL);
	return result;
}

float64_t MobilEyeSpace_get_X(struct MobilEyeSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_3_get_Item(&self->base, ((int32_t)0));
	return double_;
}

static void Del_float64_t_1D_20(struct float64_t_1D_20 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_1D_20(struct float64_t_1D_20 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_1D_20.CurrentCount--;
		Res_float64_t_1D_20.Next[Res_float64_t_1D_20.CurrentCount] = self;
		Del_float64_t_1D_20(self);
	}
}

struct float64_t_1D_20 *New_float64_t_1D_20(void)
{
	static struct float64_t_1D_20 const Default_float64_t_1D_20 = { 1 };
	struct float64_t_1D_20 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_1D_20.CurrentCount == RC_float64_t_1D_20)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_1D_20.Next[Res_float64_t_1D_20.CurrentCount];
	Res_float64_t_1D_20.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_1D_20.MaximumCount = (Res_float64_t_1D_20.CurrentCount > Res_float64_t_1D_20.MaximumCount) ? Res_float64_t_1D_20.CurrentCount : Res_float64_t_1D_20.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_1D_20;
	return instance;
}

struct float64_t_1D_20 *Assign_float64_t_1D_20(struct float64_t_1D_20 **const left, struct float64_t_1D_20 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_1D_20(*left);
	*left = right;
	return right;
}

static void RemRef_MatrixData_16(struct MatrixData_16 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_16.CurrentCount--;
		Res_MatrixData_16.Next[Res_MatrixData_16.CurrentCount] = self;
		Del_MatrixData_16(self);
	}
}

struct MatrixData_16 *New_MatrixData_16(void)
{
	static struct MatrixData_16 const Default_MatrixData_16 = { 1 };
	struct MatrixData_16 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_16.CurrentCount == RC_MatrixData_16)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_16.Next[Res_MatrixData_16.CurrentCount];
	Res_MatrixData_16.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_16.MaximumCount = (Res_MatrixData_16.CurrentCount > Res_MatrixData_16.MaximumCount) ? Res_MatrixData_16.CurrentCount : Res_MatrixData_16.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_16;
	return instance;
}

struct MatrixData_16 *Assign_MatrixData_16(struct MatrixData_16 **const left, struct MatrixData_16 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_16(*left);
	*left = right;
	return right;
}

void MatrixData_16_ctor(struct MatrixData_16 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_20 *array = NULL;

	assert(rows == ((int32_t)4));
	assert(columns == ((int32_t)5));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_20();
	(void)Assign_float64_t_1D_20(&self->_data, array);
	(void)Assign_float64_t_1D_20(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct MatrixData_16 *MatrixData_20_Zeros_14(int32_t rows, int32_t columns)
{
	struct MatrixData_16 *result = NULL;
	struct MatrixData_16 *matrixData = NULL;

	assert(rows == ((int32_t)4));
	assert(columns == ((int32_t)5));
	matrixData = New_MatrixData_16();
	MatrixData_16_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData_16(&result, matrixData);
	(void)Assign_MatrixData_16(&matrixData, NULL);
	return result;
}

struct MatrixData_16 *Matrix_11_get_MatrixData(struct Matrix_11 *const self)
{
	struct MatrixData_16 *result = NULL;

	if (!(self->_matrix != NULL))
	{
		struct MatrixData_16 *matrixData = NULL;

		matrixData = MatrixData_20_Zeros_14(self->Rows, self->Columns);
		(void)Assign_MatrixData_16(&self->_matrix, matrixData);
		(void)Assign_MatrixData_16(&matrixData, NULL);
	}
	(void)Assign_MatrixData_16(&result, self->_matrix);
	return result;
}

struct float64_t_1D_20 *MatrixData_16_get_DataReference(struct MatrixData_16 *const self)
{
	struct float64_t_1D_20 *result = NULL;

	(void)Assign_float64_t_1D_20(&result, self->_data);
	return result;
}

static void MatrixData_16_SetValueFast(struct MatrixData_16 *const self, float64_t value, int32_t row, int32_t column)
{
	struct float64_t_1D_20 *array = NULL;

	array = MatrixData_16_get_DataReference(self);
	array->Elements[(column * self->Rows) + row] = value;
	(void)Assign_float64_t_1D_20(&array, NULL);
}

void MatrixData_16_set_Item(struct MatrixData_16 *const self, int32_t row, int32_t column, float64_t value)
{
	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	MatrixData_16_SetValueFast(self, value, row, column);
}

static void Matrix_11_MatrixChanged(struct Matrix_11 *const self)
{
	(void)Assign_MatrixData(&self->CachedTranspose, NULL);
}

void Matrix_11_set_Item(struct Matrix_11 *const self, int32_t row, int32_t column, float64_t value)
{
	struct MatrixData_16 *matrixData = NULL;

	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	matrixData = Matrix_11_get_MatrixData(self);
	MatrixData_16_set_Item(matrixData, row, column, value);
	(void)Assign_MatrixData_16(&matrixData, NULL);
	Matrix_11_MatrixChanged(self);
}

void Matrix_11_set_Item_1(struct Matrix_11 *const self, float64_t row, float64_t column, float64_t value)
{
	Matrix_11_set_Item(self, (int32_t)row, (int32_t)column, value);
}

float64_t MobilEyeSpace_get_Y(struct MobilEyeSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_3_get_Item(&self->base, ((int32_t)1));
	return double_;
}

float64_t MobilEyeSpace_get_Vx(struct MobilEyeSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_3_get_Item(&self->base, ((int32_t)2));
	return double_;
}

static float64_t MobiEyeMeasModel_get_EgoYawRate(struct MobilEyeMeasurementModel *const self)
{
	return self->EgoYawRate;
}

float64_t MobilEyeSpace_get_Vy(struct MobilEyeSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_3_get_Item(&self->base, ((int32_t)3));
	return double_;
}

void MobiEyeMeasModel_FillTransMatri(struct MobilEyeMeasurementModel *const self, struct CASpace *predictedStateExpectation, struct Matrix_11 **H)
{
	float64_t r = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	float64_t double__5 = 0.0;
	float64_t v = 0.0;
	float64_t double__6 = 0.0;
	float64_t arg_58_0 = 0.0;
	float64_t double__7 = 0.0;
	float64_t sinG = 0.0;
	float64_t double__8 = 0.0;
	float64_t double__9 = 0.0;
	float64_t cosG = 0.0;
	float64_t double__10 = 0.0;
	float64_t double__11 = 0.0;
	struct Matrix_11 *arg_A6_0 = NULL;
	float64_t arg_A6_1 = 0.0;
	float64_t double__12 = 0.0;
	struct CASpace *CS_0_0000 = NULL;
	struct Matrix_11 *matrix = NULL;
	float64_t double__13 = 0.0;
	float64_t double__14 = 0.0;
	struct Matrix_11 *arg_D3_0 = NULL;
	float64_t arg_D3_1 = 0.0;
	float64_t double__15 = 0.0;
	struct CASpace *CS_0_0001 = NULL;
	struct Matrix_11 *matrix_1 = NULL;
	float64_t double__16 = 0.0;
	float64_t double__17 = 0.0;
	struct Matrix_11 *arg_FF_0 = NULL;
	float64_t arg_FF_1 = 0.0;
	float64_t double__18 = 0.0;
	struct CASpace *CS_0_0002 = NULL;
	struct Matrix_11 *matrix_2 = NULL;
	float64_t double__19 = 0.0;
	float64_t double__20 = 0.0;
	struct Matrix_11 *arg_12B_0 = NULL;
	float64_t arg_12B_1 = 0.0;
	float64_t double__21 = 0.0;
	struct CASpace *CS_0_0003 = NULL;
	struct Matrix_11 *matrix_3 = NULL;
	float64_t double__22 = 0.0;
	float64_t double__23 = 0.0;
	struct Matrix_11 *arg_16E_0 = NULL;
	float64_t arg_16E_1 = 0.0;
	float64_t double__24 = 0.0;
	struct CASpace *CS_0_0004 = NULL;
	struct Matrix_11 *matrix_4 = NULL;
	float64_t double__25 = 0.0;
	float64_t double__26 = 0.0;
	float64_t double__27 = 0.0;
	float64_t double__28 = 0.0;
	float64_t double__29 = 0.0;
	float64_t double__30 = 0.0;
	struct Matrix_11 *arg_1B1_0 = NULL;
	float64_t arg_1B1_1 = 0.0;
	float64_t double__31 = 0.0;
	struct CASpace *CS_0_0005 = NULL;
	struct Matrix_11 *matrix_5 = NULL;
	float64_t double__32 = 0.0;
	float64_t double__33 = 0.0;
	float64_t double__34 = 0.0;
	float64_t double__35 = 0.0;
	float64_t double__36 = 0.0;
	float64_t double__37 = 0.0;
	struct Matrix_11 *arg_1EB_0 = NULL;
	float64_t arg_1EB_1 = 0.0;
	float64_t double__38 = 0.0;
	struct CASpace *CS_0_0006 = NULL;
	struct Matrix_11 *matrix_6 = NULL;
	float64_t double__39 = 0.0;
	float64_t double__40 = 0.0;
	struct Matrix_11 *arg_222_0 = NULL;
	float64_t arg_222_1 = 0.0;
	float64_t double__41 = 0.0;
	struct CASpace *CS_0_0007 = NULL;
	struct Matrix_11 *matrix_7 = NULL;
	float64_t double__42 = 0.0;
	float64_t double__43 = 0.0;
	struct Matrix_11 *arg_266_0 = NULL;
	float64_t arg_266_1 = 0.0;
	float64_t double__44 = 0.0;
	struct CASpace *CS_0_0008 = NULL;
	struct Matrix_11 *matrix_8 = NULL;
	float64_t double__45 = 0.0;
	float64_t double__46 = 0.0;
	float64_t double__47 = 0.0;
	float64_t double__48 = 0.0;
	float64_t double__49 = 0.0;
	float64_t double__50 = 0.0;
	float64_t double__51 = 0.0;
	struct Matrix_11 *arg_2AA_0 = NULL;
	float64_t arg_2AA_1 = 0.0;
	float64_t double__52 = 0.0;
	struct CASpace *CS_0_0009 = NULL;
	struct Matrix_11 *matrix_9 = NULL;
	float64_t double__53 = 0.0;
	float64_t double__54 = 0.0;
	float64_t double__55 = 0.0;
	float64_t double__56 = 0.0;
	float64_t double__57 = 0.0;
	float64_t double__58 = 0.0;
	float64_t double__59 = 0.0;
	struct Matrix_11 *arg_2E3_0 = NULL;
	float64_t arg_2E3_1 = 0.0;
	float64_t double__60 = 0.0;
	struct CASpace *CS_0_0010 = NULL;
	struct Matrix_11 *matrix_10 = NULL;
	float64_t double__61 = 0.0;
	float64_t double__62 = 0.0;
	struct Matrix_11 *arg_31A_0 = NULL;
	float64_t arg_31A_1 = 0.0;
	float64_t double__63 = 0.0;
	struct CASpace *CS_0_0011 = NULL;
	struct Matrix_11 *matrix_11 = NULL;
	float64_t double__64 = 0.0;
	float64_t double__65 = 0.0;

	double_ = CVSpace_get_X(&(*&predictedStateExpectation)->base);
	double__1 = CVSpace_get_X(&(*&predictedStateExpectation)->base);
	double__2 = double_ * double__1;
	double__3 = CVSpace_get_Y(&(*&predictedStateExpectation)->base);
	double__4 = CVSpace_get_Y(&(*&predictedStateExpectation)->base);
	double__5 = Math_Sqrt(double__2 + (double__3 * double__4));
	r = double__5;
	double__6 = CVSpace_get_V(&(*&predictedStateExpectation)->base);
	v = double__6;
	double__7 = CASpace_get_A(predictedStateExpectation);
	arg_58_0 = double__7;
	double__8 = CVSpace_get_G(&(*&predictedStateExpectation)->base);
	double__9 = Math_Sin(double__8);
	sinG = double__9;
	double__10 = CVSpace_get_G(&(*&predictedStateExpectation)->base);
	double__11 = Math_Cos(double__10);
	cosG = double__11;
	(void)Assign_Matrix_11(&arg_A6_0, *H);
	double__12 = MobilEyeSpace_get_X(self->_measurementIndices);
	arg_A6_1 = double__12;
	(void)Assign_CASpace(&CS_0_0000, MobilEyeMeasuModel_1_StateIndic);
	(void)Assign_Matrix_11(&matrix, arg_A6_0);
	double__13 = arg_A6_1;
	double__14 = CVSpace_get_X(&(*&CS_0_0000)->base);
	Matrix_11_set_Item_1(matrix, double__13, double__14, (&self->base)->CosRotZ);
	(void)Assign_Matrix_11(&matrix, NULL);
	(void)Assign_Matrix_11(&arg_D3_0, *H);
	double__15 = MobilEyeSpace_get_X(self->_measurementIndices);
	arg_D3_1 = double__15;
	(void)Assign_CASpace(&CS_0_0001, MobilEyeMeasuModel_1_StateIndic);
	(void)Assign_Matrix_11(&matrix_1, arg_D3_0);
	double__16 = arg_D3_1;
	double__17 = CVSpace_get_Y(&(*&CS_0_0001)->base);
	Matrix_11_set_Item_1(matrix_1, double__16, double__17, -(&self->base)->SinRotZ);
	(void)Assign_Matrix_11(&matrix_1, NULL);
	(void)Assign_Matrix_11(&arg_FF_0, *H);
	double__18 = MobilEyeSpace_get_Y(self->_measurementIndices);
	arg_FF_1 = double__18;
	(void)Assign_CASpace(&CS_0_0002, MobilEyeMeasuModel_1_StateIndic);
	(void)Assign_Matrix_11(&matrix_2, arg_FF_0);
	double__19 = arg_FF_1;
	double__20 = CVSpace_get_X(&(*&CS_0_0002)->base);
	Matrix_11_set_Item_1(matrix_2, double__19, double__20, (&self->base)->SinRotZ);
	(void)Assign_Matrix_11(&matrix_2, NULL);
	(void)Assign_Matrix_11(&arg_12B_0, *H);
	double__21 = MobilEyeSpace_get_Y(self->_measurementIndices);
	arg_12B_1 = double__21;
	(void)Assign_CASpace(&CS_0_0003, MobilEyeMeasuModel_1_StateIndic);
	(void)Assign_Matrix_11(&matrix_3, arg_12B_0);
	double__22 = arg_12B_1;
	double__23 = CVSpace_get_Y(&(*&CS_0_0003)->base);
	Matrix_11_set_Item_1(matrix_3, double__22, double__23, (&self->base)->CosRotZ);
	(void)Assign_Matrix_11(&matrix_3, NULL);
	(void)Assign_Matrix_11(&arg_16E_0, *H);
	double__24 = MobilEyeSpace_get_Vx(self->_measurementIndices);
	arg_16E_1 = double__24;
	(void)Assign_CASpace(&CS_0_0004, MobilEyeMeasuModel_1_StateIndic);
	(void)Assign_Matrix_11(&matrix_4, arg_16E_0);
	double__25 = arg_16E_1;
	double__26 = CVSpace_get_X(&(*&CS_0_0004)->base);
	double__27 = CVSpace_get_X(&(*&predictedStateExpectation)->base);
	double__28 = double__27 / r;
	double__29 = MobiEyeMeasModel_get_EgoYawRate(self);
	double__30 = double__28 * double__29;
	Matrix_11_set_Item_1(matrix_4, double__25, double__26, double__30 * (&self->base)->SinRotZ);
	(void)Assign_Matrix_11(&matrix_4, NULL);
	(void)Assign_Matrix_11(&arg_1B1_0, *H);
	double__31 = MobilEyeSpace_get_Vx(self->_measurementIndices);
	arg_1B1_1 = double__31;
	(void)Assign_CASpace(&CS_0_0005, MobilEyeMeasuModel_1_StateIndic);
	(void)Assign_Matrix_11(&matrix_5, arg_1B1_0);
	double__32 = arg_1B1_1;
	double__33 = CVSpace_get_Y(&(*&CS_0_0005)->base);
	double__34 = CVSpace_get_Y(&(*&predictedStateExpectation)->base);
	double__35 = double__34 / r;
	double__36 = MobiEyeMeasModel_get_EgoYawRate(self);
	double__37 = double__35 * double__36;
	Matrix_11_set_Item_1(matrix_5, double__32, double__33, double__37 * (&self->base)->SinRotZ);
	(void)Assign_Matrix_11(&matrix_5, NULL);
	(void)Assign_Matrix_11(&arg_1EB_0, *H);
	double__38 = MobilEyeSpace_get_Vx(self->_measurementIndices);
	arg_1EB_1 = double__38;
	(void)Assign_CASpace(&CS_0_0006, MobilEyeMeasuModel_1_StateIndic);
	(void)Assign_Matrix_11(&matrix_6, arg_1EB_0);
	double__39 = arg_1EB_1;
	double__40 = CVSpace_get_G(&(*&CS_0_0006)->base);
	Matrix_11_set_Item_1(matrix_6, double__39, double__40, -v * ((sinG * (&self->base)->CosRotZ) + (cosG * (&self->base)->SinRotZ)));
	(void)Assign_Matrix_11(&matrix_6, NULL);
	(void)Assign_Matrix_11(&arg_222_0, *H);
	double__41 = MobilEyeSpace_get_Vx(self->_measurementIndices);
	arg_222_1 = double__41;
	(void)Assign_CASpace(&CS_0_0007, MobilEyeMeasuModel_1_StateIndic);
	(void)Assign_Matrix_11(&matrix_7, arg_222_0);
	double__42 = arg_222_1;
	double__43 = CVSpace_get_V(&(*&CS_0_0007)->base);
	Matrix_11_set_Item_1(matrix_7, double__42, double__43, (cosG * (&self->base)->CosRotZ) - (sinG * (&self->base)->SinRotZ));
	(void)Assign_Matrix_11(&matrix_7, NULL);
	(void)Assign_Matrix_11(&arg_266_0, *H);
	double__44 = MobilEyeSpace_get_Vy(self->_measurementIndices);
	arg_266_1 = double__44;
	(void)Assign_CASpace(&CS_0_0008, MobilEyeMeasuModel_1_StateIndic);
	(void)Assign_Matrix_11(&matrix_8, arg_266_0);
	double__45 = arg_266_1;
	double__46 = CVSpace_get_X(&(*&CS_0_0008)->base);
	double__47 = CVSpace_get_X(&(*&predictedStateExpectation)->base);
	double__48 = -double__47;
	double__49 = double__48 / r;
	double__50 = MobiEyeMeasModel_get_EgoYawRate(self);
	double__51 = double__49 * double__50;
	Matrix_11_set_Item_1(matrix_8, double__45, double__46, double__51 * (&self->base)->CosRotZ);
	(void)Assign_Matrix_11(&matrix_8, NULL);
	(void)Assign_Matrix_11(&arg_2AA_0, *H);
	double__52 = MobilEyeSpace_get_Vy(self->_measurementIndices);
	arg_2AA_1 = double__52;
	(void)Assign_CASpace(&CS_0_0009, MobilEyeMeasuModel_1_StateIndic);
	(void)Assign_Matrix_11(&matrix_9, arg_2AA_0);
	double__53 = arg_2AA_1;
	double__54 = CVSpace_get_Y(&(*&CS_0_0009)->base);
	double__55 = CVSpace_get_Y(&(*&predictedStateExpectation)->base);
	double__56 = -double__55;
	double__57 = double__56 / r;
	double__58 = MobiEyeMeasModel_get_EgoYawRate(self);
	double__59 = double__57 * double__58;
	Matrix_11_set_Item_1(matrix_9, double__53, double__54, double__59 * (&self->base)->CosRotZ);
	(void)Assign_Matrix_11(&matrix_9, NULL);
	(void)Assign_Matrix_11(&arg_2E3_0, *H);
	double__60 = MobilEyeSpace_get_Vy(self->_measurementIndices);
	arg_2E3_1 = double__60;
	(void)Assign_CASpace(&CS_0_0010, MobilEyeMeasuModel_1_StateIndic);
	(void)Assign_Matrix_11(&matrix_10, arg_2E3_0);
	double__61 = arg_2E3_1;
	double__62 = CVSpace_get_G(&(*&CS_0_0010)->base);
	Matrix_11_set_Item_1(matrix_10, double__61, double__62, v * ((cosG * (&self->base)->CosRotZ) - (sinG * (&self->base)->SinRotZ)));
	(void)Assign_Matrix_11(&matrix_10, NULL);
	(void)Assign_Matrix_11(&arg_31A_0, *H);
	double__63 = MobilEyeSpace_get_Vy(self->_measurementIndices);
	arg_31A_1 = double__63;
	(void)Assign_CASpace(&CS_0_0011, MobilEyeMeasuModel_1_StateIndic);
	(void)Assign_Matrix_11(&matrix_11, arg_31A_0);
	double__64 = arg_31A_1;
	double__65 = CVSpace_get_V(&(*&CS_0_0011)->base);
	Matrix_11_set_Item_1(matrix_11, double__64, double__65, (cosG * (&self->base)->SinRotZ) + (sinG * (&self->base)->CosRotZ));
	(void)Assign_Matrix_11(&matrix_11, NULL);
	RemRef_Matrix_11(arg_A6_0);
	RemRef_CASpace(CS_0_0000);
	RemRef_Matrix_11(arg_D3_0);
	RemRef_CASpace(CS_0_0001);
	RemRef_Matrix_11(arg_FF_0);
	RemRef_CASpace(CS_0_0002);
	RemRef_Matrix_11(arg_12B_0);
	RemRef_CASpace(CS_0_0003);
	RemRef_Matrix_11(arg_16E_0);
	RemRef_CASpace(CS_0_0004);
	RemRef_Matrix_11(arg_1B1_0);
	RemRef_CASpace(CS_0_0005);
	RemRef_Matrix_11(arg_1EB_0);
	RemRef_CASpace(CS_0_0006);
	RemRef_Matrix_11(arg_222_0);
	RemRef_CASpace(CS_0_0007);
	RemRef_Matrix_11(arg_266_0);
	RemRef_CASpace(CS_0_0008);
	RemRef_Matrix_11(arg_2AA_0);
	RemRef_CASpace(CS_0_0009);
	RemRef_Matrix_11(arg_2E3_0);
	RemRef_CASpace(CS_0_0010);
	RemRef_Matrix_11(arg_31A_0);
	RemRef_CASpace(CS_0_0011);
}

struct Matrix_11 *MeasurModel_6_get_TransitMatrix(struct MobilEyeMeasurementModel *const self)
{
	struct Matrix_11 *result = NULL;
	struct Matrix_11 *matrix = NULL;
	struct CASpace *caSpace = NULL;
	struct Matrix_11 *result_1 = NULL;

	matrix = New_Matrix_11();
	Matrix_11_ctor(matrix);
	(void)Assign_Matrix_11(&result, matrix);
	(void)Assign_Matrix_11(&matrix, NULL);
	caSpace = MeasuremenModel_2_get_Condition(&self->base.base.base);
	MobiEyeMeasModel_FillTransMatri(self, caSpace, &result);
	(void)Assign_CASpace(&caSpace, NULL);
	(void)Assign_Matrix_11(&result_1, result);
	RemRef_Matrix_11(result);
	return result_1;
}

void LinearAlgebra_MatrixMultiply_11(struct LinearAlgebra *const self, struct float64_t_1D_20 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_25 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_20 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)20) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)25) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)20) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)20) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)25) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)25) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)20) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)20) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_16 *MatrixMath_Multiply_22(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_16 *left, struct MatrixData_2 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_16 *matrixData = NULL;
	struct MatrixData_16 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_20 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_25 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_20 *array_2 = NULL;
	struct MatrixData_16 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == false);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Columns;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_16();
	MatrixData_16_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_16(&matrixData, matrixData_1);
	(void)Assign_MatrixData_16(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_16_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_2_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_16_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_11(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_20(&array, NULL);
	(void)Assign_float64_t_1D_25(&array_1, NULL);
	(void)Assign_float64_t_1D_20(&array_2, NULL);
	(void)Assign_MatrixData_16(&result, matrixData);
	RemRef_MatrixData_16(matrixData);
	return result;
}

void LinearAlgebra_MatrixMultiply_12(struct LinearAlgebra *const self, struct float64_t_1D_20 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_20 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_16 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)20) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)20) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)20) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)20) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)20) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)20) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)20) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)16) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_15 *MatrixMath_Multiply_23(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_16 *left, struct MatrixData_16 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_15 *matrixData = NULL;
	struct MatrixData_15 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_20 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_20 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_16 *array_2 = NULL;
	struct MatrixData_15 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == true);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Rows;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_15();
	MatrixData_15_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_15(&matrixData, matrixData_1);
	(void)Assign_MatrixData_15(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_16_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_16_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_15_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_12(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_20(&array, NULL);
	(void)Assign_float64_t_1D_20(&array_1, NULL);
	(void)Assign_float64_t_1D_16(&array_2, NULL);
	(void)Assign_MatrixData_15(&result, matrixData);
	RemRef_MatrixData_15(matrixData);
	return result;
}

struct MatrixData_15 *MatrixMath_Multiply_24(bool_t transposeFirst, bool_t transposeSecond, bool_t transposeThird, struct MatrixData_16 *first, struct MatrixData_2 *second, struct MatrixData_16 *third)
{
	struct MatrixData_16 *left = NULL;
	struct MatrixData_16 *matrixData = NULL;
	struct MatrixData_15 *result = NULL;
	struct MatrixData_15 *matrixData_1 = NULL;

	assert(transposeFirst == false);
	assert(transposeSecond == false);
	assert(transposeThird == true);
	if (!(first != NULL))
	{
		abort();
	}
	if (!(second != NULL))
	{
		abort();
	}
	if (!(third != NULL))
	{
		abort();
	}
	matrixData = MatrixMath_Multiply_22(transposeFirst, transposeSecond, first, second);
	(void)Assign_MatrixData_16(&left, matrixData);
	(void)Assign_MatrixData_16(&matrixData, NULL);
	matrixData_1 = MatrixMath_Multiply_23(false, transposeThird, left, third);
	(void)Assign_MatrixData_15(&result, matrixData_1);
	(void)Assign_MatrixData_15(&matrixData_1, NULL);
	RemRef_MatrixData_16(left);
	return result;
}

struct PositiveDefiniteMatrix_3 *MeasuremeModel_2_get_Covariance(struct MeasurementModel_2 *const self)
{
	struct PositiveDefiniteMatrix_3 *result = NULL;
	struct PositiveDefiniteMatrix_3 *positiveDefiniteMatrix = NULL;

	positiveDefiniteMatrix = MeasureModel_2_get_NoiseCovaria(self);
	(void)Assign_PositiveDefiniteMatrix_3(&result, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_3(&positiveDefiniteMatrix, NULL);
	return result;
}

struct MatrixData_15 *MatrixMath_Add_4(struct MatrixData_15 *left, struct MatrixData_15 *right)
{
	struct MatrixData_15 *matrixData = NULL;
	struct MatrixData_15 *matrixData_1 = NULL;
	struct float64_t_1D_16 *dataReference = NULL;
	struct float64_t_1D_16 *array = NULL;
	struct float64_t_1D_16 *dataReference2 = NULL;
	struct float64_t_1D_16 *array_1 = NULL;
	struct float64_t_1D_16 *dataReference3 = NULL;
	struct float64_t_1D_16 *array_2 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_15 *result = NULL;

	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData_15();
	MatrixData_15_ctor(matrixData_1, left->Rows, right->Columns);
	(void)Assign_MatrixData_15(&matrixData, matrixData_1);
	(void)Assign_MatrixData_15(&matrixData_1, NULL);
	array = MatrixData_15_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_16(&dataReference, array);
	(void)Assign_float64_t_1D_16(&array, NULL);
	array_1 = MatrixData_15_get_DataReference(left);
	(void)Assign_float64_t_1D_16(&dataReference2, array_1);
	(void)Assign_float64_t_1D_16(&array_1, NULL);
	array_2 = MatrixData_15_get_DataReference(right);
	(void)Assign_float64_t_1D_16(&dataReference3, array_2);
	(void)Assign_float64_t_1D_16(&array_2, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)16))
	{
		dataReference->Elements[i] = dataReference2->Elements[i] + dataReference3->Elements[i];
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_15(&result, matrixData);
	RemRef_MatrixData_15(matrixData);
	RemRef_float64_t_1D_16(dataReference);
	RemRef_float64_t_1D_16(dataReference2);
	RemRef_float64_t_1D_16(dataReference3);
	return result;
	abort();
}

void PositiveDefiniteMatrix_3_ctor_1(struct PositiveDefiniteMatrix_3 *const self)
{
	SquareMatrix_3_ctor(&self->base);
}

struct PositiveDefiniteMatrix_3 *PositivDefiniteMatrix_12_Create(struct MatrixData_15 *matrix)
{
	struct PositiveDefiniteMatrix_3 *result = NULL;
	struct PositiveDefiniteMatrix_3 *positiveDefiniteMatrix = NULL;

	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_3();
	PositiveDefiniteMatrix_3_ctor_1(positiveDefiniteMatrix);
	Matrix_3_set_UncheckeMatrixData(&positiveDefiniteMatrix->base.base, matrix);
	(void)Assign_PositiveDefiniteMatrix_3(&result, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_3(&positiveDefiniteMatrix, NULL);
	return result;
}

struct PositiveDefiniteMatrix_3 *PosiDefinMatri_12_CreatAndCorre(struct MatrixData_15 *matrix)
{
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	float64_t num = 0.0;
	float64_t num2 = 0.0;
	float64_t value = 0.0;
	struct PositiveDefiniteMatrix_3 *result = NULL;
	struct PositiveDefiniteMatrix_3 *positiveDefiniteMatrix = NULL;

	i = ((int32_t)0);
	while (i < matrix->Rows)
	{
		float64_t double_ = 0.0;

		double_ = MatrixData_15_get_Item(matrix, i, i);
		if (!(double_ > 0.0))
		{
			MatrixData_15_set_Item(matrix, i, i, 4.94065645841247E-324);
		}
		j = ((int32_t)0);
		while (j < i)
		{
			float64_t double__1 = 0.0;
			float64_t double__2 = 0.0;
			float64_t double__3 = 0.0;
			float64_t double__4 = 0.0;
			float64_t double__5 = 0.0;
			float64_t double__6 = 0.0;

			double__1 = MatrixData_15_get_Item(matrix, i, j);
			double__2 = MatrixData_15_get_Item(matrix, j, i);
			num = (double__1 + double__2) / 2.0;
			double__3 = MatrixData_15_get_Item(matrix, i, i);
			double__4 = MatrixData_15_get_Item(matrix, j, j);
			double__5 = Math_Sqrt(double__3 * double__4);
			num2 = 1.0 * double__5;
			double__6 = Math_Abs(num);
			if (!(double__6 <= num2))
			{
				int32_t int32 = ((int32_t)0);
				float64_t double__7 = 0.0;

				int32 = Math_Sign(num);
				double__7 = (float64_t)int32;
				value = double__7 * num2;
			}
			else
			{
				value = num;
			}
			MatrixData_15_set_Item(matrix, i, j, value);
			MatrixData_15_set_Item(matrix, j, i, value);
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	positiveDefiniteMatrix = PositivDefiniteMatrix_12_Create(matrix);
	(void)Assign_PositiveDefiniteMatrix_3(&result, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_3(&positiveDefiniteMatrix, NULL);
	return result;
}

float64_t MobilEyeParameter_get_PositionX(struct MobilEyeParameters *const self)
{
	return self->PositionX;
}

float64_t MobilEyeParameter_get_PositionY(struct MobilEyeParameters *const self)
{
	return self->PositionY;
}

static void Space_3_set_LastSetIndex(struct Space_3 *const self, struct Nullable value)
{
	self->LastSetIndex = value;
}

void MatrixData_5_set_Item(struct MatrixData_5 *const self, int32_t index, float64_t value)
{
	if (!((index >= ((int32_t)0)) && (index < ((int32_t)4))))
	{
		abort();
	}
	self->_data->Elements[index] = value;
}

void Space_3_set_Item(struct Space_3 *const self, int32_t index, float64_t value)
{
	struct Nullable nullable = { 0 };
	struct MatrixData_5 *matrixData = NULL;

	if (!((index < self->Dimensions) && (index >= ((int32_t)0))))
	{
		abort();
	}
	Nullable_ctor(&nullable, index);
	Space_3_set_LastSetIndex(self, nullable);
	matrixData = Space_3_get_MatrixData(self);
	MatrixData_5_set_Item(matrixData, index, value);
	(void)Assign_MatrixData_5(&matrixData, NULL);
}

void MobilEyeSpace_set_X(struct MobilEyeSpace *const self, float64_t value)
{
	Space_3_set_Item(&self->base, ((int32_t)0), value);
}

void MobilEyeSpace_set_Y(struct MobilEyeSpace *const self, float64_t value)
{
	Space_3_set_Item(&self->base, ((int32_t)1), value);
}

void CartesianMeasurementModel_h(struct CartesianMeasurementModel *const self, struct CASpace *state, struct MobilEyeSpace **predictedMeasurement)
{
	float64_t arg_21_0 = 0.0;
	float64_t double_ = 0.0;
	struct MobilEyeParameters *CS_0_0000 = NULL;
	struct MobilEyeParameters *mobilEyeParameters = NULL;
	float64_t x = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t arg_44_0 = 0.0;
	float64_t double__3 = 0.0;
	struct MobilEyeParameters *CS_0_0001 = NULL;
	struct MobilEyeParameters *mobilEyeParameters_1 = NULL;
	float64_t y = 0.0;
	float64_t double__4 = 0.0;
	float64_t double__5 = 0.0;

	double_ = CVSpace_get_X(&(*&state)->base);
	arg_21_0 = double_;
	mobilEyeParameters = CarteMeasuModel_get_SensoParame(self);
	(void)Assign_MobilEyeParameters(&CS_0_0000, mobilEyeParameters);
	(void)Assign_MobilEyeParameters(&mobilEyeParameters, NULL);
	double__1 = arg_21_0;
	double__2 = MobilEyeParameter_get_PositionX(CS_0_0000);
	x = double__1 - double__2;
	double__3 = CVSpace_get_Y(&(*&state)->base);
	arg_44_0 = double__3;
	mobilEyeParameters_1 = CarteMeasuModel_get_SensoParame(self);
	(void)Assign_MobilEyeParameters(&CS_0_0001, mobilEyeParameters_1);
	(void)Assign_MobilEyeParameters(&mobilEyeParameters_1, NULL);
	double__4 = arg_44_0;
	double__5 = MobilEyeParameter_get_PositionY(CS_0_0001);
	y = double__4 - double__5;
	MobilEyeSpace_set_X(*predictedMeasurement, (x * self->CosRotZ) - (y * self->SinRotZ));
	MobilEyeSpace_set_Y(*predictedMeasurement, (x * self->SinRotZ) + (y * self->CosRotZ));
	RemRef_MobilEyeParameters(CS_0_0000);
	RemRef_MobilEyeParameters(CS_0_0001);
}

static float64_t CartesMeasureModel_get_Conditi2(struct CartesianMeasurementModel *const self)
{
	return self->Condition2;
}

float64_t CartesMeasurModel_get_EgoVeloci(struct CartesianMeasurementModel *const self)
{
	float64_t double_ = 0.0;

	double_ = CartesMeasureModel_get_Conditi2(self);
	return double_;
}

void MobilEyeSpace_set_Vx(struct MobilEyeSpace *const self, float64_t value)
{
	Space_3_set_Item(&self->base, ((int32_t)2), value);
}

void MobilEyeSpace_set_Vy(struct MobilEyeSpace *const self, float64_t value)
{
	Space_3_set_Item(&self->base, ((int32_t)3), value);
}

void MobilEyeMeasurementModel_h(struct MobilEyeMeasurementModel *const self, struct CASpace *state, struct MobilEyeSpace **predictedMeasurement)
{
	float64_t r = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	float64_t double__5 = 0.0;
	float64_t sinG = 0.0;
	float64_t double__6 = 0.0;
	float64_t double__7 = 0.0;
	float64_t cosG = 0.0;
	float64_t double__8 = 0.0;
	float64_t double__9 = 0.0;
	float64_t vx = 0.0;
	float64_t double__10 = 0.0;
	float64_t double__11 = 0.0;
	float64_t double__12 = 0.0;
	float64_t vy = 0.0;
	float64_t double__13 = 0.0;
	float64_t double__14 = 0.0;
	float64_t double__15 = 0.0;
	float64_t double__16 = 0.0;

	CartesianMeasurementModel_h(&self->base, state, predictedMeasurement);
	double_ = CVSpace_get_X(&(*&state)->base);
	double__1 = CVSpace_get_X(&(*&state)->base);
	double__2 = double_ * double__1;
	double__3 = CVSpace_get_Y(&(*&state)->base);
	double__4 = CVSpace_get_Y(&(*&state)->base);
	double__5 = Math_Sqrt(double__2 + (double__3 * double__4));
	r = double__5;
	double__6 = CVSpace_get_G(&(*&state)->base);
	double__7 = Math_Sin(double__6);
	sinG = double__7;
	double__8 = CVSpace_get_G(&(*&state)->base);
	double__9 = Math_Cos(double__8);
	cosG = double__9;
	double__10 = CVSpace_get_V(&(*&state)->base);
	double__11 = double__10 * cosG;
	double__12 = CartesMeasurModel_get_EgoVeloci(&self->base);
	vx = double__11 - double__12;
	double__13 = CVSpace_get_V(&(*&state)->base);
	double__14 = double__13 * sinG;
	double__15 = r;
	double__16 = MobiEyeMeasModel_get_EgoYawRate(self);
	vy = double__14 - (double__15 * double__16);
	MobilEyeSpace_set_Vx(*predictedMeasurement, (vx * (&self->base)->CosRotZ) - (vy * (&self->base)->SinRotZ));
	MobilEyeSpace_set_Vy(*predictedMeasurement, (vx * (&self->base)->SinRotZ) + (vy * (&self->base)->CosRotZ));
}

struct MobilEyeSpace *MeasuremeModel_2_get_Expectatio(struct MobilEyeMeasurementModel *const self)
{
	struct MobilEyeSpace *result = NULL;
	struct MobilEyeSpace *mobilEyeSpace = NULL;
	struct CASpace *caSpace = NULL;
	struct MobilEyeSpace *result_1 = NULL;

	mobilEyeSpace = New_MobilEyeSpace();
	MobilEyeSpace_ctor(mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&result, mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
	caSpace = MeasuremenModel_2_get_Condition(&self->base.base.base);
	MobilEyeMeasurementModel_h(self, caSpace, &result);
	(void)Assign_CASpace(&caSpace, NULL);
	(void)Assign_MobilEyeSpace(&result_1, result);
	RemRef_MobilEyeSpace(result);
	return result_1;
}

static void Gaussian_10_cctor(void)
{
	struct MobilEyeSpace *mobilEyeSpace = NULL;

	mobilEyeSpace = New_MobilEyeSpace();
	MobilEyeSpace_ctor(mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&Gaussian_10_EmptySpace, mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
}

static void Gaussian_2_set_Expectation(struct Gaussian_2 *const self, struct MobilEyeSpace *value)
{
	(void)Assign_MobilEyeSpace(&self->Expectation, value);
}

static void Gaussian_2_ResetCachedValues(struct Gaussian_2 *const self)
{
	struct Nullable_2 nullable = { 0 };

	self->NormalizationFactor = nullable;
}

static void Gaussian_2_set_Covariance(struct Gaussian_2 *const self, struct PositiveDefiniteMatrix_3 *value)
{
	Gaussian_2_ResetCachedValues(self);
	(void)Assign_PositiveDefiniteMatrix_3(&self->covariance, value);
}

static void Gaussian_2_ctor(struct Gaussian_2 *const self, bool_t noInitialization)
{
	struct MobilEyeSpace *mobilEyeSpace = NULL;
	struct PositiveDefiniteMatrix_3 *positiveDefiniteMatrix = NULL;

	Object_ctor(&self->base);
	self->_dimensions = (&Gaussian_10_EmptySpace->base)->Dimensions;
	if (!!noInitialization)
	{
		return;
	}
	mobilEyeSpace = New_MobilEyeSpace();
	MobilEyeSpace_ctor(mobilEyeSpace);
	Gaussian_2_set_Expectation(self, mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_3();
	PositiveDefiniteMatrix_3_ctor_1(positiveDefiniteMatrix);
	Gaussian_2_set_Covariance(self, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_3(&positiveDefiniteMatrix, NULL);
}

struct Gaussian_2 *Gaussian_10_Create(struct MobilEyeSpace *expectation, struct PositiveDefiniteMatrix_3 *covariance)
{
	struct Gaussian_2 *result = NULL;
	struct Gaussian_2 *gaussian = NULL;

	gaussian = New_Gaussian_2();
	Gaussian_2_ctor(gaussian, true);
	Gaussian_2_set_Expectation(gaussian, expectation);
	Gaussian_2_set_Covariance(gaussian, covariance);
	(void)Assign_Gaussian_2(&result, gaussian);
	(void)Assign_Gaussian_2(&gaussian, NULL);
	return result;
}

struct Gaussian_2 *EKF_PredictMeasurement_2(struct Gaussian_5 *predictedState, struct MobilEyeMeasurementModel *measurementModel, struct Matrix_11 **transitionMatrix)
{
	struct CASpace *caSpace = NULL;
	struct Matrix_11 **matrix = NULL;
	struct Matrix_11 *matrix_1 = NULL;
	struct MatrixData_16 *matrixData = NULL;
	struct MatrixData_16 *matrixData_1 = NULL;
	struct MatrixData_15 *matrix_2 = NULL;
	struct MatrixData_16 *matrixData_2 = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix = NULL;
	struct MatrixData_2 *matrixData_3 = NULL;
	struct MatrixData_15 *matrixData_4 = NULL;
	struct PositiveDefiniteMatrix_3 *positiveDefiniteMatrix_1 = NULL;
	struct MatrixData_15 *matrixData_5 = NULL;
	struct MatrixData_15 *matrixData_6 = NULL;
	struct PositiveDefiniteMatrix_3 *covariance = NULL;
	struct PositiveDefiniteMatrix_3 *positiveDefiniteMatrix_2 = NULL;
	struct Gaussian_2 *result = NULL;
	struct MobilEyeSpace *mobilEyeSpace = NULL;
	struct Gaussian_2 *gaussian = NULL;

	if (!(__ContrRunti_1_insidContrEvalua > ((int32_t)4)))
	{
		bool_t boolean = false;
		bool_t boolean_1 = false;

		__ContrRunti_1_insidContrEvalua = __ContrRunti_1_insidContrEvalua + ((int32_t)1);
		boolean = Object_2_ReferenceEquals(&predictedState->base, NULL);
		if (!!boolean)
		{
			abort();
		}
		boolean_1 = Object_2_ReferenceEquals(&measurementModel->base.base.base.base, NULL);
		if (!!boolean_1)
		{
			abort();
		}
		__ContrRunti_1_insidContrEvalua = __ContrRunti_1_insidContrEvalua - ((int32_t)1);
	}
	caSpace = Gaussian_5_get_Expectation(predictedState);
	MeasuremenModel_2_set_Condition(&(*&measurementModel)->base.base.base, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	matrix = transitionMatrix;
	matrix_1 = MeasurModel_6_get_TransitMatrix(measurementModel);
	(void)Assign_Matrix_11(&*matrix, matrix_1);
	(void)Assign_Matrix_11(&matrix_1, NULL);
	matrixData_1 = Matrix_11_get_MatrixData(*transitionMatrix);
	(void)Assign_MatrixData_16(&matrixData, matrixData_1);
	(void)Assign_MatrixData_16(&matrixData_1, NULL);
	(void)Assign_MatrixData_16(&matrixData_2, matrixData);
	positiveDefiniteMatrix = Gaussian_5_get_Covariance(predictedState);
	matrixData_3 = Matrix_10_get_MatrixData(&positiveDefiniteMatrix->base.base);
	matrixData_4 = MatrixMath_Multiply_24(false, false, true, matrixData_2, matrixData_3, matrixData);
	positiveDefiniteMatrix_1 = MeasuremeModel_2_get_Covariance(&(*&measurementModel)->base.base.base);
	matrixData_5 = Matrix_3_get_MatrixData(&positiveDefiniteMatrix_1->base.base);
	matrixData_6 = MatrixMath_Add_4(matrixData_4, matrixData_5);
	(void)Assign_MatrixData_15(&matrix_2, matrixData_6);
	(void)Assign_MatrixData_16(&matrixData_2, NULL);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix, NULL);
	(void)Assign_MatrixData_2(&matrixData_3, NULL);
	(void)Assign_MatrixData_15(&matrixData_4, NULL);
	(void)Assign_PositiveDefiniteMatrix_3(&positiveDefiniteMatrix_1, NULL);
	(void)Assign_MatrixData_15(&matrixData_5, NULL);
	(void)Assign_MatrixData_15(&matrixData_6, NULL);
	positiveDefiniteMatrix_2 = PosiDefinMatri_12_CreatAndCorre(matrix_2);
	(void)Assign_PositiveDefiniteMatrix_3(&covariance, positiveDefiniteMatrix_2);
	(void)Assign_PositiveDefiniteMatrix_3(&positiveDefiniteMatrix_2, NULL);
	mobilEyeSpace = MeasuremeModel_2_get_Expectatio(measurementModel);
	gaussian = Gaussian_10_Create(mobilEyeSpace, covariance);
	(void)Assign_Gaussian_2(&result, gaussian);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
	(void)Assign_Gaussian_2(&gaussian, NULL);
	RemRef_MatrixData_16(matrixData);
	RemRef_MatrixData_15(matrix_2);
	RemRef_PositiveDefiniteMatrix_3(covariance);
	return result;
}

int32_t StaticList_16_get_Count(struct StaticList_16 *const self)
{
	return self->Count;
}

static void StaticList_16_CheckCount(struct StaticList_16 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_16_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_16_set_Count(struct StaticList_16 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_16_Add(struct StaticList_16 *const self, struct Matrix_11 *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_16_CheckCount(self);
	int32 = StaticList_16_get_Count(self);
	count = int32;
	(void)Assign_Matrix_11(&self->_items->Elements[count], value);
	int32_1 = StaticList_16_get_Count(self);
	StaticList_16_set_Count(self, int32_1 + ((int32_t)1));
}

int32_t StaticList_20_get_Count(struct StaticList_20 *const self)
{
	return self->Count;
}

static void StaticList_20_CheckCount(struct StaticList_20 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_20_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_20_set_Count(struct StaticList_20 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_20_Add(struct StaticList_20 *const self, struct Gaussian_2 *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_20_CheckCount(self);
	int32 = StaticList_20_get_Count(self);
	count = int32;
	(void)Assign_Gaussian_2(&self->_items->Elements[count], value);
	int32_1 = StaticList_20_get_Count(self);
	StaticList_20_set_Count(self, int32_1 + ((int32_t)1));
}

struct PositiveDefiniteMatrix_3 *Gaussian_2_get_Covariance(struct Gaussian_2 *const self)
{
	struct PositiveDefiniteMatrix_3 *result = NULL;

	Gaussian_2_ResetCachedValues(self);
	(void)Assign_PositiveDefiniteMatrix_3(&result, self->covariance);
	return result;
}

static int32_t MatrixData_15_GetIndexTranspose(struct MatrixData_15 *const self, int32_t row, int32_t column)
{
	return (row * self->Columns) + column;
}

static int32_t MatrixData_15_GetIndex(struct MatrixData_15 *const self, int32_t row, int32_t column)
{
	return (column * self->Rows) + row;
}

struct MatrixData_15 *MatrixData_15_get_T(struct MatrixData_15 *const self)
{
	struct MatrixData_15 *matrixData = NULL;
	struct MatrixData_15 *matrixData_1 = NULL;
	struct float64_t_1D_16 *dataReference = NULL;
	struct float64_t_1D_16 *array = NULL;
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	struct MatrixData_15 *result = NULL;

	matrixData_1 = New_MatrixData_15();
	MatrixData_15_ctor(matrixData_1, self->Columns, self->Rows);
	(void)Assign_MatrixData_15(&matrixData, matrixData_1);
	(void)Assign_MatrixData_15(&matrixData_1, NULL);
	array = MatrixData_15_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_16(&dataReference, array);
	(void)Assign_float64_t_1D_16(&array, NULL);
	i = ((int32_t)0);
	while (i < self->Rows)
	{
		j = ((int32_t)0);
		while (j < self->Columns)
		{
			struct float64_t_1D_16 *array_1 = NULL;
			int32_t int32 = ((int32_t)0);
			struct float64_t_1D_16 *array_2 = NULL;
			int32_t int32_1 = ((int32_t)0);

			(void)Assign_float64_t_1D_16(&array_1, dataReference);
			int32 = MatrixData_15_GetIndexTranspose(self, i, j);
			(void)Assign_float64_t_1D_16(&array_2, self->_data);
			int32_1 = MatrixData_15_GetIndex(self, i, j);
			array_1->Elements[int32] = array_2->Elements[int32_1];
			(void)Assign_float64_t_1D_16(&array_1, NULL);
			(void)Assign_float64_t_1D_16(&array_2, NULL);
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_15(&result, matrixData);
	RemRef_MatrixData_15(matrixData);
	RemRef_float64_t_1D_16(dataReference);
	return result;
}

static void RemRef_SquareMatrix_3(struct SquareMatrix_3 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_SquareMatrix_3.CurrentCount--;
		Res_SquareMatrix_3.Next[Res_SquareMatrix_3.CurrentCount] = self;
		Del_SquareMatrix_3(self);
	}
}

struct SquareMatrix_3 *New_SquareMatrix_3(void)
{
	static struct SquareMatrix_3 const Default_SquareMatrix_3 = { 1 };
	struct SquareMatrix_3 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_SquareMatrix_3.CurrentCount == RC_SquareMatrix_3)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_SquareMatrix_3.Next[Res_SquareMatrix_3.CurrentCount];
	Res_SquareMatrix_3.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_SquareMatrix_3.MaximumCount = (Res_SquareMatrix_3.CurrentCount > Res_SquareMatrix_3.MaximumCount) ? Res_SquareMatrix_3.CurrentCount : Res_SquareMatrix_3.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_SquareMatrix_3;
	return instance;
}

struct SquareMatrix_3 *Assign_SquareMatrix_3(struct SquareMatrix_3 **const left, struct SquareMatrix_3 *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_SquareMatrix_3(*left);
	*left = right;
	return right;
}

struct SquareMatrix_3 *SquareMatrix_10_Create(struct MatrixData_15 *matrix)
{
	struct SquareMatrix_3 *result = NULL;
	struct SquareMatrix_3 *squareMatrix = NULL;

	squareMatrix = New_SquareMatrix_3();
	SquareMatrix_3_ctor(squareMatrix);
	Matrix_3_set_UncheckeMatrixData(&squareMatrix->base, matrix);
	(void)Assign_SquareMatrix_3(&result, squareMatrix);
	(void)Assign_SquareMatrix_3(&squareMatrix, NULL);
	return result;
}

struct SquareMatrix_3 *PosiDefinMatri_3_get_CholeDecom(struct PositiveDefiniteMatrix_3 *const self)
{
	struct MatrixData_15 *arg_3D_1 = NULL;
	struct SquareMatrix_3 *result = NULL;
	struct SquareMatrix_3 *squareMatrix = NULL;

	if (!(self->CachedCholeskyDecomposition != NULL))
	{
		bool_t boolean = false;

		boolean = Matrix_3_get_IsZero(&self->base.base);
		if (!boolean)
		{
			struct MatrixData_15 *matrixData = NULL;
			struct MatrixData_15 *matrixData_1 = NULL;
			struct MatrixData_15 *matrixData_2 = NULL;

			matrixData = Matrix_3_get_MatrixData(&self->base.base);
			matrixData_1 = MatrixMath_Chol_4(matrixData);
			matrixData_2 = MatrixData_15_get_T(matrixData_1);
			(void)Assign_MatrixData_15(&arg_3D_1, matrixData_2);
			(void)Assign_MatrixData_15(&matrixData, NULL);
			(void)Assign_MatrixData_15(&matrixData_1, NULL);
			(void)Assign_MatrixData_15(&matrixData_2, NULL);
		}
		else
		{
			struct MatrixData_15 *matrixData_3 = NULL;

			matrixData_3 = MatrixData_20_Zeros_13((&self->base.base)->Rows, (&self->base.base)->Columns);
			(void)Assign_MatrixData_15(&arg_3D_1, matrixData_3);
			(void)Assign_MatrixData_15(&matrixData_3, NULL);
		}
		(void)Assign_MatrixData_15(&self->CachedCholeskyDecomposition, arg_3D_1);
	}
	squareMatrix = SquareMatrix_10_Create(self->CachedCholeskyDecomposition);
	(void)Assign_SquareMatrix_3(&result, squareMatrix);
	(void)Assign_SquareMatrix_3(&squareMatrix, NULL);
	RemRef_MatrixData_15(arg_3D_1);
	return result;
}

struct MobilEyeSpace *Gaussian_2_get_Expectation(struct Gaussian_2 *const self)
{
	struct MobilEyeSpace *result = NULL;

	(void)Assign_MobilEyeSpace(&result, self->Expectation);
	return result;
}

static void RemRef_MatrixData_18(struct MatrixData_18 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_18.CurrentCount--;
		Res_MatrixData_18.Next[Res_MatrixData_18.CurrentCount] = self;
		Del_MatrixData_18(self);
	}
}

struct MatrixData_18 *New_MatrixData_18(void)
{
	static struct MatrixData_18 const Default_MatrixData_18 = { 1 };
	struct MatrixData_18 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_18.CurrentCount == RC_MatrixData_18)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_18.Next[Res_MatrixData_18.CurrentCount];
	Res_MatrixData_18.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_18.MaximumCount = (Res_MatrixData_18.CurrentCount > Res_MatrixData_18.MaximumCount) ? Res_MatrixData_18.CurrentCount : Res_MatrixData_18.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_18;
	return instance;
}

struct MatrixData_18 *Assign_MatrixData_18(struct MatrixData_18 **const left, struct MatrixData_18 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_18(*left);
	*left = right;
	return right;
}

static void Del_float64_t_1D_200(struct float64_t_1D_200 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_1D_200(struct float64_t_1D_200 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_1D_200.CurrentCount--;
		Res_float64_t_1D_200.Next[Res_float64_t_1D_200.CurrentCount] = self;
		Del_float64_t_1D_200(self);
	}
}

struct float64_t_1D_200 *New_float64_t_1D_200(void)
{
	static struct float64_t_1D_200 const Default_float64_t_1D_200 = { 1 };
	struct float64_t_1D_200 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_1D_200.CurrentCount == RC_float64_t_1D_200)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_1D_200.Next[Res_float64_t_1D_200.CurrentCount];
	Res_float64_t_1D_200.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_1D_200.MaximumCount = (Res_float64_t_1D_200.CurrentCount > Res_float64_t_1D_200.MaximumCount) ? Res_float64_t_1D_200.CurrentCount : Res_float64_t_1D_200.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_1D_200;
	return instance;
}

struct float64_t_1D_200 *Assign_float64_t_1D_200(struct float64_t_1D_200 **const left, struct float64_t_1D_200 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_1D_200(*left);
	*left = right;
	return right;
}

void MatrixData_18_ctor(struct MatrixData_18 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_200 *array = NULL;

	assert(rows == ((int32_t)4));
	assert(columns == ((int32_t)50));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_200();
	(void)Assign_float64_t_1D_200(&self->_data, array);
	(void)Assign_float64_t_1D_200(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct float64_t_1D_200 *MatrixData_18_get_DataReference(struct MatrixData_18 *const self)
{
	struct float64_t_1D_200 *result = NULL;

	(void)Assign_float64_t_1D_200(&result, self->_data);
	return result;
}

void Random_ctor_1(struct Random *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = Environment_get_TickCount();
	Random_ctor(self, int32);
}

static int32_t Random_InternalSample(struct Random *const self)
{
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);

	num = self->inext;
	num2 = self->inextp;
	if (!((num = num + ((int32_t)1)) < ((int32_t)56)))
	{
		num = ((int32_t)1);
	}
	if (!((num2 = num2 + ((int32_t)1)) < ((int32_t)56)))
	{
		num2 = ((int32_t)1);
	}
	num3 = self->SeedArray->Elements[num] - self->SeedArray->Elements[num2];
	if (!(num3 != ((int32_t)2147483647)))
	{
		num3 = num3 - ((int32_t)1);
	}
	if (!(num3 >= ((int32_t)0)))
	{
		num3 = num3 + ((int32_t)2147483647);
	}
	self->SeedArray->Elements[num] = num3;
	self->inext = num;
	self->inextp = num2;
	return num3;
}

static float64_t Random_Sample(struct Random *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = Random_InternalSample(self);
	return (float64_t)int32 * 4.6566128752457969E-10;
}

float64_t Random_NextDouble(struct Random *const self)
{
	float64_t double_ = 0.0;

	double_ = Random_Sample(self);
	return double_;
}

static struct MatrixData_18 *Tracking_1_CreateRandnMatrix(int32_t rows, int32_t columns)
{
	struct MatrixData_18 *obj = NULL;
	struct MatrixData_18 *matrixData = NULL;
	struct float64_t_1D_200 *data = NULL;
	struct float64_t_1D_200 *array = NULL;
	int32_t i = ((int32_t)0);
	struct Random *random = NULL;
	struct Random *random_1 = NULL;
	float64_t u = 0.0;
	float64_t v = 0.0;
	float64_t combined = 0.0;
	float64_t u_1 = 0.0;
	float64_t v_1 = 0.0;
	float64_t combined_1 = 0.0;
	struct MatrixData_18 *result = NULL;

	assert(rows == ((int32_t)4));
	assert(columns == ((int32_t)50));
	matrixData = New_MatrixData_18();
	MatrixData_18_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData_18(&obj, matrixData);
	(void)Assign_MatrixData_18(&matrixData, NULL);
	array = MatrixData_18_get_DataReference(obj);
	(void)Assign_float64_t_1D_200(&data, array);
	(void)Assign_float64_t_1D_200(&array, NULL);
	i = ((int32_t)0);
	random_1 = New_Random();
	Random_ctor_1(random_1);
	(void)Assign_Random(&random, random_1);
	(void)Assign_Random(&random_1, NULL);
	while (i < (((int32_t)200) - ((int32_t)1)))
	{
		float64_t double_ = 0.0;
		float64_t double__1 = 0.0;
		float64_t double__2 = 0.0;

		while (true)
		{
			float64_t double__3 = 0.0;
			float64_t double__4 = 0.0;
			bool_t boolean = false;
			bool_t boolean_1 = false;
			bool_t boolean_2 = false;

			double__3 = Random_NextDouble(random);
			u = (2.0 * double__3) - 1.0;
			double__4 = Random_NextDouble(random);
			v = (2.0 * double__4) - 1.0;
			combined = (u * u) + (v * v);
			boolean_1 = combined >= 1.0;
			if (boolean_1 == false)
			{
				boolean = float64_t_Equals(&combined, 0.0);
				boolean_2 = boolean;
			}
			else
			{
				boolean_2 = true;
			}
			if (!boolean_2)
			{
				break;
			}
		}
		double_ = Math_Log(combined);
		double__1 = -2.0 * double_;
		double__2 = Math_Sqrt(double__1 / combined);
		combined = double__2;
		data->Elements[i] = u * combined;
		data->Elements[i + ((int32_t)1)] = v * combined;
		i = i + ((int32_t)2);
	}
	if (!(i >= ((int32_t)200)))
	{
		float64_t double__5 = 0.0;
		float64_t double__6 = 0.0;
		float64_t double__7 = 0.0;

		while (true)
		{
			float64_t double__8 = 0.0;
			float64_t double__9 = 0.0;
			bool_t boolean_3 = false;
			bool_t boolean_4 = false;
			bool_t boolean_5 = false;

			double__8 = Random_NextDouble(random);
			u_1 = (2.0 * double__8) - 1.0;
			double__9 = Random_NextDouble(random);
			v_1 = (2.0 * double__9) - 1.0;
			combined_1 = (u_1 * u_1) + (v_1 * v_1);
			boolean_4 = combined_1 >= 1.0;
			if (boolean_4 == false)
			{
				boolean_3 = float64_t_Equals(&combined_1, 0.0);
				boolean_5 = boolean_3;
			}
			else
			{
				boolean_5 = true;
			}
			if (!boolean_5)
			{
				break;
			}
		}
		double__5 = Math_Log(combined_1);
		double__6 = -2.0 * double__5;
		double__7 = Math_Sqrt(double__6 / combined_1);
		combined_1 = double__7;
		data->Elements[i] = u_1 * combined_1;
	}
	(void)Assign_MatrixData_18(&result, obj);
	RemRef_MatrixData_18(obj);
	RemRef_float64_t_1D_200(data);
	RemRef_Random(random);
	return result;
}

void LinearAlgebra_MatrixMultiply_13(struct LinearAlgebra *const self, struct float64_t_1D_16 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_200 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_200 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)16) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)200) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)16) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)16) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)200) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)200) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)16) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)200) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_18 *MatrixMath_Multiply_25(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_15 *left, struct MatrixData_18 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_18 *matrixData = NULL;
	struct MatrixData_18 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_16 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_200 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_200 *array_2 = NULL;
	struct MatrixData_18 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == false);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Columns;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_18();
	MatrixData_18_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_18(&matrixData, matrixData_1);
	(void)Assign_MatrixData_18(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_15_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_18_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_18_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_13(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_16(&array, NULL);
	(void)Assign_float64_t_1D_200(&array_1, NULL);
	(void)Assign_float64_t_1D_200(&array_2, NULL);
	(void)Assign_MatrixData_18(&result, matrixData);
	RemRef_MatrixData_18(matrixData);
	return result;
}

struct MatrixData_18 *MatrixMath_Multiply_26(struct MatrixData_15 *left, struct MatrixData_18 *right)
{
	struct MatrixData_18 *result = NULL;
	struct MatrixData_18 *matrixData = NULL;

	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	matrixData = MatrixMath_Multiply_25(false, false, left, right);
	(void)Assign_MatrixData_18(&result, matrixData);
	(void)Assign_MatrixData_18(&matrixData, NULL);
	return result;
}

static void RemRef_StaticList_7(struct StaticList_7 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_7.CurrentCount--;
		Res_StaticList_7.Next[Res_StaticList_7.CurrentCount] = self;
		Del_StaticList_7(self);
	}
}

struct StaticList_7 *New_StaticList_7(void)
{
	static struct StaticList_7 const Default_StaticList_7 = { 1 };
	struct StaticList_7 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_7.CurrentCount == RC_StaticList_7)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_7.Next[Res_StaticList_7.CurrentCount];
	Res_StaticList_7.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_7.MaximumCount = (Res_StaticList_7.CurrentCount > Res_StaticList_7.MaximumCount) ? Res_StaticList_7.CurrentCount : Res_StaticList_7.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_7;
	return instance;
}

struct StaticList_7 *Assign_StaticList_7(struct StaticList_7 **const left, struct StaticList_7 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_7(*left);
	*left = right;
	return right;
}

static void Del_MobilEyeSpace_1D_50(struct MobilEyeSpace_1D_50 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)50);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_MobilEyeSpace(self->Elements[i]);
	}
}

static void RemRef_MobilEyeSpace_1D_50(struct MobilEyeSpace_1D_50 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MobilEyeSpace_1D_50.CurrentCount--;
		Res_MobilEyeSpace_1D_50.Next[Res_MobilEyeSpace_1D_50.CurrentCount] = self;
		Del_MobilEyeSpace_1D_50(self);
	}
}

struct MobilEyeSpace_1D_50 *New_MobilEyeSpace_1D_50(void)
{
	static struct MobilEyeSpace_1D_50 const Default_MobilEyeSpace_1D_50 = { 1 };
	struct MobilEyeSpace_1D_50 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MobilEyeSpace_1D_50.CurrentCount == RC_MobilEyeSpace_1D_50)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MobilEyeSpace_1D_50.Next[Res_MobilEyeSpace_1D_50.CurrentCount];
	Res_MobilEyeSpace_1D_50.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MobilEyeSpace_1D_50.MaximumCount = (Res_MobilEyeSpace_1D_50.CurrentCount > Res_MobilEyeSpace_1D_50.MaximumCount) ? Res_MobilEyeSpace_1D_50.CurrentCount : Res_MobilEyeSpace_1D_50.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MobilEyeSpace_1D_50;
	return instance;
}

struct MobilEyeSpace_1D_50 *Assign_MobilEyeSpace_1D_50(struct MobilEyeSpace_1D_50 **const left, struct MobilEyeSpace_1D_50 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MobilEyeSpace_1D_50(*left);
	*left = right;
	return right;
}

void StaticList_7_ctor(struct StaticList_7 *const self, int32_t maximumCount)
{
	struct MobilEyeSpace_1D_50 *array = NULL;

	assert(maximumCount == ((int32_t)50));
	Object_ctor(&self->base);
	array = New_MobilEyeSpace_1D_50();
	(void)Assign_MobilEyeSpace_1D_50(&self->_items, array);
	(void)Assign_MobilEyeSpace_1D_50(&array, NULL);
	self->MaximumCount = maximumCount;
}

int32_t StaticList_7_get_Count(struct StaticList_7 *const self)
{
	return self->Count;
}

static void StaticList_7_CheckCount(struct StaticList_7 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_7_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_7_set_Count(struct StaticList_7 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_7_Add(struct StaticList_7 *const self, struct MobilEyeSpace *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_7_CheckCount(self);
	int32 = StaticList_7_get_Count(self);
	count = int32;
	(void)Assign_MobilEyeSpace(&self->_items->Elements[count], value);
	int32_1 = StaticList_7_get_Count(self);
	StaticList_7_set_Count(self, int32_1 + ((int32_t)1));
}

void StaticList_7_set_Item(struct StaticList_7 *const self, int32_t index, struct MobilEyeSpace *value)
{
	(void)Assign_MobilEyeSpace(&self->_items->Elements[index], value);
}

struct MobilEyeSpace *StaticList_7_get_Item(struct StaticList_7 *const self, int32_t index)
{
	struct MobilEyeSpace *result = NULL;

	(void)Assign_MobilEyeSpace(&result, self->_items->Elements[index]);
	return result;
}

static struct StaticList_7 *Tracking_1_Draw(struct Gaussian_2 *state, int32_t count)
{
	struct MatrixData_18 *x = NULL;
	struct PositiveDefiniteMatrix_3 *positiveDefiniteMatrix = NULL;
	struct SquareMatrix_3 *squareMatrix = NULL;
	struct MatrixData_15 *matrixData = NULL;
	struct MobilEyeSpace *mobilEyeSpace = NULL;
	int32_t int32 = ((int32_t)0);
	struct MatrixData_18 *matrixData_1 = NULL;
	struct MatrixData_18 *matrixData_2 = NULL;
	struct StaticList_7 *samples = NULL;
	struct StaticList_7 *staticList = NULL;
	int32_t i = ((int32_t)0);
	int32_t writeSampleIndex = ((int32_t)0);
	int32_t writeDimensionIndex = ((int32_t)0);
	int32_t readElementIndex = ((int32_t)0);
	struct MobilEyeSpace *CS_0_0001 = NULL;
	struct MobilEyeSpace *mobilEyeSpace_1 = NULL;
	struct float64_t_1D_4 *expectation = NULL;
	struct MatrixData_5 *matrixData_3 = NULL;
	struct float64_t_1D_4 *array = NULL;
	struct float64_t_1D_200 *matrix = NULL;
	struct float64_t_1D_200 *array_1 = NULL;
	struct MobilEyeSpace *CS_0_0002 = NULL;
	struct StaticList_7 *result = NULL;

	assert(count == ((int32_t)50));
	positiveDefiniteMatrix = Gaussian_2_get_Covariance(state);
	squareMatrix = PosiDefinMatri_3_get_CholeDecom(positiveDefiniteMatrix);
	matrixData = Matrix_3_get_MatrixData(&squareMatrix->base);
	mobilEyeSpace = Gaussian_2_get_Expectation(state);
	int32 = (&mobilEyeSpace->base)->Dimensions;
	matrixData_1 = Tracking_1_CreateRandnMatrix(int32, count);
	matrixData_2 = MatrixMath_Multiply_26(matrixData, matrixData_1);
	(void)Assign_MatrixData_18(&x, matrixData_2);
	(void)Assign_PositiveDefiniteMatrix_3(&positiveDefiniteMatrix, NULL);
	(void)Assign_SquareMatrix_3(&squareMatrix, NULL);
	(void)Assign_MatrixData_15(&matrixData, NULL);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
	(void)Assign_MatrixData_18(&matrixData_1, NULL);
	(void)Assign_MatrixData_18(&matrixData_2, NULL);
	staticList = New_StaticList_7();
	StaticList_7_ctor(staticList, count);
	(void)Assign_StaticList_7(&samples, staticList);
	(void)Assign_StaticList_7(&staticList, NULL);
	i = ((int32_t)0);
	while (i < count)
	{
		StaticList_7_Add(samples, NULL);
		i = i + ((int32_t)1);
	}
	writeSampleIndex = ((int32_t)0);
	writeDimensionIndex = ((int32_t)0);
	readElementIndex = ((int32_t)0);
	mobilEyeSpace_1 = Gaussian_2_get_Expectation(state);
	(void)Assign_MobilEyeSpace(&CS_0_0001, mobilEyeSpace_1);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace_1, NULL);
	matrixData_3 = Space_3_get_MatrixData(&(*&CS_0_0001)->base);
	array = MatrixData_5_get_DataReference(matrixData_3);
	(void)Assign_float64_t_1D_4(&expectation, array);
	(void)Assign_MatrixData_5(&matrixData_3, NULL);
	(void)Assign_float64_t_1D_4(&array, NULL);
	array_1 = MatrixData_18_get_DataReference(x);
	(void)Assign_float64_t_1D_200(&matrix, array_1);
	(void)Assign_float64_t_1D_200(&array_1, NULL);
	while (readElementIndex < (x->Rows * x->Columns))
	{
		struct MobilEyeSpace *mobilEyeSpace_2 = NULL;
		struct MatrixData_5 *matrixData_4 = NULL;
		struct float64_t_1D_4 *array_2 = NULL;
		int32_t int32_1 = ((int32_t)0);
		struct float64_t_1D_200 *array_3 = NULL;
		float64_t double_ = 0.0;
		int32_t int32_2 = ((int32_t)0);
		struct MobilEyeSpace *mobilEyeSpace_3 = NULL;

		if (!(writeDimensionIndex != ((int32_t)0)))
		{
			struct StaticList_7 *staticList_1 = NULL;
			int32_t int32_3 = ((int32_t)0);
			struct MobilEyeSpace *mobilEyeSpace_4 = NULL;

			(void)Assign_StaticList_7(&staticList_1, samples);
			int32_3 = writeSampleIndex;
			mobilEyeSpace_4 = New_MobilEyeSpace();
			MobilEyeSpace_ctor(mobilEyeSpace_4);
			StaticList_7_set_Item(staticList_1, int32_3, mobilEyeSpace_4);
			(void)Assign_StaticList_7(&staticList_1, NULL);
			(void)Assign_MobilEyeSpace(&mobilEyeSpace_4, NULL);
		}
		mobilEyeSpace_2 = StaticList_7_get_Item(samples, writeSampleIndex);
		(void)Assign_MobilEyeSpace(&CS_0_0002, mobilEyeSpace_2);
		(void)Assign_MobilEyeSpace(&mobilEyeSpace_2, NULL);
		matrixData_4 = Space_3_get_MatrixData(&(*&CS_0_0002)->base);
		array_2 = MatrixData_5_get_DataReference(matrixData_4);
		int32_1 = writeDimensionIndex;
		(void)Assign_float64_t_1D_200(&array_3, matrix);
		double_ = array_3->Elements[(*&readElementIndex)++];
		array_2->Elements[int32_1] = double_ + expectation->Elements[writeDimensionIndex];
		(void)Assign_MatrixData_5(&matrixData_4, NULL);
		(void)Assign_float64_t_1D_4(&array_2, NULL);
		(void)Assign_float64_t_1D_200(&array_3, NULL);
		writeDimensionIndex = writeDimensionIndex + ((int32_t)1);
		int32_2 = writeDimensionIndex;
		mobilEyeSpace_3 = Gaussian_2_get_Expectation(state);
		if (!((int32_2 % (&mobilEyeSpace_3->base)->Dimensions) != ((int32_t)0)))
		{
			(void)Assign_MobilEyeSpace(&mobilEyeSpace_3, NULL);
			writeDimensionIndex = ((int32_t)0);
			writeSampleIndex = writeSampleIndex + ((int32_t)1);
		}
		else
		{
			(void)Assign_MobilEyeSpace(&mobilEyeSpace_3, NULL);
		}
	}
	(void)Assign_StaticList_7(&result, samples);
	RemRef_MatrixData_18(x);
	RemRef_StaticList_7(samples);
	RemRef_MobilEyeSpace(CS_0_0001);
	RemRef_float64_t_1D_4(expectation);
	RemRef_float64_t_1D_200(matrix);
	RemRef_MobilEyeSpace(CS_0_0002);
	return result;
}

static void SampleSet_3_cctor(void)
{
	struct MobilEyeSpace *mobilEyeSpace = NULL;

	mobilEyeSpace = New_MobilEyeSpace();
	MobilEyeSpace_ctor(mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&SampleSet_3_EmptySample, mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
}

static void RemRef_SampleSet(struct SampleSet *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_SampleSet.CurrentCount--;
		Res_SampleSet.Next[Res_SampleSet.CurrentCount] = self;
		Del_SampleSet(self);
	}
}

struct SampleSet *New_SampleSet(void)
{
	static struct SampleSet const Default_SampleSet = { 1 };
	struct SampleSet *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_SampleSet.CurrentCount == RC_SampleSet)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_SampleSet.Next[Res_SampleSet.CurrentCount];
	Res_SampleSet.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_SampleSet.MaximumCount = (Res_SampleSet.CurrentCount > Res_SampleSet.MaximumCount) ? Res_SampleSet.CurrentCount : Res_SampleSet.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_SampleSet;
	return instance;
}

struct SampleSet *Assign_SampleSet(struct SampleSet **const left, struct SampleSet *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_SampleSet(*left);
	*left = right;
	return right;
}

int32_t StatiListFacto_1_get_MaximCount(struct StaticListFactory_1 *const self)
{
	return self->_maximumCount;
}

static void RemRef_StaticList_13(struct StaticList_13 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_13.CurrentCount--;
		Res_StaticList_13.Next[Res_StaticList_13.CurrentCount] = self;
		Del_StaticList_13(self);
	}
}

struct StaticList_13 *New_StaticList_13(void)
{
	static struct StaticList_13 const Default_StaticList_13 = { 1 };
	struct StaticList_13 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_13.CurrentCount == RC_StaticList_13)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_13.Next[Res_StaticList_13.CurrentCount];
	Res_StaticList_13.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_13.MaximumCount = (Res_StaticList_13.CurrentCount > Res_StaticList_13.MaximumCount) ? Res_StaticList_13.CurrentCount : Res_StaticList_13.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_13;
	return instance;
}

struct StaticList_13 *Assign_StaticList_13(struct StaticList_13 **const left, struct StaticList_13 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_13(*left);
	*left = right;
	return right;
}

static void RemRef_SampleProbabilityPair(struct SampleProbabilityPair *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_SampleProbabilityPair.CurrentCount--;
		Res_SampleProbabilityPair.Next[Res_SampleProbabilityPair.CurrentCount] = self;
		Del_SampleProbabilityPair(self);
	}
}

struct SampleProbabilityPair *New_SampleProbabilityPair(void)
{
	static struct SampleProbabilityPair const Default_SampleProbabilityPair = { 1 };
	struct SampleProbabilityPair *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_SampleProbabilityPair.CurrentCount == RC_SampleProbabilityPair)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_SampleProbabilityPair.Next[Res_SampleProbabilityPair.CurrentCount];
	Res_SampleProbabilityPair.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_SampleProbabilityPair.MaximumCount = (Res_SampleProbabilityPair.CurrentCount > Res_SampleProbabilityPair.MaximumCount) ? Res_SampleProbabilityPair.CurrentCount : Res_SampleProbabilityPair.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_SampleProbabilityPair;
	return instance;
}

struct SampleProbabilityPair *Assign_SampleProbabilityPair(struct SampleProbabilityPair **const left, struct SampleProbabilityPair *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_SampleProbabilityPair(*left);
	*left = right;
	return right;
}

static void Del_SampleProbabilityPair_1D_50(struct SampleProbabilityPair_1D_50 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)50);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_SampleProbabilityPair(self->Elements[i]);
	}
}

static void RemRef_SampleProbabilPair_1D_50(struct SampleProbabilityPair_1D_50 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_SampleProbabilityPair_1D_50.CurrentCount--;
		Res_SampleProbabilityPair_1D_50.Next[Res_SampleProbabilityPair_1D_50.CurrentCount] = self;
		Del_SampleProbabilityPair_1D_50(self);
	}
}

struct SampleProbabilityPair_1D_50 *New_SampleProbabilityPair_1D_50(void)
{
	static struct SampleProbabilityPair_1D_50 const Default_SampleProbabiPair_1D_50 = { 1 };
	struct SampleProbabilityPair_1D_50 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_SampleProbabilityPair_1D_50.CurrentCount == RC_SampleProbabilityPair_1D_50)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_SampleProbabilityPair_1D_50.Next[Res_SampleProbabilityPair_1D_50.CurrentCount];
	Res_SampleProbabilityPair_1D_50.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_SampleProbabilityPair_1D_50.MaximumCount = (Res_SampleProbabilityPair_1D_50.CurrentCount > Res_SampleProbabilityPair_1D_50.MaximumCount) ? Res_SampleProbabilityPair_1D_50.CurrentCount : Res_SampleProbabilityPair_1D_50.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_SampleProbabiPair_1D_50;
	return instance;
}

struct SampleProbabilityPair_1D_50 *Assign_SampleProbabilPair_1D_50(struct SampleProbabilityPair_1D_50 **const left, struct SampleProbabilityPair_1D_50 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_SampleProbabilPair_1D_50(*left);
	*left = right;
	return right;
}

void StaticList_13_ctor(struct StaticList_13 *const self, int32_t maximumCount)
{
	struct SampleProbabilityPair_1D_50 *array = NULL;

	assert(maximumCount == ((int32_t)50));
	Object_ctor(&self->base);
	array = New_SampleProbabilityPair_1D_50();
	(void)Assign_SampleProbabilPair_1D_50(&self->_items, array);
	(void)Assign_SampleProbabilPair_1D_50(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_13 *StaticListFactor_1_CreateInstan(struct StaticListFactory_1 *const self, int32_t capacity)
{
	struct StaticList_13 *result = NULL;
	struct StaticList_13 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_1_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_13();
	StaticList_13_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_13(&result, staticList);
	(void)Assign_StaticList_13(&staticList, NULL);
	return result;
}

static void SampleSet_set_Samples(struct SampleSet *const self, struct StaticList_13 *value)
{
	(void)Assign_StaticList_13(&self->Samples, value);
}

void SampleSet_ctor(struct SampleSet *const self, int32_t capacity, struct StaticListFactory_1 *listFactory)
{
	struct UniformRandomGenerator *uniformRandomGenerator = NULL;
	struct StaticListFactory_1 *arg_1F_1 = NULL;
	struct StaticList_13 *staticList = NULL;

	uniformRandomGenerator = New_UniformRandomGenerator();
	UniformRandomGenerator_ctor(uniformRandomGenerator);
	(void)Assign_UniformRandomGenerator(&self->_randomGenerator, uniformRandomGenerator);
	(void)Assign_UniformRandomGenerator(&uniformRandomGenerator, NULL);
	Object_ctor(&self->base);
	(void)Assign_StaticListFactory_1(&arg_1F_1, listFactory);
	(void)Assign_StaticListFactory_1(&self->_listFactory, arg_1F_1);
	staticList = StaticListFactor_1_CreateInstan(self->_listFactory, capacity);
	SampleSet_set_Samples(self, staticList);
	(void)Assign_StaticList_13(&staticList, NULL);
	RemRef_StaticListFactory_1(arg_1F_1);
}

void SampleSet_ctor_1(struct SampleSet *const self, struct StaticListFactory_1 *listFactory)
{
	SampleSet_ctor(self, ((int32_t)0), listFactory);
}

static void RemRef_StaticListEnumerator_3(struct StaticListEnumerator_3 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListEnumerator_3.CurrentCount--;
		Res_StaticListEnumerator_3.Next[Res_StaticListEnumerator_3.CurrentCount] = self;
		Del_StaticListEnumerator_3(self);
	}
}

struct StaticListEnumerator_3 *New_StaticListEnumerator_3(void)
{
	static struct StaticListEnumerator_3 const Default_StaticListEnumerator_3 = { 1 };
	struct StaticListEnumerator_3 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListEnumerator_3.CurrentCount == RC_StaticListEnumerator_3)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListEnumerator_3.Next[Res_StaticListEnumerator_3.CurrentCount];
	Res_StaticListEnumerator_3.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListEnumerator_3.MaximumCount = (Res_StaticListEnumerator_3.CurrentCount > Res_StaticListEnumerator_3.MaximumCount) ? Res_StaticListEnumerator_3.CurrentCount : Res_StaticListEnumerator_3.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListEnumerator_3;
	return instance;
}

struct StaticListEnumerator_3 *Assign_StaticListEnumerator_3(struct StaticListEnumerator_3 **const left, struct StaticListEnumerator_3 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListEnumerator_3(*left);
	*left = right;
	return right;
}

void StaticListEnumerator_3_ctor(struct StaticListEnumerator_3 *const self, struct StaticList_7 *list)
{
	self->_current = ((int32_t)-1);
	Object_ctor(&self->base);
	(void)Assign_StaticList_7(&self->_list, list);
}

struct StaticListEnumerator_3 *StaticList_7_GetEnumerator(struct StaticList_7 *const self)
{
	struct StaticListEnumerator_3 *result = NULL;
	struct StaticListEnumerator_3 *staticListEnumerator = NULL;

	staticListEnumerator = New_StaticListEnumerator_3();
	StaticListEnumerator_3_ctor(staticListEnumerator, self);
	(void)Assign_StaticListEnumerator_3(&result, staticListEnumerator);
	(void)Assign_StaticListEnumerator_3(&staticListEnumerator, NULL);
	return result;
}

bool_t StaticListEnumerator_3_MoveNext(struct StaticListEnumerator_3 *const self)
{
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	self->_current = self->_current + ((int32_t)1);
	int32 = self->_current;
	int32_1 = StaticList_7_get_Count(self->_list);
	return int32 != int32_1;
}

struct MobilEyeSpace *StaticListEnumera_3_get_Current(struct StaticListEnumerator_3 *const self)
{
	struct MobilEyeSpace *result = NULL;
	struct MobilEyeSpace *mobilEyeSpace = NULL;

	mobilEyeSpace = StaticList_7_get_Item(self->_list, self->_current);
	(void)Assign_MobilEyeSpace(&result, mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
	return result;
}

static struct MobilEyeSpace *Object_MemberwiseClone_2(struct MobilEyeSpace *const self)
{
	struct MobilEyeSpace *result;

	result = New_MobilEyeSpace();
	*result = *self;
	(&result->base.base)->ReferenceCount = ((int32_t)1);
	Clone_MobilEyeSpace(result);
	return result;
}

static void MatrixData_5_ctor_1(struct MatrixData_5 *const self, struct float64_t_1D_4 *data, int32_t rows, int32_t columns, bool_t takeDataOwnership)
{
	assert(rows == ((int32_t)4));
	assert(columns == ((int32_t)1));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	if (!(data != NULL))
	{
		abort();
	}
	if (!!takeDataOwnership)
	{
		(void)Assign_float64_t_1D_4(&self->_data, data);
	}
	else
	{
		struct float64_t_1D_4 *array = NULL;

		array = New_float64_t_1D_4();
		(void)Assign_float64_t_1D_4(&self->_data, array);
		(void)Assign_float64_t_1D_4(&array, NULL);
		(void)memcpy(&self->_data->Elements, &data->Elements, sizeof(float64_t) * ((int32_t)4));
	}
	self->Rows = rows;
	self->Columns = columns;
}

struct MatrixData_5 *MatrixData_5_get_Copy(struct MatrixData_5 *const self)
{
	struct MatrixData_5 *result = NULL;
	struct MatrixData_5 *matrixData = NULL;

	matrixData = New_MatrixData_5();
	MatrixData_5_ctor_1(matrixData, self->_data, self->Rows, self->Columns, false);
	(void)Assign_MatrixData_5(&result, matrixData);
	(void)Assign_MatrixData_5(&matrixData, NULL);
	return result;
}

static struct MobilEyeSpace *Space_3_ShallowCopy(struct MobilEyeSpace *const self)
{
	struct MobilEyeSpace *space = NULL;
	struct MobilEyeSpace *mobilEyeSpace = NULL;
	struct MobilEyeSpace *result = NULL;

	mobilEyeSpace = Object_MemberwiseClone_2(self);
	(void)Assign_MobilEyeSpace(&space, mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
	if (!!((&self->base)->_vector != NULL))
	{
		struct MobilEyeSpace *mobilEyeSpace_1 = NULL;
		struct MatrixData_5 *matrixData = NULL;

		(void)Assign_MobilEyeSpace(&mobilEyeSpace_1, space);
		matrixData = MatrixData_5_get_Copy((&self->base)->_vector);
		(void)Assign_MatrixData_5(&(&mobilEyeSpace_1->base)->_vector, matrixData);
		(void)Assign_MobilEyeSpace(&mobilEyeSpace_1, NULL);
		(void)Assign_MatrixData_5(&matrixData, NULL);
	}
	if (!!((&self->base)->_spaceInformationLock != NULL))
	{
		struct MobilEyeSpace *mobilEyeSpace_2 = NULL;
		struct Object *object = NULL;

		(void)Assign_MobilEyeSpace(&mobilEyeSpace_2, space);
		object = New_Object();
		Object_ctor(object);
		(void)Assign_Object(&(&mobilEyeSpace_2->base)->_spaceInformationLock, object);
		(void)Assign_MobilEyeSpace(&mobilEyeSpace_2, NULL);
		(void)Assign_Object(&object, NULL);
	}
	(void)Assign_MobilEyeSpace(&result, space);
	RemRef_MobilEyeSpace(space);
	return result;
}

struct MobilEyeSpace *SpaceExtensions_Clone_2(struct MobilEyeSpace *space)
{
	struct MobilEyeSpace *result = NULL;
	struct MobilEyeSpace *mobilEyeSpace = NULL;

	mobilEyeSpace = Space_3_ShallowCopy(space);
	(void)Assign_MobilEyeSpace(&result, mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
	return result;
}

static struct StaticList_13 *SampleSet_get_Samples(struct SampleSet *const self)
{
	struct StaticList_13 *result = NULL;

	(void)Assign_StaticList_13(&result, self->Samples);
	return result;
}

void SampleProbabilitPair_set_Sample(struct SampleProbabilityPair *const self, struct MobilEyeSpace *value)
{
	(void)Assign_MobilEyeSpace(&self->Sample, value);
}

void SampleProbabilPair_set_Probabil(struct SampleProbabilityPair *const self, float64_t value)
{
	self->Probability = value;
}

void SampleProbabilityPair_ctor(struct SampleProbabilityPair *const self, struct MobilEyeSpace *sample, float64_t probability)
{
	Object_ctor(&self->base);
	SampleProbabilitPair_set_Sample(self, sample);
	SampleProbabilPair_set_Probabil(self, probability);
}

int32_t StaticList_13_get_Count(struct StaticList_13 *const self)
{
	return self->Count;
}

static void StaticList_13_CheckCount(struct StaticList_13 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_13_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_13_set_Count(struct StaticList_13 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_13_Add(struct StaticList_13 *const self, struct SampleProbabilityPair *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_13_CheckCount(self);
	int32 = StaticList_13_get_Count(self);
	count = int32;
	(void)Assign_SampleProbabilityPair(&self->_items->Elements[count], value);
	int32_1 = StaticList_13_get_Count(self);
	StaticList_13_set_Count(self, int32_1 + ((int32_t)1));
}

void SampleSet_Add(struct SampleSet *const self, struct MobilEyeSpace *sample, float64_t probability)
{
	struct StaticList_13 *staticList = NULL;
	struct SampleProbabilityPair *sampleProbabilityPair = NULL;

	if (!(probability >= 0.0))
	{
		abort();
	}
	staticList = SampleSet_get_Samples(self);
	sampleProbabilityPair = New_SampleProbabilityPair();
	SampleProbabilityPair_ctor(sampleProbabilityPair, sample, probability);
	StaticList_13_Add(staticList, sampleProbabilityPair);
	(void)Assign_StaticList_13(&staticList, NULL);
	(void)Assign_SampleProbabilityPair(&sampleProbabilityPair, NULL);
}

void StaticListEnumerator_3_Dispose(struct StaticListEnumerator_3 *const self)
{
}

static void RemRef_StaticListEnumerator_8(struct StaticListEnumerator_8 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListEnumerator_8.CurrentCount--;
		Res_StaticListEnumerator_8.Next[Res_StaticListEnumerator_8.CurrentCount] = self;
		Del_StaticListEnumerator_8(self);
	}
}

struct StaticListEnumerator_8 *New_StaticListEnumerator_8(void)
{
	static struct StaticListEnumerator_8 const Default_StaticListEnumerator_8 = { 1 };
	struct StaticListEnumerator_8 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListEnumerator_8.CurrentCount == RC_StaticListEnumerator_8)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListEnumerator_8.Next[Res_StaticListEnumerator_8.CurrentCount];
	Res_StaticListEnumerator_8.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListEnumerator_8.MaximumCount = (Res_StaticListEnumerator_8.CurrentCount > Res_StaticListEnumerator_8.MaximumCount) ? Res_StaticListEnumerator_8.CurrentCount : Res_StaticListEnumerator_8.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListEnumerator_8;
	return instance;
}

struct StaticListEnumerator_8 *Assign_StaticListEnumerator_8(struct StaticListEnumerator_8 **const left, struct StaticListEnumerator_8 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListEnumerator_8(*left);
	*left = right;
	return right;
}

void StaticListEnumerator_8_ctor(struct StaticListEnumerator_8 *const self, struct StaticList_13 *list)
{
	self->_current = ((int32_t)-1);
	Object_ctor(&self->base);
	(void)Assign_StaticList_13(&self->_list, list);
}

struct StaticListEnumerator_8 *StaticList_13_GetEnumerator(struct StaticList_13 *const self)
{
	struct StaticListEnumerator_8 *result = NULL;
	struct StaticListEnumerator_8 *staticListEnumerator = NULL;

	staticListEnumerator = New_StaticListEnumerator_8();
	StaticListEnumerator_8_ctor(staticListEnumerator, self);
	(void)Assign_StaticListEnumerator_8(&result, staticListEnumerator);
	(void)Assign_StaticListEnumerator_8(&staticListEnumerator, NULL);
	return result;
}

bool_t StaticListEnumerator_8_MoveNext(struct StaticListEnumerator_8 *const self)
{
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	self->_current = self->_current + ((int32_t)1);
	int32 = self->_current;
	int32_1 = StaticList_13_get_Count(self->_list);
	return int32 != int32_1;
}

struct SampleProbabilityPair *StaticList_13_get_Item(struct StaticList_13 *const self, int32_t index)
{
	struct SampleProbabilityPair *result = NULL;

	(void)Assign_SampleProbabilityPair(&result, self->_items->Elements[index]);
	return result;
}

struct SampleProbabilityPair *StaticListEnumera_8_get_Current(struct StaticListEnumerator_8 *const self)
{
	struct SampleProbabilityPair *result = NULL;
	struct SampleProbabilityPair *sampleProbabilityPair = NULL;

	sampleProbabilityPair = StaticList_13_get_Item(self->_list, self->_current);
	(void)Assign_SampleProbabilityPair(&result, sampleProbabilityPair);
	(void)Assign_SampleProbabilityPair(&sampleProbabilityPair, NULL);
	return result;
}

float64_t SampleProbabilPair_get_Probabil(struct SampleProbabilityPair *const self)
{
	return self->Probability;
}

void StaticListEnumerator_8_Dispose(struct StaticListEnumerator_8 *const self)
{
}

int32_t SampleSet_get_Count(struct SampleSet *const self)
{
	int32_t result = ((int32_t)0);
	struct StaticList_13 *staticList = NULL;
	int32_t int32 = ((int32_t)0);

	staticList = SampleSet_get_Samples(self);
	int32 = StaticList_13_get_Count(staticList);
	result = int32;
	(void)Assign_StaticList_13(&staticList, NULL);
	return result;
}

void SampleSet_Normalize(struct SampleSet *const self)
{
	float64_t num = 0.0;
	struct StaticListEnumerator_8 *enumerator = NULL;
	struct StaticList_13 *staticList = NULL;
	struct StaticListEnumerator_8 *staticListEnumerator = NULL;
	struct SampleProbabilityPair *current = NULL;
	bool_t boolean = false;
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	struct SampleProbabilityPair *expr_B3 = NULL;
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	num = 0.0;
	staticList = SampleSet_get_Samples(self);
	staticListEnumerator = StaticList_13_GetEnumerator(staticList);
	(void)Assign_StaticListEnumerator_8(&enumerator, staticListEnumerator);
	(void)Assign_StaticList_13(&staticList, NULL);
	(void)Assign_StaticListEnumerator_8(&staticListEnumerator, NULL);
	boolean = StaticListEnumerator_8_MoveNext(enumerator);
	while (boolean)
	{
		struct SampleProbabilityPair *sampleProbabilityPair = NULL;
		float64_t double_ = 0.0;
		float64_t double__1 = 0.0;

		sampleProbabilityPair = StaticListEnumera_8_get_Current(enumerator);
		(void)Assign_SampleProbabilityPair(&current, sampleProbabilityPair);
		(void)Assign_SampleProbabilityPair(&sampleProbabilityPair, NULL);
		double_ = num;
		double__1 = SampleProbabilPair_get_Probabil(current);
		num = double_ + double__1;
		boolean = StaticListEnumerator_8_MoveNext(enumerator);
	}
	if (!!(enumerator != NULL))
	{
		StaticListEnumerator_8_Dispose(enumerator);
	}
	if (!(num != 0.0))
	{
		int32_t int32_2 = ((int32_t)0);
		int32_t int32_3 = ((int32_t)0);

		i = ((int32_t)0);
		int32_2 = i;
		int32_3 = SampleSet_get_Count(self);
		while (int32_2 < int32_3)
		{
			struct StaticList_13 *staticList_1 = NULL;
			struct SampleProbabilityPair *sampleProbabilityPair_1 = NULL;
			int32_t int32_4 = ((int32_t)0);

			staticList_1 = SampleSet_get_Samples(self);
			sampleProbabilityPair_1 = StaticList_13_get_Item(staticList_1, i);
			int32_4 = SampleSet_get_Count(self);
			SampleProbabilPair_set_Probabil(sampleProbabilityPair_1, 1.0 / (float64_t)int32_4);
			(void)Assign_StaticList_13(&staticList_1, NULL);
			(void)Assign_SampleProbabilityPair(&sampleProbabilityPair_1, NULL);
			i = i + ((int32_t)1);
			int32_2 = i;
			int32_3 = SampleSet_get_Count(self);
		}
		RemRef_StaticListEnumerator_8(enumerator);
		RemRef_SampleProbabilityPair(current);
		RemRef_SampleProbabilityPair(expr_B3);
		return;
	}
	if (!(num != 1.0))
	{
		RemRef_StaticListEnumerator_8(enumerator);
		RemRef_SampleProbabilityPair(current);
		RemRef_SampleProbabilityPair(expr_B3);
		return;
	}
	j = ((int32_t)0);
	int32 = j;
	int32_1 = SampleSet_get_Count(self);
	while (int32 < int32_1)
	{
		struct StaticList_13 *staticList_2 = NULL;
		struct SampleProbabilityPair *sampleProbabilityPair_2 = NULL;
		struct SampleProbabilityPair *sampleProbabilityPair_3 = NULL;
		float64_t double__2 = 0.0;

		staticList_2 = SampleSet_get_Samples(self);
		sampleProbabilityPair_2 = StaticList_13_get_Item(staticList_2, j);
		(void)Assign_SampleProbabilityPair(&expr_B3, sampleProbabilityPair_2);
		(void)Assign_StaticList_13(&staticList_2, NULL);
		(void)Assign_SampleProbabilityPair(&sampleProbabilityPair_2, NULL);
		(void)Assign_SampleProbabilityPair(&sampleProbabilityPair_3, expr_B3);
		double__2 = SampleProbabilPair_get_Probabil(expr_B3);
		SampleProbabilPair_set_Probabil(sampleProbabilityPair_3, double__2 / num);
		(void)Assign_SampleProbabilityPair(&sampleProbabilityPair_3, NULL);
		j = j + ((int32_t)1);
		int32 = j;
		int32_1 = SampleSet_get_Count(self);
	}
	RemRef_StaticListEnumerator_8(enumerator);
	RemRef_SampleProbabilityPair(current);
	RemRef_SampleProbabilityPair(expr_B3);
}

void SampleSet_ctor_2(struct SampleSet *const self, struct StaticList_7 *samples, struct StaticListFactory_1 *listFactory)
{
	struct StaticListEnumerator_3 *enumerator = NULL;
	struct StaticListEnumerator_3 *staticListEnumerator = NULL;
	struct MobilEyeSpace *current = NULL;
	bool_t boolean = false;

	SampleSet_ctor_1(self, listFactory);
	staticListEnumerator = StaticList_7_GetEnumerator(samples);
	(void)Assign_StaticListEnumerator_3(&enumerator, staticListEnumerator);
	(void)Assign_StaticListEnumerator_3(&staticListEnumerator, NULL);
	boolean = StaticListEnumerator_3_MoveNext(enumerator);
	while (boolean)
	{
		struct MobilEyeSpace *mobilEyeSpace = NULL;
		struct MobilEyeSpace *mobilEyeSpace_1 = NULL;

		mobilEyeSpace = StaticListEnumera_3_get_Current(enumerator);
		(void)Assign_MobilEyeSpace(&current, mobilEyeSpace);
		(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
		mobilEyeSpace_1 = SpaceExtensions_Clone_2(current);
		SampleSet_Add(self, mobilEyeSpace_1, 1.0);
		(void)Assign_MobilEyeSpace(&mobilEyeSpace_1, NULL);
		boolean = StaticListEnumerator_3_MoveNext(enumerator);
	}
	if (!!(enumerator != NULL))
	{
		StaticListEnumerator_3_Dispose(enumerator);
	}
	SampleSet_Normalize(self);
	RemRef_StaticListEnumerator_3(enumerator);
	RemRef_MobilEyeSpace(current);
}

void MarginalizedEvaluable_ctor(struct MarginalizedEvaluable *const self, struct MobilEyeDetectionModel *conditionalDistribution, struct SampleSet *condition)
{
	Object_ctor(&self->base);
	(void)Assign_MobilEyeDetectionModel(&self->_conditionalDistribution, conditionalDistribution);
	(void)Assign_SampleSet(&self->_condition, condition);
}

int32_t StaticList_22_get_Count(struct StaticList_22 *const self)
{
	return self->Count;
}

static void StaticList_22_CheckCount(struct StaticList_22 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_22_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_22_set_Count(struct StaticList_22 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_22_Add(struct StaticList_22 *const self, struct MarginalizedEvaluable *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_22_CheckCount(self);
	int32 = StaticList_22_get_Count(self);
	count = int32;
	(void)Assign_MarginalizedEvaluable(&self->_items->Elements[count], value);
	int32_1 = StaticList_22_get_Count(self);
	StaticList_22_set_Count(self, int32_1 + ((int32_t)1));
}

static void RemRef_ProbabilityGate(struct ProbabilityGate *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base)->ReferenceCount--;
	if ((&self->base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_ProbabilityGate.CurrentCount--;
		Res_ProbabilityGate.Next[Res_ProbabilityGate.CurrentCount] = self;
		Del_ProbabilityGate(self);
	}
}

struct ProbabilityGate *New_ProbabilityGate(void)
{
	static struct ProbabilityGate const Default_ProbabilityGate = { 1 };
	struct ProbabilityGate *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_ProbabilityGate.CurrentCount == RC_ProbabilityGate)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_ProbabilityGate.Next[Res_ProbabilityGate.CurrentCount];
	Res_ProbabilityGate.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_ProbabilityGate.MaximumCount = (Res_ProbabilityGate.CurrentCount > Res_ProbabilityGate.MaximumCount) ? Res_ProbabilityGate.CurrentCount : Res_ProbabilityGate.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_ProbabilityGate;
	return instance;
}

struct ProbabilityGate *Assign_ProbabilityGate(struct ProbabilityGate **const left, struct ProbabilityGate *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base)->ReferenceCount++;
	}
	RemRef_ProbabilityGate(*left);
	*left = right;
	return right;
}

static float64_t Gaussia_10_InverseNormalDistrib(float64_t y0)
{
	int32_t num = ((int32_t)0);
	float64_t num2 = 0.0;
	float64_t num3 = 0.0;
	float64_t num4 = 0.0;
	float64_t num5 = 0.0;
	float64_t num6 = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t num7 = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t num8 = 0.0;
	float64_t num9 = 0.0;
	float64_t num10 = 0.0;
	float64_t num11 = 0.0;
	float64_t num12 = 0.0;
	float64_t num13 = 0.0;

	if (!(y0 > 0.0))
	{
		return -1.7976931348623157E+308;
	}
	if (!(y0 < 1.0))
	{
		return 1.7976931348623157E+308;
	}
	num = ((int32_t)1);
	num2 = y0;
	if (!(num2 <= 0.8646647167633873))
	{
		num2 = 1.0 - num2;
		num = ((int32_t)0);
	}
	if (!(num2 <= 0.1353352832366127))
	{
		num2 = num2 - 0.5;
		num3 = num2 * num2;
		num4 = -59.963350101410789;
		num4 = 98.001075418599967 + (num3 * num4);
		num4 = -56.676285746907027 + (num3 * num4);
		num4 = 13.931260938727968 + (num3 * num4);
		num4 = -1.2391658386738125 + (num3 * num4);
		num5 = 1.0;
		num5 = 1.9544885833814176 + (num3 * num5);
		num5 = 4.6762791289888153 + (num3 * num5);
		num5 = 86.360242139089053 + (num3 * num5);
		num5 = -225.46268785411937 + (num3 * num5);
		num5 = 200.26021238006066 + (num3 * num5);
		num5 = -82.037225616833339 + (num3 * num5);
		num5 = 15.90562251262117 + (num3 * num5);
		num5 = -1.1833162112133 + (num3 * num5);
		num6 = num2 + (((num2 * num3) * num4) / num5);
		return num6 * 2.5066282746310007;
	}
	double_ = Math_Log(num2);
	double__1 = Math_Sqrt(-(2.0 * double_));
	num6 = double__1;
	double__2 = num6;
	double__3 = Math_Log(num6);
	num7 = double__2 - (double__3 / num6);
	num8 = 1.0 / num6;
	if (!(num6 >= 8.0))
	{
		num9 = 4.0554489230596245;
		num9 = 31.525109459989388 + (num8 * num9);
		num9 = 57.162819224642128 + (num8 * num9);
		num9 = 44.080507389320083 + (num8 * num9);
		num9 = 14.684956192885803 + (num8 * num9);
		num9 = 2.1866330685079025 + (num8 * num9);
		num9 = -0.14025607917135449 + (num8 * num9);
		num9 = -0.035042462682784818 + (num8 * num9);
		num9 = -0.00085745678515468545 + (num8 * num9);
		num10 = 1.0;
		num10 = 15.779988325646675 + (num8 * num10);
		num10 = 45.390763512887922 + (num8 * num10);
		num10 = 41.3172038254672 + (num8 * num10);
		num10 = 15.04253856929075 + (num8 * num10);
		num10 = 2.5046494620830941 + (num8 * num10);
		num10 = -0.14218292285478781 + (num8 * num10);
		num10 = -0.038080640769157834 + (num8 * num10);
		num10 = -0.00093325948089545755 + (num8 * num10);
		num11 = (num8 * num9) / num10;
	}
	else
	{
		num12 = 3.2377489177694603;
		num12 = 6.9152288906898418 + (num8 * num12);
		num12 = 3.9388102529247444 + (num8 * num12);
		num12 = 1.3330346081580755 + (num8 * num12);
		num12 = 0.20148538954917911 + (num8 * num12);
		num12 = 0.012371663481782003 + (num8 * num12);
		num12 = 0.00030158155350823543 + (num8 * num12);
		num12 = 2.658069746867375E-06 + (num8 * num12);
		num12 = 6.2397453918498331E-09 + (num8 * num12);
		num13 = 1.0;
		num13 = 6.02427039364742 + (num8 * num13);
		num13 = 3.6798356385616087 + (num8 * num13);
		num13 = 1.3770209948908132 + (num8 * num13);
		num13 = 0.21623699359449666 + (num8 * num13);
		num13 = 0.01342040060885432 + (num8 * num13);
		num13 = 0.00032801446468212774 + (num8 * num13);
		num13 = 2.8924786474538064E-06 + (num8 * num13);
		num13 = 6.7901940800998127E-09 + (num8 * num13);
		num11 = (num8 * num12) / num13;
	}
	num6 = num7 - num11;
	if (!!(num != ((int32_t)0)))
	{
		num6 = -num6;
	}
	return num6;
}

static float64_t Gaus_10_LnGammXGreaOrEquaMinu34(float64_t x)
{
	float64_t num = 0.0;
	float64_t num2 = 0.0;
	float64_t num3 = 0.0;
	float64_t num4 = 0.0;
	float64_t num5 = 0.0;
	float64_t num6 = 0.0;
	float64_t num7 = 0.0;
	float64_t num8 = 0.0;

	if (!(x >= 13.0))
	{
		float64_t double_ = 0.0;
		float64_t double__1 = 0.0;

		num = 1.0;
		num2 = 0.0;
		num3 = x;
		while (num3 >= 3.0)
		{
			num2 = num2 - 1.0;
			num3 = x + num2;
			num = num * num3;
		}
		while (num3 < 2.0)
		{
			num = num / num3;
			num2 = num2 + 1.0;
			num3 = x + num2;
		}
		double_ = Math_Abs(num);
		num = double_;
		if (!(num3 != 2.0))
		{
			float64_t double__2 = 0.0;

			double__2 = Math_Log(num);
			return double__2;
		}
		num2 = num2 - 2.0;
		x = x + num2;
		num4 = -1378.2515256912086;
		num4 = -38801.631513463784 + (x * num4);
		num4 = -331612.99273887119 + (x * num4);
		num4 = -1162370.9749276231 + (x * num4);
		num4 = -1721737.0082083966 + (x * num4);
		num4 = -853555.66424576542 + (x * num4);
		num5 = 1.0;
		num5 = -351.81570143652345 + (x * num5);
		num5 = -17064.210665188115 + (x * num5);
		num5 = -220528.59055385445 + (x * num5);
		num5 = -1139334.4436798252 + (x * num5);
		num5 = -2532523.0717758294 + (x * num5);
		num5 = -2018891.4143353277 + (x * num5);
		num2 = (x * num4) / num5;
		double__1 = Math_Log(num);
		return double__1 + num2;
	}
	else
	{
		float64_t double__3 = 0.0;
		float64_t double__4 = 0.0;
		float64_t double__5 = 0.0;

		double__3 = x - 0.5;
		double__4 = Math_Log(x);
		double__5 = double__3 * double__4;
		num6 = (double__5 - x) + 0.91893853320467278;
		if (!(x <= 100000000.0))
		{
			return num6;
		}
		num7 = 1.0 / (x * x);
		if (!(x < 1000.0))
		{
			return num6 + (((((0.00079365079365079376 * num7) - 0.0027777777777777779) * num7) + 0.083333333333333329) / x);
		}
		num8 = 0.00081161416747050838;
		num8 = -0.00059506190428430144 + (num7 * num8);
		num8 = 0.00079365034045771694 + (num7 * num8);
		num8 = -0.0027777777773009969 + (num7 * num8);
		num8 = 0.0833333333333332 + (num7 * num8);
		return num6 + (num8 / x);
	}
}

static float64_t Gaussian_10_LnGamma(float64_t x)
{
	float64_t num = 0.0;
	float64_t num2 = 0.0;
	float64_t double_ = 0.0;
	float64_t num3 = 0.0;
	float64_t double__1 = 0.0;
	float64_t num4 = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	float64_t double__5 = 0.0;

	if (!(x < -34.0))
	{
		float64_t double__6 = 0.0;

		double__6 = Gaus_10_LnGammXGreaOrEquaMinu34(x);
		return double__6;
	}
	num = -x;
	double_ = Gaus_10_LnGammXGreaOrEquaMinu34(num);
	num2 = double_;
	double__1 = Math_Floor(num);
	num3 = double__1;
	num4 = num - num3;
	if (!(num4 <= 0.5))
	{
		num3 = num3 + 1.0;
		num4 = num3 - num;
	}
	double__2 = num;
	double__3 = Math_Sin(3.1415926535897931 * num4);
	num4 = double__2 * double__3;
	double__4 = Math_Log(num4);
	double__5 = 1.1447298858494002 - double__4;
	return double__5 - num2;
}

static float64_t Ga_10_InGamIntXSmaTha1OrSmaThaA(float64_t a, float64_t x)
{
	float64_t num = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	float64_t num2 = 0.0;
	float64_t num3 = 0.0;
	float64_t num4 = 0.0;
	float64_t double__5 = 0.0;

	if (!!((x <= 0.0) | (a <= 0.0)))
	{
		return 0.0;
	}
	double_ = a;
	double__1 = Math_Log(x);
	double__2 = double_ * double__1;
	double__3 = double__2 - x;
	double__4 = Gaussian_10_LnGamma(a);
	num = double__3 - double__4;
	if (!(num >= -709.782712893384))
	{
		return 0.0;
	}
	num2 = a;
	num3 = 1.0;
	num4 = 1.0;
	while (true)
	{
		num2 = num2 + 1.0;
		num3 = (num3 * x) / num2;
		num4 = num4 + num3;
		if (!((num3 / num4) > 1E-15))
		{
			break;
		}
	}
	double__5 = Math_Exp(num);
	num = double__5;
	return (num4 * num) / a;
}

static float64_t Gauss_10_ComplIncompGammaIntegr(float64_t a, float64_t x)
{
	float64_t num = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	float64_t num2 = 0.0;
	float64_t num3 = 0.0;
	float64_t num4 = 0.0;
	float64_t num5 = 0.0;
	float64_t num6 = 0.0;
	float64_t num7 = 0.0;
	float64_t num8 = 0.0;
	float64_t num9 = 0.0;
	float64_t num10 = 0.0;
	float64_t num11 = 0.0;
	float64_t num12 = 0.0;
	float64_t num13 = 0.0;
	float64_t num14 = 0.0;
	float64_t double__5 = 0.0;

	if (!!((x <= 0.0) | (a <= 0.0)))
	{
		return 1.0;
	}
	if (!!((x < 1.0) | (x < a)))
	{
		float64_t double__6 = 0.0;

		double__6 = Ga_10_InGamIntXSmaTha1OrSmaThaA(a, x);
		return 1.0 - double__6;
	}
	double_ = a;
	double__1 = Math_Log(x);
	double__2 = double_ * double__1;
	double__3 = double__2 - x;
	double__4 = Gaussian_10_LnGamma(a);
	num = double__3 - double__4;
	if (!(num >= -709.782712893384))
	{
		return 0.0;
	}
	num2 = 1.0 - a;
	num3 = (x + num2) + 1.0;
	num4 = 0.0;
	num5 = 1.0;
	num6 = x;
	num7 = x + 1.0;
	num8 = num3 * x;
	num9 = num7 / num8;
	while (true)
	{
		float64_t double__7 = 0.0;

		num4 = num4 + 1.0;
		num2 = num2 + 1.0;
		num3 = num3 + 2.0;
		num10 = num2 * num4;
		num11 = (num7 * num3) - (num5 * num10);
		num12 = (num8 * num3) - (num6 * num10);
		if (!(num12 == 0.0))
		{
			float64_t double__8 = 0.0;

			num13 = num11 / num12;
			double__8 = Math_Abs((num9 - num13) / num13);
			num14 = double__8;
			num9 = num13;
		}
		else
		{
			num14 = 1.0;
		}
		num5 = num7;
		num7 = num11;
		num6 = num8;
		num8 = num12;
		double__7 = Math_Abs(num11);
		if (!(double__7 <= 4503599627370496.0))
		{
			num5 = num5 * 2.2204460492503131E-16;
			num7 = num7 * 2.2204460492503131E-16;
			num6 = num6 * 2.2204460492503131E-16;
			num8 = num8 * 2.2204460492503131E-16;
		}
		if (!(num14 > 1E-15))
		{
			break;
		}
	}
	double__5 = Math_Exp(num);
	num = double__5;
	return num9 * num;
}

static float64_t Gaus_10_InveCompIncomGammaInteg(float64_t a, float64_t y0)
{
	float64_t num = 0.0;
	float64_t num2 = 0.0;
	float64_t num3 = 0.0;
	float64_t num4 = 0.0;
	float64_t num5 = 0.0;
	float64_t num6 = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t num7 = 0.0;
	float64_t num8 = 0.0;
	float64_t double__3 = 0.0;
	int32_t i = ((int32_t)0);
	int32_t num9 = ((int32_t)0);

	num = 4503599627370496.0;
	num2 = 0.0;
	num3 = 0.0;
	num4 = 1.0;
	num5 = 1.0 / (9.0 * a);
	double_ = 1.0 - num5;
	double__1 = Gaussia_10_InverseNormalDistrib(y0);
	double__2 = Math_Sqrt(num5);
	num6 = double_ - (double__1 * double__2);
	num7 = ((a * num6) * num6) * num6;
	double__3 = Gaussian_10_LnGamma(a);
	num8 = double__3;
	i = ((int32_t)0);
	while (i < ((int32_t)10))
	{
		float64_t double__4 = 0.0;
		float64_t double__5 = 0.0;
		float64_t double__6 = 0.0;
		float64_t double__7 = 0.0;
		float64_t double__8 = 0.0;
		float64_t double__9 = 0.0;
		float64_t double__10 = 0.0;

		if (!!((num7 > num) | (num7 < num3)))
		{
			num5 = 0.0625;
			break;
		}
		double__4 = Gauss_10_ComplIncompGammaIntegr(a, num7);
		num6 = double__4;
		if (!!((num6 < num2) | (num6 > num4)))
		{
			num5 = 0.0625;
			break;
		}
		if (!(num6 >= y0))
		{
			num = num7;
			num2 = num6;
		}
		else
		{
			num3 = num7;
			num4 = num6;
		}
		double__5 = a - 1.0;
		double__6 = Math_Log(num7);
		double__7 = double__5 * double__6;
		double__8 = double__7 - num7;
		num5 = double__8 - num8;
		if (!(num5 >= -709.782712893384))
		{
			num5 = 0.0625;
			break;
		}
		double__9 = Math_Exp(num5);
		num5 = -double__9;
		num5 = (num6 - y0) / num5;
		double__10 = Math_Abs(num5 / num7);
		if (!(double__10 >= 1E-15))
		{
			return num7;
		}
		num7 = num7 - num5;
		i = i + ((int32_t)1);
	}
	if (!(num != 4503599627370496.0))
	{
		float64_t double__11 = 0.0;

		if (!(num7 > 0.0))
		{
			num7 = 1.0;
		}
		num7 = (1.0 + num5) * num7;
		double__11 = Gauss_10_ComplIncompGammaIntegr(a, num7);
		num6 = double__11;
		if (!(num6 >= y0))
		{
			num = num7;
			num2 = num6;
		}
	}
	num5 = 0.5;
	num9 = ((int32_t)0);
	i = ((int32_t)0);
	while (i < ((int32_t)400))
	{
		float64_t double__12 = 0.0;
		float64_t double__13 = 0.0;
		float64_t double__14 = 0.0;
		bool_t boolean = false;

		num7 = num3 + (num5 * (num - num3));
		double__12 = Gauss_10_ComplIncompGammaIntegr(a, num7);
		num6 = double__12;
		num8 = (num - num3) / (num3 + num);
		double__13 = Math_Abs(num8);
		if (!!(double__13 < 5.0000000000000008E-15))
		{
			break;
		}
		num8 = (num6 - y0) / y0;
		double__14 = Math_Abs(num8);
		boolean = double__14 < 5.0000000000000008E-15;
		if (!!(boolean || (num7 <= 0.0)))
		{
			break;
		}
		if (!(num6 < y0))
		{
			num3 = num7;
			num4 = num6;
			if (!(num9 >= ((int32_t)0)))
			{
				num9 = ((int32_t)0);
				num5 = 0.5;
			}
			else
			{
				if (!(num9 <= ((int32_t)1)))
				{
					num5 = (0.5 * num5) + 0.5;
				}
				else
				{
					num5 = (y0 - num2) / (num4 - num2);
				}
			}
			num9 = num9 + ((int32_t)1);
		}
		else
		{
			num = num7;
			num2 = num6;
			if (!(num9 <= ((int32_t)0)))
			{
				num9 = ((int32_t)0);
				num5 = 0.5;
			}
			else
			{
				if (!(num9 >= ((int32_t)-1)))
				{
					num5 = 0.5 * num5;
				}
				else
				{
					num5 = (y0 - num2) / (num4 - num2);
				}
			}
			num9 = num9 - ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	return num7;
}

float64_t Gaus_10_GetMaximMahalDistaSquar(float64_t gateProbability)
{
	float64_t double_ = 0.0;

	if (!((gateProbability >= 0.0) && (gateProbability <= 1.0)))
	{
		abort();
	}
	double_ = Gaus_10_InveCompIncomGammaInteg(0.5 * (float64_t)(&Gaussian_10_EmptySpace->base)->Dimensions, 1.0 - gateProbability);
	return 2.0 * double_;
}

static void RemRef_SquaredMahalanobDistance(struct SquaredMahalanobisDistance *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_SquaredMahalanobisDistance.CurrentCount--;
		Res_SquaredMahalanobisDistance.Next[Res_SquaredMahalanobisDistance.CurrentCount] = self;
		Del_SquaredMahalanobisDistance(self);
	}
}

struct SquaredMahalanobisDistance *New_SquaredMahalanobisDistance(void)
{
	static struct SquaredMahalanobisDistance const Default_SquaredMahalanoDistance = { 1 };
	struct SquaredMahalanobisDistance *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_SquaredMahalanobisDistance.CurrentCount == RC_SquaredMahalanobisDistance)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_SquaredMahalanobisDistance.Next[Res_SquaredMahalanobisDistance.CurrentCount];
	Res_SquaredMahalanobisDistance.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_SquaredMahalanobisDistance.MaximumCount = (Res_SquaredMahalanobisDistance.CurrentCount > Res_SquaredMahalanobisDistance.MaximumCount) ? Res_SquaredMahalanobisDistance.CurrentCount : Res_SquaredMahalanobisDistance.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_SquaredMahalanoDistance;
	return instance;
}

struct SquaredMahalanobisDistance *Assign_SquaredMahalanobDistance(struct SquaredMahalanobisDistance **const left, struct SquaredMahalanobisDistance *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_SquaredMahalanobDistance(*left);
	*left = right;
	return right;
}

void SquaredMahalanobisDistance_ctor(struct SquaredMahalanobisDistance *const self)
{
	Object_ctor(&self->base);
}

static void RemRef_IMetric(struct IMetric *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_IMetric.CurrentCount--;
		Res_IMetric.Next[Res_IMetric.CurrentCount] = self;
		Del_IMetric(self);
	}
}

struct IMetric *New_IMetric(void)
{
	static struct IMetric const Default_IMetric = { 1 };
	struct IMetric *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_IMetric.CurrentCount == RC_IMetric)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_IMetric.Next[Res_IMetric.CurrentCount];
	Res_IMetric.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_IMetric.MaximumCount = (Res_IMetric.CurrentCount > Res_IMetric.MaximumCount) ? Res_IMetric.CurrentCount : Res_IMetric.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_IMetric;
	return instance;
}

struct IMetric *Assign_IMetric(struct IMetric **const left, struct IMetric *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_IMetric(*left);
	*left = right;
	return right;
}

static void Gate_set_MaximumDistance(struct Gate *const self, float64_t value)
{
	self->MaximumDistance = value;
}

void Gate_ctor(struct Gate *const self, struct SquaredMahalanobisDistance *metric, float64_t maximumDistance)
{
	if (!(metric != NULL))
	{
		abort();
	}
	Object_ctor(&self->base);
	(void)Assign_SquaredMahalanobDistance(&self->_metric, metric);
	Gate_set_MaximumDistance(self, maximumDistance);
}

static void GaussianGate_set_GateProbabilit(struct GaussianGate *const self, float64_t value)
{
	self->GateProbability = value;
}

static void GaussianGate_ctor(struct GaussianGate *const self, float64_t maxSquaredMahalanobisDistance, float64_t gateProbability)
{
	struct SquaredMahalanobisDistance *squaredMahalanobisDistance = NULL;

	squaredMahalanobisDistance = New_SquaredMahalanobisDistance();
	SquaredMahalanobisDistance_ctor(squaredMahalanobisDistance);
	Gate_ctor(&self->base, squaredMahalanobisDistance, maxSquaredMahalanobisDistance);
	(void)Assign_SquaredMahalanobDistance(&squaredMahalanobisDistance, NULL);
	if (!(maxSquaredMahalanobisDistance >= 0.0))
	{
		abort();
	}
	if (!((gateProbability >= 0.0) && (gateProbability <= 1.0)))
	{
		abort();
	}
	GaussianGate_set_GateProbabilit(self, gateProbability);
}

void ProbabilityGate_ctor(struct ProbabilityGate *const self, float64_t gateProbability)
{
	float64_t double_ = 0.0;

	double_ = Gaus_10_GetMaximMahalDistaSquar(gateProbability);
	GaussianGate_ctor(&self->base, double_, gateProbability);
}

static void MultipLocalNearesNeighb_1_cctor(void)
{
}

static void RemRef_MultipLocalNearesNeighbo(struct MultipleLocalNearestNeighbor *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MultiplLocalNearestNeighbor.CurrentCount--;
		Res_MultiplLocalNearestNeighbor.Next[Res_MultiplLocalNearestNeighbor.CurrentCount] = self;
		Del_MultiplLocalNearestNeighbor(self);
	}
}

struct MultipleLocalNearestNeighbor *New_MultiplLocalNearestNeighbor(void)
{
	static struct MultipleLocalNearestNeighbor const Defaul_MultipLocalNearesNeighbo = { 1 };
	struct MultipleLocalNearestNeighbor *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MultiplLocalNearestNeighbor.CurrentCount == RC_MultipleLocalNearestNeighbor)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MultiplLocalNearestNeighbor.Next[Res_MultiplLocalNearestNeighbor.CurrentCount];
	Res_MultiplLocalNearestNeighbor.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MultiplLocalNearestNeighbor.MaximumCount = (Res_MultiplLocalNearestNeighbor.CurrentCount > Res_MultiplLocalNearestNeighbor.MaximumCount) ? Res_MultiplLocalNearestNeighbor.CurrentCount : Res_MultiplLocalNearestNeighbor.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Defaul_MultipLocalNearesNeighbo;
	return instance;
}

struct MultipleLocalNearestNeighbor *Assign_MultipLocalNearesNeighbo(struct MultipleLocalNearestNeighbor **const left, struct MultipleLocalNearestNeighbor *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MultipLocalNearesNeighbo(*left);
	*left = right;
	return right;
}

void MultiplLocalNearestNeighbo_ctor(struct MultipleLocalNearestNeighbor *const self, struct StatiIPDATrackColleFactorProvid *factoryProvider)
{
	struct StatiIPDATrackColleFactorProvid *arg_14_1 = NULL;

	Object_ctor(&self->base);
	(void)Assi_StatIPDATracCollFactoProvi(&arg_14_1, factoryProvider);
	(void)Assi_StatIPDATracCollFactoProvi(&self->_factoryProvider, arg_14_1);
	RemRef_StatIPDATracCollFactProv(arg_14_1);
}

static void RemRef_IEnumerable(struct IEnumerable *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_IEnumerable.CurrentCount--;
		Res_IEnumerable.Next[Res_IEnumerable.CurrentCount] = self;
		Del_IEnumerable(self);
	}
}

struct IEnumerable *New_IEnumerable(void)
{
	static struct IEnumerable const Default_IEnumerable = { 1 };
	struct IEnumerable *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_IEnumerable.CurrentCount == RC_IEnumerable)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_IEnumerable.Next[Res_IEnumerable.CurrentCount];
	Res_IEnumerable.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_IEnumerable.MaximumCount = (Res_IEnumerable.CurrentCount > Res_IEnumerable.MaximumCount) ? Res_IEnumerable.CurrentCount : Res_IEnumerable.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_IEnumerable;
	return instance;
}

struct IEnumerable *Assign_IEnumerable(struct IEnumerable **const left, struct IEnumerable *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_IEnumerable(*left);
	*left = right;
	return right;
}

static void RemRef_IEnumerable_1(struct IEnumerable_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_IEnumerable_1.CurrentCount--;
		Res_IEnumerable_1.Next[Res_IEnumerable_1.CurrentCount] = self;
		Del_IEnumerable_1(self);
	}
}

struct IEnumerable_1 *New_IEnumerable_1(void)
{
	static struct IEnumerable_1 const Default_IEnumerable_1 = { 1 };
	struct IEnumerable_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_IEnumerable_1.CurrentCount == RC_IEnumerable_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_IEnumerable_1.Next[Res_IEnumerable_1.CurrentCount];
	Res_IEnumerable_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_IEnumerable_1.MaximumCount = (Res_IEnumerable_1.CurrentCount > Res_IEnumerable_1.MaximumCount) ? Res_IEnumerable_1.CurrentCount : Res_IEnumerable_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_IEnumerable_1;
	return instance;
}

struct IEnumerable_1 *Assign_IEnumerable_1(struct IEnumerable_1 **const left, struct IEnumerable_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_IEnumerable_1(*left);
	*left = right;
	return right;
}

static void RemRef_IEnumerable_2(struct IEnumerable_2 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_IEnumerable_2.CurrentCount--;
		Res_IEnumerable_2.Next[Res_IEnumerable_2.CurrentCount] = self;
		Del_IEnumerable_2(self);
	}
}

struct IEnumerable_2 *New_IEnumerable_2(void)
{
	static struct IEnumerable_2 const Default_IEnumerable_2 = { 1 };
	struct IEnumerable_2 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_IEnumerable_2.CurrentCount == RC_IEnumerable_2)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_IEnumerable_2.Next[Res_IEnumerable_2.CurrentCount];
	Res_IEnumerable_2.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_IEnumerable_2.MaximumCount = (Res_IEnumerable_2.CurrentCount > Res_IEnumerable_2.MaximumCount) ? Res_IEnumerable_2.CurrentCount : Res_IEnumerable_2.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_IEnumerable_2;
	return instance;
}

struct IEnumerable_2 *Assign_IEnumerable_2(struct IEnumerable_2 **const left, struct IEnumerable_2 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_IEnumerable_2(*left);
	*left = right;
	return right;
}

static void RemRef_IAssociationAlgorithm(struct IAssociationAlgorithm *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_IAssociationAlgorithm.CurrentCount--;
		Res_IAssociationAlgorithm.Next[Res_IAssociationAlgorithm.CurrentCount] = self;
		Del_IAssociationAlgorithm(self);
	}
}

struct IAssociationAlgorithm *New_IAssociationAlgorithm(void)
{
	static struct IAssociationAlgorithm const Default_IAssociationAlgorithm = { 1 };
	struct IAssociationAlgorithm *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_IAssociationAlgorithm.CurrentCount == RC_IAssociationAlgorithm)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_IAssociationAlgorithm.Next[Res_IAssociationAlgorithm.CurrentCount];
	Res_IAssociationAlgorithm.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_IAssociationAlgorithm.MaximumCount = (Res_IAssociationAlgorithm.CurrentCount > Res_IAssociationAlgorithm.MaximumCount) ? Res_IAssociationAlgorithm.CurrentCount : Res_IAssociationAlgorithm.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_IAssociationAlgorithm;
	return instance;
}

struct IAssociationAlgorithm *Assign_IAssociationAlgorithm(struct IAssociationAlgorithm **const left, struct IAssociationAlgorithm *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_IAssociationAlgorithm(*left);
	*left = right;
	return right;
}

static void RemRef_MeasurementAssociation(struct MeasurementAssociation *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_MeasurementAssociation.CurrentCount--;
		Res_MeasurementAssociation.Next[Res_MeasurementAssociation.CurrentCount] = self;
		Del_MeasurementAssociation(self);
	}
}

struct MeasurementAssociation *New_MeasurementAssociation(void)
{
	static struct MeasurementAssociation const Default_MeasurementAssociation = { 1 };
	struct MeasurementAssociation *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MeasurementAssociation.CurrentCount == RC_MeasurementAssociation)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MeasurementAssociation.Next[Res_MeasurementAssociation.CurrentCount];
	Res_MeasurementAssociation.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MeasurementAssociation.MaximumCount = (Res_MeasurementAssociation.CurrentCount > Res_MeasurementAssociation.MaximumCount) ? Res_MeasurementAssociation.CurrentCount : Res_MeasurementAssociation.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MeasurementAssociation;
	return instance;
}

struct MeasurementAssociation *Assign_MeasurementAssociation(struct MeasurementAssociation **const left, struct MeasurementAssociation *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_MeasurementAssociation(*left);
	*left = right;
	return right;
}

struct StaticListFactory_4 *StIPDATrCoFacPro_get_Obj1LisFac(struct StatiIPDATrackColleFactorProvid *const self)
{
	struct StaticListFactory_4 *result = NULL;

	(void)Assign_StaticListFactory_4(&result, self->_trackListFactory);
	return result;
}

static void Association_set_Objects1(struct Association *const self, struct StaticList_20 *value)
{
	(void)Assign_StaticList_20(&self->Objects1, value);
}

struct StaticListFactory_5 *StIPDATrCoFacPro_get_Obj2LisFac(struct StatiIPDATrackColleFactorProvid *const self)
{
	struct StaticListFactory_5 *result = NULL;

	(void)Assign_StaticListFactory_5(&result, self->_measurementListFactory);
	return result;
}

int32_t StatiListFacto_5_get_MaximCount(struct StaticListFactory_5 *const self)
{
	return self->_maximumCount;
}

struct StaticList_6 *StaticListFactor_5_CreateInstan(struct StaticListFactory_5 *const self, int32_t capacity)
{
	struct StaticList_6 *result = NULL;
	struct StaticList_6 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_5_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_6();
	StaticList_6_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_6(&result, staticList);
	(void)Assign_StaticList_6(&staticList, NULL);
	return result;
}

static void Association_set_Objects2(struct Association *const self, struct StaticList_6 *value)
{
	(void)Assign_StaticList_6(&self->Objects2, value);
}

static void RemRef_StaticListEnumerator_12(struct StaticListEnumerator_12 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListEnumerator_12.CurrentCount--;
		Res_StaticListEnumerator_12.Next[Res_StaticListEnumerator_12.CurrentCount] = self;
		Del_StaticListEnumerator_12(self);
	}
}

struct StaticListEnumerator_12 *New_StaticListEnumerator_12(void)
{
	static struct StaticListEnumerator_12 const Default_StaticListEnumerator_12 = { 1 };
	struct StaticListEnumerator_12 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListEnumerator_12.CurrentCount == RC_StaticListEnumerator_12)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListEnumerator_12.Next[Res_StaticListEnumerator_12.CurrentCount];
	Res_StaticListEnumerator_12.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListEnumerator_12.MaximumCount = (Res_StaticListEnumerator_12.CurrentCount > Res_StaticListEnumerator_12.MaximumCount) ? Res_StaticListEnumerator_12.CurrentCount : Res_StaticListEnumerator_12.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListEnumerator_12;
	return instance;
}

struct StaticListEnumerator_12 *Assign_StaticListEnumerator_12(struct StaticListEnumerator_12 **const left, struct StaticListEnumerator_12 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListEnumerator_12(*left);
	*left = right;
	return right;
}

void StaticListEnumerator_12_ctor(struct StaticListEnumerator_12 *const self, struct StaticList_20 *list)
{
	self->_current = ((int32_t)-1);
	Object_ctor(&self->base);
	(void)Assign_StaticList_20(&self->_list, list);
}

struct StaticListEnumerator_12 *StaticList_20_GetEnumerator(struct StaticList_20 *const self)
{
	struct StaticListEnumerator_12 *result = NULL;
	struct StaticListEnumerator_12 *staticListEnumerator = NULL;

	staticListEnumerator = New_StaticListEnumerator_12();
	StaticListEnumerator_12_ctor(staticListEnumerator, self);
	(void)Assign_StaticListEnumerator_12(&result, staticListEnumerator);
	(void)Assign_StaticListEnumerator_12(&staticListEnumerator, NULL);
	return result;
}

bool_t StaticListEnumerato_12_MoveNext(struct StaticListEnumerator_12 *const self)
{
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	self->_current = self->_current + ((int32_t)1);
	int32 = self->_current;
	int32_1 = StaticList_20_get_Count(self->_list);
	return int32 != int32_1;
}

struct Gaussian_2 *StaticList_20_get_Item(struct StaticList_20 *const self, int32_t index)
{
	struct Gaussian_2 *result = NULL;

	(void)Assign_Gaussian_2(&result, self->_items->Elements[index]);
	return result;
}

struct Gaussian_2 *StaticListEnumer_12_get_Current(struct StaticListEnumerator_12 *const self)
{
	struct Gaussian_2 *result = NULL;
	struct Gaussian_2 *gaussian = NULL;

	gaussian = StaticList_20_get_Item(self->_list, self->_current);
	(void)Assign_Gaussian_2(&result, gaussian);
	(void)Assign_Gaussian_2(&gaussian, NULL);
	return result;
}

static struct StaticList_20 *Association_get_Objects1(struct Association *const self)
{
	struct StaticList_20 *result = NULL;

	(void)Assign_StaticList_20(&result, self->Objects1);
	return result;
}

void StaticListEnumerator_12_Dispose(struct StaticListEnumerator_12 *const self)
{
}

static void RemRef_StaticListEnumerator_2(struct StaticListEnumerator_2 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListEnumerator_2.CurrentCount--;
		Res_StaticListEnumerator_2.Next[Res_StaticListEnumerator_2.CurrentCount] = self;
		Del_StaticListEnumerator_2(self);
	}
}

struct StaticListEnumerator_2 *New_StaticListEnumerator_2(void)
{
	static struct StaticListEnumerator_2 const Default_StaticListEnumerator_2 = { 1 };
	struct StaticListEnumerator_2 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListEnumerator_2.CurrentCount == RC_StaticListEnumerator_2)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListEnumerator_2.Next[Res_StaticListEnumerator_2.CurrentCount];
	Res_StaticListEnumerator_2.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListEnumerator_2.MaximumCount = (Res_StaticListEnumerator_2.CurrentCount > Res_StaticListEnumerator_2.MaximumCount) ? Res_StaticListEnumerator_2.CurrentCount : Res_StaticListEnumerator_2.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListEnumerator_2;
	return instance;
}

struct StaticListEnumerator_2 *Assign_StaticListEnumerator_2(struct StaticListEnumerator_2 **const left, struct StaticListEnumerator_2 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListEnumerator_2(*left);
	*left = right;
	return right;
}

void StaticListEnumerator_2_ctor(struct StaticListEnumerator_2 *const self, struct StaticList_6 *list)
{
	self->_current = ((int32_t)-1);
	Object_ctor(&self->base);
	(void)Assign_StaticList_6(&self->_list, list);
}

struct StaticListEnumerator_2 *StaticList_6_GetEnumerator(struct StaticList_6 *const self)
{
	struct StaticListEnumerator_2 *result = NULL;
	struct StaticListEnumerator_2 *staticListEnumerator = NULL;

	staticListEnumerator = New_StaticListEnumerator_2();
	StaticListEnumerator_2_ctor(staticListEnumerator, self);
	(void)Assign_StaticListEnumerator_2(&result, staticListEnumerator);
	(void)Assign_StaticListEnumerator_2(&staticListEnumerator, NULL);
	return result;
}

bool_t StaticListEnumerator_2_MoveNext(struct StaticListEnumerator_2 *const self)
{
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	self->_current = self->_current + ((int32_t)1);
	int32 = self->_current;
	int32_1 = StaticList_6_get_Count(self->_list);
	return int32 != int32_1;
}

struct MobilEyeSpace *StaticList_6_get_Item(struct StaticList_6 *const self, int32_t index)
{
	struct MobilEyeSpace *result = NULL;

	(void)Assign_MobilEyeSpace(&result, self->_items->Elements[index]);
	return result;
}

struct MobilEyeSpace *StaticListEnumera_2_get_Current(struct StaticListEnumerator_2 *const self)
{
	struct MobilEyeSpace *result = NULL;
	struct MobilEyeSpace *mobilEyeSpace = NULL;

	mobilEyeSpace = StaticList_6_get_Item(self->_list, self->_current);
	(void)Assign_MobilEyeSpace(&result, mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
	return result;
}

static struct StaticList_6 *Association_get_Objects2(struct Association *const self)
{
	struct StaticList_6 *result = NULL;

	(void)Assign_StaticList_6(&result, self->Objects2);
	return result;
}

void StaticListEnumerator_2_Dispose(struct StaticListEnumerator_2 *const self)
{
}

struct StaticAssociationTableFactory *StIPDATrColFacPro_get_AssTabFac(struct StatiIPDATrackColleFactorProvid *const self)
{
	struct StaticAssociationTableFactory *result = NULL;

	(void)Assign_StaticAssociTableFactory(&result, self->_associationTableFactory);
	return result;
}

int32_t StatAssoTablFacto_get_MaximRows(struct StaticAssociationTableFactory *const self)
{
	return self->_maximumRows;
}

int32_t StatAssoTablFact_get_MaximColum(struct StaticAssociationTableFactory *const self)
{
	return self->_maximumColumns;
}

static void RemRef_AssociationTable(struct AssociationTable *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_AssociationTable.CurrentCount--;
		Res_AssociationTable.Next[Res_AssociationTable.CurrentCount] = self;
		Del_AssociationTable(self);
	}
}

struct AssociationTable *New_AssociationTable(void)
{
	static struct AssociationTable const Default_AssociationTable = { 1 };
	struct AssociationTable *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_AssociationTable.CurrentCount == RC_AssociationTable)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_AssociationTable.Next[Res_AssociationTable.CurrentCount];
	Res_AssociationTable.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_AssociationTable.MaximumCount = (Res_AssociationTable.CurrentCount > Res_AssociationTable.MaximumCount) ? Res_AssociationTable.CurrentCount : Res_AssociationTable.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_AssociationTable;
	return instance;
}

struct AssociationTable *Assign_AssociationTable(struct AssociationTable **const left, struct AssociationTable *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_AssociationTable(*left);
	*left = right;
	return right;
}

static void Del_float64_t_2D_15_40(struct float64_t_2D_15_40 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_2D_15_40(struct float64_t_2D_15_40 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_2D_15_40.CurrentCount--;
		Res_float64_t_2D_15_40.Next[Res_float64_t_2D_15_40.CurrentCount] = self;
		Del_float64_t_2D_15_40(self);
	}
}

struct float64_t_2D_15_40 *New_float64_t_2D_15_40(void)
{
	static struct float64_t_2D_15_40 const Default_float64_t_2D_15_40 = { 1 };
	struct float64_t_2D_15_40 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_2D_15_40.CurrentCount == RC_float64_t_2D_15_40)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_2D_15_40.Next[Res_float64_t_2D_15_40.CurrentCount];
	Res_float64_t_2D_15_40.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_2D_15_40.MaximumCount = (Res_float64_t_2D_15_40.CurrentCount > Res_float64_t_2D_15_40.MaximumCount) ? Res_float64_t_2D_15_40.CurrentCount : Res_float64_t_2D_15_40.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_2D_15_40;
	return instance;
}

struct float64_t_2D_15_40 *Assign_float64_t_2D_15_40(struct float64_t_2D_15_40 **const left, struct float64_t_2D_15_40 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_2D_15_40(*left);
	*left = right;
	return right;
}

static void AssociationTable_ctor(struct AssociationTable *const self, int32_t rows, int32_t columns, int32_t maximumNumberOfRows, int32_t maximumNumberOfColumns)
{
	struct float64_t_2D_15_40 *array = NULL;

	assert(maximumNumberOfRows == ((int32_t)15));
	assert(maximumNumberOfColumns == ((int32_t)40));
	if (!(rows >= ((int32_t)0)))
	{
		abort();
	}
	if (!(columns >= ((int32_t)0)))
	{
		abort();
	}
	if (!(maximumNumberOfRows >= rows))
	{
		abort();
	}
	if (!(maximumNumberOfColumns >= columns))
	{
		abort();
	}
	Object_ctor(&self->base);
	self->_rows = rows;
	self->_columns = columns;
	array = New_float64_t_2D_15_40();
	(void)Assign_float64_t_2D_15_40(&self->_items, array);
	(void)Assign_float64_t_2D_15_40(&array, NULL);
}

struct AssociationTable *StatiAssocTableFacto_CreatInsta(struct StaticAssociationTableFactory *const self, int32_t rows, int32_t columns)
{
	struct AssociationTable *result = NULL;
	struct AssociationTable *associationTable = NULL;

	if (!(__ContrRunti_1_insidContrEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);
		int32_t int32_2 = ((int32_t)0);
		int32_t int32_3 = ((int32_t)0);

		__ContrRunti_1_insidContrEvalua = __ContrRunti_1_insidContrEvalua + ((int32_t)1);
		if (!(rows >= ((int32_t)0)))
		{
			abort();
		}
		if (!(columns >= ((int32_t)0)))
		{
			abort();
		}
		int32 = rows;
		int32_1 = StatAssoTablFacto_get_MaximRows(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		int32_2 = columns;
		int32_3 = StatAssoTablFact_get_MaximColum(self);
		if (!(int32_2 <= int32_3))
		{
			abort();
		}
		__ContrRunti_1_insidContrEvalua = __ContrRunti_1_insidContrEvalua - ((int32_t)1);
	}
	associationTable = New_AssociationTable();
	AssociationTable_ctor(associationTable, rows, columns, self->_maximumRows, self->_maximumColumns);
	(void)Assign_AssociationTable(&result, associationTable);
	(void)Assign_AssociationTable(&associationTable, NULL);
	return result;
}

static void Associatio_set_AssociationTable(struct Association *const self, struct AssociationTable *value)
{
	(void)Assign_AssociationTable(&self->AssociationTable, value);
}

static void Association_ctor(struct Association *const self, struct StaticList_20 *objects1, struct StaticList_6 *objects2, struct MultipleLocalNearestNeighbor *associationAlgorithm, struct StatiIPDATrackColleFactorProvid *factoryProvider)
{
	struct StatiIPDATrackColleFactorProvid *arg_4E_1 = NULL;
	struct StaticListFactory_4 *staticListFactory = NULL;
	struct StaticList_20 *staticList = NULL;
	struct StaticListFactory_5 *staticListFactory_1 = NULL;
	struct StaticList_6 *staticList_1 = NULL;
	struct StaticListEnumerator_12 *enumerator = NULL;
	struct StaticListEnumerator_12 *staticListEnumerator = NULL;
	struct Gaussian_2 *current = NULL;
	bool_t boolean = false;
	struct StaticListEnumerator_2 *enumerator2 = NULL;
	struct StaticListEnumerator_2 *staticListEnumerator_1 = NULL;
	struct MobilEyeSpace *current2 = NULL;
	bool_t boolean_1 = false;
	struct StaticAssociationTableFactory *staticAssociationTableFactory = NULL;
	struct StaticList_20 *staticList_2 = NULL;
	int32_t int32 = ((int32_t)0);
	struct StaticList_6 *staticList_3 = NULL;
	int32_t int32_1 = ((int32_t)0);
	struct AssociationTable *associationTable = NULL;

	if (!(objects1 != NULL))
	{
		abort();
	}
	if (!(objects2 != NULL))
	{
		abort();
	}
	if (!(associationAlgorithm != NULL))
	{
		abort();
	}
	Object_ctor(&self->base);
	(void)Assi_StatIPDATracCollFactoProvi(&arg_4E_1, factoryProvider);
	(void)Assi_StatIPDATracCollFactoProvi(&self->_factoryProvider, arg_4E_1);
	staticListFactory = StIPDATrCoFacPro_get_Obj1LisFac(self->_factoryProvider);
	staticList = StatiListFactor_4_CreateInstan(staticListFactory, ((int32_t)0));
	Association_set_Objects1(self, staticList);
	(void)Assign_StaticListFactory_4(&staticListFactory, NULL);
	(void)Assign_StaticList_20(&staticList, NULL);
	staticListFactory_1 = StIPDATrCoFacPro_get_Obj2LisFac(self->_factoryProvider);
	staticList_1 = StaticListFactor_5_CreateInstan(staticListFactory_1, ((int32_t)0));
	Association_set_Objects2(self, staticList_1);
	(void)Assign_StaticListFactory_5(&staticListFactory_1, NULL);
	(void)Assign_StaticList_6(&staticList_1, NULL);
	staticListEnumerator = StaticList_20_GetEnumerator(objects1);
	(void)Assign_StaticListEnumerator_12(&enumerator, staticListEnumerator);
	(void)Assign_StaticListEnumerator_12(&staticListEnumerator, NULL);
	boolean = StaticListEnumerato_12_MoveNext(enumerator);
	while (boolean)
	{
		struct Gaussian_2 *gaussian = NULL;
		struct StaticList_20 *staticList_4 = NULL;

		gaussian = StaticListEnumer_12_get_Current(enumerator);
		(void)Assign_Gaussian_2(&current, gaussian);
		(void)Assign_Gaussian_2(&gaussian, NULL);
		staticList_4 = Association_get_Objects1(self);
		StaticList_20_Add(staticList_4, current);
		(void)Assign_StaticList_20(&staticList_4, NULL);
		boolean = StaticListEnumerato_12_MoveNext(enumerator);
	}
	if (!!(enumerator != NULL))
	{
		StaticListEnumerator_12_Dispose(enumerator);
	}
	staticListEnumerator_1 = StaticList_6_GetEnumerator(objects2);
	(void)Assign_StaticListEnumerator_2(&enumerator2, staticListEnumerator_1);
	(void)Assign_StaticListEnumerator_2(&staticListEnumerator_1, NULL);
	boolean_1 = StaticListEnumerator_2_MoveNext(enumerator2);
	while (boolean_1)
	{
		struct MobilEyeSpace *mobilEyeSpace = NULL;
		struct StaticList_6 *staticList_5 = NULL;

		mobilEyeSpace = StaticListEnumera_2_get_Current(enumerator2);
		(void)Assign_MobilEyeSpace(&current2, mobilEyeSpace);
		(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
		staticList_5 = Association_get_Objects2(self);
		StaticList_6_Add(staticList_5, current2);
		(void)Assign_StaticList_6(&staticList_5, NULL);
		boolean_1 = StaticListEnumerator_2_MoveNext(enumerator2);
	}
	if (!!(enumerator2 != NULL))
	{
		StaticListEnumerator_2_Dispose(enumerator2);
	}
	(void)Assign_MultipLocalNearesNeighbo(&self->_associationAlgorithm, associationAlgorithm);
	staticAssociationTableFactory = StIPDATrColFacPro_get_AssTabFac(self->_factoryProvider);
	staticList_2 = Association_get_Objects1(self);
	int32 = StaticList_20_get_Count(staticList_2);
	staticList_3 = Association_get_Objects2(self);
	int32_1 = StaticList_6_get_Count(staticList_3);
	associationTable = StatiAssocTableFacto_CreatInsta(staticAssociationTableFactory, int32, int32_1);
	Associatio_set_AssociationTable(self, associationTable);
	(void)Assign_StaticAssociTableFactory(&staticAssociationTableFactory, NULL);
	(void)Assign_StaticList_20(&staticList_2, NULL);
	(void)Assign_StaticList_6(&staticList_3, NULL);
	(void)Assign_AssociationTable(&associationTable, NULL);
	RemRef_StatIPDATracCollFactProv(arg_4E_1);
	RemRef_StaticListEnumerator_12(enumerator);
	RemRef_Gaussian_2(current);
	RemRef_StaticListEnumerator_2(enumerator2);
	RemRef_MobilEyeSpace(current2);
}

static void RemRef_StaticListEnumerator_14(struct StaticListEnumerator_14 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListEnumerator_14.CurrentCount--;
		Res_StaticListEnumerator_14.Next[Res_StaticListEnumerator_14.CurrentCount] = self;
		Del_StaticListEnumerator_14(self);
	}
}

struct StaticListEnumerator_14 *New_StaticListEnumerator_14(void)
{
	static struct StaticListEnumerator_14 const Default_StaticListEnumerator_14 = { 1 };
	struct StaticListEnumerator_14 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListEnumerator_14.CurrentCount == RC_StaticListEnumerator_14)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListEnumerator_14.Next[Res_StaticListEnumerator_14.CurrentCount];
	Res_StaticListEnumerator_14.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListEnumerator_14.MaximumCount = (Res_StaticListEnumerator_14.CurrentCount > Res_StaticListEnumerator_14.MaximumCount) ? Res_StaticListEnumerator_14.CurrentCount : Res_StaticListEnumerator_14.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListEnumerator_14;
	return instance;
}

struct StaticListEnumerator_14 *Assign_StaticListEnumerator_14(struct StaticListEnumerator_14 **const left, struct StaticListEnumerator_14 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListEnumerator_14(*left);
	*left = right;
	return right;
}

void StaticListEnumerator_14_ctor(struct StaticListEnumerator_14 *const self, struct StaticList_26 *list)
{
	self->_current = ((int32_t)-1);
	Object_ctor(&self->base);
	(void)Assign_StaticList_26(&self->_list, list);
}

struct StaticListEnumerator_14 *StaticList_26_GetEnumerator(struct StaticList_26 *const self)
{
	struct StaticListEnumerator_14 *result = NULL;
	struct StaticListEnumerator_14 *staticListEnumerator = NULL;

	staticListEnumerator = New_StaticListEnumerator_14();
	StaticListEnumerator_14_ctor(staticListEnumerator, self);
	(void)Assign_StaticListEnumerator_14(&result, staticListEnumerator);
	(void)Assign_StaticListEnumerator_14(&staticListEnumerator, NULL);
	return result;
}

static struct AssociationTable *Associatio_get_AssociationTable(struct Association *const self)
{
	struct AssociationTable *result = NULL;

	(void)Assign_AssociationTable(&result, self->AssociationTable);
	return result;
}

int32_t AssociationTable_get_Rows(struct AssociationTable *const self)
{
	return self->_rows;
}

int32_t Association_get_Count1(struct Association *const self)
{
	int32_t result = ((int32_t)0);
	struct AssociationTable *associationTable = NULL;
	int32_t int32 = ((int32_t)0);

	associationTable = Associatio_get_AssociationTable(self);
	int32 = AssociationTable_get_Rows(associationTable);
	result = int32;
	(void)Assign_AssociationTable(&associationTable, NULL);
	return result;
}

bool_t StaticListEnumerato_14_MoveNext(struct StaticListEnumerator_14 *const self)
{
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	self->_current = self->_current + ((int32_t)1);
	int32 = self->_current;
	int32_1 = StaticList_26_get_Count(self->_list);
	return int32 != int32_1;
}

int32_t AssociationTable_get_Columns(struct AssociationTable *const self)
{
	return self->_columns;
}

int32_t Association_get_Count2(struct Association *const self)
{
	int32_t result = ((int32_t)0);
	struct AssociationTable *associationTable = NULL;
	int32_t int32 = ((int32_t)0);

	associationTable = Associatio_get_AssociationTable(self);
	int32 = AssociationTable_get_Columns(associationTable);
	result = int32;
	(void)Assign_AssociationTable(&associationTable, NULL);
	return result;
}

struct MatrixData_5 *MatrixMath_Subtract_3(struct MatrixData_5 *left, struct MatrixData_5 *right)
{
	struct MatrixData_5 *matrixData = NULL;
	struct MatrixData_5 *matrixData_1 = NULL;
	struct float64_t_1D_4 *dataReference = NULL;
	struct float64_t_1D_4 *array = NULL;
	struct float64_t_1D_4 *dataReference2 = NULL;
	struct float64_t_1D_4 *array_1 = NULL;
	struct float64_t_1D_4 *dataReference3 = NULL;
	struct float64_t_1D_4 *array_2 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_5 *result = NULL;
	struct MatrixData_5 *matrixData2 = NULL;
	struct MatrixData_5 *matrixData_2 = NULL;
	struct float64_t_1D_4 *dataReference4 = NULL;
	struct float64_t_1D_4 *array_3 = NULL;
	struct float64_t_1D_4 *dataReference5 = NULL;
	struct float64_t_1D_4 *array_4 = NULL;
	struct float64_t_1D_4 *dataReference6 = NULL;
	struct float64_t_1D_4 *array_5 = NULL;
	int32_t num = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	struct MatrixData_5 *matrixData3 = NULL;
	struct MatrixData_5 *matrixData_3 = NULL;
	struct float64_t_1D_4 *dataReference7 = NULL;
	struct float64_t_1D_4 *array_6 = NULL;
	struct float64_t_1D_4 *dataReference8 = NULL;
	struct float64_t_1D_4 *array_7 = NULL;
	struct float64_t_1D_4 *dataReference9 = NULL;
	struct float64_t_1D_4 *array_8 = NULL;
	int32_t num2 = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t m = ((int32_t)0);

	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData_5();
	MatrixData_5_ctor(matrixData_1, left->Rows, right->Columns);
	(void)Assign_MatrixData_5(&matrixData, matrixData_1);
	(void)Assign_MatrixData_5(&matrixData_1, NULL);
	array = MatrixData_5_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_4(&dataReference, array);
	(void)Assign_float64_t_1D_4(&array, NULL);
	array_1 = MatrixData_5_get_DataReference(left);
	(void)Assign_float64_t_1D_4(&dataReference2, array_1);
	(void)Assign_float64_t_1D_4(&array_1, NULL);
	array_2 = MatrixData_5_get_DataReference(right);
	(void)Assign_float64_t_1D_4(&dataReference3, array_2);
	(void)Assign_float64_t_1D_4(&array_2, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)4))
	{
		dataReference->Elements[i] = dataReference2->Elements[i] - dataReference3->Elements[i];
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_5(&result, matrixData);
	RemRef_MatrixData_5(matrixData);
	RemRef_float64_t_1D_4(dataReference);
	RemRef_float64_t_1D_4(dataReference2);
	RemRef_float64_t_1D_4(dataReference3);
	RemRef_MatrixData_5(matrixData2);
	RemRef_float64_t_1D_4(dataReference4);
	RemRef_float64_t_1D_4(dataReference5);
	RemRef_float64_t_1D_4(dataReference6);
	RemRef_MatrixData_5(matrixData3);
	RemRef_float64_t_1D_4(dataReference7);
	RemRef_float64_t_1D_4(dataReference8);
	RemRef_float64_t_1D_4(dataReference9);
	return result;
	matrixData_2 = New_MatrixData_5();
	MatrixData_5_ctor(matrixData_2, left->Rows, right->Columns);
	(void)Assign_MatrixData_5(&matrixData2, matrixData_2);
	(void)Assign_MatrixData_5(&matrixData_2, NULL);
	array_3 = MatrixData_5_get_DataReference(matrixData2);
	(void)Assign_float64_t_1D_4(&dataReference4, array_3);
	(void)Assign_float64_t_1D_4(&array_3, NULL);
	array_4 = MatrixData_5_get_DataReference(left);
	(void)Assign_float64_t_1D_4(&dataReference5, array_4);
	(void)Assign_float64_t_1D_4(&array_4, NULL);
	array_5 = MatrixData_5_get_DataReference(right);
	(void)Assign_float64_t_1D_4(&dataReference6, array_5);
	(void)Assign_float64_t_1D_4(&array_5, NULL);
	num = ((int32_t)0);
	j = ((int32_t)0);
	while (j < right->Columns)
	{
		k = ((int32_t)0);
		while (k < left->Rows)
		{
			dataReference4->Elements[num] = dataReference5->Elements[k] - dataReference6->Elements[num];
			num = num + ((int32_t)1);
			k = k + ((int32_t)1);
		}
		j = j + ((int32_t)1);
	}
	(void)Assign_MatrixData_5(&result, matrixData2);
	RemRef_MatrixData_5(matrixData);
	RemRef_float64_t_1D_4(dataReference);
	RemRef_float64_t_1D_4(dataReference2);
	RemRef_float64_t_1D_4(dataReference3);
	RemRef_MatrixData_5(matrixData2);
	RemRef_float64_t_1D_4(dataReference4);
	RemRef_float64_t_1D_4(dataReference5);
	RemRef_float64_t_1D_4(dataReference6);
	RemRef_MatrixData_5(matrixData3);
	RemRef_float64_t_1D_4(dataReference7);
	RemRef_float64_t_1D_4(dataReference8);
	RemRef_float64_t_1D_4(dataReference9);
	return result;
	matrixData_3 = New_MatrixData_5();
	MatrixData_5_ctor(matrixData_3, left->Rows, left->Columns);
	(void)Assign_MatrixData_5(&matrixData3, matrixData_3);
	(void)Assign_MatrixData_5(&matrixData_3, NULL);
	array_6 = MatrixData_5_get_DataReference(matrixData3);
	(void)Assign_float64_t_1D_4(&dataReference7, array_6);
	(void)Assign_float64_t_1D_4(&array_6, NULL);
	array_7 = MatrixData_5_get_DataReference(left);
	(void)Assign_float64_t_1D_4(&dataReference8, array_7);
	(void)Assign_float64_t_1D_4(&array_7, NULL);
	array_8 = MatrixData_5_get_DataReference(right);
	(void)Assign_float64_t_1D_4(&dataReference9, array_8);
	(void)Assign_float64_t_1D_4(&array_8, NULL);
	num2 = ((int32_t)0);
	l = ((int32_t)0);
	while (l < left->Columns)
	{
		m = ((int32_t)0);
		while (m < left->Rows)
		{
			dataReference7->Elements[num2] = dataReference8->Elements[num2] - dataReference9->Elements[m];
			num2 = num2 + ((int32_t)1);
			m = m + ((int32_t)1);
		}
		l = l + ((int32_t)1);
	}
	(void)Assign_MatrixData_5(&result, matrixData3);
	RemRef_MatrixData_5(matrixData);
	RemRef_float64_t_1D_4(dataReference);
	RemRef_float64_t_1D_4(dataReference2);
	RemRef_float64_t_1D_4(dataReference3);
	RemRef_MatrixData_5(matrixData2);
	RemRef_float64_t_1D_4(dataReference4);
	RemRef_float64_t_1D_4(dataReference5);
	RemRef_float64_t_1D_4(dataReference6);
	RemRef_MatrixData_5(matrixData3);
	RemRef_float64_t_1D_4(dataReference7);
	RemRef_float64_t_1D_4(dataReference8);
	RemRef_float64_t_1D_4(dataReference9);
	return result;
	abort();
}

static struct float64_t_1D_4 *Space_3_Subtract(struct Space_3 *const self, struct Space_3 *other)
{
	struct float64_t_1D_4 *array = NULL;
	struct float64_t_1D_4 *array_1 = NULL;
	struct MatrixData_5 *matrixData = NULL;
	struct MatrixData_5 *matrixData_1 = NULL;
	struct MatrixData_5 *matrixData_2 = NULL;
	struct MatrixData_5 *matrixData_3 = NULL;
	struct float64_t_1D_4 *array_2 = NULL;
	struct float64_t_1D_4 *result = NULL;

	array_1 = New_float64_t_1D_4();
	(void)Assign_float64_t_1D_4(&array, array_1);
	(void)Assign_float64_t_1D_4(&array_1, NULL);
	matrixData_1 = Space_3_get_MatrixData(self);
	matrixData_2 = Space_3_get_MatrixData(other);
	matrixData_3 = MatrixMath_Subtract_3(matrixData_1, matrixData_2);
	(void)Assign_MatrixData_5(&matrixData, matrixData_3);
	(void)Assign_MatrixData_5(&matrixData_1, NULL);
	(void)Assign_MatrixData_5(&matrixData_2, NULL);
	(void)Assign_MatrixData_5(&matrixData_3, NULL);
	array_2 = MatrixData_5_get_DataReference(matrixData);
	(void)memcpy(&array->Elements, &array_2->Elements, sizeof(float64_t) * ((int32_t)4));
	(void)Assign_float64_t_1D_4(&array_2, NULL);
	(void)Assign_float64_t_1D_4(&result, array);
	RemRef_float64_t_1D_4(array);
	RemRef_MatrixData_5(matrixData);
	return result;
}

struct float64_t_1D_4 *Space_6_op_Subtraction_2(struct Space_3 *left, struct Space_3 *right)
{
	struct float64_t_1D_4 *result = NULL;
	struct float64_t_1D_4 *array = NULL;

	array = Space_3_Subtract(left, right);
	(void)Assign_float64_t_1D_4(&result, array);
	(void)Assign_float64_t_1D_4(&array, NULL);
	return result;
}

static void MatrixData_5_ctor_2(struct MatrixData_5 *const self, struct float64_t_1D_4 *data, bool_t takeDataOwnership)
{
	int32_t arg_5F_1 = ((int32_t)0);

	Object_ctor(&self->base);
	if (!(data != NULL))
	{
		abort();
	}
	if (!!takeDataOwnership)
	{
		(void)Assign_float64_t_1D_4(&self->_data, data);
	}
	else
	{
		struct float64_t_1D_4 *array = NULL;

		array = New_float64_t_1D_4();
		(void)Assign_float64_t_1D_4(&self->_data, array);
		(void)Assign_float64_t_1D_4(&array, NULL);
		(void)memcpy(&self->_data->Elements, &data->Elements, sizeof(float64_t) * ((int32_t)4));
	}
	self->Rows = ((int32_t)4);
	arg_5F_1 = ((int32_t)1);
	self->Columns = arg_5F_1;
}

struct MatrixData_5 *MatrixData_20_Create_1(struct float64_t_1D_4 *data)
{
	struct MatrixData_5 *result = NULL;
	struct MatrixData_5 *matrixData = NULL;

	matrixData = New_MatrixData_5();
	MatrixData_5_ctor_2(matrixData, data, true);
	(void)Assign_MatrixData_5(&result, matrixData);
	(void)Assign_MatrixData_5(&matrixData, NULL);
	return result;
}

struct MatrixData_15 *MatrixData_20_Eye_3(int32_t rows, int32_t columns)
{
	struct MatrixData_15 *matrixData = NULL;
	struct MatrixData_15 *matrixData_1 = NULL;
	int32_t num = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	struct MatrixData_15 *result = NULL;

	assert(rows == ((int32_t)4));
	assert(columns == ((int32_t)4));
	matrixData_1 = New_MatrixData_15();
	MatrixData_15_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_15(&matrixData, matrixData_1);
	(void)Assign_MatrixData_15(&matrixData_1, NULL);
	int32 = Math_Min(rows, columns);
	num = int32;
	i = ((int32_t)0);
	while (i < num)
	{
		MatrixData_15_SetValueFast(matrixData, 1.0, i, i);
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_15(&result, matrixData);
	RemRef_MatrixData_15(matrixData);
	return result;
}

static void MatrixData_15_ctor_1(struct MatrixData_15 *const self, struct float64_t_1D_16 *data, int32_t rows, int32_t columns, bool_t takeDataOwnership)
{
	assert(rows == ((int32_t)4));
	assert(columns == ((int32_t)4));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	if (!(data != NULL))
	{
		abort();
	}
	if (!!takeDataOwnership)
	{
		(void)Assign_float64_t_1D_16(&self->_data, data);
	}
	else
	{
		struct float64_t_1D_16 *array = NULL;

		array = New_float64_t_1D_16();
		(void)Assign_float64_t_1D_16(&self->_data, array);
		(void)Assign_float64_t_1D_16(&array, NULL);
		(void)memcpy(&self->_data->Elements, &data->Elements, sizeof(float64_t) * ((int32_t)16));
	}
	self->Rows = rows;
	self->Columns = columns;
}

struct MatrixData_15 *MatrixData_15_get_Copy(struct MatrixData_15 *const self)
{
	struct MatrixData_15 *result = NULL;
	struct MatrixData_15 *matrixData = NULL;

	matrixData = New_MatrixData_15();
	MatrixData_15_ctor_1(matrixData, self->_data, self->Rows, self->Columns, false);
	(void)Assign_MatrixData_15(&result, matrixData);
	(void)Assign_MatrixData_15(&matrixData, NULL);
	return result;
}

static void LineaAlgebr_1_SolveUpperTriang(struct float64_t_1D_16 *a, int32_t lda, int32_t rank, struct float64_t_1D_16 *b, int32_t ldb, int32_t rightHandSides, bool_t ignoreDiagonal)
{
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t expr_23_cp_1 = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t expr_41_cp_1 = ((int32_t)0);

	i = ((int32_t)0);
	while (i < rightHandSides)
	{
		j = rank - ((int32_t)1);
		while (j >= ((int32_t)0))
		{
			if (!ignoreDiagonal)
			{
				expr_23_cp_1 = (i * ldb) + j;
				b->Elements[expr_23_cp_1] = b->Elements[expr_23_cp_1] / a->Elements[(j * lda) + j];
			}
			k = ((int32_t)0);
			while (k < j)
			{
				expr_41_cp_1 = (i * ldb) + k;
				b->Elements[expr_41_cp_1] = b->Elements[expr_41_cp_1] - (b->Elements[(i * ldb) + j] * a->Elements[(j * lda) + k]);
				k = k + ((int32_t)1);
			}
			j = j - ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
}

void LinearAlgebra_SolveCholesky(struct LinearAlgebra *const self, struct float64_t_1D_16 *a, int32_t rows, struct float64_t_1D_16 *b)
{
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t expr_A6_cp_1 = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t expr_C7_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rows > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)16) % rows) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!!((((int32_t)16) % rows) != ((int32_t)0)))
	{
		abort();
	}
	num = ((int32_t)16) / rows;
	if (!(num == rows))
	{
		abort();
	}
	num2 = ((int32_t)16) / rows;
	i = ((int32_t)0);
	while (i < num2)
	{
		j = ((int32_t)0);
		while (j < num)
		{
			expr_A6_cp_1 = (i * rows) + j;
			b->Elements[expr_A6_cp_1] = b->Elements[expr_A6_cp_1] / a->Elements[(j * rows) + j];
			k = j + ((int32_t)1);
			while (k < num)
			{
				expr_C7_cp_1 = (i * rows) + k;
				b->Elements[expr_C7_cp_1] = b->Elements[expr_C7_cp_1] - (b->Elements[(i * rows) + j] * a->Elements[(k * rows) + j]);
				k = k + ((int32_t)1);
			}
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	LineaAlgebr_1_SolveUpperTriang(a, rows, rows, b, rows, num2, false);
}

struct MatrixData_15 *MatrixMath_LinsolveHermitian(struct MatrixData_15 *left, struct MatrixData_15 *right)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	struct MatrixData_15 *copy = NULL;
	struct MatrixData_15 *matrixData = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_16 *array = NULL;
	struct MatrixData_15 *copy2 = NULL;
	struct MatrixData_15 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra_1 = NULL;
	struct float64_t_1D_16 *array_1 = NULL;
	int32_t int32 = ((int32_t)0);
	struct float64_t_1D_16 *array_2 = NULL;
	struct MatrixData_15 *result = NULL;

	if (!(left != NULL))
	{
		abort();
	}
	boolean = MatrixData_15_get_IsEmpty(left);
	if (!(right != NULL))
	{
		abort();
	}
	boolean_1 = MatrixData_15_get_IsEmpty(right);
	matrixData = MatrixData_15_get_Copy(left);
	(void)Assign_MatrixData_15(&copy, matrixData);
	(void)Assign_MatrixData_15(&matrixData, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_15_get_DataReference(copy);
	LinearAlgebra_FactorCholesky_4(linearAlgebra, array, copy->Rows);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_16(&array, NULL);
	matrixData_1 = MatrixData_15_get_Copy(right);
	(void)Assign_MatrixData_15(&copy2, matrixData_1);
	(void)Assign_MatrixData_15(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra_1, MatrixMath_LinearAlgebra);
	array_1 = MatrixData_15_get_DataReference(copy);
	int32 = copy->Rows;
	array_2 = MatrixData_15_get_DataReference(copy2);
	LinearAlgebra_SolveCholesky(linearAlgebra_1, array_1, int32, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra_1, NULL);
	(void)Assign_float64_t_1D_16(&array_1, NULL);
	(void)Assign_float64_t_1D_16(&array_2, NULL);
	(void)Assign_MatrixData_15(&result, copy2);
	RemRef_MatrixData_15(copy);
	RemRef_MatrixData_15(copy2);
	return result;
}

struct PositiveDefiniteMatrix_3 *PositiDefiniMatrix_3_get_Invers(struct PositiveDefiniteMatrix_3 *const self)
{
	struct PositiveDefiniteMatrix_3 *result = NULL;
	struct PositiveDefiniteMatrix_3 *positiveDefiniteMatrix = NULL;

	if (!(self->CachedInverse != NULL))
	{
		struct MatrixData_15 *matrixData = NULL;
		struct MatrixData_15 *matrixData_1 = NULL;
		struct MatrixData_15 *matrixData_2 = NULL;

		matrixData = Matrix_3_get_MatrixData(&self->base.base);
		matrixData_1 = MatrixData_20_Eye_3((&self->base)->Dimensions, (&self->base)->Dimensions);
		matrixData_2 = MatrixMath_LinsolveHermitian(matrixData, matrixData_1);
		(void)Assign_MatrixData_15(&self->CachedInverse, matrixData_2);
		(void)Assign_MatrixData_15(&matrixData, NULL);
		(void)Assign_MatrixData_15(&matrixData_1, NULL);
		(void)Assign_MatrixData_15(&matrixData_2, NULL);
	}
	positiveDefiniteMatrix = PositivDefiniteMatrix_12_Create(self->CachedInverse);
	(void)Assign_PositiveDefiniteMatrix_3(&result, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_3(&positiveDefiniteMatrix, NULL);
	return result;
}

static void RemRef_MatrixData_7(struct MatrixData_7 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_7.CurrentCount--;
		Res_MatrixData_7.Next[Res_MatrixData_7.CurrentCount] = self;
		Del_MatrixData_7(self);
	}
}

struct MatrixData_7 *New_MatrixData_7(void)
{
	static struct MatrixData_7 const Default_MatrixData_7 = { 1 };
	struct MatrixData_7 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_7.CurrentCount == RC_MatrixData_7)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_7.Next[Res_MatrixData_7.CurrentCount];
	Res_MatrixData_7.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_7.MaximumCount = (Res_MatrixData_7.CurrentCount > Res_MatrixData_7.MaximumCount) ? Res_MatrixData_7.CurrentCount : Res_MatrixData_7.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_7;
	return instance;
}

struct MatrixData_7 *Assign_MatrixData_7(struct MatrixData_7 **const left, struct MatrixData_7 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_7(*left);
	*left = right;
	return right;
}

void MatrixData_7_ctor(struct MatrixData_7 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_4 *array = NULL;

	assert(rows == ((int32_t)1));
	assert(columns == ((int32_t)4));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_4();
	(void)Assign_float64_t_1D_4(&self->_data, array);
	(void)Assign_float64_t_1D_4(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct float64_t_1D_4 *MatrixData_7_get_DataReference(struct MatrixData_7 *const self)
{
	struct float64_t_1D_4 *result = NULL;

	(void)Assign_float64_t_1D_4(&result, self->_data);
	return result;
}

void LinearAlgebra_MatrixMultiply_14(struct LinearAlgebra *const self, struct float64_t_1D_4 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_16 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_4 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)4) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)16) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)4) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)4) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)16) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)16) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)4) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)4) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_7 *MatrixMath_Multiply_27(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_5 *left, struct MatrixData_15 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_7 *matrixData = NULL;
	struct MatrixData_7 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_4 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_16 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_4 *array_2 = NULL;
	struct MatrixData_7 *result = NULL;

	assert(transposeLeft == true);
	assert(transposeRight == false);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Columns;
	rows = arg_145_0;
	arg_15D_0 = right->Columns;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_7();
	MatrixData_7_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_7(&matrixData, matrixData_1);
	(void)Assign_MatrixData_7(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_5_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_15_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_7_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_14(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_4(&array, NULL);
	(void)Assign_float64_t_1D_16(&array_1, NULL);
	(void)Assign_float64_t_1D_4(&array_2, NULL);
	(void)Assign_MatrixData_7(&result, matrixData);
	RemRef_MatrixData_7(matrixData);
	return result;
}

void LinearAlgebra_MatrixMultiply_15(struct LinearAlgebra *const self, struct float64_t_1D_4 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_4 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_1 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)4) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)4) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)4) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)4) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)4) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)4) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)4) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)1) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_3 *MatrixMath_Multiply_28(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_7 *left, struct MatrixData_5 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_3 *matrixData = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_4 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_4 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_1 *array_2 = NULL;
	struct MatrixData_3 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == false);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Columns;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_3();
	MatrixData_3_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_3(&matrixData, matrixData_1);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_7_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_5_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_3_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_15(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_4(&array, NULL);
	(void)Assign_float64_t_1D_4(&array_1, NULL);
	(void)Assign_float64_t_1D_1(&array_2, NULL);
	(void)Assign_MatrixData_3(&result, matrixData);
	RemRef_MatrixData_3(matrixData);
	return result;
}

struct MatrixData_3 *MatrixMath_Multiply_29(bool_t transposeFirst, bool_t transposeSecond, bool_t transposeThird, struct MatrixData_5 *first, struct MatrixData_15 *second, struct MatrixData_5 *third)
{
	struct MatrixData_7 *left = NULL;
	struct MatrixData_7 *matrixData = NULL;
	struct MatrixData_3 *result = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;

	assert(transposeFirst == true);
	assert(transposeSecond == false);
	assert(transposeThird == false);
	if (!(first != NULL))
	{
		abort();
	}
	if (!(second != NULL))
	{
		abort();
	}
	if (!(third != NULL))
	{
		abort();
	}
	matrixData = MatrixMath_Multiply_27(transposeFirst, transposeSecond, first, second);
	(void)Assign_MatrixData_7(&left, matrixData);
	(void)Assign_MatrixData_7(&matrixData, NULL);
	matrixData_1 = MatrixMath_Multiply_28(false, transposeThird, left, third);
	(void)Assign_MatrixData_3(&result, matrixData_1);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
	RemRef_MatrixData_7(left);
	return result;
}

float64_t Gaussi_2_GetMahalaDistanSquared(struct Gaussian_2 *const self, struct MobilEyeSpace *sample)
{
	struct MatrixData_5 *matrixData = NULL;
	struct MobilEyeSpace *mobilEyeSpace = NULL;
	struct MobilEyeSpace *mobilEyeSpace_1 = NULL;
	struct float64_t_1D_4 *array = NULL;
	struct MatrixData_5 *matrixData_1 = NULL;
	float64_t result = 0.0;
	struct MatrixData_5 *matrixData_2 = NULL;
	struct PositiveDefiniteMatrix_3 *positiveDefiniteMatrix = NULL;
	struct PositiveDefiniteMatrix_3 *positiveDefiniteMatrix_1 = NULL;
	struct MatrixData_15 *matrixData_3 = NULL;
	struct MatrixData_3 *matrixData_4 = NULL;
	float64_t double_ = 0.0;

	(void)Assign_MobilEyeSpace(&mobilEyeSpace, sample);
	mobilEyeSpace_1 = Gaussian_2_get_Expectation(self);
	array = Space_6_op_Subtraction_2(&mobilEyeSpace->base, &mobilEyeSpace_1->base);
	matrixData_1 = MatrixData_20_Create_1(array);
	(void)Assign_MatrixData_5(&matrixData, matrixData_1);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace_1, NULL);
	(void)Assign_float64_t_1D_4(&array, NULL);
	(void)Assign_MatrixData_5(&matrixData_1, NULL);
	(void)Assign_MatrixData_5(&matrixData_2, matrixData);
	positiveDefiniteMatrix = Gaussian_2_get_Covariance(self);
	positiveDefiniteMatrix_1 = PositiDefiniMatrix_3_get_Invers(positiveDefiniteMatrix);
	matrixData_3 = Matrix_3_get_MatrixData(&positiveDefiniteMatrix_1->base.base);
	matrixData_4 = MatrixMath_Multiply_29(true, false, false, matrixData_2, matrixData_3, matrixData);
	double_ = MatrixData_3_get_Item(matrixData_4, ((int32_t)0), ((int32_t)0));
	result = double_;
	(void)Assign_MatrixData_5(&matrixData_2, NULL);
	(void)Assign_PositiveDefiniteMatrix_3(&positiveDefiniteMatrix, NULL);
	(void)Assign_PositiveDefiniteMatrix_3(&positiveDefiniteMatrix_1, NULL);
	(void)Assign_MatrixData_15(&matrixData_3, NULL);
	(void)Assign_MatrixData_3(&matrixData_4, NULL);
	RemRef_MatrixData_5(matrixData);
	return result;
}

float64_t SquaredMahalanDistanc_GetMetric(struct SquaredMahalanobisDistance *const self, struct Gaussian_2 *object1, struct MobilEyeSpace *object2)
{
	float64_t double_ = 0.0;

	if (!(object1 != NULL))
	{
		abort();
	}
	if (!(object2 != NULL))
	{
		abort();
	}
	double_ = Gaussi_2_GetMahalaDistanSquared(object1, object2);
	return double_;
}

float64_t Gate_get_MaximumDistance(struct Gate *const self)
{
	return self->MaximumDistance;
}

bool_t Gate_IsInside(struct Gate *const self, struct Gaussian_2 *object1, struct MobilEyeSpace *object2)
{
	float64_t metric = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;

	if (!(object1 != NULL))
	{
		abort();
	}
	if (!(object2 != NULL))
	{
		abort();
	}
	double_ = SquaredMahalanDistanc_GetMetric(self->_metric, object1, object2);
	metric = double_;
	double__1 = metric;
	double__2 = Gate_get_MaximumDistance(self);
	return double__1 <= double__2;
}

struct Existence *StaticList_26_get_Item(struct StaticList_26 *const self, int32_t index)
{
	struct Existence *result = NULL;

	(void)Assign_Existence(&result, self->_items->Elements[index]);
	return result;
}

struct Existence *StaticListEnumer_14_get_Current(struct StaticListEnumerator_14 *const self)
{
	struct Existence *result = NULL;
	struct Existence *existence = NULL;

	existence = StaticList_26_get_Item(self->_list, self->_current);
	(void)Assign_Existence(&result, existence);
	(void)Assign_Existence(&existence, NULL);
	return result;
}

float64_t TwoPointDistribution_Evaluate(struct TwoPointDistribution *const self, struct ExistenceSpace *sample)
{
	float64_t result = 0.0;
	struct ExistenceSpace *existenceSpace = NULL;
	struct ExistenceSpace *existenceSpace_1 = NULL;
	bool_t boolean = false;
	struct ExistenceSpace *existenceSpace_2 = NULL;
	struct ExistenceSpace *existenceSpace_3 = NULL;
	bool_t boolean_1 = false;

	(void)Assign_ExistenceSpace(&existenceSpace, sample);
	existenceSpace_1 = TwoPointDistri_get_SuccesSample(self);
	boolean = Space_6_op_Equality(existenceSpace, existenceSpace_1);
	if (!!boolean)
	{
		struct StaticList_15 *staticList = NULL;
		struct SampleProbabilityPair_2 *sampleProbabilityPair = NULL;
		float64_t double_ = 0.0;

		(void)Assign_ExistenceSpace(&existenceSpace, NULL);
		(void)Assign_ExistenceSpace(&existenceSpace_1, NULL);
		staticList = SampleSet_2_get_Samples(&self->base);
		sampleProbabilityPair = StaticList_15_get_Item(staticList, ((int32_t)0));
		double_ = SampleProbabiPair_2_get_Probabi(sampleProbabilityPair);
		result = double_;
		(void)Assign_StaticList_15(&staticList, NULL);
		(void)Assign_SampleProbabilityPair_2(&sampleProbabilityPair, NULL);
		return result;
	}
	else
	{
		(void)Assign_ExistenceSpace(&existenceSpace, NULL);
		(void)Assign_ExistenceSpace(&existenceSpace_1, NULL);
	}
	(void)Assign_ExistenceSpace(&existenceSpace_2, sample);
	existenceSpace_3 = TwoPointDistri_get_FailurSample(self);
	boolean_1 = Space_6_op_Equality(existenceSpace_2, existenceSpace_3);
	if (!!boolean_1)
	{
		struct StaticList_15 *staticList_1 = NULL;
		struct SampleProbabilityPair_2 *sampleProbabilityPair_1 = NULL;
		float64_t double__1 = 0.0;

		(void)Assign_ExistenceSpace(&existenceSpace_2, NULL);
		(void)Assign_ExistenceSpace(&existenceSpace_3, NULL);
		staticList_1 = SampleSet_2_get_Samples(&self->base);
		sampleProbabilityPair_1 = StaticList_15_get_Item(staticList_1, ((int32_t)1));
		double__1 = SampleProbabiPair_2_get_Probabi(sampleProbabilityPair_1);
		result = double__1;
		(void)Assign_StaticList_15(&staticList_1, NULL);
		(void)Assign_SampleProbabilityPair_2(&sampleProbabilityPair_1, NULL);
		return result;
	}
	else
	{
		(void)Assign_ExistenceSpace(&existenceSpace_2, NULL);
		(void)Assign_ExistenceSpace(&existenceSpace_3, NULL);
	}
	return 0.0;
}

bool_t Nullable_2_get_HasValue(struct Nullable_2 *const self)
{
	return (*self).hasValue;
}

int32_t Gaussian_2_get_Dimensions(struct Gaussian_2 *const self)
{
	return self->_dimensions;
}

bool_t MatrixData_15_get_IsScalar(struct MatrixData_15 *const self)
{
	return ((int32_t)16) == ((int32_t)1);
}

static void Del_int32_t_1D_4(struct int32_t_1D_4 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_int32_t_1D_4(struct int32_t_1D_4 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_int32_t_1D_4.CurrentCount--;
		Res_int32_t_1D_4.Next[Res_int32_t_1D_4.CurrentCount] = self;
		Del_int32_t_1D_4(self);
	}
}

struct int32_t_1D_4 *New_int32_t_1D_4(void)
{
	static struct int32_t_1D_4 const Default_int32_t_1D_4 = { 1 };
	struct int32_t_1D_4 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_int32_t_1D_4.CurrentCount == RC_int32_t_1D_4)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_int32_t_1D_4.Next[Res_int32_t_1D_4.CurrentCount];
	Res_int32_t_1D_4.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_int32_t_1D_4.MaximumCount = (Res_int32_t_1D_4.CurrentCount > Res_int32_t_1D_4.MaximumCount) ? Res_int32_t_1D_4.CurrentCount : Res_int32_t_1D_4.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_int32_t_1D_4;
	return instance;
}

struct int32_t_1D_4 *Assign_int32_t_1D_4(struct int32_t_1D_4 **const left, struct int32_t_1D_4 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_int32_t_1D_4(*left);
	*left = right;
	return right;
}

void LinearAlgebra_FactorLU_1(struct LinearAlgebra *const self, struct float64_t_1D_16 *a, int32_t rows, struct int32_t_1D_4 *pivotIndices)
{
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	float64_t num4 = 0.0;
	int32_t j = ((int32_t)0);
	float64_t num5 = 0.0;
	int32_t k = ((int32_t)0);
	float64_t num6 = 0.0;
	int32_t l = ((int32_t)0);
	int32_t expr_150_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t expr_187_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rows > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)16) % rows) != ((int32_t)0)))
	{
		abort();
	}
	num = ((int32_t)16) / rows;
	int32 = Math_Min(num, rows);
	num2 = int32;
	if (!(pivotIndices != NULL))
	{
		abort();
	}
	if (!(((int32_t)4) == num2))
	{
		abort();
	}
	i = ((int32_t)0);
	while (i < num2)
	{
		num3 = i;
		num4 = 0.0;
		j = i;
		while (j < num)
		{
			float64_t double_ = 0.0;

			double_ = Math_Abs(a->Elements[(i * rows) + j]);
			num5 = double_;
			if (!(num5 <= num4))
			{
				num4 = num5;
				num3 = j;
			}
			j = j + ((int32_t)1);
		}
		pivotIndices->Elements[i] = num3 + ((int32_t)1);
		if (!!(a->Elements[(i * rows) + num3] == 0.0))
		{
			abort();
		}
		if (!(num3 == i))
		{
			k = ((int32_t)0);
			while (k < num)
			{
				num6 = a->Elements[(k * rows) + num3];
				a->Elements[(k * rows) + num3] = a->Elements[(k * rows) + i];
				a->Elements[(k * rows) + i] = num6;
				k = k + ((int32_t)1);
			}
		}
		if (!(a->Elements[(i * rows) + i] == 1.0))
		{
			l = i + ((int32_t)1);
			while (l < rows)
			{
				expr_150_cp_1 = (i * rows) + l;
				a->Elements[expr_150_cp_1] = a->Elements[expr_150_cp_1] / a->Elements[(i * rows) + i];
				l = l + ((int32_t)1);
			}
		}
		m = i + ((int32_t)1);
		while (m < num)
		{
			n = i + ((int32_t)1);
			while (n < rows)
			{
				expr_187_cp_1 = (m * rows) + n;
				a->Elements[expr_187_cp_1] = a->Elements[expr_187_cp_1] - (a->Elements[(m * rows) + i] * a->Elements[(i * rows) + n]);
				n = n + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
}

float64_t MatrixMath_Det(struct MatrixData_15 *matrix)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	bool_t boolean_2 = false;
	struct float64_t_1D_16 *array = NULL;
	struct float64_t_1D_16 *array_1 = NULL;
	struct float64_t_1D_16 *array_2 = NULL;
	struct float64_t_1D_16 *array_3 = NULL;
	struct int32_t_1D_4 *array2 = NULL;
	struct int32_t_1D_4 *array_4 = NULL;
	float64_t num = 0.0;
	int32_t i = ((int32_t)0);

	if (!(matrix != NULL))
	{
		abort();
	}
	boolean = MatrixData_15_get_IsEmpty(matrix);
	boolean_1 = MatrixData_15_get_IsScalar(matrix);
	boolean_2 = MatrixData_15_get_IsZero(matrix);
	if (!!boolean_2)
	{
		RemRef_float64_t_1D_16(array);
		RemRef_int32_t_1D_4(array2);
		return 0.0;
	}
	array_1 = MatrixData_15_get_DataReference(matrix);
	array_2 = New_float64_t_1D_16();
	(void)Assign_float64_t_1D_16(&array, array_2);
	(void)Assign_float64_t_1D_16(&array_1, NULL);
	(void)Assign_float64_t_1D_16(&array_2, NULL);
	array_3 = MatrixData_15_get_DataReference(matrix);
	(void)memcpy(&array->Elements, &array_3->Elements, sizeof(float64_t) * ((int32_t)16));
	(void)Assign_float64_t_1D_16(&array_3, NULL);
	array_4 = New_int32_t_1D_4();
	(void)Assign_int32_t_1D_4(&array2, array_4);
	(void)Assign_int32_t_1D_4(&array_4, NULL);
	LinearAlgebra_FactorLU_1(MatrixMath_LinearAlgebra, array, matrix->Rows, array2);
	num = 1.0;
	i = ((int32_t)0);
	while (i < matrix->Rows)
	{
		num = num * array->Elements[(i * matrix->Rows) + i];
		if (!(array2->Elements[i] == (i + ((int32_t)1))))
		{
			num = num * -1.0;
		}
		i = i + ((int32_t)1);
	}
	RemRef_float64_t_1D_16(array);
	RemRef_int32_t_1D_4(array2);
	return num;
}

void Nullable_2_ctor(struct Nullable_2 *const self, float64_t value)
{
	(*self).value = value;
	(*self).hasValue = true;
}

float64_t Nullable_2_get_Value(struct Nullable_2 *const self)
{
	if (!(*self).hasValue)
	{
		ThrowHelpe_ThrowInvalOperaExcep(ExcepResou_InvaliOperat_NoValue);
	}
	return (*self).value;
}

float64_t SquareMatrix_3_get_Determinant(struct PositiveDefiniteMatrix_3 *const self)
{
	struct PositiveDefiniteMatrix_3 *positiveDefiniteMatrix = NULL;
	bool_t boolean = false;
	struct PositiveDefiniteMatrix_3 *positiveDefiniteMatrix_1 = NULL;
	float64_t double_ = 0.0;

	(void)Assign_PositiveDefiniteMatrix_3(&positiveDefiniteMatrix, self);
	boolean = Nullable_2_get_HasValue(&(&positiveDefiniteMatrix->base)->CachedDeterminant);
	if (!boolean)
	{
		struct MatrixData_15 *matrixData = NULL;
		float64_t double__1 = 0.0;
		struct Nullable_2 nullable = { 0 };

		matrixData = Matrix_3_get_MatrixData(&self->base.base);
		double__1 = MatrixMath_Det(matrixData);
		Nullable_2_ctor(&nullable, double__1);
		(&self->base)->CachedDeterminant = nullable;
		(void)Assign_MatrixData_15(&matrixData, NULL);
	}
	(void)Assign_PositiveDefiniteMatrix_3(&positiveDefiniteMatrix_1, self);
	double_ = Nullable_2_get_Value(&(&positiveDefiniteMatrix_1->base)->CachedDeterminant);
	RemRef_PositiveDefiniteMatrix_3(positiveDefiniteMatrix);
	RemRef_PositiveDefiniteMatrix_3(positiveDefiniteMatrix_1);
	return double_;
}

float64_t Gaussian_2_Evaluate(struct Gaussian_2 *const self, float64_t mahalanobisSquared)
{
	struct Gaussian_2 *gaussian = NULL;
	bool_t boolean = false;
	struct Gaussian_2 *gaussian_1 = NULL;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;

	(void)Assign_Gaussian_2(&gaussian, self);
	boolean = Nullable_2_get_HasValue(&gaussian->NormalizationFactor);
	if (!boolean)
	{
		int32_t int32 = ((int32_t)0);
		float64_t double__2 = 0.0;
		struct PositiveDefiniteMatrix_3 *positiveDefiniteMatrix = NULL;
		float64_t double__3 = 0.0;
		float64_t double__4 = 0.0;
		struct Nullable_2 nullable = { 0 };

		int32 = Gaussian_2_get_Dimensions(self);
		double__2 = Math_Pow(6.2831853071795862, (float64_t)int32 / 2.0);
		positiveDefiniteMatrix = Gaussian_2_get_Covariance(self);
		double__3 = SquareMatrix_3_get_Determinant(positiveDefiniteMatrix);
		double__4 = Math_Sqrt(double__3);
		Nullable_2_ctor(&nullable, 1.0 / (double__2 * double__4));
		self->NormalizationFactor = nullable;
		(void)Assign_PositiveDefiniteMatrix_3(&positiveDefiniteMatrix, NULL);
	}
	(void)Assign_Gaussian_2(&gaussian_1, self);
	double_ = Nullable_2_get_Value(&gaussian_1->NormalizationFactor);
	double__1 = Math_Exp(-mahalanobisSquared / 2.0);
	RemRef_Gaussian_2(gaussian);
	RemRef_Gaussian_2(gaussian_1);
	return double_ * double__1;
}

float64_t Gaussian_2_Evaluate_1(struct Gaussian_2 *const self, struct MobilEyeSpace *sample)
{
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;

	double_ = Gaussi_2_GetMahalaDistanSquared(self, sample);
	double__1 = Gaussian_2_Evaluate(self, double_);
	return double__1;
}

void AssociationTable_set_Item(struct AssociationTable *const self, int32_t row, int32_t column, float64_t value)
{
	bool_t arg_33_0 = false;
	bool_t arg_55_0 = false;

	if (!(__ContrRunti_1_insidContrEvalua > ((int32_t)4)))
	{
		__ContrRunti_1_insidContrEvalua = __ContrRunti_1_insidContrEvalua + ((int32_t)1);
		if (!(row < ((int32_t)0)))
		{
			int32_t int32 = ((int32_t)0);
			int32_t int32_1 = ((int32_t)0);

			int32 = row;
			int32_1 = AssociationTable_get_Rows(self);
			arg_33_0 = int32 < int32_1;
		}
		else
		{
			arg_33_0 = false;
		}
		if (!arg_33_0)
		{
			abort();
		}
		if (!(column < ((int32_t)0)))
		{
			int32_t int32_2 = ((int32_t)0);
			int32_t int32_3 = ((int32_t)0);

			int32_2 = column;
			int32_3 = AssociationTable_get_Columns(self);
			arg_55_0 = int32_2 < int32_3;
		}
		else
		{
			arg_55_0 = false;
		}
		if (!arg_55_0)
		{
			abort();
		}
		if (!(value >= 0.0))
		{
			abort();
		}
		__ContrRunti_1_insidContrEvalua = __ContrRunti_1_insidContrEvalua - ((int32_t)1);
	}
	self->_items->Elements[(row * ((int32_t)40)) + column] = value;
}

static void Del_int32_t_1D_40(struct int32_t_1D_40 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_int32_t_1D_40(struct int32_t_1D_40 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_int32_t_1D_40.CurrentCount--;
		Res_int32_t_1D_40.Next[Res_int32_t_1D_40.CurrentCount] = self;
		Del_int32_t_1D_40(self);
	}
}

struct int32_t_1D_40 *New_int32_t_1D_40(void)
{
	static struct int32_t_1D_40 const Default_int32_t_1D_40 = { 1 };
	struct int32_t_1D_40 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_int32_t_1D_40.CurrentCount == RC_int32_t_1D_40)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_int32_t_1D_40.Next[Res_int32_t_1D_40.CurrentCount];
	Res_int32_t_1D_40.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_int32_t_1D_40.MaximumCount = (Res_int32_t_1D_40.CurrentCount > Res_int32_t_1D_40.MaximumCount) ? Res_int32_t_1D_40.CurrentCount : Res_int32_t_1D_40.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_int32_t_1D_40;
	return instance;
}

struct int32_t_1D_40 *Assign_int32_t_1D_40(struct int32_t_1D_40 **const left, struct int32_t_1D_40 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_int32_t_1D_40(*left);
	*left = right;
	return right;
}

static void RemRef_IAssociationTable(struct IAssociationTable *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_IAssociationTable.CurrentCount--;
		Res_IAssociationTable.Next[Res_IAssociationTable.CurrentCount] = self;
		Del_IAssociationTable(self);
	}
}

struct IAssociationTable *New_IAssociationTable(void)
{
	static struct IAssociationTable const Default_IAssociationTable = { 1 };
	struct IAssociationTable *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_IAssociationTable.CurrentCount == RC_IAssociationTable)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_IAssociationTable.Next[Res_IAssociationTable.CurrentCount];
	Res_IAssociationTable.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_IAssociationTable.MaximumCount = (Res_IAssociationTable.CurrentCount > Res_IAssociationTable.MaximumCount) ? Res_IAssociationTable.CurrentCount : Res_IAssociationTable.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_IAssociationTable;
	return instance;
}

struct IAssociationTable *Assign_IAssociationTable(struct IAssociationTable **const left, struct IAssociationTable *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_IAssociationTable(*left);
	*left = right;
	return right;
}

static void RemRef_StaticList_5(struct StaticList_5 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_5.CurrentCount--;
		Res_StaticList_5.Next[Res_StaticList_5.CurrentCount] = self;
		Del_StaticList_5(self);
	}
}

struct StaticList_5 *New_StaticList_5(void)
{
	static struct StaticList_5 const Default_StaticList_5 = { 1 };
	struct StaticList_5 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_5.CurrentCount == RC_StaticList_5)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_5.Next[Res_StaticList_5.CurrentCount];
	Res_StaticList_5.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_5.MaximumCount = (Res_StaticList_5.CurrentCount > Res_StaticList_5.MaximumCount) ? Res_StaticList_5.CurrentCount : Res_StaticList_5.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_5;
	return instance;
}

struct StaticList_5 *Assign_StaticList_5(struct StaticList_5 **const left, struct StaticList_5 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_5(*left);
	*left = right;
	return right;
}

static void Del_StaticList_1D_15(struct StaticList_1D_15 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)15);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_StaticList(self->Elements[i]);
	}
}

static void RemRef_StaticList_1D_15(struct StaticList_1D_15 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_1D_15.CurrentCount--;
		Res_StaticList_1D_15.Next[Res_StaticList_1D_15.CurrentCount] = self;
		Del_StaticList_1D_15(self);
	}
}

struct StaticList_1D_15 *New_StaticList_1D_15(void)
{
	static struct StaticList_1D_15 const Default_StaticList_1D_15 = { 1 };
	struct StaticList_1D_15 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_1D_15.CurrentCount == RC_StaticList_1D_15)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_1D_15.Next[Res_StaticList_1D_15.CurrentCount];
	Res_StaticList_1D_15.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_1D_15.MaximumCount = (Res_StaticList_1D_15.CurrentCount > Res_StaticList_1D_15.MaximumCount) ? Res_StaticList_1D_15.CurrentCount : Res_StaticList_1D_15.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_1D_15;
	return instance;
}

struct StaticList_1D_15 *Assign_StaticList_1D_15(struct StaticList_1D_15 **const left, struct StaticList_1D_15 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_1D_15(*left);
	*left = right;
	return right;
}

void StaticList_5_ctor(struct StaticList_5 *const self, int32_t maximumCount)
{
	struct StaticList_1D_15 *array = NULL;

	assert(maximumCount == ((int32_t)15));
	Object_ctor(&self->base);
	array = New_StaticList_1D_15();
	(void)Assign_StaticList_1D_15(&self->_items, array);
	(void)Assign_StaticList_1D_15(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_5 *StatiListFacto_4_CreateInstan_3(struct StaticListFactory_4 *const self, int32_t capacity)
{
	struct StaticList_5 *result = NULL;
	struct StaticList_5 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_4_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_5();
	StaticList_5_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_5(&result, staticList);
	(void)Assign_StaticList_5(&staticList, NULL);
	return result;
}

static void RemRef_StaticList(struct StaticList *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList.CurrentCount--;
		Res_StaticList.Next[Res_StaticList.CurrentCount] = self;
		Del_StaticList(self);
	}
}

struct StaticList *New_StaticList(void)
{
	static struct StaticList const Default_StaticList = { 1 };
	struct StaticList *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList.CurrentCount == RC_StaticList)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList.Next[Res_StaticList.CurrentCount];
	Res_StaticList.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList.MaximumCount = (Res_StaticList.CurrentCount > Res_StaticList.MaximumCount) ? Res_StaticList.CurrentCount : Res_StaticList.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList;
	return instance;
}

struct StaticList *Assign_StaticList(struct StaticList **const left, struct StaticList *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList(*left);
	*left = right;
	return right;
}

void StaticList_ctor(struct StaticList *const self, int32_t maximumCount)
{
	struct int32_t_1D_40 *array = NULL;

	assert(maximumCount == ((int32_t)40));
	Object_ctor(&self->base);
	array = New_int32_t_1D_40();
	(void)Assign_int32_t_1D_40(&self->_items, array);
	(void)Assign_int32_t_1D_40(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList *StatiListFactor_5_CreateInstan(struct StaticListFactory_5 *const self, int32_t capacity)
{
	struct StaticList *result = NULL;
	struct StaticList *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_5_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList();
	StaticList_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList(&result, staticList);
	(void)Assign_StaticList(&staticList, NULL);
	return result;
}

int32_t StaticList_5_get_Count(struct StaticList_5 *const self)
{
	return self->Count;
}

static void StaticList_5_CheckCount(struct StaticList_5 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_5_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_5_set_Count(struct StaticList_5 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_5_Add(struct StaticList_5 *const self, struct StaticList *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_5_CheckCount(self);
	int32 = StaticList_5_get_Count(self);
	count = int32;
	(void)Assign_StaticList(&self->_items->Elements[count], value);
	int32_1 = StaticList_5_get_Count(self);
	StaticList_5_set_Count(self, int32_1 + ((int32_t)1));
}

float64_t AssociationTable_get_Item(struct AssociationTable *const self, int32_t row, int32_t column)
{
	bool_t arg_33_0 = false;
	bool_t arg_55_0 = false;

	if (!(__ContrRunti_1_insidContrEvalua > ((int32_t)1)))
	{
		__ContrRunti_1_insidContrEvalua = __ContrRunti_1_insidContrEvalua + ((int32_t)1);
		if (!(row < ((int32_t)0)))
		{
			int32_t int32 = ((int32_t)0);
			int32_t int32_1 = ((int32_t)0);

			int32 = row;
			int32_1 = AssociationTable_get_Rows(self);
			arg_33_0 = int32 < int32_1;
		}
		else
		{
			arg_33_0 = false;
		}
		if (!arg_33_0)
		{
			abort();
		}
		if (!(column < ((int32_t)0)))
		{
			int32_t int32_2 = ((int32_t)0);
			int32_t int32_3 = ((int32_t)0);

			int32_2 = column;
			int32_3 = AssociationTable_get_Columns(self);
			arg_55_0 = int32_2 < int32_3;
		}
		else
		{
			arg_55_0 = false;
		}
		if (!arg_55_0)
		{
			abort();
		}
		__ContrRunti_1_insidContrEvalua = __ContrRunti_1_insidContrEvalua - ((int32_t)1);
	}
	return self->_items->Elements[(row * ((int32_t)40)) + column];
}

int32_t StaticList_get_Count(struct StaticList *const self)
{
	return self->Count;
}

static void StaticList_CheckCount(struct StaticList *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_set_Count(struct StaticList *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_Add(struct StaticList *const self, int32_t value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_CheckCount(self);
	int32 = StaticList_get_Count(self);
	count = int32;
	self->_items->Elements[count] = value;
	int32_1 = StaticList_get_Count(self);
	StaticList_set_Count(self, int32_1 + ((int32_t)1));
}

struct StaticList *StaticList_5_get_Item(struct StaticList_5 *const self, int32_t index)
{
	struct StaticList *result = NULL;

	(void)Assign_StaticList(&result, self->_items->Elements[index]);
	return result;
}

struct StaticList_5 *MultiLocalNeareNeighb_GetAssoci(struct MultipleLocalNearestNeighbor *const self, struct AssociationTable *associationTable, struct StaticList **notAssociated)
{
	struct StaticList_5 *list = NULL;
	struct StaticListFactory_4 *staticListFactory = NULL;
	int32_t int32 = ((int32_t)0);
	struct StaticList_5 *staticList = NULL;
	struct StaticList **staticList_1 = NULL;
	struct StaticListFactory_5 *staticListFactory_1 = NULL;
	struct StaticList *staticList_2 = NULL;
	int32_t i = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);
	int32_t int32_2 = ((int32_t)0);
	int32_t j = ((int32_t)0);
	float64_t num = 0.0;
	int32_t num2 = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t int32_3 = ((int32_t)0);
	int32_t int32_4 = ((int32_t)0);
	struct StaticList_5 *result = NULL;

	if (!(associationTable != NULL))
	{
		abort();
	}
	staticListFactory = StIPDATrCoFacPro_get_Obj1LisFac(self->_factoryProvider);
	int32 = AssociationTable_get_Rows(associationTable);
	staticList = StatiListFacto_4_CreateInstan_3(staticListFactory, int32);
	(void)Assign_StaticList_5(&list, staticList);
	(void)Assign_StaticListFactory_4(&staticListFactory, NULL);
	(void)Assign_StaticList_5(&staticList, NULL);
	staticList_1 = notAssociated;
	staticListFactory_1 = StIPDATrCoFacPro_get_Obj2LisFac(self->_factoryProvider);
	staticList_2 = StatiListFactor_5_CreateInstan(staticListFactory_1, ((int32_t)0));
	(void)Assign_StaticList(&*staticList_1, staticList_2);
	(void)Assign_StaticListFactory_5(&staticListFactory_1, NULL);
	(void)Assign_StaticList(&staticList_2, NULL);
	i = ((int32_t)0);
	int32_1 = i;
	int32_2 = AssociationTable_get_Rows(associationTable);
	while (int32_1 < int32_2)
	{
		struct StaticList_5 *staticList_3 = NULL;
		struct StaticListFactory_5 *staticListFactory_2 = NULL;
		struct StaticList *staticList_4 = NULL;

		(void)Assign_StaticList_5(&staticList_3, list);
		staticListFactory_2 = StIPDATrCoFacPro_get_Obj2LisFac(self->_factoryProvider);
		staticList_4 = StatiListFactor_5_CreateInstan(staticListFactory_2, ((int32_t)0));
		StaticList_5_Add(staticList_3, staticList_4);
		(void)Assign_StaticList_5(&staticList_3, NULL);
		(void)Assign_StaticListFactory_5(&staticListFactory_2, NULL);
		(void)Assign_StaticList(&staticList_4, NULL);
		i = i + ((int32_t)1);
		int32_1 = i;
		int32_2 = AssociationTable_get_Rows(associationTable);
	}
	j = ((int32_t)0);
	int32_3 = j;
	int32_4 = AssociationTable_get_Columns(associationTable);
	while (int32_3 < int32_4)
	{
		int32_t int32_5 = ((int32_t)0);
		int32_t int32_6 = ((int32_t)0);

		num = 0.0;
		num2 = ((int32_t)-1);
		k = ((int32_t)0);
		int32_5 = k;
		int32_6 = AssociationTable_get_Rows(associationTable);
		while (int32_5 < int32_6)
		{
			float64_t double_ = 0.0;

			double_ = AssociationTable_get_Item(associationTable, k, j);
			if (!(double_ <= num))
			{
				float64_t double__1 = 0.0;

				double__1 = AssociationTable_get_Item(associationTable, k, j);
				num = double__1;
				num2 = k;
			}
			k = k + ((int32_t)1);
			int32_5 = k;
			int32_6 = AssociationTable_get_Rows(associationTable);
		}
		if (!(num2 != ((int32_t)-1)))
		{
			StaticList_Add(*notAssociated, j);
		}
		else
		{
			struct StaticList *staticList_5 = NULL;

			staticList_5 = StaticList_5_get_Item(list, num2);
			StaticList_Add(staticList_5, j);
			(void)Assign_StaticList(&staticList_5, NULL);
		}
		j = j + ((int32_t)1);
		int32_3 = j;
		int32_4 = AssociationTable_get_Columns(associationTable);
	}
	(void)Assign_StaticList_5(&result, list);
	RemRef_StaticList_5(list);
	return result;
}

static void Associatio_DetermineAssociation(struct Association *const self)
{
	struct MultipleLocalNearestNeighbor *multipleLocalNearestNeighbor = NULL;
	struct AssociationTable *associationTable = NULL;
	struct StaticList_5 *staticList = NULL;

	(void)Assign_MultipLocalNearesNeighbo(&multipleLocalNearestNeighbor, self->_associationAlgorithm);
	associationTable = Associatio_get_AssociationTable(self);
	staticList = MultiLocalNeareNeighb_GetAssoci(multipleLocalNearestNeighbor, associationTable, &self->_notAssociatedObjects);
	(void)Assign_StaticList_5(&self->_associations, staticList);
	(void)Assign_MultipLocalNearesNeighbo(&multipleLocalNearestNeighbor, NULL);
	(void)Assign_AssociationTable(&associationTable, NULL);
	(void)Assign_StaticList_5(&staticList, NULL);
}

void MeasurementAssociation_ctor(struct MeasurementAssociation *const self, struct StaticList_20 *likelihoods, struct StaticList_26 *existences, struct StaticList_6 *measurements, struct MultipleLocalNearestNeighbor *associationAlgorithm, struct ProbabilityGate *gate, struct StatiIPDATrackColleFactorProvid *factoryProvider)
{
	struct StaticListEnumerator_14 *enumerator = NULL;
	struct StaticListEnumerator_14 *staticListEnumerator = NULL;
	int32_t i = ((int32_t)0);
	struct Gaussian_2 *object = NULL;
	int32_t j = ((int32_t)0);
	struct MobilEyeSpace *tMeasurementSpace = NULL;
	float64_t num = 0.0;
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	if (!(likelihoods != NULL))
	{
		abort();
	}
	if (!(existences != NULL))
	{
		abort();
	}
	if (!(measurements != NULL))
	{
		abort();
	}
	if (!(associationAlgorithm != NULL))
	{
		abort();
	}
	Association_ctor(&self->base, likelihoods, measurements, associationAlgorithm, factoryProvider);
	staticListEnumerator = StaticList_26_GetEnumerator(existences);
	(void)Assign_StaticListEnumerator_14(&enumerator, staticListEnumerator);
	(void)Assign_StaticListEnumerator_14(&staticListEnumerator, NULL);
	i = ((int32_t)0);
	int32 = i;
	int32_1 = Association_get_Count1(&self->base);
	while (int32 < int32_1)
	{
		struct StaticList_20 *staticList = NULL;
		struct Gaussian_2 *gaussian = NULL;
		bool_t boolean = false;
		int32_t int32_2 = ((int32_t)0);
		int32_t int32_3 = ((int32_t)0);

		staticList = Association_get_Objects1(&self->base);
		gaussian = StaticList_20_get_Item(staticList, i);
		(void)Assign_Gaussian_2(&object, gaussian);
		(void)Assign_StaticList_20(&staticList, NULL);
		(void)Assign_Gaussian_2(&gaussian, NULL);
		boolean = StaticListEnumerato_14_MoveNext(enumerator);
		if (!boolean)
		{
			abort();
		}
		j = ((int32_t)0);
		int32_2 = j;
		int32_3 = Association_get_Count2(&self->base);
		while (int32_2 < int32_3)
		{
			struct StaticList_6 *staticList_1 = NULL;
			struct MobilEyeSpace *mobilEyeSpace = NULL;
			bool_t boolean_1 = false;
			struct ProbabilityGate *probabilityGate = NULL;
			bool_t boolean_2 = false;

			staticList_1 = Association_get_Objects2(&self->base);
			mobilEyeSpace = StaticList_6_get_Item(staticList_1, j);
			(void)Assign_MobilEyeSpace(&tMeasurementSpace, mobilEyeSpace);
			(void)Assign_StaticList_6(&staticList_1, NULL);
			(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
			(void)Assign_ProbabilityGate(&probabilityGate, gate);
			if ((probabilityGate != NULL) == true)
			{
				boolean_1 = Gate_IsInside(&gate->base.base, object, tMeasurementSpace);
				boolean_2 = !boolean_1;
			}
			else
			{
				boolean_2 = false;
			}
			if (!boolean_2)
			{
				struct Existence *existence = NULL;
				float64_t double_ = 0.0;
				struct AssociationTable *associationTable = NULL;
				int32_t int32_4 = ((int32_t)0);
				int32_t int32_5 = ((int32_t)0);
				float64_t double__1 = 0.0;

				(void)Assign_ProbabilityGate(&probabilityGate, NULL);
				existence = StaticListEnumer_14_get_Current(enumerator);
				double_ = TwoPointDistribution_Evaluate(&existence->base, ExistenceSpace_1_Existent);
				num = double_;
				(void)Assign_Existence(&existence, NULL);
				associationTable = Associatio_get_AssociationTable(&self->base);
				int32_4 = i;
				int32_5 = j;
				double__1 = Gaussian_2_Evaluate_1(object, tMeasurementSpace);
				AssociationTable_set_Item(associationTable, int32_4, int32_5, double__1 * num);
				(void)Assign_AssociationTable(&associationTable, NULL);
			}
			else
			{
				(void)Assign_ProbabilityGate(&probabilityGate, NULL);
			}
			j = j + ((int32_t)1);
			int32_2 = j;
			int32_3 = Association_get_Count2(&self->base);
		}
		i = i + ((int32_t)1);
		int32 = i;
		int32_1 = Association_get_Count1(&self->base);
	}
	Associatio_DetermineAssociation(&self->base);
	RemRef_StaticListEnumerator_14(enumerator);
	RemRef_Gaussian_2(object);
	RemRef_MobilEyeSpace(tMeasurementSpace);
}

struct MeasurementAssociation *MeasurementAssociation_2_Create(struct StaticList_20 *likelihoodIntegralDistributions, struct StaticList_26 *existences, struct StaticList_6 *measurements, struct MultipleLocalNearestNeighbor *associationAlgorithm, struct ProbabilityGate *gate, struct StatiIPDATrackColleFactorProvid *factoryProvider)
{
	struct MeasurementAssociation *result = NULL;
	struct MeasurementAssociation *measurementAssociation = NULL;

	if (!(likelihoodIntegralDistributions != NULL))
	{
		abort();
	}
	if (!(existences != NULL))
	{
		abort();
	}
	if (!(measurements != NULL))
	{
		abort();
	}
	if (!(associationAlgorithm != NULL))
	{
		abort();
	}
	measurementAssociation = New_MeasurementAssociation();
	MeasurementAssociation_ctor(measurementAssociation, likelihoodIntegralDistributions, existences, measurements, associationAlgorithm, gate, factoryProvider);
	(void)Assign_MeasurementAssociation(&result, measurementAssociation);
	(void)Assign_MeasurementAssociation(&measurementAssociation, NULL);
	return result;
}

struct StaticList_27 *StatiListFacto_4_CreateInstan_4(struct StaticListFactory_4 *const self, int32_t capacity)
{
	struct StaticList_27 *result = NULL;
	struct StaticList_27 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_4_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_27();
	StaticList_27_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_27(&result, staticList);
	(void)Assign_StaticList_27(&staticList, NULL);
	return result;
}

static void RemRef_StaticListEnumerator(struct StaticListEnumerator *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListEnumerator.CurrentCount--;
		Res_StaticListEnumerator.Next[Res_StaticListEnumerator.CurrentCount] = self;
		Del_StaticListEnumerator(self);
	}
}

struct StaticListEnumerator *New_StaticListEnumerator(void)
{
	static struct StaticListEnumerator const Default_StaticListEnumerator = { 1 };
	struct StaticListEnumerator *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListEnumerator.CurrentCount == RC_StaticListEnumerator)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListEnumerator.Next[Res_StaticListEnumerator.CurrentCount];
	Res_StaticListEnumerator.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListEnumerator.MaximumCount = (Res_StaticListEnumerator.CurrentCount > Res_StaticListEnumerator.MaximumCount) ? Res_StaticListEnumerator.CurrentCount : Res_StaticListEnumerator.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListEnumerator;
	return instance;
}

struct StaticListEnumerator *Assign_StaticListEnumerator(struct StaticListEnumerator **const left, struct StaticListEnumerator *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListEnumerator(*left);
	*left = right;
	return right;
}

void StaticListEnumerator_ctor(struct StaticListEnumerator *const self, struct StaticList *list)
{
	self->_current = ((int32_t)-1);
	Object_ctor(&self->base);
	(void)Assign_StaticList(&self->_list, list);
}

struct StaticListEnumerator *StaticList_GetEnumerator(struct StaticList *const self)
{
	struct StaticListEnumerator *result = NULL;
	struct StaticListEnumerator *staticListEnumerator = NULL;

	staticListEnumerator = New_StaticListEnumerator();
	StaticListEnumerator_ctor(staticListEnumerator, self);
	(void)Assign_StaticListEnumerator(&result, staticListEnumerator);
	(void)Assign_StaticListEnumerator(&staticListEnumerator, NULL);
	return result;
}

bool_t StaticListEnumerator_MoveNext(struct StaticListEnumerator *const self)
{
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	self->_current = self->_current + ((int32_t)1);
	int32 = self->_current;
	int32_1 = StaticList_get_Count(self->_list);
	return int32 != int32_1;
}

int32_t StaticList_get_Item(struct StaticList *const self, int32_t index)
{
	return self->_items->Elements[index];
}

int32_t StaticListEnumerato_get_Current(struct StaticListEnumerator *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_get_Item(self->_list, self->_current);
	return int32;
}

void StaticListEnumerator_Dispose(struct StaticListEnumerator *const self)
{
}

struct StaticList_6 *Associatio_GetAssociatedObjects(struct Association *const self, int32_t object1Index)
{
	struct StaticList_6 *list = NULL;
	struct StaticListFactory_5 *staticListFactory = NULL;
	struct StaticList_6 *staticList = NULL;
	struct StaticListEnumerator *enumerator = NULL;
	struct StaticList *staticList_1 = NULL;
	struct StaticListEnumerator *staticListEnumerator = NULL;
	int32_t current = ((int32_t)0);
	bool_t boolean = false;
	struct StaticList_6 *result = NULL;

	if (!(__ContrRunti_1_insidContrEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_1_insidContrEvalua = __ContrRunti_1_insidContrEvalua + ((int32_t)1);
		if (!(object1Index >= ((int32_t)0)))
		{
			abort();
		}
		int32 = object1Index;
		int32_1 = Association_get_Count1(self);
		if (!(int32 < int32_1))
		{
			abort();
		}
		__ContrRunti_1_insidContrEvalua = __ContrRunti_1_insidContrEvalua - ((int32_t)1);
	}
	staticListFactory = StIPDATrCoFacPro_get_Obj2LisFac(self->_factoryProvider);
	staticList = StaticListFactor_5_CreateInstan(staticListFactory, ((int32_t)0));
	(void)Assign_StaticList_6(&list, staticList);
	(void)Assign_StaticListFactory_5(&staticListFactory, NULL);
	(void)Assign_StaticList_6(&staticList, NULL);
	staticList_1 = StaticList_5_get_Item(self->_associations, object1Index);
	staticListEnumerator = StaticList_GetEnumerator(staticList_1);
	(void)Assign_StaticListEnumerator(&enumerator, staticListEnumerator);
	(void)Assign_StaticList(&staticList_1, NULL);
	(void)Assign_StaticListEnumerator(&staticListEnumerator, NULL);
	boolean = StaticListEnumerator_MoveNext(enumerator);
	while (boolean)
	{
		int32_t int32_2 = ((int32_t)0);
		struct StaticList_6 *staticList_2 = NULL;
		struct StaticList_6 *staticList_3 = NULL;
		struct MobilEyeSpace *mobilEyeSpace = NULL;

		int32_2 = StaticListEnumerato_get_Current(enumerator);
		current = int32_2;
		(void)Assign_StaticList_6(&staticList_2, list);
		staticList_3 = Association_get_Objects2(self);
		mobilEyeSpace = StaticList_6_get_Item(staticList_3, current);
		StaticList_6_Add(staticList_2, mobilEyeSpace);
		(void)Assign_StaticList_6(&staticList_2, NULL);
		(void)Assign_StaticList_6(&staticList_3, NULL);
		(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
		boolean = StaticListEnumerator_MoveNext(enumerator);
	}
	if (!!(enumerator != NULL))
	{
		StaticListEnumerator_Dispose(enumerator);
	}
	(void)Assign_StaticList_6(&result, list);
	RemRef_StaticList_6(list);
	RemRef_StaticListEnumerator(enumerator);
	return result;
}

struct MarginalizedEvaluable *StaticList_22_get_Item(struct StaticList_22 *const self, int32_t index)
{
	struct MarginalizedEvaluable *result = NULL;

	(void)Assign_MarginalizedEvaluable(&result, self->_items->Elements[index]);
	return result;
}

float64_t MobilEyeParame_get_ClutteLambda(struct MobilEyeParameters *const self)
{
	return self->ClutterLambda;
}

static void RemRef_IEvaluable(struct IEvaluable *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_IEvaluable.CurrentCount--;
		Res_IEvaluable.Next[Res_IEvaluable.CurrentCount] = self;
		Del_IEvaluable(self);
	}
}

struct IEvaluable *New_IEvaluable(void)
{
	static struct IEvaluable const Default_IEvaluable = { 1 };
	struct IEvaluable *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_IEvaluable.CurrentCount == RC_IEvaluable)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_IEvaluable.Next[Res_IEvaluable.CurrentCount];
	Res_IEvaluable.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_IEvaluable.MaximumCount = (Res_IEvaluable.CurrentCount > Res_IEvaluable.MaximumCount) ? Res_IEvaluable.CurrentCount : Res_IEvaluable.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_IEvaluable;
	return instance;
}

struct IEvaluable *Assign_IEvaluable(struct IEvaluable **const left, struct IEvaluable *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_IEvaluable(*left);
	*left = right;
	return right;
}

static void RemRef_IEvaluable_1(struct IEvaluable_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_IEvaluable_1.CurrentCount--;
		Res_IEvaluable_1.Next[Res_IEvaluable_1.CurrentCount] = self;
		Del_IEvaluable_1(self);
	}
}

struct IEvaluable_1 *New_IEvaluable_1(void)
{
	static struct IEvaluable_1 const Default_IEvaluable_1 = { 1 };
	struct IEvaluable_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_IEvaluable_1.CurrentCount == RC_IEvaluable_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_IEvaluable_1.Next[Res_IEvaluable_1.CurrentCount];
	Res_IEvaluable_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_IEvaluable_1.MaximumCount = (Res_IEvaluable_1.CurrentCount > Res_IEvaluable_1.MaximumCount) ? Res_IEvaluable_1.CurrentCount : Res_IEvaluable_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_IEvaluable_1;
	return instance;
}

struct IEvaluable_1 *Assign_IEvaluable_1(struct IEvaluable_1 **const left, struct IEvaluable_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_IEvaluable_1(*left);
	*left = right;
	return right;
}

static void RemRef_IEvaluable_2(struct IEvaluable_2 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_IEvaluable_2.CurrentCount--;
		Res_IEvaluable_2.Next[Res_IEvaluable_2.CurrentCount] = self;
		Del_IEvaluable_2(self);
	}
}

struct IEvaluable_2 *New_IEvaluable_2(void)
{
	static struct IEvaluable_2 const Default_IEvaluable_2 = { 1 };
	struct IEvaluable_2 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_IEvaluable_2.CurrentCount == RC_IEvaluable_2)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_IEvaluable_2.Next[Res_IEvaluable_2.CurrentCount];
	Res_IEvaluable_2.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_IEvaluable_2.MaximumCount = (Res_IEvaluable_2.CurrentCount > Res_IEvaluable_2.MaximumCount) ? Res_IEvaluable_2.CurrentCount : Res_IEvaluable_2.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_IEvaluable_2;
	return instance;
}

struct IEvaluable_2 *Assign_IEvaluable_2(struct IEvaluable_2 **const left, struct IEvaluable_2 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_IEvaluable_2(*left);
	*left = right;
	return right;
}

static void IPDA_3_cctor(void)
{
}

static void RemRef_IPDA(struct IPDA *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_IPDA.CurrentCount--;
		Res_IPDA.Next[Res_IPDA.CurrentCount] = self;
		Del_IPDA(self);
	}
}

struct IPDA *New_IPDA(void)
{
	static struct IPDA const Default_IPDA = { 1 };
	struct IPDA *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_IPDA.CurrentCount == RC_IPDA)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_IPDA.Next[Res_IPDA.CurrentCount];
	Res_IPDA.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_IPDA.MaximumCount = (Res_IPDA.CurrentCount > Res_IPDA.MaximumCount) ? Res_IPDA.CurrentCount : Res_IPDA.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_IPDA;
	return instance;
}

struct IPDA *Assign_IPDA(struct IPDA **const left, struct IPDA *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_IPDA(*left);
	*left = right;
	return right;
}

static void IPDA_set_Lambda(struct IPDA *const self, float64_t value)
{
	self->Lambda = value;
}

static void RemRef_CardinalitySpace(struct CardinalitySpace *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_CardinalitySpace.CurrentCount--;
		Res_CardinalitySpace.Next[Res_CardinalitySpace.CurrentCount] = self;
		Del_CardinalitySpace(self);
	}
}

struct CardinalitySpace *New_CardinalitySpace(void)
{
	static struct CardinalitySpace const Default_CardinalitySpace = { 1 };
	struct CardinalitySpace *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_CardinalitySpace.CurrentCount == RC_CardinalitySpace)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_CardinalitySpace.Next[Res_CardinalitySpace.CurrentCount];
	Res_CardinalitySpace.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_CardinalitySpace.MaximumCount = (Res_CardinalitySpace.CurrentCount > Res_CardinalitySpace.MaximumCount) ? Res_CardinalitySpace.CurrentCount : Res_CardinalitySpace.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_CardinalitySpace;
	return instance;
}

struct CardinalitySpace *Assign_CardinalitySpace(struct CardinalitySpace **const left, struct CardinalitySpace *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_CardinalitySpace(*left);
	*left = right;
	return right;
}

void CardinalitySpace_ctor(struct CardinalitySpace *const self)
{
	Space_1_ctor(&self->base, ((int32_t)1));
}

void CardinalitSpace_set_Cardinality(struct CardinalitySpace *const self, int32_t value)
{
	if (!(value >= ((int32_t)0)))
	{
		abort();
	}
	Space_1_set_Item(&self->base, ((int32_t)0), (float64_t)value);
}

struct CardinalitySpace *CardinalitySpace_1_Create(int32_t cardinality)
{
	struct CardinalitySpace *result = NULL;
	struct CardinalitySpace *cardinalitySpace = NULL;

	cardinalitySpace = New_CardinalitySpace();
	CardinalitySpace_ctor(cardinalitySpace);
	CardinalitSpace_set_Cardinality(cardinalitySpace, cardinality);
	(void)Assign_CardinalitySpace(&result, cardinalitySpace);
	(void)Assign_CardinalitySpace(&cardinalitySpace, NULL);
	return result;
}

struct CardinalitySpace *CardinalitySpace_1_op_Implicit(int32_t cardinality)
{
	struct CardinalitySpace *result = NULL;
	struct CardinalitySpace *cardinalitySpace = NULL;

	cardinalitySpace = CardinalitySpace_1_Create(cardinality);
	(void)Assign_CardinalitySpace(&result, cardinalitySpace);
	(void)Assign_CardinalitySpace(&cardinalitySpace, NULL);
	return result;
}

struct StaticListEnumerator_8 *SampleSet_GetEnumerator(struct SampleSet *const self)
{
	struct StaticListEnumerator_8 *result = NULL;
	struct StaticList_13 *staticList = NULL;
	struct StaticListEnumerator_8 *staticListEnumerator = NULL;

	staticList = SampleSet_get_Samples(self);
	staticListEnumerator = StaticList_13_GetEnumerator(staticList);
	(void)Assign_StaticListEnumerator_8(&result, staticListEnumerator);
	(void)Assign_StaticList_13(&staticList, NULL);
	(void)Assign_StaticListEnumerator_8(&staticListEnumerator, NULL);
	return result;
}

struct MobilEyeSpace *SampleProbabilitPair_get_Sample(struct SampleProbabilityPair *const self)
{
	struct MobilEyeSpace *result = NULL;

	(void)Assign_MobilEyeSpace(&result, self->Sample);
	return result;
}

static struct MobilEyeSpace *DetectionModel_get_Condition(struct DetectionModel *const self)
{
	struct MobilEyeSpace *result = NULL;

	(void)Assign_MobilEyeSpace(&result, self->Condition);
	return result;
}

int32_t CardinalitSpace_get_Cardinality(struct CardinalitySpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_1_get_Item(&self->base, ((int32_t)0));
	return (int32_t)double_;
}

float64_t Math_Atan2(float64_t y, float64_t x)
{
	return (float64_t)atan2(y, x);
}

float64_t MobilEyeParame_get_MaximumRange(struct MobilEyeParameters *const self)
{
	return self->MaximumRange;
}

float64_t MobilEyeParame_get_MinimumRange(struct MobilEyeParameters *const self)
{
	return self->MinimumRange;
}

float64_t MobilEyeParame_get_MinimumAngle(struct MobilEyeParameters *const self)
{
	return self->MinimumAngle;
}

float64_t MobilEyeParame_get_MaximumAngle(struct MobilEyeParameters *const self)
{
	return self->MaximumAngle;
}

float64_t MobilEyeParame_get_DetectProbab(struct MobilEyeParameters *const self)
{
	return self->DetectionProbability;
}

static float64_t MobiEyeDetecModel_GetDetecProba(struct MobilEyeDetectionModel *const self, struct MobilEyeSpace *state)
{
	float64_t x = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t y = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t range = 0.0;
	float64_t double__4 = 0.0;
	float64_t phi = 0.0;
	float64_t double__5 = 0.0;
	float64_t double__6 = 0.0;
	float64_t double__7 = 0.0;
	float64_t double__8 = 0.0;
	float64_t double__9 = 0.0;
	float64_t double__10 = 0.0;
	float64_t double__11 = 0.0;
	float64_t arg_89_0 = 0.0;
	float64_t double__12 = 0.0;
	float64_t double__13 = 0.0;
	bool_t boolean = false;
	bool_t boolean_1 = false;
	bool_t boolean_2 = false;
	bool_t boolean_3 = false;

	double_ = MobilEyeSpace_get_X(state);
	double__1 = MobilEyeParameter_get_PositionX(self->_parameters);
	x = double_ - double__1;
	double__2 = MobilEyeSpace_get_Y(state);
	double__3 = MobilEyeParameter_get_PositionY(self->_parameters);
	y = double__2 - double__3;
	double__4 = Math_Sqrt((x * x) + (y * y));
	range = double__4;
	double__5 = Math_Atan2(y, x);
	phi = double__5;
	double__12 = range;
	double__13 = MobilEyeParame_get_MaximumRange(self->_parameters);
	boolean = double__12 <= double__13;
	if (boolean == true)
	{
		double__6 = range;
		double__7 = MobilEyeParame_get_MinimumRange(self->_parameters);
		boolean_1 = double__6 >= double__7;
	}
	else
	{
		boolean_1 = false;
	}
	if (boolean_1 == true)
	{
		double__8 = phi;
		double__9 = MobilEyeParame_get_MinimumAngle(self->_parameters);
		boolean_2 = double__8 >= double__9;
	}
	else
	{
		boolean_2 = false;
	}
	if (boolean_2 == true)
	{
		double__10 = phi;
		double__11 = MobilEyeParame_get_MaximumAngle(self->_parameters);
		boolean_3 = double__10 <= double__11;
	}
	else
	{
		boolean_3 = false;
	}
	if (!boolean_3)
	{
		arg_89_0 = 0.0;
	}
	else
	{
		float64_t double__14 = 0.0;

		double__14 = MobilEyeParame_get_DetectProbab(self->_parameters);
		arg_89_0 = double__14;
	}
	return arg_89_0;
}

float64_t SinglDetectModel_get_GateProbab(struct SingleDetectionModel *const self)
{
	return self->_gateProbability;
}

static float64_t SinglDetecModel_GetDetectProbab(struct MobilEyeDetectionModel *const self, struct CardinalitySpace *sample, struct MobilEyeSpace *state)
{
	int32_t int32 = ((int32_t)0);

	int32 = CardinalitSpace_get_Cardinality(sample);
	switch (int32)
	{
		case ((int32_t)0):
			{
				float64_t double_ = 0.0;
				float64_t double__1 = 0.0;

				double_ = MobiEyeDetecModel_GetDetecProba(self, state);
				double__1 = SinglDetectModel_get_GateProbab(&self->base);
				return 1.0 - (double_ * double__1);
			}
		case ((int32_t)1):
			{
				float64_t double__2 = 0.0;
				float64_t double__3 = 0.0;

				double__2 = MobiEyeDetecModel_GetDetecProba(self, state);
				double__3 = SinglDetectModel_get_GateProbab(&self->base);
				return double__2 * double__3;
			}
		default:
			return 0.0;
	}
}

float64_t DetectionModel_Evaluate(struct MobilEyeDetectionModel *const self, struct CardinalitySpace *sample)
{
	float64_t result = 0.0;
	struct CardinalitySpace *cardinalitySpace = NULL;
	struct MobilEyeSpace *mobilEyeSpace = NULL;
	float64_t double_ = 0.0;

	(void)Assign_CardinalitySpace(&cardinalitySpace, sample);
	mobilEyeSpace = DetectionModel_get_Condition(&self->base.base);
	double_ = SinglDetecModel_GetDetectProbab(self, cardinalitySpace, mobilEyeSpace);
	result = double_;
	(void)Assign_CardinalitySpace(&cardinalitySpace, NULL);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
	return result;
}

float64_t MarginalizedEvaluable_Evaluate(struct MarginalizedEvaluable *const self, struct CardinalitySpace *sample)
{
	float64_t probability = 0.0;
	struct SampleSet *CS_0_0000 = NULL;
	struct StaticListEnumerator_8 *CS_5_0001 = NULL;
	struct StaticListEnumerator_8 *staticListEnumerator = NULL;
	struct SampleProbabilityPair *pair = NULL;
	struct MobilEyeDetectionModel *CS_0_0002 = NULL;
	float64_t arg_61_0 = 0.0;
	struct MobilEyeDetectionModel *CS_0_0003 = NULL;
	bool_t boolean = false;

	probability = 0.0;
	(void)Assign_SampleSet(&CS_0_0000, self->_condition);
	staticListEnumerator = SampleSet_GetEnumerator(CS_0_0000);
	(void)Assign_StaticListEnumerator_8(&CS_5_0001, staticListEnumerator);
	(void)Assign_StaticListEnumerator_8(&staticListEnumerator, NULL);
	boolean = StaticListEnumerator_8_MoveNext(CS_5_0001);
	while (boolean)
	{
		struct SampleProbabilityPair *sampleProbabilityPair = NULL;
		struct MobilEyeSpace *mobilEyeSpace = NULL;
		float64_t double_ = 0.0;
		float64_t double__1 = 0.0;
		float64_t double__2 = 0.0;

		sampleProbabilityPair = StaticListEnumera_8_get_Current(CS_5_0001);
		(void)Assign_SampleProbabilityPair(&pair, sampleProbabilityPair);
		(void)Assign_SampleProbabilityPair(&sampleProbabilityPair, NULL);
		(void)Assign_MobilEyeDetectionModel(&CS_0_0002, self->_conditionalDistribution);
		mobilEyeSpace = SampleProbabilitPair_get_Sample(pair);
		DetectionModel_set_Condition(&(*&CS_0_0002)->base.base, mobilEyeSpace);
		(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
		arg_61_0 = probability;
		(void)Assign_MobilEyeDetectionModel(&CS_0_0003, self->_conditionalDistribution);
		double_ = arg_61_0;
		double__1 = DetectionModel_Evaluate(CS_0_0003, sample);
		double__2 = SampleProbabilPair_get_Probabil(pair);
		probability = double_ + (double__1 * double__2);
		boolean = StaticListEnumerator_8_MoveNext(CS_5_0001);
	}
	if (!!(CS_5_0001 != NULL))
	{
		StaticListEnumerator_8_Dispose(CS_5_0001);
	}
	if (!(probability <= 1.0))
	{
		RemRef_SampleSet(CS_0_0000);
		RemRef_StaticListEnumerator_8(CS_5_0001);
		RemRef_SampleProbabilityPair(pair);
		RemRef_MobilEyeDetectionModel(CS_0_0002);
		RemRef_MobilEyeDetectionModel(CS_0_0003);
		return 1.0;
	}
	RemRef_SampleSet(CS_0_0000);
	RemRef_StaticListEnumerator_8(CS_5_0001);
	RemRef_SampleProbabilityPair(pair);
	RemRef_MobilEyeDetectionModel(CS_0_0002);
	RemRef_MobilEyeDetectionModel(CS_0_0003);
	return probability;
}

struct StaticListFactory_5 *StIPDATrColFacPro_get_MeaLisFac(struct StatiIPDATrackColleFactorProvid *const self)
{
	struct StaticListFactory_5 *result = NULL;

	(void)Assign_StaticListFactory_5(&result, self->_measurementListFactory);
	return result;
}

static void RemRef_StaticList_1(struct StaticList_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_1.CurrentCount--;
		Res_StaticList_1.Next[Res_StaticList_1.CurrentCount] = self;
		Del_StaticList_1(self);
	}
}

struct StaticList_1 *New_StaticList_1(void)
{
	static struct StaticList_1 const Default_StaticList_1 = { 1 };
	struct StaticList_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_1.CurrentCount == RC_StaticList_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_1.Next[Res_StaticList_1.CurrentCount];
	Res_StaticList_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_1.MaximumCount = (Res_StaticList_1.CurrentCount > Res_StaticList_1.MaximumCount) ? Res_StaticList_1.CurrentCount : Res_StaticList_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_1;
	return instance;
}

struct StaticList_1 *Assign_StaticList_1(struct StaticList_1 **const left, struct StaticList_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_1(*left);
	*left = right;
	return right;
}

static void Del_float64_t_1D_40(struct float64_t_1D_40 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_1D_40(struct float64_t_1D_40 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_1D_40.CurrentCount--;
		Res_float64_t_1D_40.Next[Res_float64_t_1D_40.CurrentCount] = self;
		Del_float64_t_1D_40(self);
	}
}

struct float64_t_1D_40 *New_float64_t_1D_40(void)
{
	static struct float64_t_1D_40 const Default_float64_t_1D_40 = { 1 };
	struct float64_t_1D_40 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_1D_40.CurrentCount == RC_float64_t_1D_40)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_1D_40.Next[Res_float64_t_1D_40.CurrentCount];
	Res_float64_t_1D_40.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_1D_40.MaximumCount = (Res_float64_t_1D_40.CurrentCount > Res_float64_t_1D_40.MaximumCount) ? Res_float64_t_1D_40.CurrentCount : Res_float64_t_1D_40.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_1D_40;
	return instance;
}

struct float64_t_1D_40 *Assign_float64_t_1D_40(struct float64_t_1D_40 **const left, struct float64_t_1D_40 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_1D_40(*left);
	*left = right;
	return right;
}

void StaticList_1_ctor(struct StaticList_1 *const self, int32_t maximumCount)
{
	struct float64_t_1D_40 *array = NULL;

	assert(maximumCount == ((int32_t)40));
	Object_ctor(&self->base);
	array = New_float64_t_1D_40();
	(void)Assign_float64_t_1D_40(&self->_items, array);
	(void)Assign_float64_t_1D_40(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_1 *StatiListFacto_5_CreateInstan(struct StaticListFactory_5 *const self, int32_t capacity)
{
	struct StaticList_1 *result = NULL;
	struct StaticList_1 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_5_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_1();
	StaticList_1_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_1(&result, staticList);
	(void)Assign_StaticList_1(&staticList, NULL);
	return result;
}

int32_t StaticList_1_get_Count(struct StaticList_1 *const self)
{
	return self->Count;
}

static void StaticList_1_CheckCount(struct StaticList_1 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_1_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_1_set_Count(struct StaticList_1 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_1_Add(struct StaticList_1 *const self, float64_t value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_1_CheckCount(self);
	int32 = StaticList_1_get_Count(self);
	count = int32;
	self->_items->Elements[count] = value;
	int32_1 = StaticList_1_get_Count(self);
	StaticList_1_set_Count(self, int32_1 + ((int32_t)1));
}

static void RemRef_MeasurementSetLikelihood(struct MeasurementSetLikelihood *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MeasurementSetLikelihood.CurrentCount--;
		Res_MeasurementSetLikelihood.Next[Res_MeasurementSetLikelihood.CurrentCount] = self;
		Del_MeasurementSetLikelihood(self);
	}
}

struct MeasurementSetLikelihood *New_MeasurementSetLikelihood(void)
{
	static struct MeasurementSetLikelihood const Default_MeasuremenSetLikelihood = { 1 };
	struct MeasurementSetLikelihood *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MeasurementSetLikelihood.CurrentCount == RC_MeasurementSetLikelihood)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MeasurementSetLikelihood.Next[Res_MeasurementSetLikelihood.CurrentCount];
	Res_MeasurementSetLikelihood.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MeasurementSetLikelihood.MaximumCount = (Res_MeasurementSetLikelihood.CurrentCount > Res_MeasurementSetLikelihood.MaximumCount) ? Res_MeasurementSetLikelihood.CurrentCount : Res_MeasurementSetLikelihood.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MeasuremenSetLikelihood;
	return instance;
}

struct MeasurementSetLikelihood *Assign_MeasurementSetLikelihood(struct MeasurementSetLikelihood **const left, struct MeasurementSetLikelihood *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MeasurementSetLikelihood(*left);
	*left = right;
	return right;
}

void MeasurementSetLikelihood_ctor(struct MeasurementSetLikelihood *const self, float64_t likelihoodGivenExistent, float64_t likelihoodGivenNonExistent)
{
	Object_ctor(&self->base);
	if (!(likelihoodGivenExistent >= 0.0))
	{
		abort();
	}
	if (!(likelihoodGivenNonExistent >= 0.0))
	{
		abort();
	}
	self->_likelihoodGivenExistent = likelihoodGivenExistent;
	self->_likelihoodGivenNonExistent = likelihoodGivenNonExistent;
}

struct StaticListFactory_2 *StIPDATrColFacPro_get_HypLisFac(struct StatiIPDATrackColleFactorProvid *const self)
{
	struct StaticListFactory_2 *result = NULL;

	(void)Assign_StaticListFactory_2(&result, self->_hypothesisListFactory);
	return result;
}

int32_t StatiListFacto_2_get_MaximCount(struct StaticListFactory_2 *const self)
{
	return self->_maximumCount;
}

static void RemRef_StaticList_18(struct StaticList_18 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_18.CurrentCount--;
		Res_StaticList_18.Next[Res_StaticList_18.CurrentCount] = self;
		Del_StaticList_18(self);
	}
}

struct StaticList_18 *New_StaticList_18(void)
{
	static struct StaticList_18 const Default_StaticList_18 = { 1 };
	struct StaticList_18 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_18.CurrentCount == RC_StaticList_18)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_18.Next[Res_StaticList_18.CurrentCount];
	Res_StaticList_18.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_18.MaximumCount = (Res_StaticList_18.CurrentCount > Res_StaticList_18.MaximumCount) ? Res_StaticList_18.CurrentCount : Res_StaticList_18.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_18;
	return instance;
}

struct StaticList_18 *Assign_StaticList_18(struct StaticList_18 **const left, struct StaticList_18 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_18(*left);
	*left = right;
	return right;
}

static void RemRef_TruePositivesHypothesis(struct TruePositivesHypothesis *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_TruePositivesHypothesis.CurrentCount--;
		Res_TruePositivesHypothesis.Next[Res_TruePositivesHypothesis.CurrentCount] = self;
		Del_TruePositivesHypothesis(self);
	}
}

struct TruePositivesHypothesis *New_TruePositivesHypothesis(void)
{
	static struct TruePositivesHypothesis const Default_TruePositivesHypothesis = { 1 };
	struct TruePositivesHypothesis *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_TruePositivesHypothesis.CurrentCount == RC_TruePositivesHypothesis)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_TruePositivesHypothesis.Next[Res_TruePositivesHypothesis.CurrentCount];
	Res_TruePositivesHypothesis.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_TruePositivesHypothesis.MaximumCount = (Res_TruePositivesHypothesis.CurrentCount > Res_TruePositivesHypothesis.MaximumCount) ? Res_TruePositivesHypothesis.CurrentCount : Res_TruePositivesHypothesis.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_TruePositivesHypothesis;
	return instance;
}

struct TruePositivesHypothesis *Assign_TruePositivesHypothesis(struct TruePositivesHypothesis **const left, struct TruePositivesHypothesis *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_TruePositivesHypothesis(*left);
	*left = right;
	return right;
}

static void Del_TruePositiveHypothesi_1D_41(struct TruePositivesHypothesis_1D_41 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)41);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_TruePositivesHypothesis(self->Elements[i]);
	}
}

static void RemRef_TruePositivHypothe_1D_41(struct TruePositivesHypothesis_1D_41 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_TruePositiveHypothesi_1D_41.CurrentCount--;
		Res_TruePositiveHypothesi_1D_41.Next[Res_TruePositiveHypothesi_1D_41.CurrentCount] = self;
		Del_TruePositiveHypothesi_1D_41(self);
	}
}

struct TruePositivesHypothesis_1D_41 *New_TruePositiveHypothesi_1D_41(void)
{
	static struct TruePositivesHypothesis_1D_41 const Defaul_TruePositivHypothe_1D_41 = { 1 };
	struct TruePositivesHypothesis_1D_41 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_TruePositiveHypothesi_1D_41.CurrentCount == RC_TruePositivesHypothesi_1D_41)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_TruePositiveHypothesi_1D_41.Next[Res_TruePositiveHypothesi_1D_41.CurrentCount];
	Res_TruePositiveHypothesi_1D_41.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_TruePositiveHypothesi_1D_41.MaximumCount = (Res_TruePositiveHypothesi_1D_41.CurrentCount > Res_TruePositiveHypothesi_1D_41.MaximumCount) ? Res_TruePositiveHypothesi_1D_41.CurrentCount : Res_TruePositiveHypothesi_1D_41.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Defaul_TruePositivHypothe_1D_41;
	return instance;
}

struct TruePositivesHypothesis_1D_41 *Assign_TruePositivHypothe_1D_41(struct TruePositivesHypothesis_1D_41 **const left, struct TruePositivesHypothesis_1D_41 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_TruePositivHypothe_1D_41(*left);
	*left = right;
	return right;
}

void StaticList_18_ctor(struct StaticList_18 *const self, int32_t maximumCount)
{
	struct TruePositivesHypothesis_1D_41 *array = NULL;

	assert(maximumCount == ((int32_t)41));
	Object_ctor(&self->base);
	array = New_TruePositiveHypothesi_1D_41();
	(void)Assign_TruePositivHypothe_1D_41(&self->_items, array);
	(void)Assign_TruePositivHypothe_1D_41(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_18 *StaticListFactor_2_CreateInstan(struct StaticListFactory_2 *const self, int32_t capacity)
{
	struct StaticList_18 *result = NULL;
	struct StaticList_18 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_2_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_18();
	StaticList_18_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_18(&result, staticList);
	(void)Assign_StaticList_18(&staticList, NULL);
	return result;
}

struct StaticListFactory_3 *StIPDATrCoFaPr_get_TruEleLisFac(struct StatiIPDATrackColleFactorProvid *const self)
{
	struct StaticListFactory_3 *result = NULL;

	(void)Assign_StaticListFactory_3(&result, self->_trueElementsListFactory);
	return result;
}

int32_t StatiListFacto_3_get_MaximCount(struct StaticListFactory_3 *const self)
{
	return self->_maximumCount;
}

static void RemRef_StaticList_8(struct StaticList_8 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_8.CurrentCount--;
		Res_StaticList_8.Next[Res_StaticList_8.CurrentCount] = self;
		Del_StaticList_8(self);
	}
}

struct StaticList_8 *New_StaticList_8(void)
{
	static struct StaticList_8 const Default_StaticList_8 = { 1 };
	struct StaticList_8 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_8.CurrentCount == RC_StaticList_8)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_8.Next[Res_StaticList_8.CurrentCount];
	Res_StaticList_8.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_8.MaximumCount = (Res_StaticList_8.CurrentCount > Res_StaticList_8.MaximumCount) ? Res_StaticList_8.CurrentCount : Res_StaticList_8.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_8;
	return instance;
}

struct StaticList_8 *Assign_StaticList_8(struct StaticList_8 **const left, struct StaticList_8 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_8(*left);
	*left = right;
	return right;
}

static void Del_MobilEyeSpace_1D_1(struct MobilEyeSpace_1D_1 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)1);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_MobilEyeSpace(self->Elements[i]);
	}
}

static void RemRef_MobilEyeSpace_1D_1(struct MobilEyeSpace_1D_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MobilEyeSpace_1D_1.CurrentCount--;
		Res_MobilEyeSpace_1D_1.Next[Res_MobilEyeSpace_1D_1.CurrentCount] = self;
		Del_MobilEyeSpace_1D_1(self);
	}
}

struct MobilEyeSpace_1D_1 *New_MobilEyeSpace_1D_1(void)
{
	static struct MobilEyeSpace_1D_1 const Default_MobilEyeSpace_1D_1 = { 1 };
	struct MobilEyeSpace_1D_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MobilEyeSpace_1D_1.CurrentCount == RC_MobilEyeSpace_1D_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MobilEyeSpace_1D_1.Next[Res_MobilEyeSpace_1D_1.CurrentCount];
	Res_MobilEyeSpace_1D_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MobilEyeSpace_1D_1.MaximumCount = (Res_MobilEyeSpace_1D_1.CurrentCount > Res_MobilEyeSpace_1D_1.MaximumCount) ? Res_MobilEyeSpace_1D_1.CurrentCount : Res_MobilEyeSpace_1D_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MobilEyeSpace_1D_1;
	return instance;
}

struct MobilEyeSpace_1D_1 *Assign_MobilEyeSpace_1D_1(struct MobilEyeSpace_1D_1 **const left, struct MobilEyeSpace_1D_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MobilEyeSpace_1D_1(*left);
	*left = right;
	return right;
}

void StaticList_8_ctor(struct StaticList_8 *const self, int32_t maximumCount)
{
	struct MobilEyeSpace_1D_1 *array = NULL;

	assert(maximumCount == ((int32_t)1));
	Object_ctor(&self->base);
	array = New_MobilEyeSpace_1D_1();
	(void)Assign_MobilEyeSpace_1D_1(&self->_items, array);
	(void)Assign_MobilEyeSpace_1D_1(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_8 *StaticListFactor_3_CreateInstan(struct StaticListFactory_3 *const self, int32_t capacity)
{
	struct StaticList_8 *result = NULL;
	struct StaticList_8 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_3_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_8();
	StaticList_8_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_8(&result, staticList);
	(void)Assign_StaticList_8(&staticList, NULL);
	return result;
}

static void TruePositivHypothe_set_Elements(struct TruePositivesHypothesis *const self, struct StaticList_8 *value)
{
	(void)Assign_StaticList_8(&self->Elements, value);
}

static void TruePositiveHypothes_set_Weight(struct TruePositivesHypothesis *const self, float64_t value)
{
	self->Weight = value;
}

void TruePositivesHypothesis_ctor(struct TruePositivesHypothesis *const self, float64_t weight, struct StaticList_8 *elements)
{
	Object_ctor(&self->base);
	TruePositivHypothe_set_Elements(self, elements);
	TruePositiveHypothes_set_Weight(self, weight);
}

int32_t StaticList_18_get_Count(struct StaticList_18 *const self)
{
	return self->Count;
}

static void StaticList_18_CheckCount(struct StaticList_18 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_18_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_18_set_Count(struct StaticList_18 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_18_Add(struct StaticList_18 *const self, struct TruePositivesHypothesis *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_18_CheckCount(self);
	int32 = StaticList_18_get_Count(self);
	count = int32;
	(void)Assign_TruePositivesHypothesis(&self->_items->Elements[count], value);
	int32_1 = StaticList_18_get_Count(self);
	StaticList_18_set_Count(self, int32_1 + ((int32_t)1));
}

float64_t StaticList_1_get_Item(struct StaticList_1 *const self, int32_t index)
{
	return self->_items->Elements[index];
}

int32_t StaticList_8_get_Count(struct StaticList_8 *const self)
{
	return self->Count;
}

static void StaticList_8_CheckCount(struct StaticList_8 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_8_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_8_set_Count(struct StaticList_8 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_8_Add(struct StaticList_8 *const self, struct MobilEyeSpace *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_8_CheckCount(self);
	int32 = StaticList_8_get_Count(self);
	count = int32;
	(void)Assign_MobilEyeSpace(&self->_items->Elements[count], value);
	int32_1 = StaticList_8_get_Count(self);
	StaticList_8_set_Count(self, int32_1 + ((int32_t)1));
}

void IPDA_ctor(struct IPDA *const self, struct Gaussian_2 *spatialLikelihood, struct Existence *existence, struct MarginalizedEvaluable *truePositiveLikelihood, struct StaticList_6 *elements, float64_t lambda, struct StatiIPDATrackColleFactorProvid *factoryProvider)
{
	struct StatiIPDATrackColleFactorProvid *arg_7A_0 = NULL;
	struct StatiIPDATrackColleFactorProvid *hypothesisListFactoryProvider = NULL;
	float64_t num = 0.0;
	struct MarginalizedEvaluable *marginalizedEvaluable = NULL;
	struct CardinalitySpace *cardinalitySpace = NULL;
	float64_t double_ = 0.0;
	float64_t num2 = 0.0;
	float64_t double__1 = 0.0;
	struct StaticList_1 *list = NULL;
	struct StaticListFactory_5 *staticListFactory = NULL;
	struct StaticList_1 *staticList = NULL;
	struct StaticList_6 *list2 = NULL;
	struct StaticListFactory_5 *staticListFactory_1 = NULL;
	struct StaticList_6 *staticList_1 = NULL;
	float64_t num3 = 0.0;
	struct StaticListEnumerator_2 *enumerator = NULL;
	struct StaticListEnumerator_2 *staticListEnumerator = NULL;
	struct MobilEyeSpace *current = NULL;
	float64_t num4 = 0.0;
	bool_t boolean = false;
	float64_t num5 = 0.0;
	struct MeasurementSetLikelihood *measurementSetLikelihood = NULL;
	float64_t num6 = 0.0;
	struct StaticList_18 *list3 = NULL;
	struct StaticListFactory_2 *staticListFactory_2 = NULL;
	int32_t int32 = ((int32_t)0);
	struct StaticList_18 *staticList_2 = NULL;
	struct StaticList_18 *staticList_3 = NULL;
	float64_t double__2 = 0.0;
	struct StaticListFactory_3 *staticListFactory_3 = NULL;
	struct StaticList_8 *staticList_4 = NULL;
	struct TruePositivesHypothesis *truePositivesHypothesis = NULL;
	int32_t i = ((int32_t)0);
	float64_t weight = 0.0;
	struct StaticList_8 *list4 = NULL;
	int32_t int32_1 = ((int32_t)0);
	int32_t int32_2 = ((int32_t)0);

	if (!(spatialLikelihood != NULL))
	{
		abort();
	}
	if (!(existence != NULL))
	{
		abort();
	}
	if (!(truePositiveLikelihood != NULL))
	{
		abort();
	}
	if (!(elements != NULL))
	{
		abort();
	}
	if (!(lambda > 0.0))
	{
		abort();
	}
	Object_ctor(&self->base);
	(void)Assi_StatIPDATracCollFactoProvi(&arg_7A_0, factoryProvider);
	(void)Assi_StatIPDATracCollFactoProvi(&hypothesisListFactoryProvider, arg_7A_0);
	IPDA_set_Lambda(self, lambda);
	(void)Assign_MarginalizedEvaluable(&marginalizedEvaluable, truePositiveLikelihood);
	cardinalitySpace = CardinalitySpace_1_op_Implicit(((int32_t)0));
	double_ = MarginalizedEvaluable_Evaluate(marginalizedEvaluable, cardinalitySpace);
	num = 1.0 - double_;
	(void)Assign_MarginalizedEvaluable(&marginalizedEvaluable, NULL);
	(void)Assign_CardinalitySpace(&cardinalitySpace, NULL);
	double__1 = TwoPointDistribution_Evaluate(&existence->base, ExistenceSpace_1_Existent);
	num2 = double__1;
	staticListFactory = StIPDATrColFacPro_get_MeaLisFac(hypothesisListFactoryProvider);
	staticList = StatiListFacto_5_CreateInstan(staticListFactory, ((int32_t)0));
	(void)Assign_StaticList_1(&list, staticList);
	(void)Assign_StaticListFactory_5(&staticListFactory, NULL);
	(void)Assign_StaticList_1(&staticList, NULL);
	staticListFactory_1 = StIPDATrColFacPro_get_MeaLisFac(hypothesisListFactoryProvider);
	staticList_1 = StaticListFactor_5_CreateInstan(staticListFactory_1, ((int32_t)0));
	(void)Assign_StaticList_6(&list2, staticList_1);
	(void)Assign_StaticListFactory_5(&staticListFactory_1, NULL);
	(void)Assign_StaticList_6(&staticList_1, NULL);
	num3 = 0.0;
	staticListEnumerator = StaticList_6_GetEnumerator(elements);
	(void)Assign_StaticListEnumerator_2(&enumerator, staticListEnumerator);
	(void)Assign_StaticListEnumerator_2(&staticListEnumerator, NULL);
	boolean = StaticListEnumerator_2_MoveNext(enumerator);
	while (boolean)
	{
		struct MobilEyeSpace *mobilEyeSpace = NULL;
		float64_t double__3 = 0.0;

		mobilEyeSpace = StaticListEnumera_2_get_Current(enumerator);
		(void)Assign_MobilEyeSpace(&current, mobilEyeSpace);
		(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
		StaticList_6_Add(list2, current);
		double__3 = Gaussian_2_Evaluate_1(spatialLikelihood, current);
		num4 = double__3;
		StaticList_1_Add(list, num4);
		num3 = num3 + num4;
		boolean = StaticListEnumerator_2_MoveNext(enumerator);
	}
	if (!!(enumerator != NULL))
	{
		StaticListEnumerator_2_Dispose(enumerator);
	}
	num5 = num - ((num3 * num) / lambda);
	measurementSetLikelihood = New_MeasurementSetLikelihood();
	MeasurementSetLikelihood_ctor(measurementSetLikelihood, 1.0 - num5, 1.0);
	(void)Assign_MeasurementSetLikelihood(&self->_elementsLikelihood, measurementSetLikelihood);
	(void)Assign_MeasurementSetLikelihood(&measurementSetLikelihood, NULL);
	num6 = 1.0 - (num5 * num2);
	staticListFactory_2 = StIPDATrColFacPro_get_HypLisFac(hypothesisListFactoryProvider);
	int32 = StaticList_6_get_Count(list2);
	staticList_2 = StaticListFactor_2_CreateInstan(staticListFactory_2, int32 + ((int32_t)1));
	(void)Assign_StaticList_18(&list3, staticList_2);
	(void)Assign_StaticListFactory_2(&staticListFactory_2, NULL);
	(void)Assign_StaticList_18(&staticList_2, NULL);
	(void)Assign_StaticList_18(&staticList_3, list3);
	double__2 = (1.0 - (num2 * num)) / num6;
	staticListFactory_3 = StIPDATrCoFaPr_get_TruEleLisFac(hypothesisListFactoryProvider);
	staticList_4 = StaticListFactor_3_CreateInstan(staticListFactory_3, ((int32_t)0));
	truePositivesHypothesis = New_TruePositivesHypothesis();
	TruePositivesHypothesis_ctor(truePositivesHypothesis, double__2, staticList_4);
	StaticList_18_Add(staticList_3, truePositivesHypothesis);
	(void)Assign_StaticList_18(&staticList_3, NULL);
	(void)Assign_StaticListFactory_3(&staticListFactory_3, NULL);
	(void)Assign_StaticList_8(&staticList_4, NULL);
	(void)Assign_TruePositivesHypothesis(&truePositivesHypothesis, NULL);
	i = ((int32_t)0);
	int32_1 = i;
	int32_2 = StaticList_6_get_Count(list2);
	while (int32_1 < int32_2)
	{
		float64_t double__4 = 0.0;
		float64_t double__5 = 0.0;
		float64_t double__6 = 0.0;
		struct StaticListFactory_3 *staticListFactory_4 = NULL;
		struct StaticList_8 *staticList_5 = NULL;
		struct StaticList_8 *staticList_6 = NULL;
		struct MobilEyeSpace *mobilEyeSpace_1 = NULL;
		struct StaticList_18 *staticList_7 = NULL;
		struct TruePositivesHypothesis *truePositivesHypothesis_1 = NULL;

		double__4 = StaticList_1_get_Item(list, i);
		double__5 = double__4 * num2;
		double__6 = double__5 * num;
		weight = double__6 / (num6 * lambda);
		staticListFactory_4 = StIPDATrCoFaPr_get_TruEleLisFac(hypothesisListFactoryProvider);
		staticList_5 = StaticListFactor_3_CreateInstan(staticListFactory_4, ((int32_t)1));
		(void)Assign_StaticList_8(&list4, staticList_5);
		(void)Assign_StaticListFactory_3(&staticListFactory_4, NULL);
		(void)Assign_StaticList_8(&staticList_5, NULL);
		(void)Assign_StaticList_8(&staticList_6, list4);
		mobilEyeSpace_1 = StaticList_6_get_Item(list2, i);
		StaticList_8_Add(staticList_6, mobilEyeSpace_1);
		(void)Assign_StaticList_8(&staticList_6, NULL);
		(void)Assign_MobilEyeSpace(&mobilEyeSpace_1, NULL);
		(void)Assign_StaticList_18(&staticList_7, list3);
		truePositivesHypothesis_1 = New_TruePositivesHypothesis();
		TruePositivesHypothesis_ctor(truePositivesHypothesis_1, weight, list4);
		StaticList_18_Add(staticList_7, truePositivesHypothesis_1);
		(void)Assign_StaticList_18(&staticList_7, NULL);
		(void)Assign_TruePositivesHypothesis(&truePositivesHypothesis_1, NULL);
		i = i + ((int32_t)1);
		int32_1 = i;
		int32_2 = StaticList_6_get_Count(list2);
	}
	(void)Assign_StaticList_18(&self->_hypotheses, list3);
	RemRef_StatIPDATracCollFactProv(arg_7A_0);
	RemRef_StatIPDATracCollFactProv(hypothesisListFactoryProvider);
	RemRef_StaticList_1(list);
	RemRef_StaticList_6(list2);
	RemRef_StaticListEnumerator_2(enumerator);
	RemRef_MobilEyeSpace(current);
	RemRef_StaticList_18(list3);
	RemRef_StaticList_8(list4);
}

struct IPDA *IPDA_2_Create(struct Gaussian_2 *spatialLikelihood, struct Existence *existence, struct MarginalizedEvaluable *truePositiveLikelihood, struct StaticList_6 *elements, float64_t lambda, struct StatiIPDATrackColleFactorProvid *factoryProvider)
{
	struct IPDA *result = NULL;
	struct IPDA *ipda = NULL;

	if (!(spatialLikelihood != NULL))
	{
		abort();
	}
	if (!(existence != NULL))
	{
		abort();
	}
	if (!(truePositiveLikelihood != NULL))
	{
		abort();
	}
	if (!(elements != NULL))
	{
		abort();
	}
	if (!(lambda > 0.0))
	{
		abort();
	}
	ipda = New_IPDA();
	IPDA_ctor(ipda, spatialLikelihood, existence, truePositiveLikelihood, elements, lambda, factoryProvider);
	(void)Assign_IPDA(&result, ipda);
	(void)Assign_IPDA(&ipda, NULL);
	return result;
}

struct StaticList_18 *IPDA_GetHypotheses(struct IPDA *const self)
{
	struct StaticList_18 *result = NULL;

	(void)Assign_StaticList_18(&result, self->_hypotheses);
	return result;
}

static void GaussianMixture_1_cctor(void)
{
}

static void RemRef_GaussianMixture(struct GaussianMixture *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_GaussianMixture.CurrentCount--;
		Res_GaussianMixture.Next[Res_GaussianMixture.CurrentCount] = self;
		Del_GaussianMixture(self);
	}
}

struct GaussianMixture *New_GaussianMixture(void)
{
	static struct GaussianMixture const Default_GaussianMixture = { 1 };
	struct GaussianMixture *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_GaussianMixture.CurrentCount == RC_GaussianMixture)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_GaussianMixture.Next[Res_GaussianMixture.CurrentCount];
	Res_GaussianMixture.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_GaussianMixture.MaximumCount = (Res_GaussianMixture.CurrentCount > Res_GaussianMixture.MaximumCount) ? Res_GaussianMixture.CurrentCount : Res_GaussianMixture.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_GaussianMixture;
	return instance;
}

struct GaussianMixture *Assign_GaussianMixture(struct GaussianMixture **const left, struct GaussianMixture *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_GaussianMixture(*left);
	*left = right;
	return right;
}

static void RemRef_IListFactory(struct IListFactory *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_IListFactory.CurrentCount--;
		Res_IListFactory.Next[Res_IListFactory.CurrentCount] = self;
		Del_IListFactory(self);
	}
}

struct IListFactory *New_IListFactory(void)
{
	static struct IListFactory const Default_IListFactory = { 1 };
	struct IListFactory *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_IListFactory.CurrentCount == RC_IListFactory)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_IListFactory.Next[Res_IListFactory.CurrentCount];
	Res_IListFactory.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_IListFactory.MaximumCount = (Res_IListFactory.CurrentCount > Res_IListFactory.MaximumCount) ? Res_IListFactory.CurrentCount : Res_IListFactory.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_IListFactory;
	return instance;
}

struct IListFactory *Assign_IListFactory(struct IListFactory **const left, struct IListFactory *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_IListFactory(*left);
	*left = right;
	return right;
}

static void RemRef_StaticList_24(struct StaticList_24 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_24.CurrentCount--;
		Res_StaticList_24.Next[Res_StaticList_24.CurrentCount] = self;
		Del_StaticList_24(self);
	}
}

struct StaticList_24 *New_StaticList_24(void)
{
	static struct StaticList_24 const Default_StaticList_24 = { 1 };
	struct StaticList_24 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_24.CurrentCount == RC_StaticList_24)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_24.Next[Res_StaticList_24.CurrentCount];
	Res_StaticList_24.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_24.MaximumCount = (Res_StaticList_24.CurrentCount > Res_StaticList_24.MaximumCount) ? Res_StaticList_24.CurrentCount : Res_StaticList_24.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_24;
	return instance;
}

struct StaticList_24 *Assign_StaticList_24(struct StaticList_24 **const left, struct StaticList_24 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_24(*left);
	*left = right;
	return right;
}

static void Del_Gaussian_5_1D_41(struct Gaussian_5_1D_41 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)41);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_Gaussian_5(self->Elements[i]);
	}
}

static void RemRef_Gaussian_5_1D_41(struct Gaussian_5_1D_41 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Gaussian_5_1D_41.CurrentCount--;
		Res_Gaussian_5_1D_41.Next[Res_Gaussian_5_1D_41.CurrentCount] = self;
		Del_Gaussian_5_1D_41(self);
	}
}

struct Gaussian_5_1D_41 *New_Gaussian_5_1D_41(void)
{
	static struct Gaussian_5_1D_41 const Default_Gaussian_5_1D_41 = { 1 };
	struct Gaussian_5_1D_41 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Gaussian_5_1D_41.CurrentCount == RC_Gaussian_5_1D_41)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Gaussian_5_1D_41.Next[Res_Gaussian_5_1D_41.CurrentCount];
	Res_Gaussian_5_1D_41.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Gaussian_5_1D_41.MaximumCount = (Res_Gaussian_5_1D_41.CurrentCount > Res_Gaussian_5_1D_41.MaximumCount) ? Res_Gaussian_5_1D_41.CurrentCount : Res_Gaussian_5_1D_41.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Gaussian_5_1D_41;
	return instance;
}

struct Gaussian_5_1D_41 *Assign_Gaussian_5_1D_41(struct Gaussian_5_1D_41 **const left, struct Gaussian_5_1D_41 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Gaussian_5_1D_41(*left);
	*left = right;
	return right;
}

void StaticList_24_ctor(struct StaticList_24 *const self, int32_t maximumCount)
{
	struct Gaussian_5_1D_41 *array = NULL;

	assert(maximumCount == ((int32_t)41));
	Object_ctor(&self->base);
	array = New_Gaussian_5_1D_41();
	(void)Assign_Gaussian_5_1D_41(&self->_items, array);
	(void)Assign_Gaussian_5_1D_41(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_24 *StatiListFactor_2_CreateInstan(struct StaticListFactory_2 *const self, int32_t capacity)
{
	struct StaticList_24 *result = NULL;
	struct StaticList_24 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_2_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_24();
	StaticList_24_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_24(&result, staticList);
	(void)Assign_StaticList_24(&staticList, NULL);
	return result;
}

static void RemRef_StaticList_2(struct StaticList_2 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_2.CurrentCount--;
		Res_StaticList_2.Next[Res_StaticList_2.CurrentCount] = self;
		Del_StaticList_2(self);
	}
}

struct StaticList_2 *New_StaticList_2(void)
{
	static struct StaticList_2 const Default_StaticList_2 = { 1 };
	struct StaticList_2 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_2.CurrentCount == RC_StaticList_2)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_2.Next[Res_StaticList_2.CurrentCount];
	Res_StaticList_2.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_2.MaximumCount = (Res_StaticList_2.CurrentCount > Res_StaticList_2.MaximumCount) ? Res_StaticList_2.CurrentCount : Res_StaticList_2.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_2;
	return instance;
}

struct StaticList_2 *Assign_StaticList_2(struct StaticList_2 **const left, struct StaticList_2 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_2(*left);
	*left = right;
	return right;
}

static void Del_float64_t_1D_41(struct float64_t_1D_41 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_1D_41(struct float64_t_1D_41 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_1D_41.CurrentCount--;
		Res_float64_t_1D_41.Next[Res_float64_t_1D_41.CurrentCount] = self;
		Del_float64_t_1D_41(self);
	}
}

struct float64_t_1D_41 *New_float64_t_1D_41(void)
{
	static struct float64_t_1D_41 const Default_float64_t_1D_41 = { 1 };
	struct float64_t_1D_41 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_1D_41.CurrentCount == RC_float64_t_1D_41)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_1D_41.Next[Res_float64_t_1D_41.CurrentCount];
	Res_float64_t_1D_41.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_1D_41.MaximumCount = (Res_float64_t_1D_41.CurrentCount > Res_float64_t_1D_41.MaximumCount) ? Res_float64_t_1D_41.CurrentCount : Res_float64_t_1D_41.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_1D_41;
	return instance;
}

struct float64_t_1D_41 *Assign_float64_t_1D_41(struct float64_t_1D_41 **const left, struct float64_t_1D_41 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_1D_41(*left);
	*left = right;
	return right;
}

void StaticList_2_ctor(struct StaticList_2 *const self, int32_t maximumCount)
{
	struct float64_t_1D_41 *array = NULL;

	assert(maximumCount == ((int32_t)41));
	Object_ctor(&self->base);
	array = New_float64_t_1D_41();
	(void)Assign_float64_t_1D_41(&self->_items, array);
	(void)Assign_float64_t_1D_41(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_2 *StatiListFacto_2_CreateInstan(struct StaticListFactory_2 *const self, int32_t capacity)
{
	struct StaticList_2 *result = NULL;
	struct StaticList_2 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_2_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_2();
	StaticList_2_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_2(&result, staticList);
	(void)Assign_StaticList_2(&staticList, NULL);
	return result;
}

void GaussianMixture_ctor(struct GaussianMixture *const self, int32_t capacity, struct StaticListFactory_2 *listFactory)
{
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);
	struct StaticList_24 *staticList = NULL;
	struct StaticList_2 *staticList_1 = NULL;
	struct CASpace *caSpace = NULL;

	if (!(capacity >= ((int32_t)0)))
	{
		abort();
	}
	if (!(listFactory != NULL))
	{
		abort();
	}
	int32 = capacity;
	int32_1 = StatiListFacto_2_get_MaximCount(listFactory);
	if (!(int32 <= int32_1))
	{
		abort();
	}
	Object_ctor(&self->base);
	staticList = StatiListFactor_2_CreateInstan(listFactory, capacity);
	(void)Assign_StaticList_24(&self->_gaussians, staticList);
	(void)Assign_StaticList_24(&staticList, NULL);
	staticList_1 = StatiListFacto_2_CreateInstan(listFactory, capacity);
	(void)Assign_StaticList_2(&self->_weights, staticList_1);
	(void)Assign_StaticList_2(&staticList_1, NULL);
	caSpace = New_CASpace();
	CASpace_ctor(caSpace);
	self->Dimensions = (&caSpace->base.base.base)->Dimensions;
	(void)Assign_CASpace(&caSpace, NULL);
}

struct MeasurementSetLikelihood *IPDA_GetElementsLikelihood(struct IPDA *const self)
{
	struct MeasurementSetLikelihood *result = NULL;

	(void)Assign_MeasurementSetLikelihood(&result, self->_elementsLikelihood);
	return result;
}

static void RemRef_StaticListEnumerator_10(struct StaticListEnumerator_10 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListEnumerator_10.CurrentCount--;
		Res_StaticListEnumerator_10.Next[Res_StaticListEnumerator_10.CurrentCount] = self;
		Del_StaticListEnumerator_10(self);
	}
}

struct StaticListEnumerator_10 *New_StaticListEnumerator_10(void)
{
	static struct StaticListEnumerator_10 const Default_StaticListEnumerator_10 = { 1 };
	struct StaticListEnumerator_10 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListEnumerator_10.CurrentCount == RC_StaticListEnumerator_10)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListEnumerator_10.Next[Res_StaticListEnumerator_10.CurrentCount];
	Res_StaticListEnumerator_10.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListEnumerator_10.MaximumCount = (Res_StaticListEnumerator_10.CurrentCount > Res_StaticListEnumerator_10.MaximumCount) ? Res_StaticListEnumerator_10.CurrentCount : Res_StaticListEnumerator_10.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListEnumerator_10;
	return instance;
}

struct StaticListEnumerator_10 *Assign_StaticListEnumerator_10(struct StaticListEnumerator_10 **const left, struct StaticListEnumerator_10 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListEnumerator_10(*left);
	*left = right;
	return right;
}

void StaticListEnumerator_10_ctor(struct StaticListEnumerator_10 *const self, struct StaticList_18 *list)
{
	self->_current = ((int32_t)-1);
	Object_ctor(&self->base);
	(void)Assign_StaticList_18(&self->_list, list);
}

struct StaticListEnumerator_10 *StaticList_18_GetEnumerator(struct StaticList_18 *const self)
{
	struct StaticListEnumerator_10 *result = NULL;
	struct StaticListEnumerator_10 *staticListEnumerator = NULL;

	staticListEnumerator = New_StaticListEnumerator_10();
	StaticListEnumerator_10_ctor(staticListEnumerator, self);
	(void)Assign_StaticListEnumerator_10(&result, staticListEnumerator);
	(void)Assign_StaticListEnumerator_10(&staticListEnumerator, NULL);
	return result;
}

bool_t StaticListEnumerato_10_MoveNext(struct StaticListEnumerator_10 *const self)
{
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	self->_current = self->_current + ((int32_t)1);
	int32 = self->_current;
	int32_1 = StaticList_18_get_Count(self->_list);
	return int32 != int32_1;
}

struct TruePositivesHypothesis *StaticList_18_get_Item(struct StaticList_18 *const self, int32_t index)
{
	struct TruePositivesHypothesis *result = NULL;

	(void)Assign_TruePositivesHypothesis(&result, self->_items->Elements[index]);
	return result;
}

struct TruePositivesHypothesis *StaticListEnumer_10_get_Current(struct StaticListEnumerator_10 *const self)
{
	struct TruePositivesHypothesis *result = NULL;
	struct TruePositivesHypothesis *truePositivesHypothesis = NULL;

	truePositivesHypothesis = StaticList_18_get_Item(self->_list, self->_current);
	(void)Assign_TruePositivesHypothesis(&result, truePositivesHypothesis);
	(void)Assign_TruePositivesHypothesis(&truePositivesHypothesis, NULL);
	return result;
}

struct StaticList_8 *TruePositivHypothe_get_Elements(struct TruePositivesHypothesis *const self)
{
	struct StaticList_8 *result = NULL;

	(void)Assign_StaticList_8(&result, self->Elements);
	return result;
}

static void RemRef_StaticListEnumerator_4(struct StaticListEnumerator_4 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListEnumerator_4.CurrentCount--;
		Res_StaticListEnumerator_4.Next[Res_StaticListEnumerator_4.CurrentCount] = self;
		Del_StaticListEnumerator_4(self);
	}
}

struct StaticListEnumerator_4 *New_StaticListEnumerator_4(void)
{
	static struct StaticListEnumerator_4 const Default_StaticListEnumerator_4 = { 1 };
	struct StaticListEnumerator_4 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListEnumerator_4.CurrentCount == RC_StaticListEnumerator_4)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListEnumerator_4.Next[Res_StaticListEnumerator_4.CurrentCount];
	Res_StaticListEnumerator_4.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListEnumerator_4.MaximumCount = (Res_StaticListEnumerator_4.CurrentCount > Res_StaticListEnumerator_4.MaximumCount) ? Res_StaticListEnumerator_4.CurrentCount : Res_StaticListEnumerator_4.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListEnumerator_4;
	return instance;
}

struct StaticListEnumerator_4 *Assign_StaticListEnumerator_4(struct StaticListEnumerator_4 **const left, struct StaticListEnumerator_4 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListEnumerator_4(*left);
	*left = right;
	return right;
}

void StaticListEnumerator_4_ctor(struct StaticListEnumerator_4 *const self, struct StaticList_8 *list)
{
	self->_current = ((int32_t)-1);
	Object_ctor(&self->base);
	(void)Assign_StaticList_8(&self->_list, list);
}

struct StaticListEnumerator_4 *StaticList_8_GetEnumerator(struct StaticList_8 *const self)
{
	struct StaticListEnumerator_4 *result = NULL;
	struct StaticListEnumerator_4 *staticListEnumerator = NULL;

	staticListEnumerator = New_StaticListEnumerator_4();
	StaticListEnumerator_4_ctor(staticListEnumerator, self);
	(void)Assign_StaticListEnumerator_4(&result, staticListEnumerator);
	(void)Assign_StaticListEnumerator_4(&staticListEnumerator, NULL);
	return result;
}

bool_t StaticListEnumerator_4_MoveNext(struct StaticListEnumerator_4 *const self)
{
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	self->_current = self->_current + ((int32_t)1);
	int32 = self->_current;
	int32_1 = StaticList_8_get_Count(self->_list);
	return int32 != int32_1;
}

struct MobilEyeSpace *StaticList_8_get_Item(struct StaticList_8 *const self, int32_t index)
{
	struct MobilEyeSpace *result = NULL;

	(void)Assign_MobilEyeSpace(&result, self->_items->Elements[index]);
	return result;
}

struct MobilEyeSpace *StaticListEnumera_4_get_Current(struct StaticListEnumerator_4 *const self)
{
	struct MobilEyeSpace *result = NULL;
	struct MobilEyeSpace *mobilEyeSpace = NULL;

	mobilEyeSpace = StaticList_8_get_Item(self->_list, self->_current);
	(void)Assign_MobilEyeSpace(&result, mobilEyeSpace);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
	return result;
}

void StaticListEnumerator_4_Dispose(struct StaticListEnumerator_4 *const self)
{
}

struct MobilEyeSpace *Trackin_1_SimplifFirstOrDefault(struct StaticList_8 *source)
{
	struct StaticListEnumerator_4 *enumerator = NULL;
	struct StaticListEnumerator_4 *staticListEnumerator = NULL;
	struct MobilEyeSpace *result = NULL;
	bool_t boolean = false;

	staticListEnumerator = StaticList_8_GetEnumerator(source);
	(void)Assign_StaticListEnumerator_4(&enumerator, staticListEnumerator);
	(void)Assign_StaticListEnumerator_4(&staticListEnumerator, NULL);
	boolean = StaticListEnumerator_4_MoveNext(enumerator);
	if (!!boolean)
	{
		struct MobilEyeSpace *mobilEyeSpace = NULL;

		mobilEyeSpace = StaticListEnumera_4_get_Current(enumerator);
		(void)Assign_MobilEyeSpace(&result, mobilEyeSpace);
		(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
		RemRef_StaticListEnumerator_4(enumerator);
		return result;
	}
	StaticListEnumerator_4_Dispose(enumerator);
	(void)Assign_MobilEyeSpace(&result, NULL);
	RemRef_StaticListEnumerator_4(enumerator);
	return result;
}

static void RemRef_Space(struct Space *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Space.CurrentCount--;
		Res_Space.Next[Res_Space.CurrentCount] = self;
		Del_Space(self);
	}
}

struct Space *New_Space(void)
{
	static struct Space const Default_Space = { 1 };
	struct Space *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Space.CurrentCount == RC_Space)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Space.Next[Res_Space.CurrentCount];
	Res_Space.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Space.MaximumCount = (Res_Space.CurrentCount > Res_Space.MaximumCount) ? Res_Space.CurrentCount : Res_Space.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Space;
	return instance;
}

struct Space *Assign_Space(struct Space **const left, struct Space *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Space(*left);
	*left = right;
	return right;
}

struct Type *Object_GetType_1(struct Space *const self)
{
	struct Type *result;

	result = New_Type();
	Object_ctor(&result->base.base);
	result->_id = ((int32_t)-2137649931);
	return result;
}

struct Type *Object_GetType_2(struct MobilEyeSpace *const self)
{
	struct Type *result;

	result = New_Type();
	Object_ctor(&result->base.base);
	result->_id = ((int32_t)1052300830);
	return result;
}

bool_t MatrixData_5_Equals(struct MatrixData_5 *const self, struct MatrixData *other)
{
	bool_t boolean = false;
	bool_t arg_3B_0 = false;
	bool_t flag = false;
	bool_t flag2 = false;
	struct float64_t_1D_4 *array = NULL;
	int32_t int32 = ((int32_t)0);
	struct float64_t_1D_5 *array_1 = NULL;
	bool_t result = false;

	if (!(other != NULL))
	{
		return false;
	}
	boolean = Object_2_ReferenceEquals(&self->base, &other->base);
	if (!!boolean)
	{
		return true;
	}
	arg_3B_0 = false;
	flag = arg_3B_0;
	array = MatrixData_5_get_DataReference(self);
	int32 = ((int32_t)4);
	array_1 = MatrixData_get_DataReference(other);
	flag2 = int32 == ((int32_t)5);
	(void)Assign_float64_t_1D_4(&array, NULL);
	(void)Assign_float64_t_1D_5(&array_1, NULL);
	result = true;
	return false;
}

bool_t Space_3_Equals(struct MobilEyeSpace *const self, struct Space *other)
{
	struct Type *type = NULL;
	struct Type *type_1 = NULL;
	bool_t boolean = false;
	bool_t boolean_1 = false;
	bool_t boolean_2 = false;
	bool_t boolean_3 = false;
	bool_t boolean_4 = false;
	bool_t boolean_5 = false;
	bool_t boolean_6 = false;
	bool_t boolean_7 = false;
	bool_t boolean_8 = false;
	bool_t boolean_9 = false;
	bool_t result = false;
	struct MatrixData_5 *matrixData = NULL;
	struct MatrixData *matrixData_1 = NULL;
	bool_t boolean_10 = false;

	boolean_1 = Object_2_ReferenceEquals(&other->base, NULL);
	boolean_2 = !boolean_1;
	boolean_3 = boolean_2;
	if (boolean_3 == true)
	{
		type = Object_GetType_1(other);
		type_1 = Object_GetType_2(self);
		boolean = Type_1_op_Inequality(type, type_1);
		boolean_4 = !boolean;
	}
	else
	{
		boolean_4 = false;
	}
	if (!boolean_4)
	{
		if (boolean_3 == true)
		{
			(void)Assign_Type(&type, NULL);
			(void)Assign_Type(&type_1, NULL);
		}
		return false;
	}
	else
	{
		if (boolean_3 == true)
		{
			(void)Assign_Type(&type, NULL);
			(void)Assign_Type(&type_1, NULL);
		}
	}
	boolean_5 = Object_2_ReferenceEquals(&other->base, &self->base.base);
	if (!!boolean_5)
	{
		return true;
	}
	boolean_7 = Object_2_ReferenceEquals(&(&self->base)->_vector->base, NULL);
	boolean_8 = !boolean_7;
	if (boolean_8 == false)
	{
		boolean_6 = Object_2_ReferenceEquals(&other->_vector->base, NULL);
		boolean_9 = !boolean_6;
	}
	else
	{
		boolean_9 = true;
	}
	if (!boolean_9)
	{
		return (&self->base)->Dimensions == other->Dimensions;
	}
	matrixData = Space_3_get_MatrixData(&self->base);
	matrixData_1 = Space_get_MatrixData(other);
	boolean_10 = MatrixData_5_Equals(matrixData, matrixData_1);
	result = boolean_10;
	(void)Assign_MatrixData_5(&matrixData, NULL);
	(void)Assign_MatrixData(&matrixData_1, NULL);
	return result;
}

bool_t Space_6_op_Equality_1(struct MobilEyeSpace *left, struct Space *right)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;

	boolean = Object_2_ReferenceEquals(&left->base.base, NULL);
	if (!!boolean)
	{
		bool_t boolean_2 = false;

		boolean_2 = Object_2_ReferenceEquals(&right->base, NULL);
		return boolean_2;
	}
	boolean_1 = Space_3_Equals(left, right);
	return boolean_1;
}

struct Gaussian_5 *StaticList_23_get_Item(struct StaticList_23 *const self, int32_t index)
{
	struct Gaussian_5 *result = NULL;

	(void)Assign_Gaussian_5(&result, self->_items->Elements[index]);
	return result;
}

float64_t TruePositiveHypothes_get_Weight(struct TruePositivesHypothesis *const self)
{
	return self->Weight;
}

int32_t StaticList_24_get_Count(struct StaticList_24 *const self)
{
	return self->Count;
}

static void StaticList_24_CheckCount(struct StaticList_24 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_24_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_24_set_Count(struct StaticList_24 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_24_Add(struct StaticList_24 *const self, struct Gaussian_5 *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_24_CheckCount(self);
	int32 = StaticList_24_get_Count(self);
	count = int32;
	(void)Assign_Gaussian_5(&self->_items->Elements[count], value);
	int32_1 = StaticList_24_get_Count(self);
	StaticList_24_set_Count(self, int32_1 + ((int32_t)1));
}

int32_t StaticList_2_get_Count(struct StaticList_2 *const self)
{
	return self->Count;
}

static void StaticList_2_CheckCount(struct StaticList_2 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_2_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_2_set_Count(struct StaticList_2 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_2_Add(struct StaticList_2 *const self, float64_t value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_2_CheckCount(self);
	int32 = StaticList_2_get_Count(self);
	count = int32;
	self->_items->Elements[count] = value;
	int32_1 = StaticList_2_get_Count(self);
	StaticList_2_set_Count(self, int32_1 + ((int32_t)1));
}

void GaussianMixture_Add(struct GaussianMixture *const self, struct Gaussian_5 *gaussian, float64_t weight)
{
	StaticList_24_Add(self->_gaussians, gaussian);
	StaticList_2_Add(self->_weights, weight);
}

struct Matrix_11 *StaticList_16_get_Item(struct StaticList_16 *const self, int32_t index)
{
	struct Matrix_11 *result = NULL;

	(void)Assign_Matrix_11(&result, self->_items->Elements[index]);
	return result;
}

void LinearAlgebra_SolveLU_1(struct LinearAlgebra *const self, struct float64_t_1D_16 *a, int32_t rows, struct int32_t_1D_4 *pivotIndices, struct float64_t_1D_16 *b)
{
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t j = ((int32_t)0);
	float64_t num5 = 0.0;
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t expr_16A_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rows > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)16) % rows) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!!((((int32_t)16) % rows) != ((int32_t)0)))
	{
		abort();
	}
	num = ((int32_t)16) / rows;
	num2 = ((int32_t)16) / rows;
	int32 = Math_Min(num, rows);
	num3 = int32;
	if (!(pivotIndices != NULL))
	{
		abort();
	}
	if (!(((int32_t)4) == num3))
	{
		abort();
	}
	if (!(num <= rows))
	{
		abort();
	}
	i = ((int32_t)0);
	while (i < num3)
	{
		num4 = pivotIndices->Elements[i] - ((int32_t)1);
		if (!(num4 == i))
		{
			j = ((int32_t)0);
			while (j < num2)
			{
				num5 = b->Elements[(j * rows) + num4];
				b->Elements[(j * rows) + num4] = b->Elements[(j * rows) + i];
				b->Elements[(j * rows) + i] = num5;
				j = j + ((int32_t)1);
			}
		}
		i = i + ((int32_t)1);
	}
	k = ((int32_t)0);
	while (k < num2)
	{
		l = ((int32_t)0);
		while (l < num3)
		{
			m = l + ((int32_t)1);
			while (m < num3)
			{
				expr_16A_cp_1 = (k * rows) + m;
				b->Elements[expr_16A_cp_1] = b->Elements[expr_16A_cp_1] - (b->Elements[(k * rows) + l] * a->Elements[(l * rows) + m]);
				m = m + ((int32_t)1);
			}
			l = l + ((int32_t)1);
		}
		k = k + ((int32_t)1);
	}
	LineaAlgebr_1_SolveUpperTriang(a, rows, num3, b, rows, num2, false);
}

struct MatrixData_15 *MatrixMath_LinsolveSquare_1(struct MatrixData_15 *left, struct MatrixData_15 *right)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t rows = ((int32_t)0);
	struct MatrixData_15 *copy = NULL;
	struct MatrixData_15 *matrixData = NULL;
	struct int32_t_1D_4 *pivotIndices = NULL;
	struct int32_t_1D_4 *array = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_16 *array_1 = NULL;
	struct MatrixData_15 *copy2 = NULL;
	struct MatrixData_15 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra_1 = NULL;
	struct float64_t_1D_16 *array_2 = NULL;
	int32_t int32 = ((int32_t)0);
	struct int32_t_1D_4 *array_3 = NULL;
	struct float64_t_1D_16 *array_4 = NULL;
	struct MatrixData_15 *result = NULL;

	if (!(left != NULL))
	{
		abort();
	}
	boolean = MatrixData_15_get_IsEmpty(left);
	if (!(right != NULL))
	{
		abort();
	}
	boolean_1 = MatrixData_15_get_IsEmpty(right);
	rows = left->Rows;
	matrixData = MatrixData_15_get_Copy(left);
	(void)Assign_MatrixData_15(&copy, matrixData);
	(void)Assign_MatrixData_15(&matrixData, NULL);
	array = New_int32_t_1D_4();
	(void)Assign_int32_t_1D_4(&pivotIndices, array);
	(void)Assign_int32_t_1D_4(&array, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array_1 = MatrixData_15_get_DataReference(copy);
	LinearAlgebra_FactorLU_1(linearAlgebra, array_1, rows, pivotIndices);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_16(&array_1, NULL);
	matrixData_1 = MatrixData_15_get_Copy(right);
	(void)Assign_MatrixData_15(&copy2, matrixData_1);
	(void)Assign_MatrixData_15(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra_1, MatrixMath_LinearAlgebra);
	array_2 = MatrixData_15_get_DataReference(copy);
	int32 = copy->Rows;
	(void)Assign_int32_t_1D_4(&array_3, pivotIndices);
	array_4 = MatrixData_15_get_DataReference(copy2);
	LinearAlgebra_SolveLU_1(linearAlgebra_1, array_2, int32, array_3, array_4);
	(void)Assign_LinearAlgebra(&linearAlgebra_1, NULL);
	(void)Assign_float64_t_1D_16(&array_2, NULL);
	(void)Assign_int32_t_1D_4(&array_3, NULL);
	(void)Assign_float64_t_1D_16(&array_4, NULL);
	(void)Assign_MatrixData_15(&result, copy2);
	RemRef_MatrixData_15(copy);
	RemRef_int32_t_1D_4(pivotIndices);
	RemRef_MatrixData_15(copy2);
	return result;
}

static void RemRef_MatrixData_17(struct MatrixData_17 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_17.CurrentCount--;
		Res_MatrixData_17.Next[Res_MatrixData_17.CurrentCount] = self;
		Del_MatrixData_17(self);
	}
}

struct MatrixData_17 *New_MatrixData_17(void)
{
	static struct MatrixData_17 const Default_MatrixData_17 = { 1 };
	struct MatrixData_17 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_17.CurrentCount == RC_MatrixData_17)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_17.Next[Res_MatrixData_17.CurrentCount];
	Res_MatrixData_17.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_17.MaximumCount = (Res_MatrixData_17.CurrentCount > Res_MatrixData_17.MaximumCount) ? Res_MatrixData_17.CurrentCount : Res_MatrixData_17.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_17;
	return instance;
}

struct MatrixData_17 *Assign_MatrixData_17(struct MatrixData_17 **const left, struct MatrixData_17 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_17(*left);
	*left = right;
	return right;
}

void MatrixData_17_ctor(struct MatrixData_17 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_20 *array = NULL;

	assert(rows == ((int32_t)5));
	assert(columns == ((int32_t)4));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_20();
	(void)Assign_float64_t_1D_20(&self->_data, array);
	(void)Assign_float64_t_1D_20(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct float64_t_1D_20 *MatrixData_17_get_DataReference(struct MatrixData_17 *const self)
{
	struct float64_t_1D_20 *result = NULL;

	(void)Assign_float64_t_1D_20(&result, self->_data);
	return result;
}

void LinearAlgebra_MatrixMultiply_16(struct LinearAlgebra *const self, struct float64_t_1D_25 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_20 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_20 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)25) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)20) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)25) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)25) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)20) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)20) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)25) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)20) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_17 *MatrixMath_Multiply_30(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_2 *left, struct MatrixData_16 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_17 *matrixData = NULL;
	struct MatrixData_17 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_25 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_20 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_20 *array_2 = NULL;
	struct MatrixData_17 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == true);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Rows;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_17();
	MatrixData_17_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_17(&matrixData, matrixData_1);
	(void)Assign_MatrixData_17(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_2_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_16_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_17_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_16(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_25(&array, NULL);
	(void)Assign_float64_t_1D_20(&array_1, NULL);
	(void)Assign_float64_t_1D_20(&array_2, NULL);
	(void)Assign_MatrixData_17(&result, matrixData);
	RemRef_MatrixData_17(matrixData);
	return result;
}

void LinearAlgebra_MatrixMultiply_17(struct LinearAlgebra *const self, struct float64_t_1D_20 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_16 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_20 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)20) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)16) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)20) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)20) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)16) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)16) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)20) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)20) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_17 *MatrixMath_Multiply_31(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_17 *left, struct MatrixData_15 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_17 *matrixData = NULL;
	struct MatrixData_17 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_20 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_16 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_20 *array_2 = NULL;
	struct MatrixData_17 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == false);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Columns;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_17();
	MatrixData_17_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_17(&matrixData, matrixData_1);
	(void)Assign_MatrixData_17(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_17_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_15_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_17_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_17(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_20(&array, NULL);
	(void)Assign_float64_t_1D_16(&array_1, NULL);
	(void)Assign_float64_t_1D_20(&array_2, NULL);
	(void)Assign_MatrixData_17(&result, matrixData);
	RemRef_MatrixData_17(matrixData);
	return result;
}

struct MatrixData_17 *MatrixMath_Multiply_32(bool_t transposeFirst, bool_t transposeSecond, bool_t transposeThird, struct MatrixData_2 *first, struct MatrixData_16 *second, struct MatrixData_15 *third)
{
	struct MatrixData_17 *left = NULL;
	struct MatrixData_17 *matrixData = NULL;
	struct MatrixData_17 *result = NULL;
	struct MatrixData_17 *matrixData_1 = NULL;

	assert(transposeFirst == false);
	assert(transposeSecond == true);
	assert(transposeThird == false);
	if (!(first != NULL))
	{
		abort();
	}
	if (!(second != NULL))
	{
		abort();
	}
	if (!(third != NULL))
	{
		abort();
	}
	matrixData = MatrixMath_Multiply_30(transposeFirst, transposeSecond, first, second);
	(void)Assign_MatrixData_17(&left, matrixData);
	(void)Assign_MatrixData_17(&matrixData, NULL);
	matrixData_1 = MatrixMath_Multiply_31(false, transposeThird, left, third);
	(void)Assign_MatrixData_17(&result, matrixData_1);
	(void)Assign_MatrixData_17(&matrixData_1, NULL);
	RemRef_MatrixData_17(left);
	return result;
}

void LinearAlgebra_MatrixMultiply_18(struct LinearAlgebra *const self, struct float64_t_1D_20 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_4 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_5 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)20) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)4) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)20) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)20) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)4) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)4) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)20) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)5) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData *MatrixMath_Multiply_33(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_17 *left, struct MatrixData_5 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData *matrixData = NULL;
	struct MatrixData *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_20 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_4 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_5 *array_2 = NULL;
	struct MatrixData *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == false);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Columns;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData();
	MatrixData_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData(&matrixData, matrixData_1);
	(void)Assign_MatrixData(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_17_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_5_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_18(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_20(&array, NULL);
	(void)Assign_float64_t_1D_4(&array_1, NULL);
	(void)Assign_float64_t_1D_5(&array_2, NULL);
	(void)Assign_MatrixData(&result, matrixData);
	RemRef_MatrixData(matrixData);
	return result;
}

struct MatrixData *MatrixMath_Add_5(struct MatrixData *left, struct MatrixData *right)
{
	struct MatrixData *matrixData = NULL;
	struct MatrixData *matrixData_1 = NULL;
	struct float64_t_1D_5 *dataReference = NULL;
	struct float64_t_1D_5 *array = NULL;
	struct float64_t_1D_5 *dataReference2 = NULL;
	struct float64_t_1D_5 *array_1 = NULL;
	struct float64_t_1D_5 *dataReference3 = NULL;
	struct float64_t_1D_5 *array_2 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData *result = NULL;
	struct MatrixData *matrixData2 = NULL;
	struct MatrixData *matrixData_2 = NULL;
	struct float64_t_1D_5 *dataReference4 = NULL;
	struct float64_t_1D_5 *array_3 = NULL;
	struct float64_t_1D_5 *dataReference5 = NULL;
	struct float64_t_1D_5 *array_4 = NULL;
	struct float64_t_1D_5 *dataReference6 = NULL;
	struct float64_t_1D_5 *array_5 = NULL;
	int32_t num = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	struct MatrixData *matrixData3 = NULL;
	struct MatrixData *matrixData_3 = NULL;
	struct float64_t_1D_5 *dataReference7 = NULL;
	struct float64_t_1D_5 *array_6 = NULL;
	struct float64_t_1D_5 *dataReference8 = NULL;
	struct float64_t_1D_5 *array_7 = NULL;
	struct float64_t_1D_5 *dataReference9 = NULL;
	struct float64_t_1D_5 *array_8 = NULL;
	int32_t num2 = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t m = ((int32_t)0);

	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData();
	MatrixData_ctor(matrixData_1, left->Rows, right->Columns);
	(void)Assign_MatrixData(&matrixData, matrixData_1);
	(void)Assign_MatrixData(&matrixData_1, NULL);
	array = MatrixData_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_5(&dataReference, array);
	(void)Assign_float64_t_1D_5(&array, NULL);
	array_1 = MatrixData_get_DataReference(left);
	(void)Assign_float64_t_1D_5(&dataReference2, array_1);
	(void)Assign_float64_t_1D_5(&array_1, NULL);
	array_2 = MatrixData_get_DataReference(right);
	(void)Assign_float64_t_1D_5(&dataReference3, array_2);
	(void)Assign_float64_t_1D_5(&array_2, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)5))
	{
		dataReference->Elements[i] = dataReference2->Elements[i] + dataReference3->Elements[i];
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData(&result, matrixData);
	RemRef_MatrixData(matrixData);
	RemRef_float64_t_1D_5(dataReference);
	RemRef_float64_t_1D_5(dataReference2);
	RemRef_float64_t_1D_5(dataReference3);
	RemRef_MatrixData(matrixData2);
	RemRef_float64_t_1D_5(dataReference4);
	RemRef_float64_t_1D_5(dataReference5);
	RemRef_float64_t_1D_5(dataReference6);
	RemRef_MatrixData(matrixData3);
	RemRef_float64_t_1D_5(dataReference7);
	RemRef_float64_t_1D_5(dataReference8);
	RemRef_float64_t_1D_5(dataReference9);
	return result;
	matrixData_2 = New_MatrixData();
	MatrixData_ctor(matrixData_2, left->Rows, right->Columns);
	(void)Assign_MatrixData(&matrixData2, matrixData_2);
	(void)Assign_MatrixData(&matrixData_2, NULL);
	array_3 = MatrixData_get_DataReference(matrixData2);
	(void)Assign_float64_t_1D_5(&dataReference4, array_3);
	(void)Assign_float64_t_1D_5(&array_3, NULL);
	array_4 = MatrixData_get_DataReference(left);
	(void)Assign_float64_t_1D_5(&dataReference5, array_4);
	(void)Assign_float64_t_1D_5(&array_4, NULL);
	array_5 = MatrixData_get_DataReference(right);
	(void)Assign_float64_t_1D_5(&dataReference6, array_5);
	(void)Assign_float64_t_1D_5(&array_5, NULL);
	num = ((int32_t)0);
	j = ((int32_t)0);
	while (j < right->Columns)
	{
		k = ((int32_t)0);
		while (k < left->Rows)
		{
			dataReference4->Elements[num] = dataReference5->Elements[k] + dataReference6->Elements[num];
			num = num + ((int32_t)1);
			k = k + ((int32_t)1);
		}
		j = j + ((int32_t)1);
	}
	(void)Assign_MatrixData(&result, matrixData2);
	RemRef_MatrixData(matrixData);
	RemRef_float64_t_1D_5(dataReference);
	RemRef_float64_t_1D_5(dataReference2);
	RemRef_float64_t_1D_5(dataReference3);
	RemRef_MatrixData(matrixData2);
	RemRef_float64_t_1D_5(dataReference4);
	RemRef_float64_t_1D_5(dataReference5);
	RemRef_float64_t_1D_5(dataReference6);
	RemRef_MatrixData(matrixData3);
	RemRef_float64_t_1D_5(dataReference7);
	RemRef_float64_t_1D_5(dataReference8);
	RemRef_float64_t_1D_5(dataReference9);
	return result;
	matrixData_3 = New_MatrixData();
	MatrixData_ctor(matrixData_3, left->Rows, left->Columns);
	(void)Assign_MatrixData(&matrixData3, matrixData_3);
	(void)Assign_MatrixData(&matrixData_3, NULL);
	array_6 = MatrixData_get_DataReference(matrixData3);
	(void)Assign_float64_t_1D_5(&dataReference7, array_6);
	(void)Assign_float64_t_1D_5(&array_6, NULL);
	array_7 = MatrixData_get_DataReference(left);
	(void)Assign_float64_t_1D_5(&dataReference8, array_7);
	(void)Assign_float64_t_1D_5(&array_7, NULL);
	array_8 = MatrixData_get_DataReference(right);
	(void)Assign_float64_t_1D_5(&dataReference9, array_8);
	(void)Assign_float64_t_1D_5(&array_8, NULL);
	num2 = ((int32_t)0);
	l = ((int32_t)0);
	while (l < left->Columns)
	{
		m = ((int32_t)0);
		while (m < left->Rows)
		{
			dataReference7->Elements[num2] = dataReference8->Elements[num2] + dataReference9->Elements[m];
			num2 = num2 + ((int32_t)1);
			m = m + ((int32_t)1);
		}
		l = l + ((int32_t)1);
	}
	(void)Assign_MatrixData(&result, matrixData3);
	RemRef_MatrixData(matrixData);
	RemRef_float64_t_1D_5(dataReference);
	RemRef_float64_t_1D_5(dataReference2);
	RemRef_float64_t_1D_5(dataReference3);
	RemRef_MatrixData(matrixData2);
	RemRef_float64_t_1D_5(dataReference4);
	RemRef_float64_t_1D_5(dataReference5);
	RemRef_float64_t_1D_5(dataReference6);
	RemRef_MatrixData(matrixData3);
	RemRef_float64_t_1D_5(dataReference7);
	RemRef_float64_t_1D_5(dataReference8);
	RemRef_float64_t_1D_5(dataReference9);
	return result;
	abort();
}

void LinearAlgebra_MatrixMultiply_19(struct LinearAlgebra *const self, struct float64_t_1D_20 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_20 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_25 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)20) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)20) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)20) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)20) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)20) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)20) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)20) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)25) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_2 *MatrixMath_Multiply_34(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_17 *left, struct MatrixData_17 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_20 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_20 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_25 *array_2 = NULL;
	struct MatrixData_2 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == true);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Rows;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_2();
	MatrixData_2_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_2(&matrixData, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_17_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_17_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_2_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_19(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_20(&array, NULL);
	(void)Assign_float64_t_1D_20(&array_1, NULL);
	(void)Assign_float64_t_1D_25(&array_2, NULL);
	(void)Assign_MatrixData_2(&result, matrixData);
	RemRef_MatrixData_2(matrixData);
	return result;
}

struct MatrixData_2 *MatrixMath_Multiply_35(bool_t transposeFirst, bool_t transposeSecond, bool_t transposeThird, struct MatrixData_17 *first, struct MatrixData_15 *second, struct MatrixData_17 *third)
{
	struct MatrixData_17 *left = NULL;
	struct MatrixData_17 *matrixData = NULL;
	struct MatrixData_2 *result = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;

	assert(transposeFirst == false);
	assert(transposeSecond == false);
	assert(transposeThird == true);
	if (!(first != NULL))
	{
		abort();
	}
	if (!(second != NULL))
	{
		abort();
	}
	if (!(third != NULL))
	{
		abort();
	}
	matrixData = MatrixMath_Multiply_31(transposeFirst, transposeSecond, first, second);
	(void)Assign_MatrixData_17(&left, matrixData);
	(void)Assign_MatrixData_17(&matrixData, NULL);
	matrixData_1 = MatrixMath_Multiply_34(false, transposeThird, left, third);
	(void)Assign_MatrixData_2(&result, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	RemRef_MatrixData_17(left);
	return result;
}

struct MatrixData_2 *MatrixMath_Subtract_4(struct MatrixData_2 *left, struct MatrixData_2 *right)
{
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	struct float64_t_1D_25 *dataReference = NULL;
	struct float64_t_1D_25 *array = NULL;
	struct float64_t_1D_25 *dataReference2 = NULL;
	struct float64_t_1D_25 *array_1 = NULL;
	struct float64_t_1D_25 *dataReference3 = NULL;
	struct float64_t_1D_25 *array_2 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_2 *result = NULL;

	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData_2();
	MatrixData_2_ctor(matrixData_1, left->Rows, right->Columns);
	(void)Assign_MatrixData_2(&matrixData, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	array = MatrixData_2_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_25(&dataReference, array);
	(void)Assign_float64_t_1D_25(&array, NULL);
	array_1 = MatrixData_2_get_DataReference(left);
	(void)Assign_float64_t_1D_25(&dataReference2, array_1);
	(void)Assign_float64_t_1D_25(&array_1, NULL);
	array_2 = MatrixData_2_get_DataReference(right);
	(void)Assign_float64_t_1D_25(&dataReference3, array_2);
	(void)Assign_float64_t_1D_25(&array_2, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)25))
	{
		dataReference->Elements[i] = dataReference2->Elements[i] - dataReference3->Elements[i];
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_2(&result, matrixData);
	RemRef_MatrixData_2(matrixData);
	RemRef_float64_t_1D_25(dataReference);
	RemRef_float64_t_1D_25(dataReference2);
	RemRef_float64_t_1D_25(dataReference3);
	return result;
	abort();
}

void Space_6_Create_2(struct CASpace **space, struct MatrixData *vector)
{
	struct CASpace **caSpace = NULL;
	struct CASpace *caSpace_1 = NULL;

	caSpace = space;
	caSpace_1 = New_CASpace();
	CASpace_ctor(caSpace_1);
	(void)Assign_CASpace(&*caSpace, caSpace_1);
	(void)Assign_CASpace(&caSpace_1, NULL);
	(void)Assign_MatrixData(&(&(*space)->base.base.base)->_vector, vector);
}

struct CASpace *Space_6_Create_3(struct MatrixData *vector)
{
	struct CASpace *result = NULL;
	struct CASpace *result_1 = NULL;

	Space_6_Create_2(&result, vector);
	(void)Assign_CASpace(&result_1, result);
	RemRef_CASpace(result);
	return result_1;
}

struct MatrixData *MatrixMath_Subtract_5(struct MatrixData *left, struct MatrixData *right)
{
	struct MatrixData *matrixData = NULL;
	struct MatrixData *matrixData_1 = NULL;
	struct float64_t_1D_5 *dataReference = NULL;
	struct float64_t_1D_5 *array = NULL;
	struct float64_t_1D_5 *dataReference2 = NULL;
	struct float64_t_1D_5 *array_1 = NULL;
	struct float64_t_1D_5 *dataReference3 = NULL;
	struct float64_t_1D_5 *array_2 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData *result = NULL;
	struct MatrixData *matrixData2 = NULL;
	struct MatrixData *matrixData_2 = NULL;
	struct float64_t_1D_5 *dataReference4 = NULL;
	struct float64_t_1D_5 *array_3 = NULL;
	struct float64_t_1D_5 *dataReference5 = NULL;
	struct float64_t_1D_5 *array_4 = NULL;
	struct float64_t_1D_5 *dataReference6 = NULL;
	struct float64_t_1D_5 *array_5 = NULL;
	int32_t num = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	struct MatrixData *matrixData3 = NULL;
	struct MatrixData *matrixData_3 = NULL;
	struct float64_t_1D_5 *dataReference7 = NULL;
	struct float64_t_1D_5 *array_6 = NULL;
	struct float64_t_1D_5 *dataReference8 = NULL;
	struct float64_t_1D_5 *array_7 = NULL;
	struct float64_t_1D_5 *dataReference9 = NULL;
	struct float64_t_1D_5 *array_8 = NULL;
	int32_t num2 = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t m = ((int32_t)0);

	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData();
	MatrixData_ctor(matrixData_1, left->Rows, right->Columns);
	(void)Assign_MatrixData(&matrixData, matrixData_1);
	(void)Assign_MatrixData(&matrixData_1, NULL);
	array = MatrixData_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_5(&dataReference, array);
	(void)Assign_float64_t_1D_5(&array, NULL);
	array_1 = MatrixData_get_DataReference(left);
	(void)Assign_float64_t_1D_5(&dataReference2, array_1);
	(void)Assign_float64_t_1D_5(&array_1, NULL);
	array_2 = MatrixData_get_DataReference(right);
	(void)Assign_float64_t_1D_5(&dataReference3, array_2);
	(void)Assign_float64_t_1D_5(&array_2, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)5))
	{
		dataReference->Elements[i] = dataReference2->Elements[i] - dataReference3->Elements[i];
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData(&result, matrixData);
	RemRef_MatrixData(matrixData);
	RemRef_float64_t_1D_5(dataReference);
	RemRef_float64_t_1D_5(dataReference2);
	RemRef_float64_t_1D_5(dataReference3);
	RemRef_MatrixData(matrixData2);
	RemRef_float64_t_1D_5(dataReference4);
	RemRef_float64_t_1D_5(dataReference5);
	RemRef_float64_t_1D_5(dataReference6);
	RemRef_MatrixData(matrixData3);
	RemRef_float64_t_1D_5(dataReference7);
	RemRef_float64_t_1D_5(dataReference8);
	RemRef_float64_t_1D_5(dataReference9);
	return result;
	matrixData_2 = New_MatrixData();
	MatrixData_ctor(matrixData_2, left->Rows, right->Columns);
	(void)Assign_MatrixData(&matrixData2, matrixData_2);
	(void)Assign_MatrixData(&matrixData_2, NULL);
	array_3 = MatrixData_get_DataReference(matrixData2);
	(void)Assign_float64_t_1D_5(&dataReference4, array_3);
	(void)Assign_float64_t_1D_5(&array_3, NULL);
	array_4 = MatrixData_get_DataReference(left);
	(void)Assign_float64_t_1D_5(&dataReference5, array_4);
	(void)Assign_float64_t_1D_5(&array_4, NULL);
	array_5 = MatrixData_get_DataReference(right);
	(void)Assign_float64_t_1D_5(&dataReference6, array_5);
	(void)Assign_float64_t_1D_5(&array_5, NULL);
	num = ((int32_t)0);
	j = ((int32_t)0);
	while (j < right->Columns)
	{
		k = ((int32_t)0);
		while (k < left->Rows)
		{
			dataReference4->Elements[num] = dataReference5->Elements[k] - dataReference6->Elements[num];
			num = num + ((int32_t)1);
			k = k + ((int32_t)1);
		}
		j = j + ((int32_t)1);
	}
	(void)Assign_MatrixData(&result, matrixData2);
	RemRef_MatrixData(matrixData);
	RemRef_float64_t_1D_5(dataReference);
	RemRef_float64_t_1D_5(dataReference2);
	RemRef_float64_t_1D_5(dataReference3);
	RemRef_MatrixData(matrixData2);
	RemRef_float64_t_1D_5(dataReference4);
	RemRef_float64_t_1D_5(dataReference5);
	RemRef_float64_t_1D_5(dataReference6);
	RemRef_MatrixData(matrixData3);
	RemRef_float64_t_1D_5(dataReference7);
	RemRef_float64_t_1D_5(dataReference8);
	RemRef_float64_t_1D_5(dataReference9);
	return result;
	matrixData_3 = New_MatrixData();
	MatrixData_ctor(matrixData_3, left->Rows, left->Columns);
	(void)Assign_MatrixData(&matrixData3, matrixData_3);
	(void)Assign_MatrixData(&matrixData_3, NULL);
	array_6 = MatrixData_get_DataReference(matrixData3);
	(void)Assign_float64_t_1D_5(&dataReference7, array_6);
	(void)Assign_float64_t_1D_5(&array_6, NULL);
	array_7 = MatrixData_get_DataReference(left);
	(void)Assign_float64_t_1D_5(&dataReference8, array_7);
	(void)Assign_float64_t_1D_5(&array_7, NULL);
	array_8 = MatrixData_get_DataReference(right);
	(void)Assign_float64_t_1D_5(&dataReference9, array_8);
	(void)Assign_float64_t_1D_5(&array_8, NULL);
	num2 = ((int32_t)0);
	l = ((int32_t)0);
	while (l < left->Columns)
	{
		m = ((int32_t)0);
		while (m < left->Rows)
		{
			dataReference7->Elements[num2] = dataReference8->Elements[num2] - dataReference9->Elements[m];
			num2 = num2 + ((int32_t)1);
			m = m + ((int32_t)1);
		}
		l = l + ((int32_t)1);
	}
	(void)Assign_MatrixData(&result, matrixData3);
	RemRef_MatrixData(matrixData);
	RemRef_float64_t_1D_5(dataReference);
	RemRef_float64_t_1D_5(dataReference2);
	RemRef_float64_t_1D_5(dataReference3);
	RemRef_MatrixData(matrixData2);
	RemRef_float64_t_1D_5(dataReference4);
	RemRef_float64_t_1D_5(dataReference5);
	RemRef_float64_t_1D_5(dataReference6);
	RemRef_MatrixData(matrixData3);
	RemRef_float64_t_1D_5(dataReference7);
	RemRef_float64_t_1D_5(dataReference8);
	RemRef_float64_t_1D_5(dataReference9);
	return result;
	abort();
}

static struct float64_t_1D_5 *Space_Subtract(struct Space *const self, struct Space *other)
{
	struct float64_t_1D_5 *array = NULL;
	struct float64_t_1D_5 *array_1 = NULL;
	struct MatrixData *matrixData = NULL;
	struct MatrixData *matrixData_1 = NULL;
	struct MatrixData *matrixData_2 = NULL;
	struct MatrixData *matrixData_3 = NULL;
	struct float64_t_1D_5 *array_2 = NULL;
	struct float64_t_1D_5 *result = NULL;

	array_1 = New_float64_t_1D_5();
	(void)Assign_float64_t_1D_5(&array, array_1);
	(void)Assign_float64_t_1D_5(&array_1, NULL);
	matrixData_1 = Space_get_MatrixData(self);
	matrixData_2 = Space_get_MatrixData(other);
	matrixData_3 = MatrixMath_Subtract_5(matrixData_1, matrixData_2);
	(void)Assign_MatrixData(&matrixData, matrixData_3);
	(void)Assign_MatrixData(&matrixData_1, NULL);
	(void)Assign_MatrixData(&matrixData_2, NULL);
	(void)Assign_MatrixData(&matrixData_3, NULL);
	array_2 = MatrixData_get_DataReference(matrixData);
	(void)memcpy(&array->Elements, &array_2->Elements, sizeof(float64_t) * ((int32_t)5));
	(void)Assign_float64_t_1D_5(&array_2, NULL);
	(void)Assign_float64_t_1D_5(&result, array);
	RemRef_float64_t_1D_5(array);
	RemRef_MatrixData(matrixData);
	return result;
}

static struct float64_t_1D_5 *AngularSpace_Subtract(struct AngularSpace *const self, struct Space *other)
{
	struct float64_t_1D_5 *array = NULL;
	struct float64_t_1D_5 *array_1 = NULL;
	struct int32_t_1D_1 *angularDimensionsIndices = NULL;
	struct int32_t_1D_1 *array_2 = NULL;
	int32_t i = ((int32_t)0);
	int32_t num = ((int32_t)0);
	struct float64_t_1D_5 *result = NULL;

	array_1 = Space_Subtract(&self->base, other);
	(void)Assign_float64_t_1D_5(&array, array_1);
	(void)Assign_float64_t_1D_5(&array_1, NULL);
	array_2 = AngulSpace_get_AngulDimenIndice(self);
	(void)Assign_int32_t_1D_1(&angularDimensionsIndices, array_2);
	(void)Assign_int32_t_1D_1(&array_2, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)1))
	{
		struct float64_t_1D_5 *array_3 = NULL;
		int32_t int32 = ((int32_t)0);
		float64_t double_ = 0.0;

		num = angularDimensionsIndices->Elements[i];
		(void)Assign_float64_t_1D_5(&array_3, array);
		int32 = num;
		double_ = Math_1_Modulus(array->Elements[num] + 3.1415926535897931, 6.2831853071795862);
		array_3->Elements[int32] = double_ - 3.1415926535897931;
		(void)Assign_float64_t_1D_5(&array_3, NULL);
		i = i + ((int32_t)1);
	}
	(void)Assign_float64_t_1D_5(&result, array);
	RemRef_float64_t_1D_5(array);
	RemRef_int32_t_1D_1(angularDimensionsIndices);
	return result;
}

struct float64_t_1D_5 *Space_6_op_Subtraction_3(struct AngularSpace *left, struct Space *right)
{
	struct float64_t_1D_5 *result = NULL;
	struct float64_t_1D_5 *array = NULL;

	array = AngularSpace_Subtract(left, right);
	(void)Assign_float64_t_1D_5(&result, array);
	(void)Assign_float64_t_1D_5(&array, NULL);
	return result;
}

struct CASpace *SpaceExtensions_FitToDomain_1(struct CASpace *space)
{
	struct float64_t_1D_5 *array = NULL;
	struct CASpace *caSpace = NULL;
	struct CASpace *caSpace_1 = NULL;
	struct float64_t_1D_5 *array_1 = NULL;
	struct MatrixData *matrixData = NULL;
	struct MatrixData *matrixData_1 = NULL;
	struct float64_t_1D_5 *array_2 = NULL;
	struct float64_t_1D_5 *array_3 = NULL;
	struct CASpace *result = NULL;
	struct CASpace *caSpace_2 = NULL;
	struct CASpace *result_1 = NULL;

	(void)Assign_CASpace(&caSpace, space);
	caSpace_1 = New_CASpace();
	CASpace_ctor(caSpace_1);
	array_1 = Space_6_op_Subtraction_3(&caSpace->base.base, &caSpace_1->base.base.base);
	(void)Assign_float64_t_1D_5(&array, array_1);
	(void)Assign_CASpace(&caSpace, NULL);
	(void)Assign_CASpace(&caSpace_1, NULL);
	(void)Assign_float64_t_1D_5(&array_1, NULL);
	matrixData_1 = New_MatrixData();
	MatrixData_ctor(matrixData_1, (&space->base.base.base)->Dimensions, ((int32_t)1));
	(void)Assign_MatrixData(&matrixData, matrixData_1);
	(void)Assign_MatrixData(&matrixData_1, NULL);
	(void)Assign_float64_t_1D_5(&array_2, array);
	array_3 = MatrixData_get_DataReference(matrixData);
	(void)memcpy(&array_3->Elements, &array_2->Elements, sizeof(float64_t) * ((int32_t)5));
	(void)Assign_float64_t_1D_5(&array_2, NULL);
	(void)Assign_float64_t_1D_5(&array_3, NULL);
	caSpace_2 = New_CASpace();
	CASpace_ctor(caSpace_2);
	(void)Assign_CASpace(&result, caSpace_2);
	(void)Assign_CASpace(&caSpace_2, NULL);
	Space_set_MatrixData(&(*&result)->base.base.base, matrixData);
	(void)Assign_CASpace(&result_1, result);
	RemRef_float64_t_1D_5(array);
	RemRef_MatrixData(matrixData);
	RemRef_CASpace(result);
	return result_1;
}

struct Gaussian_5 *EKF_Update_4(struct Gaussian_5 *predictedState, struct Gaussian_2 *predictedMeasurement, struct MobilEyeSpace *measurement, struct Matrix_11 *transitionMatrix)
{
	struct MatrixData_15 *matrixData = NULL;
	struct PositiveDefiniteMatrix_3 *positiveDefiniteMatrix = NULL;
	struct MatrixData_15 *matrixData_1 = NULL;
	struct MatrixData_17 *matrixData2 = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_1 = NULL;
	struct MatrixData_2 *matrixData_2 = NULL;
	struct MatrixData_16 *matrixData_3 = NULL;
	struct MatrixData_15 *matrixData_4 = NULL;
	struct MatrixData_15 *matrixData_5 = NULL;
	struct MatrixData_15 *matrixData_6 = NULL;
	struct MatrixData_17 *matrixData_7 = NULL;
	struct MatrixData_5 *right = NULL;
	struct MobilEyeSpace *mobilEyeSpace = NULL;
	struct MobilEyeSpace *mobilEyeSpace_1 = NULL;
	struct float64_t_1D_4 *array = NULL;
	struct MatrixData_5 *matrixData_8 = NULL;
	struct CASpace *expectation = NULL;
	struct CASpace *caSpace = NULL;
	struct MatrixData *vector = NULL;
	struct MatrixData *matrixData_9 = NULL;
	struct MatrixData *matrixData_10 = NULL;
	struct MatrixData *matrixData_11 = NULL;
	struct MatrixData_2 *matrix = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_2 = NULL;
	struct MatrixData_2 *matrixData_12 = NULL;
	struct MatrixData_2 *matrixData_13 = NULL;
	struct MatrixData_2 *matrixData_14 = NULL;
	struct CASpace *expectation2 = NULL;
	struct CASpace *caSpace_1 = NULL;
	struct CASpace *caSpace_2 = NULL;
	struct PositiveDefiniteMatrix_7 *covariance = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_3 = NULL;
	struct Gaussian_5 *result = NULL;
	struct Gaussian_5 *gaussian = NULL;

	positiveDefiniteMatrix = Gaussian_2_get_Covariance(predictedMeasurement);
	matrixData_1 = Matrix_3_get_MatrixData(&positiveDefiniteMatrix->base.base);
	(void)Assign_MatrixData_15(&matrixData, matrixData_1);
	(void)Assign_PositiveDefiniteMatrix_3(&positiveDefiniteMatrix, NULL);
	(void)Assign_MatrixData_15(&matrixData_1, NULL);
	positiveDefiniteMatrix_1 = Gaussian_5_get_Covariance(predictedState);
	matrixData_2 = Matrix_10_get_MatrixData(&positiveDefiniteMatrix_1->base.base);
	matrixData_3 = Matrix_11_get_MatrixData(transitionMatrix);
	(void)Assign_MatrixData_15(&matrixData_4, matrixData);
	matrixData_5 = MatrixData_20_Eye_3(matrixData->Rows, matrixData->Columns);
	matrixData_6 = MatrixMath_LinsolveSquare_1(matrixData_4, matrixData_5);
	matrixData_7 = MatrixMath_Multiply_32(false, true, false, matrixData_2, matrixData_3, matrixData_6);
	(void)Assign_MatrixData_17(&matrixData2, matrixData_7);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_1, NULL);
	(void)Assign_MatrixData_2(&matrixData_2, NULL);
	(void)Assign_MatrixData_16(&matrixData_3, NULL);
	(void)Assign_MatrixData_15(&matrixData_4, NULL);
	(void)Assign_MatrixData_15(&matrixData_5, NULL);
	(void)Assign_MatrixData_15(&matrixData_6, NULL);
	(void)Assign_MatrixData_17(&matrixData_7, NULL);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, measurement);
	mobilEyeSpace_1 = Gaussian_2_get_Expectation(predictedMeasurement);
	array = Space_6_op_Subtraction_2(&mobilEyeSpace->base, &mobilEyeSpace_1->base);
	matrixData_8 = MatrixData_20_Create_1(array);
	(void)Assign_MatrixData_5(&right, matrixData_8);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace_1, NULL);
	(void)Assign_float64_t_1D_4(&array, NULL);
	(void)Assign_MatrixData_5(&matrixData_8, NULL);
	caSpace = Gaussian_5_get_Expectation(predictedState);
	(void)Assign_CASpace(&expectation, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	matrixData_9 = Space_get_MatrixData(&(*&expectation)->base.base.base);
	matrixData_10 = MatrixMath_Multiply_33(false, false, matrixData2, right);
	matrixData_11 = MatrixMath_Add_5(matrixData_9, matrixData_10);
	(void)Assign_MatrixData(&vector, matrixData_11);
	(void)Assign_MatrixData(&matrixData_9, NULL);
	(void)Assign_MatrixData(&matrixData_10, NULL);
	(void)Assign_MatrixData(&matrixData_11, NULL);
	positiveDefiniteMatrix_2 = Gaussian_5_get_Covariance(predictedState);
	matrixData_12 = Matrix_10_get_MatrixData(&positiveDefiniteMatrix_2->base.base);
	matrixData_13 = MatrixMath_Multiply_35(false, false, true, matrixData2, matrixData, matrixData2);
	matrixData_14 = MatrixMath_Subtract_4(matrixData_12, matrixData_13);
	(void)Assign_MatrixData_2(&matrix, matrixData_14);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_2, NULL);
	(void)Assign_MatrixData_2(&matrixData_12, NULL);
	(void)Assign_MatrixData_2(&matrixData_13, NULL);
	(void)Assign_MatrixData_2(&matrixData_14, NULL);
	caSpace_1 = Space_6_Create_3(vector);
	caSpace_2 = SpaceExtensions_FitToDomain_1(caSpace_1);
	(void)Assign_CASpace(&expectation2, caSpace_2);
	(void)Assign_CASpace(&caSpace_1, NULL);
	(void)Assign_CASpace(&caSpace_2, NULL);
	positiveDefiniteMatrix_3 = PosiDefinMatri_11_CreatAndCorre(matrix);
	(void)Assign_PositiveDefiniteMatrix_7(&covariance, positiveDefiniteMatrix_3);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_3, NULL);
	gaussian = Gaussian_9_Create(expectation2, covariance);
	(void)Assign_Gaussian_5(&result, gaussian);
	(void)Assign_Gaussian_5(&gaussian, NULL);
	RemRef_MatrixData_15(matrixData);
	RemRef_MatrixData_17(matrixData2);
	RemRef_MatrixData_5(right);
	RemRef_CASpace(expectation);
	RemRef_MatrixData(vector);
	RemRef_MatrixData_2(matrix);
	RemRef_CASpace(expectation2);
	RemRef_PositiveDefiniteMatrix_7(covariance);
	return result;
}

int32_t Tracking_1_SimplifiedIndexOf(struct StaticList_6 *source, struct MobilEyeSpace *value)
{
	int32_t i = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	i = ((int32_t)0);
	int32 = i;
	int32_1 = StaticList_6_get_Count(source);
	while (int32 < int32_1)
	{
		struct MobilEyeSpace *mobilEyeSpace = NULL;
		struct MobilEyeSpace *mobilEyeSpace_1 = NULL;
		bool_t boolean = false;

		mobilEyeSpace = StaticList_6_get_Item(source, i);
		(void)Assign_MobilEyeSpace(&mobilEyeSpace_1, mobilEyeSpace);
		boolean = Object_2_ReferenceEquals(&mobilEyeSpace_1->base.base, &value->base.base);
		if (!!boolean)
		{
			(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
			(void)Assign_MobilEyeSpace(&mobilEyeSpace_1, NULL);
			return i;
		}
		else
		{
			(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
			(void)Assign_MobilEyeSpace(&mobilEyeSpace_1, NULL);
		}
		i = i + ((int32_t)1);
		int32 = i;
		int32_1 = StaticList_6_get_Count(source);
	}
	return ((int32_t)-1);
}

struct Obstacle *StaticList_4_get_Item(struct StaticList_4 *const self, int32_t index)
{
	struct Obstacle *result = NULL;

	(void)Assign_Obstacle(&result, self->_items->Elements[index]);
	return result;
}

void StaticListEnumerator_10_Dispose(struct StaticListEnumerator_10 *const self)
{
}

int32_t GaussianMixture_get_Count(struct GaussianMixture *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_24_get_Count(self->_gaussians);
	return int32;
}

void Gaussian_5_ctor_1(struct Gaussian_5 *const self)
{
	struct CASpace *caSpace = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix = NULL;

	Object_ctor(&self->base);
	self->_dimensions = (&Gaussian_9_EmptySpace->base.base.base)->Dimensions;
	caSpace = New_CASpace();
	CASpace_ctor(caSpace);
	Gaussian_5_set_Expectation(self, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_7();
	PositiveDefiniteMatrix_7_ctor_1(positiveDefiniteMatrix);
	Gaussian_5_set_Covariance(self, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix, NULL);
}

struct Gaussian_5 *StaticList_24_get_Item(struct StaticList_24 *const self, int32_t index)
{
	struct Gaussian_5 *result = NULL;

	(void)Assign_Gaussian_5(&result, self->_items->Elements[index]);
	return result;
}

static void RemRef_StaticListEnumerator_1(struct StaticListEnumerator_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListEnumerator_1.CurrentCount--;
		Res_StaticListEnumerator_1.Next[Res_StaticListEnumerator_1.CurrentCount] = self;
		Del_StaticListEnumerator_1(self);
	}
}

struct StaticListEnumerator_1 *New_StaticListEnumerator_1(void)
{
	static struct StaticListEnumerator_1 const Default_StaticListEnumerator_1 = { 1 };
	struct StaticListEnumerator_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListEnumerator_1.CurrentCount == RC_StaticListEnumerator_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListEnumerator_1.Next[Res_StaticListEnumerator_1.CurrentCount];
	Res_StaticListEnumerator_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListEnumerator_1.MaximumCount = (Res_StaticListEnumerator_1.CurrentCount > Res_StaticListEnumerator_1.MaximumCount) ? Res_StaticListEnumerator_1.CurrentCount : Res_StaticListEnumerator_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListEnumerator_1;
	return instance;
}

struct StaticListEnumerator_1 *Assign_StaticListEnumerator_1(struct StaticListEnumerator_1 **const left, struct StaticListEnumerator_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListEnumerator_1(*left);
	*left = right;
	return right;
}

void StaticListEnumerator_1_ctor(struct StaticListEnumerator_1 *const self, struct StaticList_2 *list)
{
	self->_current = ((int32_t)-1);
	Object_ctor(&self->base);
	(void)Assign_StaticList_2(&self->_list, list);
}

struct StaticListEnumerator_1 *StaticList_2_GetEnumerator(struct StaticList_2 *const self)
{
	struct StaticListEnumerator_1 *result = NULL;
	struct StaticListEnumerator_1 *staticListEnumerator = NULL;

	staticListEnumerator = New_StaticListEnumerator_1();
	StaticListEnumerator_1_ctor(staticListEnumerator, self);
	(void)Assign_StaticListEnumerator_1(&result, staticListEnumerator);
	(void)Assign_StaticListEnumerator_1(&staticListEnumerator, NULL);
	return result;
}

bool_t StaticListEnumerator_1_MoveNext(struct StaticListEnumerator_1 *const self)
{
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	self->_current = self->_current + ((int32_t)1);
	int32 = self->_current;
	int32_1 = StaticList_2_get_Count(self->_list);
	return int32 != int32_1;
}

float64_t StaticList_2_get_Item(struct StaticList_2 *const self, int32_t index)
{
	return self->_items->Elements[index];
}

float64_t StaticListEnumera_1_get_Current(struct StaticListEnumerator_1 *const self)
{
	float64_t double_ = 0.0;

	double_ = StaticList_2_get_Item(self->_list, self->_current);
	return double_;
}

void StaticListEnumerator_1_Dispose(struct StaticListEnumerator_1 *const self)
{
}

float64_t Enumerable_Sum(struct StaticList_2 *source)
{
	float64_t num = 0.0;
	struct StaticListEnumerator_1 *enumerator = NULL;
	struct StaticListEnumerator_1 *staticListEnumerator = NULL;
	float64_t current = 0.0;
	bool_t boolean = false;

	if (!(source != NULL))
	{
		abort();
	}
	num = 0.0;
	staticListEnumerator = StaticList_2_GetEnumerator(source);
	(void)Assign_StaticListEnumerator_1(&enumerator, staticListEnumerator);
	(void)Assign_StaticListEnumerator_1(&staticListEnumerator, NULL);
	boolean = StaticListEnumerator_1_MoveNext(enumerator);
	while (boolean)
	{
		float64_t double_ = 0.0;

		double_ = StaticListEnumera_1_get_Current(enumerator);
		current = double_;
		num = num + current;
		boolean = StaticListEnumerator_1_MoveNext(enumerator);
	}
	if (!!(enumerator != NULL))
	{
		StaticListEnumerator_1_Dispose(enumerator);
	}
	RemRef_StaticListEnumerator_1(enumerator);
	return num;
}

void StaticList_2_set_Item(struct StaticList_2 *const self, int32_t index, float64_t value)
{
	self->_items->Elements[index] = value;
}

void GaussianMixture_Normalize(struct GaussianMixture *const self)
{
	float64_t num = 0.0;
	float64_t double_ = 0.0;
	int32_t i = ((int32_t)0);
	float64_t num2 = 0.0;

	double_ = Enumerable_Sum(self->_weights);
	num = double_;
	if (!(num == 1.0))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		i = ((int32_t)0);
		int32 = i;
		int32_1 = GaussianMixture_get_Count(self);
		while (int32 < int32_1)
		{
			float64_t double__1 = 0.0;

			double__1 = StaticList_2_get_Item(self->_weights, i);
			num2 = double__1;
			StaticList_2_set_Item(self->_weights, i, num2 / num);
			i = i + ((int32_t)1);
			int32 = i;
			int32_1 = GaussianMixture_get_Count(self);
		}
	}
}

void MatrixData_ctor_1(struct MatrixData *const self, struct float64_t_1D_5 *data, int32_t rows, int32_t columns)
{
	assert(rows == ((int32_t)5));
	assert(columns == ((int32_t)1));
	MatrixData_ctor_2(self, data, rows, columns, false);
}

struct MatrixData *MatrixMath_MultiplyElem(struct MatrixData *matrix, float64_t scalar)
{
	struct MatrixData *matrixData = NULL;
	struct MatrixData *matrixData_1 = NULL;
	struct float64_t_1D_5 *dataReference = NULL;
	struct float64_t_1D_5 *array = NULL;
	struct float64_t_1D_5 *dataReference2 = NULL;
	struct float64_t_1D_5 *array_1 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData *result = NULL;

	if (!(matrix != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData();
	MatrixData_ctor(matrixData_1, matrix->Rows, matrix->Columns);
	(void)Assign_MatrixData(&matrixData, matrixData_1);
	(void)Assign_MatrixData(&matrixData_1, NULL);
	array = MatrixData_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_5(&dataReference, array);
	(void)Assign_float64_t_1D_5(&array, NULL);
	array_1 = MatrixData_get_DataReference(matrix);
	(void)Assign_float64_t_1D_5(&dataReference2, array_1);
	(void)Assign_float64_t_1D_5(&array_1, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)5))
	{
		dataReference->Elements[i] = dataReference2->Elements[i] * scalar;
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData(&result, matrixData);
	RemRef_MatrixData(matrixData);
	RemRef_float64_t_1D_5(dataReference);
	RemRef_float64_t_1D_5(dataReference2);
	return result;
}

static void MatrixData_ctor_3(struct MatrixData *const self, struct float64_t_1D_5 *data, bool_t takeDataOwnership)
{
	int32_t arg_5F_1 = ((int32_t)0);

	Object_ctor(&self->base);
	if (!(data != NULL))
	{
		abort();
	}
	if (!!takeDataOwnership)
	{
		(void)Assign_float64_t_1D_5(&self->_data, data);
	}
	else
	{
		struct float64_t_1D_5 *array = NULL;

		array = New_float64_t_1D_5();
		(void)Assign_float64_t_1D_5(&self->_data, array);
		(void)Assign_float64_t_1D_5(&array, NULL);
		(void)memcpy(&self->_data->Elements, &data->Elements, sizeof(float64_t) * ((int32_t)5));
	}
	self->Rows = ((int32_t)5);
	arg_5F_1 = ((int32_t)1);
	self->Columns = arg_5F_1;
}

struct MatrixData *MatrixData_20_Create_2(struct float64_t_1D_5 *data)
{
	struct MatrixData *result = NULL;
	struct MatrixData *matrixData = NULL;

	matrixData = New_MatrixData();
	MatrixData_ctor_3(matrixData, data, true);
	(void)Assign_MatrixData(&result, matrixData);
	(void)Assign_MatrixData(&matrixData, NULL);
	return result;
}

void LinearAlgebra_MatrixMultiply_20(struct LinearAlgebra *const self, struct float64_t_1D_5 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_5 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_25 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)5) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)5) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)5) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)5) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)5) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)5) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)5) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)25) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_2 *MatrixMath_Multiply_36(bool_t transposeLeft, bool_t transposeRight, struct MatrixData *left, struct MatrixData *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_5 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_5 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_25 *array_2 = NULL;
	struct MatrixData_2 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == true);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Rows;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_2();
	MatrixData_2_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_2(&matrixData, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_2_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_20(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_5(&array, NULL);
	(void)Assign_float64_t_1D_5(&array_1, NULL);
	(void)Assign_float64_t_1D_25(&array_2, NULL);
	(void)Assign_MatrixData_2(&result, matrixData);
	RemRef_MatrixData_2(matrixData);
	return result;
}

struct MatrixData_2 *MatrixMath_MultiplyElem_1(struct MatrixData_2 *matrix, float64_t scalar)
{
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	struct float64_t_1D_25 *dataReference = NULL;
	struct float64_t_1D_25 *array = NULL;
	struct float64_t_1D_25 *dataReference2 = NULL;
	struct float64_t_1D_25 *array_1 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_2 *result = NULL;

	if (!(matrix != NULL))
	{
		abort();
	}
	matrixData_1 = New_MatrixData_2();
	MatrixData_2_ctor(matrixData_1, matrix->Rows, matrix->Columns);
	(void)Assign_MatrixData_2(&matrixData, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	array = MatrixData_2_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_25(&dataReference, array);
	(void)Assign_float64_t_1D_25(&array, NULL);
	array_1 = MatrixData_2_get_DataReference(matrix);
	(void)Assign_float64_t_1D_25(&dataReference2, array_1);
	(void)Assign_float64_t_1D_25(&array_1, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)25))
	{
		dataReference->Elements[i] = dataReference2->Elements[i] * scalar;
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_2(&result, matrixData);
	RemRef_MatrixData_2(matrixData);
	RemRef_float64_t_1D_25(dataReference);
	RemRef_float64_t_1D_25(dataReference2);
	return result;
}

struct Gaussian_5 *GaussianMixture_ToGaussian(struct GaussianMixture *const self)
{
	struct Gaussian_5 *result = NULL;
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);
	struct CASpace *tSpace = NULL;
	struct CASpace *caSpace = NULL;
	float64_t num = 0.0;
	int32_t i = ((int32_t)0);
	struct float64_t_1D_5 *array = NULL;
	int32_t int32_2 = ((int32_t)0);
	int32_t int32_3 = ((int32_t)0);
	struct CASpace *caSpace_1 = NULL;
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	int32_t j = ((int32_t)0);
	struct MatrixData *matrixData2 = NULL;
	int32_t int32_4 = ((int32_t)0);
	int32_t int32_5 = ((int32_t)0);
	struct CASpace *caSpace_2 = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix = NULL;
	struct Gaussian_5 *gaussian = NULL;

	int32 = GaussianMixture_get_Count(self);
	if (!(int32 != ((int32_t)0)))
	{
		struct Gaussian_5 *gaussian_1 = NULL;

		gaussian_1 = New_Gaussian_5();
		Gaussian_5_ctor_1(gaussian_1);
		(void)Assign_Gaussian_5(&result, gaussian_1);
		(void)Assign_Gaussian_5(&gaussian_1, NULL);
		RemRef_CASpace(tSpace);
		RemRef_float64_t_1D_5(array);
		RemRef_MatrixData_2(matrixData);
		RemRef_MatrixData(matrixData2);
		return result;
	}
	int32_1 = GaussianMixture_get_Count(self);
	if (!(int32_1 != ((int32_t)1)))
	{
		struct Gaussian_5 *gaussian_2 = NULL;
		struct Gaussian_5 *gaussian_3 = NULL;

		gaussian_2 = StaticList_24_get_Item(self->_gaussians, ((int32_t)0));
		gaussian_3 = Gaussian_5_Clone(gaussian_2);
		(void)Assign_Gaussian_5(&result, gaussian_3);
		(void)Assign_Gaussian_5(&gaussian_2, NULL);
		(void)Assign_Gaussian_5(&gaussian_3, NULL);
		RemRef_CASpace(tSpace);
		RemRef_float64_t_1D_5(array);
		RemRef_MatrixData_2(matrixData);
		RemRef_MatrixData(matrixData2);
		return result;
	}
	GaussianMixture_Normalize(self);
	caSpace = New_CASpace();
	CASpace_ctor(caSpace);
	(void)Assign_CASpace(&tSpace, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	num = 0.0;
	i = ((int32_t)0);
	int32_2 = i;
	int32_3 = GaussianMixture_get_Count(self);
	while (int32_2 < int32_3)
	{
		float64_t double_ = 0.0;

		double_ = StaticList_2_get_Item(self->_weights, i);
		if (!(double_ == 0.0))
		{
			float64_t double__1 = 0.0;
			float64_t double__2 = 0.0;
			struct Gaussian_5 *gaussian_4 = NULL;
			struct CASpace *caSpace_3 = NULL;
			struct CASpace *caSpace_4 = NULL;
			struct float64_t_1D_5 *array_1 = NULL;
			struct MatrixData *matrixData_2 = NULL;
			struct MatrixData *matrixData_3 = NULL;
			float64_t double__3 = 0.0;
			struct MatrixData *matrixData_4 = NULL;
			struct MatrixData *matrixData_5 = NULL;
			struct CASpace *caSpace_5 = NULL;

			double__1 = num;
			double__2 = StaticList_2_get_Item(self->_weights, i);
			num = double__1 + double__2;
			gaussian_4 = StaticList_24_get_Item(self->_gaussians, i);
			caSpace_3 = Gaussian_5_get_Expectation(gaussian_4);
			(void)Assign_CASpace(&caSpace_4, caSpace_3);
			array_1 = Space_6_op_Subtraction_3(&caSpace_4->base.base, &tSpace->base.base.base);
			(void)Assign_float64_t_1D_5(&array, array_1);
			(void)Assign_Gaussian_5(&gaussian_4, NULL);
			(void)Assign_CASpace(&caSpace_3, NULL);
			(void)Assign_CASpace(&caSpace_4, NULL);
			(void)Assign_float64_t_1D_5(&array_1, NULL);
			matrixData_2 = Space_get_MatrixData(&(*&tSpace)->base.base.base);
			matrixData_3 = New_MatrixData();
			MatrixData_ctor_1(matrixData_3, array, ((int32_t)5), ((int32_t)1));
			double__3 = StaticList_2_get_Item(self->_weights, i);
			matrixData_4 = MatrixMath_MultiplyElem(matrixData_3, double__3 / num);
			matrixData_5 = MatrixMath_Add_5(matrixData_2, matrixData_4);
			caSpace_5 = Space_6_Create_3(matrixData_5);
			(void)Assign_CASpace(&tSpace, caSpace_5);
			(void)Assign_MatrixData(&matrixData_2, NULL);
			(void)Assign_MatrixData(&matrixData_3, NULL);
			(void)Assign_MatrixData(&matrixData_4, NULL);
			(void)Assign_MatrixData(&matrixData_5, NULL);
			(void)Assign_CASpace(&caSpace_5, NULL);
		}
		i = i + ((int32_t)1);
		int32_2 = i;
		int32_3 = GaussianMixture_get_Count(self);
	}
	caSpace_1 = SpaceExtensions_FitToDomain_1(tSpace);
	(void)Assign_CASpace(&tSpace, caSpace_1);
	(void)Assign_CASpace(&caSpace_1, NULL);
	matrixData_1 = MatrixData_20_Zeros_1(self->Dimensions, self->Dimensions);
	(void)Assign_MatrixData_2(&matrixData, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	j = ((int32_t)0);
	int32_4 = j;
	int32_5 = GaussianMixture_get_Count(self);
	while (int32_4 < int32_5)
	{
		struct Gaussian_5 *gaussian_5 = NULL;
		struct CASpace *caSpace_6 = NULL;
		struct CASpace *caSpace_7 = NULL;
		struct float64_t_1D_5 *array_2 = NULL;
		struct MatrixData *matrixData_6 = NULL;
		struct MatrixData_2 *matrixData_7 = NULL;
		struct Gaussian_5 *gaussian_6 = NULL;
		struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_1 = NULL;
		struct MatrixData_2 *matrixData_8 = NULL;
		struct MatrixData_2 *matrixData_9 = NULL;
		struct MatrixData_2 *matrixData_10 = NULL;
		float64_t double__4 = 0.0;
		struct MatrixData_2 *matrixData_11 = NULL;
		struct MatrixData_2 *matrixData_12 = NULL;

		gaussian_5 = StaticList_24_get_Item(self->_gaussians, j);
		caSpace_6 = Gaussian_5_get_Expectation(gaussian_5);
		(void)Assign_CASpace(&caSpace_7, caSpace_6);
		array_2 = Space_6_op_Subtraction_3(&caSpace_7->base.base, &tSpace->base.base.base);
		matrixData_6 = MatrixData_20_Create_2(array_2);
		(void)Assign_MatrixData(&matrixData2, matrixData_6);
		(void)Assign_Gaussian_5(&gaussian_5, NULL);
		(void)Assign_CASpace(&caSpace_6, NULL);
		(void)Assign_CASpace(&caSpace_7, NULL);
		(void)Assign_float64_t_1D_5(&array_2, NULL);
		(void)Assign_MatrixData(&matrixData_6, NULL);
		(void)Assign_MatrixData_2(&matrixData_7, matrixData);
		gaussian_6 = StaticList_24_get_Item(self->_gaussians, j);
		positiveDefiniteMatrix_1 = Gaussian_5_get_Covariance(gaussian_6);
		matrixData_8 = Matrix_10_get_MatrixData(&positiveDefiniteMatrix_1->base.base);
		matrixData_9 = MatrixMath_Multiply_36(false, true, matrixData2, matrixData2);
		matrixData_10 = MatrixMath_Add_3(matrixData_8, matrixData_9);
		double__4 = StaticList_2_get_Item(self->_weights, j);
		matrixData_11 = MatrixMath_MultiplyElem_1(matrixData_10, double__4);
		matrixData_12 = MatrixMath_Add_3(matrixData_7, matrixData_11);
		(void)Assign_MatrixData_2(&matrixData, matrixData_12);
		(void)Assign_MatrixData_2(&matrixData_7, NULL);
		(void)Assign_Gaussian_5(&gaussian_6, NULL);
		(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_1, NULL);
		(void)Assign_MatrixData_2(&matrixData_8, NULL);
		(void)Assign_MatrixData_2(&matrixData_9, NULL);
		(void)Assign_MatrixData_2(&matrixData_10, NULL);
		(void)Assign_MatrixData_2(&matrixData_11, NULL);
		(void)Assign_MatrixData_2(&matrixData_12, NULL);
		j = j + ((int32_t)1);
		int32_4 = j;
		int32_5 = GaussianMixture_get_Count(self);
	}
	(void)Assign_CASpace(&caSpace_2, tSpace);
	positiveDefiniteMatrix = PositivDefiniteMatrix_11_Create(matrixData);
	gaussian = Gaussian_9_Create(caSpace_2, positiveDefiniteMatrix);
	(void)Assign_Gaussian_5(&result, gaussian);
	(void)Assign_CASpace(&caSpace_2, NULL);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix, NULL);
	(void)Assign_Gaussian_5(&gaussian, NULL);
	RemRef_CASpace(tSpace);
	RemRef_float64_t_1D_5(array);
	RemRef_MatrixData_2(matrixData);
	RemRef_MatrixData(matrixData2);
	return result;
}

void MeasureSetLikeliho_set_Conditio(struct MeasurementSetLikelihood *const self, struct ExistenceSpace *value)
{
	(void)Assign_ExistenceSpace(&self->Condition, value);
}

static struct ExistenceSpace *MeasureSetLikeliho_get_Conditio(struct MeasurementSetLikelihood *const self)
{
	struct ExistenceSpace *result = NULL;

	(void)Assign_ExistenceSpace(&result, self->Condition);
	return result;
}

float64_t MeasuremeSetLikelihood_Evaluate(struct MeasurementSetLikelihood *const self)
{
	struct ExistenceSpace *existenceSpace = NULL;
	bool_t boolean = false;

	existenceSpace = MeasureSetLikeliho_get_Conditio(self);
	boolean = Space_6_op_Equality(existenceSpace, ExistenceSpace_1_Existent);
	if (!!boolean)
	{
		(void)Assign_ExistenceSpace(&existenceSpace, NULL);
		return self->_likelihoodGivenExistent;
	}
	else
	{
		(void)Assign_ExistenceSpace(&existenceSpace, NULL);
	}
	return self->_likelihoodGivenNonExistent;
}

void BayesFilter_Update(struct TwoPointDistribution **predictedState, struct MeasurementSetLikelihood *measurementLikelihood)
{
	struct MeasurementSetLikelihood *measurementSetLikelihood = NULL;
	struct ExistenceSpace *existenceSpace = NULL;
	float64_t num = 0.0;
	float64_t double_ = 0.0;
	struct MeasurementSetLikelihood *measurementSetLikelihood_1 = NULL;
	struct ExistenceSpace *existenceSpace_1 = NULL;
	float64_t num2 = 0.0;
	float64_t double__1 = 0.0;
	struct TwoPointDistribution **twoPointDistribution = NULL;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;

	(void)Assign_MeasurementSetLikelihood(&measurementSetLikelihood, measurementLikelihood);
	existenceSpace = TwoPointDistri_get_SuccesSample(*predictedState);
	MeasureSetLikeliho_set_Conditio(measurementSetLikelihood, existenceSpace);
	(void)Assign_MeasurementSetLikelihood(&measurementSetLikelihood, NULL);
	(void)Assign_ExistenceSpace(&existenceSpace, NULL);
	double_ = MeasuremeSetLikelihood_Evaluate(measurementLikelihood);
	num = double_;
	(void)Assign_MeasurementSetLikelihood(&measurementSetLikelihood_1, measurementLikelihood);
	existenceSpace_1 = TwoPointDistri_get_FailurSample(*predictedState);
	MeasureSetLikeliho_set_Conditio(measurementSetLikelihood_1, existenceSpace_1);
	(void)Assign_MeasurementSetLikelihood(&measurementSetLikelihood_1, NULL);
	(void)Assign_ExistenceSpace(&existenceSpace_1, NULL);
	double__1 = MeasuremeSetLikelihood_Evaluate(measurementLikelihood);
	num2 = double__1;
	twoPointDistribution = predictedState;
	double__2 = TwoPointDistributio_get_LogOdds(*predictedState);
	double__3 = Math_Log(num / num2);
	TwoPointDistributio_set_LogOdds(*twoPointDistribution, double__2 + double__3);
}

struct TwoPointDistribution *BayesFilter_Update_1(struct TwoPointDistribution *predictedState, struct MeasurementSetLikelihood *measurementLikelihood)
{
	struct TwoPointDistribution *result = NULL;
	struct TwoPointDistribution *twoPointDistribution = NULL;
	struct TwoPointDistribution *result_1 = NULL;

	twoPointDistribution = TwoPointDistribution_Clone(predictedState);
	(void)Assign_TwoPointDistribution(&result, twoPointDistribution);
	(void)Assign_TwoPointDistribution(&twoPointDistribution, NULL);
	BayesFilter_Update(&result, measurementLikelihood);
	(void)Assign_TwoPointDistribution(&result_1, result);
	RemRef_TwoPointDistribution(result);
	return result_1;
}

float64_t Existenc_get_ExistenceProbabili(struct Existence *const self)
{
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;

	double_ = TwoPointDistributio_get_LogOdds(&self->base);
	double__1 = Math_Exp(double_);
	return 1.0 - (1.0 / (1.0 + double__1));
}

float64_t Track_get_ExisteProbabForDeleti(struct Tracking *const self)
{
	return self->ExistenceProbabilityForDeletion;
}

float64_t Matrix_10_get_Item(struct Matrix_10 *const self, int32_t row, int32_t column)
{
	float64_t result = 0.0;
	struct MatrixData_2 *matrixData = NULL;
	float64_t double_ = 0.0;

	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	matrixData = Matrix_10_get_MatrixData(self);
	double_ = MatrixData_2_get_Item(matrixData, row, column);
	result = double_;
	(void)Assign_MatrixData_2(&matrixData, NULL);
	return result;
}

float64_t PositivDefinitMatrix_7_get_Item(struct PositiveDefiniteMatrix_7 *const self, int32_t row, int32_t column)
{
	float64_t double_ = 0.0;

	double_ = Matrix_10_get_Item(&self->base.base, row, column);
	return double_;
}

float64_t Matrix_10_get_Item_1(struct PositiveDefiniteMatrix_7 *const self, float64_t row, float64_t column)
{
	float64_t double_ = 0.0;

	double_ = PositivDefinitMatrix_7_get_Item(self, (int32_t)row, (int32_t)column);
	return double_;
}

float64_t PositiDefinitMatrix_7_get_Item(struct PositiveDefiniteMatrix_7 *const self, float64_t row, float64_t column)
{
	float64_t double_ = 0.0;

	double_ = Matrix_10_get_Item_1(self, row, column);
	return double_;
}

static void CovaElliParam_set_MajorSemiAxis(struct CovarianceEllipseParameters *const self, float64_t value)
{
	(*self).MajorSemiAxis = value;
}

static void CovaElliParam_set_MinorSemiAxis(struct CovarianceEllipseParameters *const self, float64_t value)
{
	(*self).MinorSemiAxis = value;
}

static void CovariaEllipseParamet_set_Angle(struct CovarianceEllipseParameters *const self, float64_t value)
{
	(*self).Angle = value;
}

void CovariancEllipseParameters_ctor(struct CovarianceEllipseParameters *const self, float64_t majorSemiAxis, float64_t minorSemiAxis, float64_t angle)
{
	struct CovarianceEllipseParameters covarianceEllipseParameters = { 0 };

	*self = covarianceEllipseParameters;
	CovaElliParam_set_MajorSemiAxis(self, majorSemiAxis);
	CovaElliParam_set_MinorSemiAxis(self, minorSemiAxis);
	CovariaEllipseParamet_set_Angle(self, angle);
}

struct CovarianceEllipseParameters Covari_GetCovariaEllipseParamet(struct Gaussian_5 *distribution, float64_t mahalanobisDistance)
{
	struct CASpace *indices = NULL;
	struct CASpace *caSpace = NULL;
	float64_t num = 0.0;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix = NULL;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t num2 = 0.0;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_1 = NULL;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	float64_t double__5 = 0.0;
	float64_t num3 = 0.0;
	float64_t double__6 = 0.0;
	float64_t num4 = 0.0;
	float64_t double__7 = 0.0;
	float64_t num5 = 0.0;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_2 = NULL;
	float64_t double__8 = 0.0;
	float64_t double__9 = 0.0;
	float64_t double__10 = 0.0;
	float64_t num6 = 0.0;
	float64_t double__11 = 0.0;
	float64_t num7 = 0.0;
	float64_t double__12 = 0.0;
	float64_t double__13 = 0.0;
	float64_t num8 = 0.0;
	float64_t double__14 = 0.0;
	float64_t double__15 = 0.0;
	float64_t num9 = 0.0;
	float64_t num10 = 0.0;
	float64_t double__16 = 0.0;
	float64_t double__17 = 0.0;
	float64_t double__18 = 0.0;
	float64_t double__19 = 0.0;
	float64_t double__20 = 0.0;
	float64_t majorSemiAxis = 0.0;
	float64_t double__21 = 0.0;
	float64_t double__22 = 0.0;
	float64_t minorSemiAxis = 0.0;
	float64_t double__23 = 0.0;
	float64_t double__24 = 0.0;
	struct CovarianceEllipseParameters covarianceEllipseParameters = { 0 };

	if (!(distribution != NULL))
	{
		abort();
	}
	if (!(mahalanobisDistance >= 0.0))
	{
		abort();
	}
	caSpace = Space_6_GetIndices();
	(void)Assign_CASpace(&indices, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	positiveDefiniteMatrix = Gaussian_5_get_Covariance(distribution);
	double_ = CVSpace_get_X(&(*&indices)->base);
	double__1 = CVSpace_get_X(&(*&indices)->base);
	double__2 = PositiDefinitMatrix_7_get_Item(positiveDefiniteMatrix, double_, double__1);
	num = double__2;
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix, NULL);
	positiveDefiniteMatrix_1 = Gaussian_5_get_Covariance(distribution);
	double__3 = CVSpace_get_Y(&(*&indices)->base);
	double__4 = CVSpace_get_Y(&(*&indices)->base);
	double__5 = PositiDefinitMatrix_7_get_Item(positiveDefiniteMatrix_1, double__3, double__4);
	num2 = double__5;
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_1, NULL);
	double__6 = Math_Sqrt(num);
	num3 = double__6;
	double__7 = Math_Sqrt(num2);
	num4 = double__7;
	positiveDefiniteMatrix_2 = Gaussian_5_get_Covariance(distribution);
	double__8 = CVSpace_get_X(&(*&indices)->base);
	double__9 = CVSpace_get_Y(&(*&indices)->base);
	double__10 = PositiDefinitMatrix_7_get_Item(positiveDefiniteMatrix_2, double__8, double__9);
	num5 = double__10 / (num3 * num4);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_2, NULL);
	double__11 = Math_Atan2(((2.0 * num5) * num3) * num4, num - num2);
	num6 = double__11 / 2.0;
	double__12 = Math_Cos(num6);
	double__13 = Math_Cos(num6);
	num7 = double__12 * double__13;
	double__14 = Math_Sin(num6);
	double__15 = Math_Sin(num6);
	num8 = double__14 * double__15;
	num9 = 1.0 - (num5 * num5);
	double__16 = 2.0 * num5;
	double__17 = Math_Sin(num6);
	double__18 = double__16 * double__17;
	double__19 = Math_Cos(num6);
	double__20 = double__18 * double__19;
	num10 = double__20 / (num3 * num4);
	double__21 = mahalanobisDistance;
	double__22 = Math_Sqrt(num9 / (((num7 / num) - num10) + (num8 / num2)));
	majorSemiAxis = double__21 * double__22;
	double__23 = mahalanobisDistance;
	double__24 = Math_Sqrt(num9 / (((num8 / num) + num10) + (num7 / num2)));
	minorSemiAxis = double__23 * double__24;
	CovariancEllipseParameters_ctor(&covarianceEllipseParameters, majorSemiAxis, minorSemiAxis, num6);
	RemRef_CASpace(indices);
	return covarianceEllipseParameters;
}

float64_t CovaElliParam_get_MajorSemiAxis(struct CovarianceEllipseParameters *const self)
{
	return (*self).MajorSemiAxis;
}

float64_t Track_get_EncloCirclDeletThresh(struct Tracking *const self)
{
	return self->EnclosinCircleDeletionThreshold;
}

static bool_t Tracking_KeepTrack(struct Tracking *const self, struct TrackWithMeasurements *trackHypothesis)
{
	struct Existence *existence = NULL;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	bool_t result = false;
	struct Gaussian_5 *gaussian = NULL;
	struct CovarianceEllipseParameters covarianceEllipseParameters = { 0 };
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;

	existence = GaussianTrack_get_Existence(&trackHypothesis->base);
	double_ = Existenc_get_ExistenceProbabili(existence);
	double__1 = Track_get_ExisteProbabForDeleti(self);
	if (!(double_ > double__1))
	{
		(void)Assign_Existence(&existence, NULL);
		return false;
	}
	else
	{
		(void)Assign_Existence(&existence, NULL);
	}
	gaussian = GaussianTrack_get_State(&trackHypothesis->base);
	covarianceEllipseParameters = Covari_GetCovariaEllipseParamet(gaussian, 2.797);
	double__2 = CovaElliParam_get_MajorSemiAxis(&covarianceEllipseParameters);
	double__3 = 2.0 * double__2;
	double__4 = Track_get_EncloCirclDeletThresh(self);
	result = double__3 < double__4;
	(void)Assign_Gaussian_5(&gaussian, NULL);
	return result;
}

struct StaticList_6 *Associat_GetNotAssociateObjects(struct Association *const self)
{
	struct StaticList_6 *list = NULL;
	struct StaticListFactory_5 *staticListFactory = NULL;
	int32_t int32 = ((int32_t)0);
	struct StaticList_6 *staticList = NULL;
	struct StaticListEnumerator *enumerator = NULL;
	struct StaticListEnumerator *staticListEnumerator = NULL;
	int32_t current = ((int32_t)0);
	bool_t boolean = false;
	struct StaticList_6 *result = NULL;

	staticListFactory = StIPDATrCoFacPro_get_Obj2LisFac(self->_factoryProvider);
	int32 = StaticList_get_Count(self->_notAssociatedObjects);
	staticList = StaticListFactor_5_CreateInstan(staticListFactory, int32);
	(void)Assign_StaticList_6(&list, staticList);
	(void)Assign_StaticListFactory_5(&staticListFactory, NULL);
	(void)Assign_StaticList_6(&staticList, NULL);
	staticListEnumerator = StaticList_GetEnumerator(self->_notAssociatedObjects);
	(void)Assign_StaticListEnumerator(&enumerator, staticListEnumerator);
	(void)Assign_StaticListEnumerator(&staticListEnumerator, NULL);
	boolean = StaticListEnumerator_MoveNext(enumerator);
	while (boolean)
	{
		int32_t int32_1 = ((int32_t)0);
		struct StaticList_6 *staticList_1 = NULL;
		struct StaticList_6 *staticList_2 = NULL;
		struct MobilEyeSpace *mobilEyeSpace = NULL;

		int32_1 = StaticListEnumerato_get_Current(enumerator);
		current = int32_1;
		(void)Assign_StaticList_6(&staticList_1, list);
		staticList_2 = Association_get_Objects2(self);
		mobilEyeSpace = StaticList_6_get_Item(staticList_2, current);
		StaticList_6_Add(staticList_1, mobilEyeSpace);
		(void)Assign_StaticList_6(&staticList_1, NULL);
		(void)Assign_StaticList_6(&staticList_2, NULL);
		(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
		boolean = StaticListEnumerator_MoveNext(enumerator);
	}
	if (!!(enumerator != NULL))
	{
		StaticListEnumerator_Dispose(enumerator);
	}
	(void)Assign_StaticList_6(&result, list);
	RemRef_StaticList_6(list);
	RemRef_StaticListEnumerator(enumerator);
	return result;
}

float64_t Obstacle_get_PositionX(struct Obstacle *const self)
{
	return self->PositionX;
}

static void RemRef_InverMobilEyeMeasurModel(struct InverseMobilEyeMeasurementModel *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_InverseMobilEyeMeasureModel.CurrentCount--;
		Res_InverseMobilEyeMeasureModel.Next[Res_InverseMobilEyeMeasureModel.CurrentCount] = self;
		Del_InverseMobilEyeMeasureModel(self);
	}
}

struct InverseMobilEyeMeasurementModel *New_InverseMobilEyeMeasureModel(void)
{
	static struct InverseMobilEyeMeasurementModel const Defau_InversMobilEyeMeasurModel = { 1 };
	struct InverseMobilEyeMeasurementModel *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_InverseMobilEyeMeasureModel.CurrentCount == RC_InverseMobilEyeMeasuremModel)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_InverseMobilEyeMeasureModel.Next[Res_InverseMobilEyeMeasureModel.CurrentCount];
	Res_InverseMobilEyeMeasureModel.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_InverseMobilEyeMeasureModel.MaximumCount = (Res_InverseMobilEyeMeasureModel.CurrentCount > Res_InverseMobilEyeMeasureModel.MaximumCount) ? Res_InverseMobilEyeMeasureModel.CurrentCount : Res_InverseMobilEyeMeasureModel.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Defau_InversMobilEyeMeasurModel;
	return instance;
}

struct InverseMobilEyeMeasurementModel *Assig_InversMobilEyeMeasurModel(struct InverseMobilEyeMeasurementModel **const left, struct InverseMobilEyeMeasurementModel *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_InverMobilEyeMeasurModel(*left);
	*left = right;
	return right;
}

static void InveCartMeasMode_set_SensoParam(struct InverseCartesianMeasuremenModel *const self, struct MobilEyeParameters *value)
{
	(void)Assign_MobilEyeParameters(&self->SensorParameters, value);
}

struct MobilEyeParameters *InveCartMeasMode_get_SensoParam(struct InverseCartesianMeasuremenModel *const self)
{
	struct MobilEyeParameters *result = NULL;

	(void)Assign_MobilEyeParameters(&result, self->SensorParameters);
	return result;
}

void InverseCartesiMeasureModel_ctor(struct InverseCartesianMeasuremenModel *const self, struct MobilEyeParameters *sensorParameters)
{
	struct MobilEyeParameters *mobilEyeParameters = NULL;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	struct MobilEyeParameters *mobilEyeParameters_1 = NULL;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;

	Object_ctor(&self->base);
	InveCartMeasMode_set_SensoParam(self, sensorParameters);
	mobilEyeParameters = InveCartMeasMode_get_SensoParam(self);
	double_ = MobilEyeParameter_get_RotationZ(mobilEyeParameters);
	double__1 = Math_Cos(double_);
	self->CosRotZ = double__1;
	(void)Assign_MobilEyeParameters(&mobilEyeParameters, NULL);
	mobilEyeParameters_1 = InveCartMeasMode_get_SensoParam(self);
	double__2 = MobilEyeParameter_get_RotationZ(mobilEyeParameters_1);
	double__3 = Math_Sin(double__2);
	self->SinRotZ = double__3;
	(void)Assign_MobilEyeParameters(&mobilEyeParameters_1, NULL);
}

void InveMobiEyeMeasMode_set_EgoVelo(struct InverseMobilEyeMeasurementModel *const self, float64_t value)
{
	self->EgoVelocity = value;
}

void InvMobEyeMeaMode_set_EgoYawRate(struct InverseMobilEyeMeasurementModel *const self, float64_t value)
{
	self->EgoYawRate = value;
}

void InversMobilEyeMeasureModel_ctor(struct InverseMobilEyeMeasurementModel *const self, struct MobilEyeParameters *sensorParameters, float64_t egoVelocity, float64_t egoYawRate)
{
	InverseCartesiMeasureModel_ctor(&self->base, sensorParameters);
	InveMobiEyeMeasMode_set_EgoVelo(self, egoVelocity);
	InvMobEyeMeaMode_set_EgoYawRate(self, egoYawRate);
}

void InversCartesMeasurModel_Transfo(struct InverseCartesianMeasuremenModel *const self, struct MobilEyeSpace *measurement, struct CASpace **state)
{
	float64_t x = 0.0;
	float64_t double_ = 0.0;
	float64_t y = 0.0;
	float64_t double__1 = 0.0;
	struct CASpace **caSpace = NULL;
	float64_t double__2 = 0.0;
	struct MobilEyeParameters *mobilEyeParameters = NULL;
	float64_t double__3 = 0.0;
	struct CASpace **caSpace_1 = NULL;
	float64_t double__4 = 0.0;
	struct MobilEyeParameters *mobilEyeParameters_1 = NULL;
	float64_t double__5 = 0.0;

	double_ = MobilEyeSpace_get_X(measurement);
	x = double_;
	double__1 = MobilEyeSpace_get_Y(measurement);
	y = double__1;
	caSpace = state;
	double__2 = (x * self->CosRotZ) - (y * self->SinRotZ);
	mobilEyeParameters = InveCartMeasMode_get_SensoParam(self);
	double__3 = MobilEyeParameter_get_PositionX(mobilEyeParameters);
	CVSpace_set_X(&(*caSpace)->base, double__2 + double__3);
	(void)Assign_MobilEyeParameters(&mobilEyeParameters, NULL);
	caSpace_1 = state;
	double__4 = (x * self->SinRotZ) + (y * self->CosRotZ);
	mobilEyeParameters_1 = InveCartMeasMode_get_SensoParam(self);
	double__5 = MobilEyeParameter_get_PositionY(mobilEyeParameters_1);
	CVSpace_set_Y(&(*caSpace_1)->base, double__4 + double__5);
	(void)Assign_MobilEyeParameters(&mobilEyeParameters_1, NULL);
}

float64_t InveMobiEyeMeasMode_get_EgoVelo(struct InverseMobilEyeMeasurementModel *const self)
{
	return self->EgoVelocity;
}

float64_t InvMobEyeMeaMode_get_EgoYawRate(struct InverseMobilEyeMeasurementModel *const self)
{
	return self->EgoYawRate;
}

void InverMobilEyeMeasurModel_Transf(struct InverseMobilEyeMeasurementModel *const self, struct MobilEyeSpace *measurement, struct CASpace **state)
{
	float64_t r = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	float64_t double__5 = 0.0;
	float64_t vx = 0.0;
	float64_t double__6 = 0.0;
	float64_t double__7 = 0.0;
	float64_t double__8 = 0.0;
	float64_t double__9 = 0.0;
	float64_t double__10 = 0.0;
	float64_t vy = 0.0;
	float64_t double__11 = 0.0;
	float64_t double__12 = 0.0;
	float64_t double__13 = 0.0;
	float64_t double__14 = 0.0;
	float64_t double__15 = 0.0;
	float64_t double__16 = 0.0;
	struct CASpace **caSpace = NULL;
	float64_t double__17 = 0.0;
	struct CASpace **caSpace_1 = NULL;
	float64_t double__18 = 0.0;

	InversCartesMeasurModel_Transfo(&self->base, measurement, state);
	double_ = CVSpace_get_X(&(*state)->base);
	double__1 = CVSpace_get_X(&(*state)->base);
	double__2 = double_ * double__1;
	double__3 = CVSpace_get_Y(&(*state)->base);
	double__4 = CVSpace_get_Y(&(*state)->base);
	double__5 = Math_Sqrt(double__2 + (double__3 * double__4));
	r = double__5;
	double__6 = MobilEyeSpace_get_Vx(measurement);
	double__7 = double__6 * (&self->base)->CosRotZ;
	double__8 = MobilEyeSpace_get_Vy(measurement);
	double__9 = double__7 - (double__8 * (&self->base)->SinRotZ);
	double__10 = InveMobiEyeMeasMode_get_EgoVelo(self);
	vx = double__9 + double__10;
	double__11 = MobilEyeSpace_get_Vx(measurement);
	double__12 = double__11 * (&self->base)->SinRotZ;
	double__13 = MobilEyeSpace_get_Vy(measurement);
	double__14 = double__12 + (double__13 * (&self->base)->CosRotZ);
	double__15 = r;
	double__16 = InvMobEyeMeaMode_get_EgoYawRate(self);
	vy = double__14 + (double__15 * double__16);
	caSpace = state;
	double__17 = Math_Sqrt((vx * vx) + (vy * vy));
	CVSpace_set_V(&(*caSpace)->base, double__17);
	caSpace_1 = state;
	double__18 = Math_Atan2(vy, vx);
	CVSpace_set_G(&(*caSpace_1)->base, double__18);
	CASpace_set_A(*state, 0.0);
}

static void MatrixData_17_SetValueFast(struct MatrixData_17 *const self, float64_t value, int32_t row, int32_t column)
{
	struct float64_t_1D_20 *array = NULL;

	array = MatrixData_17_get_DataReference(self);
	array->Elements[(column * self->Rows) + row] = value;
	(void)Assign_float64_t_1D_20(&array, NULL);
}

void MatrixData_17_set_Item(struct MatrixData_17 *const self, int32_t row, int32_t column, float64_t value)
{
	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	MatrixData_17_SetValueFast(self, value, row, column);
}

static void PositDefinMatrix_7_MatrixChange(struct PositiveDefiniteMatrix_7 *const self)
{
	SquareMatrix_7_MatrixChanged(&self->base);
	(void)Assign_MatrixData(&self->CachedCholeskyDecomposition, NULL);
	(void)Assign_MatrixData(&self->CachedInverse, NULL);
}

void PositivDefinitMatrix_7_set_Item(struct PositiveDefiniteMatrix_7 *const self, int32_t row, int32_t column, float64_t value)
{
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;

	if (!((row >= ((int32_t)0)) && (row < (&self->base.base)->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < (&self->base.base)->Columns)))
	{
		abort();
	}
	matrixData = Matrix_10_get_MatrixData(&self->base.base);
	MatrixData_2_set_Item(matrixData, row, column, value);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	matrixData_1 = Matrix_10_get_MatrixData(&self->base.base);
	MatrixData_2_set_Item(matrixData_1, column, row, value);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	PositDefinMatrix_7_MatrixChange(self);
}

uint32_t IDGenerator_GetNextID(void)
{
	IDGenerator__id = (int32_t)IDGenerator__id + (int32_t)((uint32_t)1u);
	return IDGenerator__id;
}

static struct TrackWithMeasurements *Trackin_CreateTrackFromMobilEye(struct Tracking *const self, struct MobilEyeSpace *measurement, float64_t egoVelocity, float64_t egoYawRate, struct MobilEyeParameters *parameters, struct Obstacle *obstacle)
{
	struct TrackWithMeasurements *result = NULL;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	struct InverseMobilEyeMeasurementModel *inverseMeasurementModel = NULL;
	struct InverseMobilEyeMeasurementModel *inverseMobilEyeMeasurementModel = NULL;
	struct CASpace *expectation = NULL;
	struct CASpace *caSpace = NULL;
	int32_t rows = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	float64_t sinRotZ = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t cosRotZ = 0.0;
	float64_t double__4 = 0.0;
	float64_t double__5 = 0.0;
	struct MatrixData_17 *transitionMatrix = NULL;
	struct MatrixData_17 *matrixData = NULL;
	float64_t x = 0.0;
	float64_t double__6 = 0.0;
	float64_t y = 0.0;
	float64_t double__7 = 0.0;
	float64_t stateX = 0.0;
	float64_t double__8 = 0.0;
	float64_t double__9 = 0.0;
	float64_t stateY = 0.0;
	float64_t double__10 = 0.0;
	float64_t double__11 = 0.0;
	float64_t r = 0.0;
	float64_t double__12 = 0.0;
	float64_t vx = 0.0;
	float64_t double__13 = 0.0;
	float64_t double__14 = 0.0;
	float64_t double__15 = 0.0;
	float64_t double__16 = 0.0;
	float64_t vy = 0.0;
	float64_t double__17 = 0.0;
	float64_t double__18 = 0.0;
	float64_t double__19 = 0.0;
	float64_t double__20 = 0.0;
	float64_t vSquared = 0.0;
	float64_t v = 0.0;
	float64_t double__21 = 0.0;
	int32_t siX = ((int32_t)0);
	float64_t double__22 = 0.0;
	int32_t siY = ((int32_t)0);
	float64_t double__23 = 0.0;
	int32_t siV = ((int32_t)0);
	float64_t double__24 = 0.0;
	int32_t siA = ((int32_t)0);
	float64_t double__25 = 0.0;
	int32_t siG = ((int32_t)0);
	float64_t double__26 = 0.0;
	int32_t meiX = ((int32_t)0);
	float64_t double__27 = 0.0;
	int32_t meiY = ((int32_t)0);
	float64_t double__28 = 0.0;
	int32_t meiVx = ((int32_t)0);
	float64_t double__29 = 0.0;
	int32_t meiVy = ((int32_t)0);
	float64_t double__30 = 0.0;
	float64_t p1 = 0.0;
	struct MatrixData_15 *measurementNoise = NULL;
	struct float64_t_1D_4 *array = NULL;
	struct PositiveDefiniteMatrix_3 *positiveDefiniteMatrix = NULL;
	struct MatrixData_15 *matrixData_1 = NULL;
	float64_t sigmaX = 0.0;
	float64_t double__31 = 0.0;
	float64_t double__32 = 0.0;
	float64_t double__33 = 0.0;
	float64_t double__34 = 0.0;
	struct MatrixData_2 *covariance = NULL;
	struct MatrixData_2 *matrixData_2 = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_1 = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_2 = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_3 = NULL;
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);
	float64_t double__35 = 0.0;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_4 = NULL;
	int32_t int32_2 = ((int32_t)0);
	int32_t int32_3 = ((int32_t)0);
	float64_t double__36 = 0.0;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_5 = NULL;
	int32_t int32_4 = ((int32_t)0);
	int32_t int32_5 = ((int32_t)0);
	float64_t double__37 = 0.0;
	struct Gaussian_5 *state = NULL;
	struct Gaussian_5 *gaussian = NULL;
	struct Gaussian_5 *gaussian_1 = NULL;
	struct Existence *existence = NULL;
	uint32_t uInt32 = ((uint32_t)0u);
	uint64_t uInt64 = ((uint64_t)0u);
	struct TrackWithMeasurements *trackWithMeasurements = NULL;

	double_ = Obstacle_get_PositionX(obstacle);
	double__1 = MobilEyeParame_get_MaximumRange(parameters);
	if (!(double_ <= double__1))
	{
		(void)Assign_TrackWithMeasurements(&result, NULL);
		RemRef_InverMobilEyeMeasurModel(inverseMeasurementModel);
		RemRef_CASpace(expectation);
		RemRef_MatrixData_17(transitionMatrix);
		RemRef_MatrixData_15(measurementNoise);
		RemRef_MatrixData_2(covariance);
		RemRef_PositiveDefiniteMatrix_7(positiveDefiniteMatrix_1);
		RemRef_Gaussian_5(state);
		return result;
	}
	inverseMobilEyeMeasurementModel = New_InverseMobilEyeMeasureModel();
	InversMobilEyeMeasureModel_ctor(inverseMobilEyeMeasurementModel, parameters, egoVelocity, egoYawRate);
	(void)Assig_InversMobilEyeMeasurModel(&inverseMeasurementModel, inverseMobilEyeMeasurementModel);
	(void)Assig_InversMobilEyeMeasurModel(&inverseMobilEyeMeasurementModel, NULL);
	caSpace = New_CASpace();
	CASpace_ctor(caSpace);
	(void)Assign_CASpace(&expectation, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	InverMobilEyeMeasurModel_Transf(inverseMeasurementModel, measurement, &expectation);
	rows = (&Tracking_1_StateIndices->base.base.base)->Dimensions;
	columns = (&measurement->base)->Dimensions;
	double__2 = MobilEyeParameter_get_RotationZ(parameters);
	double__3 = Math_Sin(double__2);
	sinRotZ = double__3;
	double__4 = MobilEyeParameter_get_RotationZ(parameters);
	double__5 = Math_Cos(double__4);
	cosRotZ = double__5;
	matrixData = New_MatrixData_17();
	MatrixData_17_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData_17(&transitionMatrix, matrixData);
	(void)Assign_MatrixData_17(&matrixData, NULL);
	double__6 = MobilEyeSpace_get_X(measurement);
	x = double__6;
	double__7 = MobilEyeSpace_get_Y(measurement);
	y = double__7;
	double__8 = (x * cosRotZ) - (y * sinRotZ);
	double__9 = MobilEyeParameter_get_PositionX(parameters);
	stateX = double__8 + double__9;
	double__10 = (x * sinRotZ) + (y * cosRotZ);
	double__11 = MobilEyeParameter_get_PositionY(parameters);
	stateY = double__10 + double__11;
	double__12 = Math_Sqrt((stateX * stateX) + (stateY * stateY));
	r = double__12;
	double__13 = MobilEyeSpace_get_Vx(measurement);
	double__14 = double__13 * cosRotZ;
	double__15 = MobilEyeSpace_get_Vy(measurement);
	double__16 = double__14 - (double__15 * sinRotZ);
	vx = double__16 + egoVelocity;
	double__17 = MobilEyeSpace_get_Vx(measurement);
	double__18 = double__17 * sinRotZ;
	double__19 = MobilEyeSpace_get_Vy(measurement);
	double__20 = double__18 + (double__19 * cosRotZ);
	vy = double__20 + (r * egoYawRate);
	vSquared = (vx * vx) + (vy * vy);
	double__21 = Math_Sqrt(vSquared);
	v = double__21;
	double__22 = CVSpace_get_X(&Tracking_1_StateIndices->base);
	siX = (int32_t)double__22;
	double__23 = CVSpace_get_Y(&Tracking_1_StateIndices->base);
	siY = (int32_t)double__23;
	double__24 = CVSpace_get_V(&Tracking_1_StateIndices->base);
	siV = (int32_t)double__24;
	double__25 = CASpace_get_A(Tracking_1_StateIndices);
	siA = (int32_t)double__25;
	double__26 = CVSpace_get_G(&Tracking_1_StateIndices->base);
	siG = (int32_t)double__26;
	double__27 = MobilEyeSpace_get_X(Tracking_1_MobilEyeIndices);
	meiX = (int32_t)double__27;
	double__28 = MobilEyeSpace_get_Y(Tracking_1_MobilEyeIndices);
	meiY = (int32_t)double__28;
	double__29 = MobilEyeSpace_get_Vx(Tracking_1_MobilEyeIndices);
	meiVx = (int32_t)double__29;
	double__30 = MobilEyeSpace_get_Vy(Tracking_1_MobilEyeIndices);
	meiVy = (int32_t)double__30;
	MatrixData_17_set_Item(transitionMatrix, siX, meiX, cosRotZ);
	MatrixData_17_set_Item(transitionMatrix, siX, meiY, -sinRotZ);
	MatrixData_17_set_Item(transitionMatrix, siY, meiX, sinRotZ);
	MatrixData_17_set_Item(transitionMatrix, siY, meiY, cosRotZ);
	if (!(v <= 1E-07))
	{
		MatrixData_17_set_Item(transitionMatrix, siV, meiVx, ((vx * cosRotZ) + (vy * sinRotZ)) / v);
		MatrixData_17_set_Item(transitionMatrix, siV, meiVy, ((-vx * sinRotZ) + (vy * cosRotZ)) / v);
		MatrixData_17_set_Item(transitionMatrix, siV, meiX, (((vy / v) * egoYawRate) * ((stateX * cosRotZ) + (stateY * sinRotZ))) / r);
		MatrixData_17_set_Item(transitionMatrix, siV, meiY, (((vy / v) * egoYawRate) * ((-x * sinRotZ) + (y * cosRotZ))) / r);
		p1 = (egoYawRate * ((egoVelocity + (vx * cosRotZ)) - (vy * sinRotZ))) / (r * vSquared);
		MatrixData_17_set_Item(transitionMatrix, siG, meiX, p1 * x);
		MatrixData_17_set_Item(transitionMatrix, siG, meiY, p1 * y);
		MatrixData_17_set_Item(transitionMatrix, siG, meiVx, (((egoVelocity * sinRotZ) - vy) - ((egoYawRate * r) * cosRotZ)) / vSquared);
		MatrixData_17_set_Item(transitionMatrix, siG, meiVy, (((egoVelocity * cosRotZ) + vx) + ((egoYawRate * r) * sinRotZ)) / vSquared);
	}
	array = MobiEyePara_get_NoiseMatriDiago(parameters);
	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_3();
	PositiveDefiniteMatrix_3_ctor(positiveDefiniteMatrix, array);
	matrixData_1 = Matrix_3_get_MatrixData(&positiveDefiniteMatrix->base.base);
	(void)Assign_MatrixData_15(&measurementNoise, matrixData_1);
	(void)Assign_float64_t_1D_4(&array, NULL);
	(void)Assign_PositiveDefiniteMatrix_3(&positiveDefiniteMatrix, NULL);
	(void)Assign_MatrixData_15(&matrixData_1, NULL);
	double__31 = MobilEyeSpace_get_X(measurement);
	double__32 = double__31 * 0.1;
	double__33 = MobilEyeParameters_get_SigmaX(parameters);
	double__34 = Math_Max_1(double__32, double__33);
	sigmaX = double__34;
	MatrixData_15_set_Item(measurementNoise, ((int32_t)0), ((int32_t)0), sigmaX * sigmaX);
	matrixData_2 = MatrixMath_Multiply_35(false, false, true, transitionMatrix, measurementNoise, transitionMatrix);
	(void)Assign_MatrixData_2(&covariance, matrixData_2);
	(void)Assign_MatrixData_2(&matrixData_2, NULL);
	positiveDefiniteMatrix_2 = PositivDefiniteMatrix_11_Create(covariance);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_1, positiveDefiniteMatrix_2);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_2, NULL);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_3, positiveDefiniteMatrix_1);
	int32 = siG;
	int32_1 = siG;
	double__35 = PositivDefinitMatrix_7_get_Item(positiveDefiniteMatrix_1, siG, siG);
	PositivDefinitMatrix_7_set_Item(positiveDefiniteMatrix_3, int32, int32_1, double__35 + 0.07);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_3, NULL);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_4, positiveDefiniteMatrix_1);
	int32_2 = siV;
	int32_3 = siV;
	double__36 = PositivDefinitMatrix_7_get_Item(positiveDefiniteMatrix_1, siV, siV);
	PositivDefinitMatrix_7_set_Item(positiveDefiniteMatrix_4, int32_2, int32_3, double__36 + 2.0);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_4, NULL);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_5, positiveDefiniteMatrix_1);
	int32_4 = siA;
	int32_5 = siA;
	double__37 = PositivDefinitMatrix_7_get_Item(positiveDefiniteMatrix_1, siA, siA);
	PositivDefinitMatrix_7_set_Item(positiveDefiniteMatrix_5, int32_4, int32_5, double__37 + 5.0);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_5, NULL);
	gaussian = Gaussian_9_Create(expectation, positiveDefiniteMatrix_1);
	(void)Assign_Gaussian_5(&state, gaussian);
	(void)Assign_Gaussian_5(&gaussian, NULL);
	(void)Assign_Gaussian_5(&gaussian_1, state);
	existence = New_Existence();
	Existence_ctor_1(existence, 0.6);
	uInt32 = IDGenerator_GetNextID();
	uInt64 = (uint64_t)uInt32;
	trackWithMeasurements = New_TrackWithMeasurements();
	TrackWithMeasurements_ctor(trackWithMeasurements, gaussian_1, existence, uInt64, obstacle, NULL);
	(void)Assign_TrackWithMeasurements(&result, trackWithMeasurements);
	(void)Assign_Gaussian_5(&gaussian_1, NULL);
	(void)Assign_Existence(&existence, NULL);
	(void)Assign_TrackWithMeasurements(&trackWithMeasurements, NULL);
	RemRef_InverMobilEyeMeasurModel(inverseMeasurementModel);
	RemRef_CASpace(expectation);
	RemRef_MatrixData_17(transitionMatrix);
	RemRef_MatrixData_15(measurementNoise);
	RemRef_MatrixData_2(covariance);
	RemRef_PositiveDefiniteMatrix_7(positiveDefiniteMatrix_1);
	RemRef_Gaussian_5(state);
	return result;
}

static void Del_MatrixData_2_1D_1(struct MatrixData_2_1D_1 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)1);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_MatrixData_2(self->Elements[i]);
	}
}

static void RemRef_MatrixData_2_1D_1(struct MatrixData_2_1D_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_2_1D_1.CurrentCount--;
		Res_MatrixData_2_1D_1.Next[Res_MatrixData_2_1D_1.CurrentCount] = self;
		Del_MatrixData_2_1D_1(self);
	}
}

struct MatrixData_2_1D_1 *New_MatrixData_2_1D_1(void)
{
	static struct MatrixData_2_1D_1 const Default_MatrixData_2_1D_1 = { 1 };
	struct MatrixData_2_1D_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_2_1D_1.CurrentCount == RC_MatrixData_2_1D_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_2_1D_1.Next[Res_MatrixData_2_1D_1.CurrentCount];
	Res_MatrixData_2_1D_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_2_1D_1.MaximumCount = (Res_MatrixData_2_1D_1.CurrentCount > Res_MatrixData_2_1D_1.MaximumCount) ? Res_MatrixData_2_1D_1.CurrentCount : Res_MatrixData_2_1D_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_2_1D_1;
	return instance;
}

struct MatrixData_2_1D_1 *Assign_MatrixData_2_1D_1(struct MatrixData_2_1D_1 **const left, struct MatrixData_2_1D_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_2_1D_1(*left);
	*left = right;
	return right;
}

static void Del_MatrixData_1D_0(struct MatrixData_1D_0 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_MatrixData_1D_0(struct MatrixData_1D_0 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_1D_0.CurrentCount--;
		Res_MatrixData_1D_0.Next[Res_MatrixData_1D_0.CurrentCount] = self;
		Del_MatrixData_1D_0(self);
	}
}

struct MatrixData_1D_0 *New_MatrixData_1D_0(void)
{
	static struct MatrixData_1D_0 const Default_MatrixData_1D_0 = { 1 };
	struct MatrixData_1D_0 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_1D_0.CurrentCount == RC_MatrixData_1D_0)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_1D_0.Next[Res_MatrixData_1D_0.CurrentCount];
	Res_MatrixData_1D_0.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_1D_0.MaximumCount = (Res_MatrixData_1D_0.CurrentCount > Res_MatrixData_1D_0.MaximumCount) ? Res_MatrixData_1D_0.CurrentCount : Res_MatrixData_1D_0.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_1D_0;
	return instance;
}

struct MatrixData_1D_0 *Assign_MatrixData_1D_0(struct MatrixData_1D_0 **const left, struct MatrixData_1D_0 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_1D_0(*left);
	*left = right;
	return right;
}

struct MatrixData_2 *MatrixMath_Multiply_37(struct MatrixData_2 *first, struct MatrixData_2 *second, struct MatrixData_2_1D_1 *matrices)
{
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	int32_t i = ((int32_t)0);
	struct MatrixData_2 *result = NULL;

	if (!(first != NULL))
	{
		abort();
	}
	if (!(second != NULL))
	{
		abort();
	}
	if (!(matrices != NULL))
	{
		abort();
	}
	matrixData_1 = MatrixMath_Multiply_16(false, false, first, second);
	(void)Assign_MatrixData_2(&matrixData, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)1))
	{
		struct MatrixData_2 *matrixData_2 = NULL;

		matrixData_2 = MatrixMath_Multiply_16(false, false, matrixData, matrices->Elements[i]);
		(void)Assign_MatrixData_2(&matrixData, matrixData_2);
		(void)Assign_MatrixData_2(&matrixData_2, NULL);
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_2(&result, matrixData);
	RemRef_MatrixData_2(matrixData);
	return result;
}

void Matrix_10_set_MatrixData_1(struct PositiveDefiniteMatrix_7 *const self, struct MatrixData_2 *value)
{
	struct MatrixData_2 *matrix = NULL;

	if (!(value != NULL))
	{
		abort();
	}
	(void)Assign_MatrixData_2(&matrix, (&self->base.base)->_matrix);
	(void)Assign_MatrixData_2(&(&self->base.base)->_matrix, value);
	PositDefiniMatrix_7_CheckMatrix(self);
	PositDefinMatrix_7_MatrixChange(self);
	RemRef_MatrixData_2(matrix);
}

void Tracking_NormalizeVelocity(struct Tracking *const self, struct StaticList_27 **tracks)
{
	struct StaticListEnumerator_15 *CS_5_0000 = NULL;
	struct StaticListEnumerator_15 *staticListEnumerator = NULL;
	struct TrackWithMeasurements *track = NULL;
	struct CASpace *expr_3D = NULL;
	struct CASpace *expr_5D = NULL;
	struct CASpace *expr_7D = NULL;
	bool_t boolean = false;

	staticListEnumerator = StaticList_27_GetEnumerator(*tracks);
	(void)Assign_StaticListEnumerator_15(&CS_5_0000, staticListEnumerator);
	(void)Assign_StaticListEnumerator_15(&staticListEnumerator, NULL);
	boolean = StaticListEnumerato_15_MoveNext(CS_5_0000);
	while (boolean)
	{
		struct TrackWithMeasurements *trackWithMeasurements = NULL;
		struct Gaussian_5 *gaussian = NULL;
		struct CASpace *caSpace = NULL;
		float64_t double_ = 0.0;

		trackWithMeasurements = StaticListEnumer_15_get_Current(CS_5_0000);
		(void)Assign_TrackWithMeasurements(&track, trackWithMeasurements);
		(void)Assign_TrackWithMeasurements(&trackWithMeasurements, NULL);
		gaussian = GaussianTrack_get_State(&track->base);
		caSpace = Gaussian_5_get_Expectation(gaussian);
		double_ = CVSpace_get_V(&caSpace->base);
		if (!(double_ >= 0.0))
		{
			struct Gaussian_5 *gaussian_1 = NULL;
			struct CASpace *caSpace_1 = NULL;
			struct CASpace *caSpace_2 = NULL;
			float64_t double__1 = 0.0;
			struct Gaussian_5 *gaussian_2 = NULL;
			struct CASpace *caSpace_3 = NULL;
			struct CASpace *caSpace_4 = NULL;
			float64_t double__2 = 0.0;
			struct Gaussian_5 *gaussian_3 = NULL;
			struct CASpace *caSpace_5 = NULL;
			struct CASpace *caSpace_6 = NULL;
			float64_t double__3 = 0.0;
			struct Gaussian_5 *gaussian_4 = NULL;
			struct CASpace *caSpace_7 = NULL;
			struct Gaussian_5 *gaussian_5 = NULL;
			struct CASpace *caSpace_8 = NULL;
			float64_t double__4 = 0.0;
			float64_t double__5 = 0.0;
			struct Gaussian_5 *gaussian_6 = NULL;
			struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix = NULL;
			struct MatrixData_2 *matrixData = NULL;
			struct Gaussian_5 *gaussian_7 = NULL;
			struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_1 = NULL;
			struct MatrixData_2 *matrixData_1 = NULL;
			struct MatrixData_2_1D_1 *array = NULL;
			struct MatrixData_2 *matrixData_2 = NULL;

			(void)Assign_Gaussian_5(&gaussian, NULL);
			(void)Assign_CASpace(&caSpace, NULL);
			gaussian_1 = GaussianTrack_get_State(&track->base);
			caSpace_1 = Gaussian_5_get_Expectation(gaussian_1);
			(void)Assign_CASpace(&expr_3D, caSpace_1);
			(void)Assign_Gaussian_5(&gaussian_1, NULL);
			(void)Assign_CASpace(&caSpace_1, NULL);
			(void)Assign_CASpace(&caSpace_2, expr_3D);
			double__1 = CVSpace_get_V(&expr_3D->base);
			CVSpace_set_V(&caSpace_2->base, double__1 * -1.0);
			(void)Assign_CASpace(&caSpace_2, NULL);
			gaussian_2 = GaussianTrack_get_State(&track->base);
			caSpace_3 = Gaussian_5_get_Expectation(gaussian_2);
			(void)Assign_CASpace(&expr_5D, caSpace_3);
			(void)Assign_Gaussian_5(&gaussian_2, NULL);
			(void)Assign_CASpace(&caSpace_3, NULL);
			(void)Assign_CASpace(&caSpace_4, expr_5D);
			double__2 = CASpace_get_A(expr_5D);
			CASpace_set_A(caSpace_4, double__2 * -1.0);
			(void)Assign_CASpace(&caSpace_4, NULL);
			gaussian_3 = GaussianTrack_get_State(&track->base);
			caSpace_5 = Gaussian_5_get_Expectation(gaussian_3);
			(void)Assign_CASpace(&expr_7D, caSpace_5);
			(void)Assign_Gaussian_5(&gaussian_3, NULL);
			(void)Assign_CASpace(&caSpace_5, NULL);
			(void)Assign_CASpace(&caSpace_6, expr_7D);
			double__3 = CVSpace_get_G(&expr_7D->base);
			CVSpace_set_G(&caSpace_6->base, double__3 + 3.1415926535897931);
			(void)Assign_CASpace(&caSpace_6, NULL);
			gaussian_4 = GaussianTrack_get_State(&track->base);
			caSpace_7 = Gaussian_5_get_Expectation(gaussian_4);
			gaussian_5 = GaussianTrack_get_State(&track->base);
			caSpace_8 = Gaussian_5_get_Expectation(gaussian_5);
			double__4 = CVSpace_get_G(&caSpace_8->base);
			double__5 = Math_1_Modulus(double__4 + 3.1415926535897931, 6.2831853071795862);
			CVSpace_set_G(&caSpace_7->base, double__5 - 3.1415926535897931);
			(void)Assign_Gaussian_5(&gaussian_4, NULL);
			(void)Assign_CASpace(&caSpace_7, NULL);
			(void)Assign_Gaussian_5(&gaussian_5, NULL);
			(void)Assign_CASpace(&caSpace_8, NULL);
			gaussian_6 = GaussianTrack_get_State(&track->base);
			positiveDefiniteMatrix = Gaussian_5_get_Covariance(gaussian_6);
			(void)Assign_MatrixData_2(&matrixData, self->_velocityNormalization);
			gaussian_7 = GaussianTrack_get_State(&track->base);
			positiveDefiniteMatrix_1 = Gaussian_5_get_Covariance(gaussian_7);
			matrixData_1 = Matrix_10_get_MatrixData(&positiveDefiniteMatrix_1->base.base);
			array = New_MatrixData_2_1D_1();
			(void)Assign_MatrixData_2(&array->Elements[((int32_t)0)], self->_velocityNormalization);
			matrixData_2 = MatrixMath_Multiply_37(matrixData, matrixData_1, array);
			Matrix_10_set_MatrixData_1(positiveDefiniteMatrix, matrixData_2);
			(void)Assign_Gaussian_5(&gaussian_6, NULL);
			(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix, NULL);
			(void)Assign_MatrixData_2(&matrixData, NULL);
			(void)Assign_Gaussian_5(&gaussian_7, NULL);
			(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_1, NULL);
			(void)Assign_MatrixData_2(&matrixData_1, NULL);
			(void)Assign_MatrixData_2_1D_1(&array, NULL);
			(void)Assign_MatrixData_2(&matrixData_2, NULL);
		}
		else
		{
			(void)Assign_Gaussian_5(&gaussian, NULL);
			(void)Assign_CASpace(&caSpace, NULL);
		}
		boolean = StaticListEnumerato_15_MoveNext(CS_5_0000);
	}
	if (!!(CS_5_0000 != NULL))
	{
		StaticListEnumerator_15_Dispose(CS_5_0000);
	}
	RemRef_StaticListEnumerator_15(CS_5_0000);
	RemRef_TrackWithMeasurements(track);
	RemRef_CASpace(expr_3D);
	RemRef_CASpace(expr_5D);
	RemRef_CASpace(expr_7D);
}

struct StaticList_27 *Trackin_ProcessMobilEyeDetectio(struct Tracking *const self, struct DateTime time_1, struct StaticList_6 *measurements, struct StaticList_4 *obstacles)
{
	struct StaticListFactory_1 *listFactory = NULL;
	struct StaticListFactory_1 *staticListFactory = NULL;
	struct StatiIPDATrackColleFactorProvid *factoryProvider = NULL;
	struct StatiIPDATrackColleFactorProvid *statiIPDATrackColleFactorProvid = NULL;
	struct MobilEyeParameters *parameters = NULL;
	struct MobilEyeParameters *mobilEyeParameters = NULL;
	struct StaticList_27 *result = NULL;
	bool_t s__LockTakena = false;
	struct Object *CS_2_0001 = NULL;
	struct Object *object = NULL;
	struct Gaussian_4 *egoMotionState = NULL;
	struct Gaussian_4 *gaussian = NULL;
	bool_t boolean = false;
	struct StaticList_27 *CS_1_0000 = NULL;
	struct Tracking *tracking = NULL;
	struct Tracking *tracking_1 = NULL;
	struct StaticList_23 *predictedStates = NULL;
	struct StaticList_20 *predictedMeasurements = NULL;
	struct StaticList_16 *transitionMatrices = NULL;
	struct StaticList_26 *predictedExistences = NULL;
	struct StaticList_22 *measuremenCardinalitLikelihoods = NULL;
	struct CAModel *systemModel = NULL;
	struct Tracking *tracking_2 = NULL;
	struct TimeSpan deltaT = { 0 };
	struct PersistenceModel *persistenceModel = NULL;
	struct MobilEyeDetectionModel *detectionModel = NULL;
	struct EgoMotionCompensation *egoMotionCompensation = NULL;
	struct StaticListEnumerator_15 *CS_5_0002 = NULL;
	struct TrackWithMeasurements *track = NULL;
	struct Gaussian_5 *egoMotionCompensatedState = NULL;
	struct Gaussian_5 *predictedState = NULL;
	struct MobilEyeMeasurementModel *measurementModel = NULL;
	struct Matrix_11 *transitionMatrix = NULL;
	struct Gaussian_2 *predictedMeasurement = NULL;
	struct SampleSet *sampledPredictedMeasurement = NULL;
	struct ProbabilityGate *gate = NULL;
	struct MultipleLocalNearestNeighbor *associationAlgorithm = NULL;
	struct MeasurementAssociation *association = NULL;
	struct StaticList_27 *updatedTracks = NULL;
	int32_t index = ((int32_t)0);
	struct TrackWithMeasurements *track_1 = NULL;
	struct StaticList_6 *associatedMeasurements = NULL;
	struct IPDA *hypothesisGenerator = NULL;
	struct StaticList_18 *associationHypotheses = NULL;
	struct GaussianMixture *mixedState = NULL;
	struct MeasurementSetLikelihood *existenConditioElementsLikeliho = NULL;
	struct Obstacle *associatedObstacle = NULL;
	struct StaticListEnumerator_10 *CS_5_0003 = NULL;
	struct TruePositivesHypothesis *hypothesis = NULL;
	struct MobilEyeSpace *truePositiveMeasurement = NULL;
	int32_t associatedMobilEyeSpaceIndex = ((int32_t)0);
	struct Gaussian_5 *updatedState = NULL;
	struct TwoPointDistribution *updatedExistence = NULL;
	struct TrackWithMeasurements *updatedTrack = NULL;
	struct StaticListEnumerator_2 *CS_5_0004 = NULL;
	struct MobilEyeSpace *measurement = NULL;
	int32_t associatedMobilEyeSpaceIndex_1 = ((int32_t)0);
	struct TrackWithMeasurements *trackFromMobilEye = NULL;
	bool_t boolean_1 = false;
	bool_t boolean_2 = false;
	bool_t boolean_3 = false;

	staticListFactory = New_StaticListFactory_1();
	StaticListFactory_1_ctor(staticListFactory, ((int32_t)50));
	(void)Assign_StaticListFactory_1(&listFactory, staticListFactory);
	(void)Assign_StaticListFactory_1(&staticListFactory, NULL);
	statiIPDATrackColleFactorProvid = New_StatIPDATracColleFactoProvi();
	StatIPDATracCollFactoProvi_ctor(statiIPDATrackColleFactorProvid, ((int32_t)15), ((int32_t)40));
	(void)Assi_StatIPDATracCollFactoProvi(&factoryProvider, statiIPDATrackColleFactorProvid);
	(void)Assi_StatIPDATracCollFactoProvi(&statiIPDATrackColleFactorProvid, NULL);
	mobilEyeParameters = SensorProper_get_MobilEyeParame(self->_sensorProperties);
	(void)Assign_MobilEyeParameters(&parameters, mobilEyeParameters);
	(void)Assign_MobilEyeParameters(&mobilEyeParameters, NULL);
	if (!self->UpdateFromMobilEye)
	{
		(void)Assign_StaticList_27(&result, NULL);
		RemRef_StaticListFactory_1(listFactory);
		RemRef_StatIPDATracCollFactProv(factoryProvider);
		RemRef_MobilEyeParameters(parameters);
		RemRef_Object(CS_2_0001);
		RemRef_Gaussian_4(egoMotionState);
		RemRef_StaticList_27(CS_1_0000);
		RemRef_Tracking(tracking);
		RemRef_Tracking(tracking_1);
		RemRef_StaticList_23(predictedStates);
		RemRef_StaticList_20(predictedMeasurements);
		RemRef_StaticList_16(transitionMatrices);
		RemRef_StaticList_26(predictedExistences);
		RemRef_StaticList_22(measuremenCardinalitLikelihoods);
		RemRef_CAModel(systemModel);
		RemRef_Tracking(tracking_2);
		RemRef_PersistenceModel(persistenceModel);
		RemRef_MobilEyeDetectionModel(detectionModel);
		RemRef_EgoMotionCompensation(egoMotionCompensation);
		RemRef_StaticListEnumerator_15(CS_5_0002);
		RemRef_TrackWithMeasurements(track);
		RemRef_Gaussian_5(egoMotionCompensatedState);
		RemRef_Gaussian_5(predictedState);
		RemRef_MobilEyeMeasurementModel(measurementModel);
		RemRef_Matrix_11(transitionMatrix);
		RemRef_Gaussian_2(predictedMeasurement);
		RemRef_SampleSet(sampledPredictedMeasurement);
		RemRef_ProbabilityGate(gate);
		RemRef_MultipLocalNearesNeighbo(associationAlgorithm);
		RemRef_MeasurementAssociation(association);
		RemRef_StaticList_27(updatedTracks);
		RemRef_TrackWithMeasurements(track_1);
		RemRef_StaticList_6(associatedMeasurements);
		RemRef_IPDA(hypothesisGenerator);
		RemRef_StaticList_18(associationHypotheses);
		RemRef_GaussianMixture(mixedState);
		RemRef_MeasurementSetLikelihood(existenConditioElementsLikeliho);
		RemRef_Obstacle(associatedObstacle);
		RemRef_StaticListEnumerator_10(CS_5_0003);
		RemRef_TruePositivesHypothesis(hypothesis);
		RemRef_MobilEyeSpace(truePositiveMeasurement);
		RemRef_Gaussian_5(updatedState);
		RemRef_TwoPointDistribution(updatedExistence);
		RemRef_TrackWithMeasurements(updatedTrack);
		RemRef_StaticListEnumerator_2(CS_5_0004);
		RemRef_MobilEyeSpace(measurement);
		RemRef_TrackWithMeasurements(trackFromMobilEye);
		return result;
	}
	s__LockTakena = false;
	(void)Assign_Object(&object, Assign_Object(&CS_2_0001, self->_tracksLock));
	s__LockTakena = true;
	(void)Assign_Object(&object, NULL);
	gaussian = EgoMotionFilter_PredicXAndReset(self->_egoMotionFilter, time_1);
	(void)Assign_Gaussian_4(&egoMotionState, gaussian);
	(void)Assign_Gaussian_4(&gaussian, NULL);
	boolean_1 = Object_2_ReferenceEquals(&egoMotionState->base, NULL);
	boolean_2 = !boolean_1;
	if (boolean_2 == true)
	{
		boolean = EgoMotionFilter_get_IsStable(self->_egoMotionFilter);
		boolean_3 = boolean;
	}
	else
	{
		boolean_3 = false;
	}
	if (!boolean_3)
	{
		(void)Assign_StaticList_27(&CS_1_0000, NULL);
	}
	else
	{
		bool_t boolean_4 = false;
		struct DateTime dateTime = { 0 };
		struct DateTime dateTime_1 = { 0 };
		bool_t boolean_5 = false;
		struct StaticListFactory_4 *staticListFactory_1 = NULL;
		struct StaticList_23 *staticList = NULL;
		struct StaticListFactory_4 *staticListFactory_2 = NULL;
		struct StaticList_20 *staticList_1 = NULL;
		struct StaticListFactory_4 *staticListFactory_3 = NULL;
		struct StaticList_16 *staticList_2 = NULL;
		struct StaticListFactory_4 *staticListFactory_4 = NULL;
		struct StaticList_26 *staticList_3 = NULL;
		struct StaticListFactory_4 *staticListFactory_5 = NULL;
		struct StaticList_22 *staticList_4 = NULL;
		struct CAModel *caModel = NULL;
		struct DateTime dateTime_2 = { 0 };
		struct DateTime dateTime_3 = { 0 };
		struct TimeSpan timeSpan = { 0 };
		float64_t double_ = 0.0;
		struct PersistenceModel *persistenceModel_1 = NULL;
		struct MobilEyeParameters *mobilEyeParameters_1 = NULL;
		float64_t double__1 = 0.0;
		struct MobilEyeDetectionModel *mobilEyeDetectionModel = NULL;
		struct EgoMotionCompensation *egoMotionCompensation_1 = NULL;
		struct StaticListEnumerator_15 *staticListEnumerator = NULL;
		bool_t boolean_6 = false;
		float64_t double__2 = 0.0;
		struct ProbabilityGate *probabilityGate = NULL;
		struct MultipleLocalNearestNeighbor *multipleLocalNearestNeighbor = NULL;
		struct MeasurementAssociation *measurementAssociation = NULL;
		struct StaticListFactory_4 *staticListFactory_6 = NULL;
		struct StaticList_27 *staticList_5 = NULL;
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);
		struct Nullable_1 nullable = { 0 };

		(void)Assign_Tracking(&tracking, self);
		boolean_4 = Nullable_1_get_HasValue(&tracking->_lastUpdateTime);
		if (!boolean_4)
		{
			struct Nullable_1 nullable_1 = { 0 };

			Nullable_1_ctor(&nullable_1, time_1);
			self->_lastUpdateTime = nullable_1;
		}
		dateTime = time_1;
		(void)Assign_Tracking(&tracking_1, self);
		dateTime_1 = Nullable_1_get_Value(&tracking_1->_lastUpdateTime);
		boolean_5 = DateTime_1_op_LessThan(dateTime, dateTime_1);
		if (!!boolean_5)
		{
			abort();
		}
		staticListFactory_1 = StIPDATrColFacPro_get_TraLisFac(factoryProvider);
		staticList = StaticListFactor_4_CreateInstan(staticListFactory_1, ((int32_t)0));
		(void)Assign_StaticList_23(&predictedStates, staticList);
		(void)Assign_StaticListFactory_4(&staticListFactory_1, NULL);
		(void)Assign_StaticList_23(&staticList, NULL);
		staticListFactory_2 = StIPDATrColFacPro_get_TraLisFac(factoryProvider);
		staticList_1 = StatiListFactor_4_CreateInstan(staticListFactory_2, ((int32_t)0));
		(void)Assign_StaticList_20(&predictedMeasurements, staticList_1);
		(void)Assign_StaticListFactory_4(&staticListFactory_2, NULL);
		(void)Assign_StaticList_20(&staticList_1, NULL);
		staticListFactory_3 = StIPDATrColFacPro_get_TraLisFac(factoryProvider);
		staticList_2 = StatiListFacto_4_CreateInstan(staticListFactory_3, ((int32_t)0));
		(void)Assign_StaticList_16(&transitionMatrices, staticList_2);
		(void)Assign_StaticListFactory_4(&staticListFactory_3, NULL);
		(void)Assign_StaticList_16(&staticList_2, NULL);
		staticListFactory_4 = StIPDATrColFacPro_get_TraLisFac(factoryProvider);
		staticList_3 = StatiListFacto_4_CreateInstan_1(staticListFactory_4, ((int32_t)0));
		(void)Assign_StaticList_26(&predictedExistences, staticList_3);
		(void)Assign_StaticListFactory_4(&staticListFactory_4, NULL);
		(void)Assign_StaticList_26(&staticList_3, NULL);
		staticListFactory_5 = StIPDATrColFacPro_get_TraLisFac(factoryProvider);
		staticList_4 = StatiListFacto_4_CreateInstan_2(staticListFactory_5, ((int32_t)0));
		(void)Assign_StaticList_22(&measuremenCardinalitLikelihoods, staticList_4);
		(void)Assign_StaticListFactory_4(&staticListFactory_5, NULL);
		(void)Assign_StaticList_22(&staticList_4, NULL);
		caModel = Tracking_GetSystemModel(self);
		(void)Assign_CAModel(&systemModel, caModel);
		(void)Assign_CAModel(&caModel, NULL);
		dateTime_2 = time_1;
		(void)Assign_Tracking(&tracking_2, self);
		dateTime_3 = Nullable_1_get_Value(&tracking_2->_lastUpdateTime);
		timeSpan = DateTime_1_op_Subtraction(dateTime_2, dateTime_3);
		deltaT = timeSpan;
		double_ = Trackin_get_ProcessNoiseExisten(self);
		persistenceModel_1 = New_PersistenceModel();
		PersistenceModel_ctor(persistenceModel_1, double_);
		PersisteModel_set_TimeCondition(persistenceModel_1, deltaT);
		(void)Assign_PersistenceModel(&persistenceModel, persistenceModel_1);
		(void)Assign_PersistenceModel(&persistenceModel_1, NULL);
		(void)Assign_MobilEyeParameters(&mobilEyeParameters_1, parameters);
		double__1 = Tracking_get_GateProbability(self);
		mobilEyeDetectionModel = New_MobilEyeDetectionModel();
		MobilEyeDetectionModel_ctor(mobilEyeDetectionModel, mobilEyeParameters_1, double__1);
		(void)Assign_MobilEyeDetectionModel(&detectionModel, mobilEyeDetectionModel);
		(void)Assign_MobilEyeParameters(&mobilEyeParameters_1, NULL);
		(void)Assign_MobilEyeDetectionModel(&mobilEyeDetectionModel, NULL);
		egoMotionCompensation_1 = New_EgoMotionCompensation();
		EgoMotionCompensation_ctor(egoMotionCompensation_1);
		(void)Assign_EgoMotionCompensation(&egoMotionCompensation, egoMotionCompensation_1);
		(void)Assign_EgoMotionCompensation(&egoMotionCompensation_1, NULL);
		staticListEnumerator = StaticList_27_GetEnumerator(self->_tracks);
		(void)Assign_StaticListEnumerator_15(&CS_5_0002, staticListEnumerator);
		(void)Assign_StaticListEnumerator_15(&staticListEnumerator, NULL);
		boolean_6 = StaticListEnumerato_15_MoveNext(CS_5_0002);
		while (boolean_6)
		{
			struct TrackWithMeasurements *trackWithMeasurements = NULL;
			struct Gaussian_5 *gaussian_1 = NULL;
			struct Gaussian_5 *gaussian_2 = NULL;
			struct StaticList_26 *staticList_6 = NULL;
			struct Existence *existence = NULL;
			struct TwoPointDistribution *twoPointDistribution = NULL;
			struct Existence *existence_1 = NULL;
			struct MobilEyeParameters *mobilEyeParameters_2 = NULL;
			struct CTRASpace *ctraSpace = NULL;
			struct CASpace *caSpace = NULL;
			struct MobilEyeMeasurementModel *mobilEyeMeasurementModel = NULL;
			struct Gaussian_2 *gaussian_3 = NULL;
			struct StaticList_7 *staticList_7 = NULL;
			struct SampleSet *sampleSet = NULL;
			struct StaticList_22 *staticList_8 = NULL;
			struct MarginalizedEvaluable *marginalizedEvaluable = NULL;

			trackWithMeasurements = StaticListEnumer_15_get_Current(CS_5_0002);
			(void)Assign_TrackWithMeasurements(&track, trackWithMeasurements);
			(void)Assign_TrackWithMeasurements(&trackWithMeasurements, NULL);
			gaussian_1 = CreateExtensions_Marginalize(egoMotionCompensation, &track->base, egoMotionState);
			(void)Assign_Gaussian_5(&egoMotionCompensatedState, gaussian_1);
			(void)Assign_Gaussian_5(&gaussian_1, NULL);
			gaussian_2 = EKF_PredictState_1(deltaT, egoMotionCompensatedState, systemModel);
			(void)Assign_Gaussian_5(&predictedState, gaussian_2);
			(void)Assign_Gaussian_5(&gaussian_2, NULL);
			StaticList_23_Add(predictedStates, predictedState);
			(void)Assign_StaticList_26(&staticList_6, predictedExistences);
			existence = GaussianTrack_get_Existence(&track->base);
			twoPointDistribution = BayesFilter_Predict_1(&existence->base, persistenceModel);
			existence_1 = New_Existence();
			Existence_ctor_2(existence_1, twoPointDistribution);
			StaticList_26_Add(staticList_6, existence_1);
			(void)Assign_StaticList_26(&staticList_6, NULL);
			(void)Assign_Existence(&existence, NULL);
			(void)Assign_TwoPointDistribution(&twoPointDistribution, NULL);
			(void)Assign_Existence(&existence_1, NULL);
			(void)Assign_MobilEyeParameters(&mobilEyeParameters_2, parameters);
			ctraSpace = Gaussian_4_get_Expectation(egoMotionState);
			caSpace = Gaussian_5_get_Expectation(predictedState);
			mobilEyeMeasurementModel = New_MobilEyeMeasurementModel();
			MobilEyeMeasurementModel_ctor(mobilEyeMeasurementModel, mobilEyeParameters_2, ctraSpace, caSpace);
			(void)Assign_MobilEyeMeasurementModel(&measurementModel, mobilEyeMeasurementModel);
			(void)Assign_MobilEyeParameters(&mobilEyeParameters_2, NULL);
			(void)Assign_CTRASpace(&ctraSpace, NULL);
			(void)Assign_CASpace(&caSpace, NULL);
			(void)Assign_MobilEyeMeasurementModel(&mobilEyeMeasurementModel, NULL);
			gaussian_3 = EKF_PredictMeasurement_2(predictedState, measurementModel, &transitionMatrix);
			(void)Assign_Gaussian_2(&predictedMeasurement, gaussian_3);
			(void)Assign_Gaussian_2(&gaussian_3, NULL);
			StaticList_16_Add(transitionMatrices, transitionMatrix);
			StaticList_20_Add(predictedMeasurements, predictedMeasurement);
			staticList_7 = Tracking_1_Draw(predictedMeasurement, ((int32_t)50));
			sampleSet = New_SampleSet();
			SampleSet_ctor_2(sampleSet, staticList_7, listFactory);
			(void)Assign_SampleSet(&sampledPredictedMeasurement, sampleSet);
			(void)Assign_StaticList_7(&staticList_7, NULL);
			(void)Assign_SampleSet(&sampleSet, NULL);
			(void)Assign_StaticList_22(&staticList_8, measuremenCardinalitLikelihoods);
			marginalizedEvaluable = New_MarginalizedEvaluable();
			MarginalizedEvaluable_ctor(marginalizedEvaluable, detectionModel, sampledPredictedMeasurement);
			StaticList_22_Add(staticList_8, marginalizedEvaluable);
			(void)Assign_StaticList_22(&staticList_8, NULL);
			(void)Assign_MarginalizedEvaluable(&marginalizedEvaluable, NULL);
			boolean_6 = StaticListEnumerato_15_MoveNext(CS_5_0002);
		}
		if (!!(CS_5_0002 != NULL))
		{
			StaticListEnumerator_15_Dispose(CS_5_0002);
		}
		double__2 = Tracking_get_GateProbability(self);
		probabilityGate = New_ProbabilityGate();
		ProbabilityGate_ctor(probabilityGate, double__2);
		(void)Assign_ProbabilityGate(&gate, probabilityGate);
		(void)Assign_ProbabilityGate(&probabilityGate, NULL);
		multipleLocalNearestNeighbor = New_MultiplLocalNearestNeighbor();
		MultiplLocalNearestNeighbo_ctor(multipleLocalNearestNeighbor, factoryProvider);
		(void)Assign_MultipLocalNearesNeighbo(&associationAlgorithm, multipleLocalNearestNeighbor);
		(void)Assign_MultipLocalNearesNeighbo(&multipleLocalNearestNeighbor, NULL);
		measurementAssociation = MeasurementAssociation_2_Create(predictedMeasurements, predictedExistences, measurements, associationAlgorithm, gate, factoryProvider);
		(void)Assign_MeasurementAssociation(&association, measurementAssociation);
		(void)Assign_MeasurementAssociation(&measurementAssociation, NULL);
		staticListFactory_6 = StIPDATrColFacPro_get_TraLisFac(factoryProvider);
		staticList_5 = StatiListFacto_4_CreateInstan_4(staticListFactory_6, ((int32_t)0));
		(void)Assign_StaticList_27(&updatedTracks, staticList_5);
		(void)Assign_StaticListFactory_4(&staticListFactory_6, NULL);
		(void)Assign_StaticList_27(&staticList_5, NULL);
		index = ((int32_t)0);
		int32 = index;
		int32_1 = StaticList_27_get_Count(self->_tracks);
		while (int32 < int32_1)
		{
			struct TrackWithMeasurements *trackWithMeasurements_1 = NULL;
			struct StaticList_6 *staticList_9 = NULL;
			struct Gaussian_2 *gaussian_4 = NULL;
			struct Existence *existence_2 = NULL;
			struct MarginalizedEvaluable *marginalizedEvaluable_1 = NULL;
			struct StaticList_6 *staticList_10 = NULL;
			float64_t double__3 = 0.0;
			struct IPDA *ipda = NULL;
			struct StaticList_18 *staticList_11 = NULL;
			int32_t int32_2 = ((int32_t)0);
			struct StaticListFactory_2 *staticListFactory_7 = NULL;
			struct GaussianMixture *gaussianMixture = NULL;
			struct MeasurementSetLikelihood *measurementSetLikelihood = NULL;
			struct StaticListEnumerator_10 *staticListEnumerator_1 = NULL;
			bool_t boolean_7 = false;
			struct Gaussian_5 *gaussian_5 = NULL;
			struct Existence *existence_3 = NULL;
			struct TwoPointDistribution *twoPointDistribution_1 = NULL;
			struct Gaussian_5 *gaussian_6 = NULL;
			struct Existence *existence_4 = NULL;
			uint64_t uInt64 = ((uint64_t)0u);
			struct Obstacle *obstacle = NULL;
			struct Object_1 *object_1 = NULL;
			struct TrackWithMeasurements *trackWithMeasurements_2 = NULL;
			bool_t boolean_8 = false;

			trackWithMeasurements_1 = StaticList_27_get_Item(self->_tracks, index);
			(void)Assign_TrackWithMeasurements(&track_1, trackWithMeasurements_1);
			(void)Assign_TrackWithMeasurements(&trackWithMeasurements_1, NULL);
			staticList_9 = Associatio_GetAssociatedObjects(&association->base, index);
			(void)Assign_StaticList_6(&associatedMeasurements, staticList_9);
			(void)Assign_StaticList_6(&staticList_9, NULL);
			gaussian_4 = StaticList_20_get_Item(predictedMeasurements, index);
			existence_2 = StaticList_26_get_Item(predictedExistences, index);
			marginalizedEvaluable_1 = StaticList_22_get_Item(measuremenCardinalitLikelihoods, index);
			(void)Assign_StaticList_6(&staticList_10, associatedMeasurements);
			double__3 = MobilEyeParame_get_ClutteLambda(parameters);
			ipda = IPDA_2_Create(gaussian_4, existence_2, marginalizedEvaluable_1, staticList_10, double__3, factoryProvider);
			(void)Assign_IPDA(&hypothesisGenerator, ipda);
			(void)Assign_Gaussian_2(&gaussian_4, NULL);
			(void)Assign_Existence(&existence_2, NULL);
			(void)Assign_MarginalizedEvaluable(&marginalizedEvaluable_1, NULL);
			(void)Assign_StaticList_6(&staticList_10, NULL);
			(void)Assign_IPDA(&ipda, NULL);
			staticList_11 = IPDA_GetHypotheses(hypothesisGenerator);
			(void)Assign_StaticList_18(&associationHypotheses, staticList_11);
			(void)Assign_StaticList_18(&staticList_11, NULL);
			int32_2 = StaticList_18_get_Count(associationHypotheses);
			staticListFactory_7 = StIPDATrColFacPro_get_HypLisFac(factoryProvider);
			gaussianMixture = New_GaussianMixture();
			GaussianMixture_ctor(gaussianMixture, int32_2, staticListFactory_7);
			(void)Assign_GaussianMixture(&mixedState, gaussianMixture);
			(void)Assign_StaticListFactory_2(&staticListFactory_7, NULL);
			(void)Assign_GaussianMixture(&gaussianMixture, NULL);
			measurementSetLikelihood = IPDA_GetElementsLikelihood(hypothesisGenerator);
			(void)Assign_MeasurementSetLikelihood(&existenConditioElementsLikeliho, measurementSetLikelihood);
			(void)Assign_MeasurementSetLikelihood(&measurementSetLikelihood, NULL);
			(void)Assign_Obstacle(&associatedObstacle, NULL);
			staticListEnumerator_1 = StaticList_18_GetEnumerator(associationHypotheses);
			(void)Assign_StaticListEnumerator_10(&CS_5_0003, staticListEnumerator_1);
			(void)Assign_StaticListEnumerator_10(&staticListEnumerator_1, NULL);
			boolean_7 = StaticListEnumerato_10_MoveNext(CS_5_0003);
			while (boolean_7)
			{
				struct TruePositivesHypothesis *truePositivesHypothesis = NULL;
				struct StaticList_8 *staticList_12 = NULL;
				struct MobilEyeSpace *mobilEyeSpace = NULL;
				bool_t boolean_9 = false;

				truePositivesHypothesis = StaticListEnumer_10_get_Current(CS_5_0003);
				(void)Assign_TruePositivesHypothesis(&hypothesis, truePositivesHypothesis);
				(void)Assign_TruePositivesHypothesis(&truePositivesHypothesis, NULL);
				staticList_12 = TruePositivHypothe_get_Elements(hypothesis);
				mobilEyeSpace = Trackin_1_SimplifFirstOrDefault(staticList_12);
				(void)Assign_MobilEyeSpace(&truePositiveMeasurement, mobilEyeSpace);
				(void)Assign_StaticList_8(&staticList_12, NULL);
				(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
				boolean_9 = Space_6_op_Equality_1(truePositiveMeasurement, NULL);
				if (!!boolean_9)
				{
					struct GaussianMixture *gaussianMixture_1 = NULL;
					struct Gaussian_5 *gaussian_7 = NULL;
					float64_t double__4 = 0.0;

					(void)Assign_GaussianMixture(&gaussianMixture_1, mixedState);
					gaussian_7 = StaticList_23_get_Item(predictedStates, index);
					double__4 = TruePositiveHypothes_get_Weight(hypothesis);
					GaussianMixture_Add(gaussianMixture_1, gaussian_7, double__4);
					(void)Assign_GaussianMixture(&gaussianMixture_1, NULL);
					(void)Assign_Gaussian_5(&gaussian_7, NULL);
				}
				else
				{
					struct GaussianMixture *gaussianMixture_2 = NULL;
					struct Gaussian_5 *gaussian_8 = NULL;
					struct Gaussian_2 *gaussian_9 = NULL;
					struct MobilEyeSpace *mobilEyeSpace_1 = NULL;
					struct Matrix_11 *matrix = NULL;
					struct Gaussian_5 *gaussian_10 = NULL;
					float64_t double__5 = 0.0;
					int32_t int32_3 = ((int32_t)0);
					struct Obstacle *obstacle_1 = NULL;

					(void)Assign_GaussianMixture(&gaussianMixture_2, mixedState);
					gaussian_8 = StaticList_23_get_Item(predictedStates, index);
					gaussian_9 = StaticList_20_get_Item(predictedMeasurements, index);
					(void)Assign_MobilEyeSpace(&mobilEyeSpace_1, truePositiveMeasurement);
					matrix = StaticList_16_get_Item(transitionMatrices, index);
					gaussian_10 = EKF_Update_4(gaussian_8, gaussian_9, mobilEyeSpace_1, matrix);
					double__5 = TruePositiveHypothes_get_Weight(hypothesis);
					GaussianMixture_Add(gaussianMixture_2, gaussian_10, double__5);
					(void)Assign_GaussianMixture(&gaussianMixture_2, NULL);
					(void)Assign_Gaussian_5(&gaussian_8, NULL);
					(void)Assign_Gaussian_2(&gaussian_9, NULL);
					(void)Assign_MobilEyeSpace(&mobilEyeSpace_1, NULL);
					(void)Assign_Matrix_11(&matrix, NULL);
					(void)Assign_Gaussian_5(&gaussian_10, NULL);
					int32_3 = Tracking_1_SimplifiedIndexOf(measurements, truePositiveMeasurement);
					associatedMobilEyeSpaceIndex = int32_3;
					obstacle_1 = StaticList_4_get_Item(obstacles, associatedMobilEyeSpaceIndex);
					(void)Assign_Obstacle(&associatedObstacle, obstacle_1);
					(void)Assign_Obstacle(&obstacle_1, NULL);
				}
				boolean_7 = StaticListEnumerato_10_MoveNext(CS_5_0003);
			}
			if (!!(CS_5_0003 != NULL))
			{
				StaticListEnumerator_10_Dispose(CS_5_0003);
			}
			gaussian_5 = GaussianMixture_ToGaussian(mixedState);
			(void)Assign_Gaussian_5(&updatedState, gaussian_5);
			(void)Assign_Gaussian_5(&gaussian_5, NULL);
			existence_3 = StaticList_26_get_Item(predictedExistences, index);
			twoPointDistribution_1 = BayesFilter_Update_1(&existence_3->base, existenConditioElementsLikeliho);
			(void)Assign_TwoPointDistribution(&updatedExistence, twoPointDistribution_1);
			(void)Assign_Existence(&existence_3, NULL);
			(void)Assign_TwoPointDistribution(&twoPointDistribution_1, NULL);
			(void)Assign_Gaussian_5(&gaussian_6, updatedState);
			existence_4 = New_Existence();
			Existence_ctor_2(existence_4, updatedExistence);
			uInt64 = GaussianTrack_get_ID(&track_1->base);
			(void)Assign_Obstacle(&obstacle, associatedObstacle);
			object_1 = TrackWithMeasu_get_ARS308Object(track_1);
			trackWithMeasurements_2 = New_TrackWithMeasurements();
			TrackWithMeasurements_ctor(trackWithMeasurements_2, gaussian_6, existence_4, uInt64, obstacle, object_1);
			(void)Assign_TrackWithMeasurements(&updatedTrack, trackWithMeasurements_2);
			(void)Assign_Gaussian_5(&gaussian_6, NULL);
			(void)Assign_Existence(&existence_4, NULL);
			(void)Assign_Obstacle(&obstacle, NULL);
			(void)Assign_Object_1(&object_1, NULL);
			(void)Assign_TrackWithMeasurements(&trackWithMeasurements_2, NULL);
			boolean_8 = Tracking_KeepTrack(self, updatedTrack);
			if (!!boolean_8)
			{
				StaticList_27_Add(updatedTracks, updatedTrack);
			}
			index = index + ((int32_t)1);
			int32 = index;
			int32_1 = StaticList_27_get_Count(self->_tracks);
		}
		if (!!self->InitializeFromMobilEye)
		{
			struct StaticList_6 *staticList_13 = NULL;
			struct StaticListEnumerator_2 *staticListEnumerator_2 = NULL;
			bool_t boolean_10 = false;

			staticList_13 = Associat_GetNotAssociateObjects(&association->base);
			staticListEnumerator_2 = StaticList_6_GetEnumerator(staticList_13);
			(void)Assign_StaticListEnumerator_2(&CS_5_0004, staticListEnumerator_2);
			(void)Assign_StaticList_6(&staticList_13, NULL);
			(void)Assign_StaticListEnumerator_2(&staticListEnumerator_2, NULL);
			boolean_10 = StaticListEnumerator_2_MoveNext(CS_5_0004);
			while (boolean_10)
			{
				struct MobilEyeSpace *mobilEyeSpace_2 = NULL;
				int32_t int32_4 = ((int32_t)0);
				struct MobilEyeSpace *mobilEyeSpace_3 = NULL;
				struct CTRASpace *ctraSpace_1 = NULL;
				float64_t double__6 = 0.0;
				struct CTRASpace *ctraSpace_2 = NULL;
				float64_t double__7 = 0.0;
				struct MobilEyeParameters *mobilEyeParameters_3 = NULL;
				struct Obstacle *obstacle_2 = NULL;
				struct TrackWithMeasurements *trackWithMeasurements_3 = NULL;
				bool_t boolean_11 = false;

				mobilEyeSpace_2 = StaticListEnumera_2_get_Current(CS_5_0004);
				(void)Assign_MobilEyeSpace(&measurement, mobilEyeSpace_2);
				(void)Assign_MobilEyeSpace(&mobilEyeSpace_2, NULL);
				int32_4 = Tracking_1_SimplifiedIndexOf(measurements, measurement);
				associatedMobilEyeSpaceIndex_1 = int32_4;
				(void)Assign_MobilEyeSpace(&mobilEyeSpace_3, measurement);
				ctraSpace_1 = Gaussian_4_get_Expectation(egoMotionState);
				double__6 = CTRASpace_get_V(ctraSpace_1);
				ctraSpace_2 = Gaussian_4_get_Expectation(egoMotionState);
				double__7 = CTRASpace_get_W(ctraSpace_2);
				(void)Assign_MobilEyeParameters(&mobilEyeParameters_3, parameters);
				obstacle_2 = StaticList_4_get_Item(obstacles, associatedMobilEyeSpaceIndex_1);
				trackWithMeasurements_3 = Trackin_CreateTrackFromMobilEye(self, mobilEyeSpace_3, double__6, double__7, mobilEyeParameters_3, obstacle_2);
				(void)Assign_TrackWithMeasurements(&trackFromMobilEye, trackWithMeasurements_3);
				(void)Assign_MobilEyeSpace(&mobilEyeSpace_3, NULL);
				(void)Assign_CTRASpace(&ctraSpace_1, NULL);
				(void)Assign_CTRASpace(&ctraSpace_2, NULL);
				(void)Assign_MobilEyeParameters(&mobilEyeParameters_3, NULL);
				(void)Assign_Obstacle(&obstacle_2, NULL);
				(void)Assign_TrackWithMeasurements(&trackWithMeasurements_3, NULL);
				boolean_11 = Object_2_ReferenceEquals(&trackFromMobilEye->base.base, NULL);
				if (!boolean_11)
				{
					StaticList_27_Add(updatedTracks, trackFromMobilEye);
				}
				boolean_10 = StaticListEnumerator_2_MoveNext(CS_5_0004);
			}
			if (!!(CS_5_0004 != NULL))
			{
				StaticListEnumerator_2_Dispose(CS_5_0004);
			}
		}
		Tracking_NormalizeVelocity(self, &updatedTracks);
		(void)Assign_StaticList_27(&self->_tracks, updatedTracks);
		Nullable_1_ctor(&nullable, time_1);
		self->_lastUpdateTime = nullable;
		(void)Assign_StaticList_27(&CS_1_0000, self->_tracks);
	}
	(void)Assign_StaticList_27(&result, CS_1_0000);
	RemRef_StaticListFactory_1(listFactory);
	RemRef_StatIPDATracCollFactProv(factoryProvider);
	RemRef_MobilEyeParameters(parameters);
	RemRef_Object(CS_2_0001);
	RemRef_Gaussian_4(egoMotionState);
	RemRef_StaticList_27(CS_1_0000);
	RemRef_Tracking(tracking);
	RemRef_Tracking(tracking_1);
	RemRef_StaticList_23(predictedStates);
	RemRef_StaticList_20(predictedMeasurements);
	RemRef_StaticList_16(transitionMatrices);
	RemRef_StaticList_26(predictedExistences);
	RemRef_StaticList_22(measuremenCardinalitLikelihoods);
	RemRef_CAModel(systemModel);
	RemRef_Tracking(tracking_2);
	RemRef_PersistenceModel(persistenceModel);
	RemRef_MobilEyeDetectionModel(detectionModel);
	RemRef_EgoMotionCompensation(egoMotionCompensation);
	RemRef_StaticListEnumerator_15(CS_5_0002);
	RemRef_TrackWithMeasurements(track);
	RemRef_Gaussian_5(egoMotionCompensatedState);
	RemRef_Gaussian_5(predictedState);
	RemRef_MobilEyeMeasurementModel(measurementModel);
	RemRef_Matrix_11(transitionMatrix);
	RemRef_Gaussian_2(predictedMeasurement);
	RemRef_SampleSet(sampledPredictedMeasurement);
	RemRef_ProbabilityGate(gate);
	RemRef_MultipLocalNearesNeighbo(associationAlgorithm);
	RemRef_MeasurementAssociation(association);
	RemRef_StaticList_27(updatedTracks);
	RemRef_TrackWithMeasurements(track_1);
	RemRef_StaticList_6(associatedMeasurements);
	RemRef_IPDA(hypothesisGenerator);
	RemRef_StaticList_18(associationHypotheses);
	RemRef_GaussianMixture(mixedState);
	RemRef_MeasurementSetLikelihood(existenConditioElementsLikeliho);
	RemRef_Obstacle(associatedObstacle);
	RemRef_StaticListEnumerator_10(CS_5_0003);
	RemRef_TruePositivesHypothesis(hypothesis);
	RemRef_MobilEyeSpace(truePositiveMeasurement);
	RemRef_Gaussian_5(updatedState);
	RemRef_TwoPointDistribution(updatedExistence);
	RemRef_TrackWithMeasurements(updatedTrack);
	RemRef_StaticListEnumerator_2(CS_5_0004);
	RemRef_MobilEyeSpace(measurement);
	RemRef_TrackWithMeasurements(trackFromMobilEye);
	return result;
}

struct FrontRadarObjectParameters *SensProp_get_FronRadaObjecParam(struct SensorProperties *const self)
{
	struct FrontRadarObjectParameters *arg_18_0 = NULL;
	struct FrontRadarObjectParameters *result = NULL;

	if (!(Assign_FrontRadarObjectParamete(&arg_18_0, self->_frontRadarObjectParameters) != NULL))
	{
		struct FrontRadarObjectParameters *frontRadarObjectParameters = NULL;

		frontRadarObjectParameters = SenPro_1_GetDefFronRadaObjePara();
		(void)Assign_FrontRadarObjectParamete(&arg_18_0, Assign_FrontRadarObjectParamete(&self->_frontRadarObjectParameters, frontRadarObjectParameters));
		(void)Assign_FrontRadarObjectParamete(&frontRadarObjectParameters, NULL);
	}
	(void)Assign_FrontRadarObjectParamete(&result, arg_18_0);
	RemRef_FrontRadarObjectParamete(arg_18_0);
	return result;
}

static void RemRef_StaticList_21(struct StaticList_21 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_21.CurrentCount--;
		Res_StaticList_21.Next[Res_StaticList_21.CurrentCount] = self;
		Del_StaticList_21(self);
	}
}

struct StaticList_21 *New_StaticList_21(void)
{
	static struct StaticList_21 const Default_StaticList_21 = { 1 };
	struct StaticList_21 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_21.CurrentCount == RC_StaticList_21)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_21.Next[Res_StaticList_21.CurrentCount];
	Res_StaticList_21.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_21.MaximumCount = (Res_StaticList_21.CurrentCount > Res_StaticList_21.MaximumCount) ? Res_StaticList_21.CurrentCount : Res_StaticList_21.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_21;
	return instance;
}

struct StaticList_21 *Assign_StaticList_21(struct StaticList_21 **const left, struct StaticList_21 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_21(*left);
	*left = right;
	return right;
}

static void RemRef_Gaussian_3(struct Gaussian_3 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Gaussian_3.CurrentCount--;
		Res_Gaussian_3.Next[Res_Gaussian_3.CurrentCount] = self;
		Del_Gaussian_3(self);
	}
}

struct Gaussian_3 *New_Gaussian_3(void)
{
	static struct Gaussian_3 const Default_Gaussian_3 = { 1 };
	struct Gaussian_3 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Gaussian_3.CurrentCount == RC_Gaussian_3)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Gaussian_3.Next[Res_Gaussian_3.CurrentCount];
	Res_Gaussian_3.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Gaussian_3.MaximumCount = (Res_Gaussian_3.CurrentCount > Res_Gaussian_3.MaximumCount) ? Res_Gaussian_3.CurrentCount : Res_Gaussian_3.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Gaussian_3;
	return instance;
}

struct Gaussian_3 *Assign_Gaussian_3(struct Gaussian_3 **const left, struct Gaussian_3 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Gaussian_3(*left);
	*left = right;
	return right;
}

static void Del_Gaussian_3_1D_15(struct Gaussian_3_1D_15 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)15);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_Gaussian_3(self->Elements[i]);
	}
}

static void RemRef_Gaussian_3_1D_15(struct Gaussian_3_1D_15 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Gaussian_3_1D_15.CurrentCount--;
		Res_Gaussian_3_1D_15.Next[Res_Gaussian_3_1D_15.CurrentCount] = self;
		Del_Gaussian_3_1D_15(self);
	}
}

struct Gaussian_3_1D_15 *New_Gaussian_3_1D_15(void)
{
	static struct Gaussian_3_1D_15 const Default_Gaussian_3_1D_15 = { 1 };
	struct Gaussian_3_1D_15 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Gaussian_3_1D_15.CurrentCount == RC_Gaussian_3_1D_15)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Gaussian_3_1D_15.Next[Res_Gaussian_3_1D_15.CurrentCount];
	Res_Gaussian_3_1D_15.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Gaussian_3_1D_15.MaximumCount = (Res_Gaussian_3_1D_15.CurrentCount > Res_Gaussian_3_1D_15.MaximumCount) ? Res_Gaussian_3_1D_15.CurrentCount : Res_Gaussian_3_1D_15.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Gaussian_3_1D_15;
	return instance;
}

struct Gaussian_3_1D_15 *Assign_Gaussian_3_1D_15(struct Gaussian_3_1D_15 **const left, struct Gaussian_3_1D_15 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Gaussian_3_1D_15(*left);
	*left = right;
	return right;
}

void StaticList_21_ctor(struct StaticList_21 *const self, int32_t maximumCount)
{
	struct Gaussian_3_1D_15 *array = NULL;

	assert(maximumCount == ((int32_t)15));
	Object_ctor(&self->base);
	array = New_Gaussian_3_1D_15();
	(void)Assign_Gaussian_3_1D_15(&self->_items, array);
	(void)Assign_Gaussian_3_1D_15(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_21 *StatiListFacto_4_CreateInstan_5(struct StaticListFactory_4 *const self, int32_t capacity)
{
	struct StaticList_21 *result = NULL;
	struct StaticList_21 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_4_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_21();
	StaticList_21_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_21(&result, staticList);
	(void)Assign_StaticList_21(&staticList, NULL);
	return result;
}

static void RemRef_StaticList_17(struct StaticList_17 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_17.CurrentCount--;
		Res_StaticList_17.Next[Res_StaticList_17.CurrentCount] = self;
		Del_StaticList_17(self);
	}
}

struct StaticList_17 *New_StaticList_17(void)
{
	static struct StaticList_17 const Default_StaticList_17 = { 1 };
	struct StaticList_17 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_17.CurrentCount == RC_StaticList_17)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_17.Next[Res_StaticList_17.CurrentCount];
	Res_StaticList_17.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_17.MaximumCount = (Res_StaticList_17.CurrentCount > Res_StaticList_17.MaximumCount) ? Res_StaticList_17.CurrentCount : Res_StaticList_17.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_17;
	return instance;
}

struct StaticList_17 *Assign_StaticList_17(struct StaticList_17 **const left, struct StaticList_17 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_17(*left);
	*left = right;
	return right;
}

static void RemRef_Matrix_13(struct Matrix_13 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Matrix_13.CurrentCount--;
		Res_Matrix_13.Next[Res_Matrix_13.CurrentCount] = self;
		Del_Matrix_13(self);
	}
}

struct Matrix_13 *New_Matrix_13(void)
{
	static struct Matrix_13 const Default_Matrix_13 = { 1 };
	struct Matrix_13 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Matrix_13.CurrentCount == RC_Matrix_13)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Matrix_13.Next[Res_Matrix_13.CurrentCount];
	Res_Matrix_13.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Matrix_13.MaximumCount = (Res_Matrix_13.CurrentCount > Res_Matrix_13.MaximumCount) ? Res_Matrix_13.CurrentCount : Res_Matrix_13.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Matrix_13;
	return instance;
}

struct Matrix_13 *Assign_Matrix_13(struct Matrix_13 **const left, struct Matrix_13 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Matrix_13(*left);
	*left = right;
	return right;
}

static void Del_Matrix_13_1D_15(struct Matrix_13_1D_15 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)15);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_Matrix_13(self->Elements[i]);
	}
}

static void RemRef_Matrix_13_1D_15(struct Matrix_13_1D_15 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_Matrix_13_1D_15.CurrentCount--;
		Res_Matrix_13_1D_15.Next[Res_Matrix_13_1D_15.CurrentCount] = self;
		Del_Matrix_13_1D_15(self);
	}
}

struct Matrix_13_1D_15 *New_Matrix_13_1D_15(void)
{
	static struct Matrix_13_1D_15 const Default_Matrix_13_1D_15 = { 1 };
	struct Matrix_13_1D_15 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_Matrix_13_1D_15.CurrentCount == RC_Matrix_13_1D_15)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_Matrix_13_1D_15.Next[Res_Matrix_13_1D_15.CurrentCount];
	Res_Matrix_13_1D_15.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_Matrix_13_1D_15.MaximumCount = (Res_Matrix_13_1D_15.CurrentCount > Res_Matrix_13_1D_15.MaximumCount) ? Res_Matrix_13_1D_15.CurrentCount : Res_Matrix_13_1D_15.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_Matrix_13_1D_15;
	return instance;
}

struct Matrix_13_1D_15 *Assign_Matrix_13_1D_15(struct Matrix_13_1D_15 **const left, struct Matrix_13_1D_15 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_Matrix_13_1D_15(*left);
	*left = right;
	return right;
}

void StaticList_17_ctor(struct StaticList_17 *const self, int32_t maximumCount)
{
	struct Matrix_13_1D_15 *array = NULL;

	assert(maximumCount == ((int32_t)15));
	Object_ctor(&self->base);
	array = New_Matrix_13_1D_15();
	(void)Assign_Matrix_13_1D_15(&self->_items, array);
	(void)Assign_Matrix_13_1D_15(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_17 *StatiListFacto_4_CreateInstan_6(struct StaticListFactory_4 *const self, int32_t capacity)
{
	struct StaticList_17 *result = NULL;
	struct StaticList_17 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_4_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_17();
	StaticList_17_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_17(&result, staticList);
	(void)Assign_StaticList_17(&staticList, NULL);
	return result;
}

static void RemRef_StaticList_25(struct StaticList_25 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_25.CurrentCount--;
		Res_StaticList_25.Next[Res_StaticList_25.CurrentCount] = self;
		Del_StaticList_25(self);
	}
}

struct StaticList_25 *New_StaticList_25(void)
{
	static struct StaticList_25 const Default_StaticList_25 = { 1 };
	struct StaticList_25 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_25.CurrentCount == RC_StaticList_25)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_25.Next[Res_StaticList_25.CurrentCount];
	Res_StaticList_25.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_25.MaximumCount = (Res_StaticList_25.CurrentCount > Res_StaticList_25.MaximumCount) ? Res_StaticList_25.CurrentCount : Res_StaticList_25.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_25;
	return instance;
}

struct StaticList_25 *Assign_StaticList_25(struct StaticList_25 **const left, struct StaticList_25 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_25(*left);
	*left = right;
	return right;
}

static void RemRef_MarginalizedEvaluable_1(struct MarginalizedEvaluable_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MarginalizedEvaluable_1.CurrentCount--;
		Res_MarginalizedEvaluable_1.Next[Res_MarginalizedEvaluable_1.CurrentCount] = self;
		Del_MarginalizedEvaluable_1(self);
	}
}

struct MarginalizedEvaluable_1 *New_MarginalizedEvaluable_1(void)
{
	static struct MarginalizedEvaluable_1 const Default_MarginalizedEvaluable_1 = { 1 };
	struct MarginalizedEvaluable_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MarginalizedEvaluable_1.CurrentCount == RC_MarginalizedEvaluable_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MarginalizedEvaluable_1.Next[Res_MarginalizedEvaluable_1.CurrentCount];
	Res_MarginalizedEvaluable_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MarginalizedEvaluable_1.MaximumCount = (Res_MarginalizedEvaluable_1.CurrentCount > Res_MarginalizedEvaluable_1.MaximumCount) ? Res_MarginalizedEvaluable_1.CurrentCount : Res_MarginalizedEvaluable_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MarginalizedEvaluable_1;
	return instance;
}

struct MarginalizedEvaluable_1 *Assign_MarginalizedEvaluable_1(struct MarginalizedEvaluable_1 **const left, struct MarginalizedEvaluable_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MarginalizedEvaluable_1(*left);
	*left = right;
	return right;
}

static void Del_MarginalizEvaluable_1_1D_15(struct MarginalizedEvaluable_1_1D_15 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)15);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_MarginalizedEvaluable_1(self->Elements[i]);
	}
}

static void RemRef_MarginalEvaluabl_1_1D_15(struct MarginalizedEvaluable_1_1D_15 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MarginalizEvaluable_1_1D_15.CurrentCount--;
		Res_MarginalizEvaluable_1_1D_15.Next[Res_MarginalizEvaluable_1_1D_15.CurrentCount] = self;
		Del_MarginalizEvaluable_1_1D_15(self);
	}
}

struct MarginalizedEvaluable_1_1D_15 *New_MarginalizEvaluable_1_1D_15(void)
{
	static struct MarginalizedEvaluable_1_1D_15 const Default_MarginaEvaluabl_1_1D_15 = { 1 };
	struct MarginalizedEvaluable_1_1D_15 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MarginalizEvaluable_1_1D_15.CurrentCount == RC_MarginalizeEvaluable_1_1D_15)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MarginalizEvaluable_1_1D_15.Next[Res_MarginalizEvaluable_1_1D_15.CurrentCount];
	Res_MarginalizEvaluable_1_1D_15.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MarginalizEvaluable_1_1D_15.MaximumCount = (Res_MarginalizEvaluable_1_1D_15.CurrentCount > Res_MarginalizEvaluable_1_1D_15.MaximumCount) ? Res_MarginalizEvaluable_1_1D_15.CurrentCount : Res_MarginalizEvaluable_1_1D_15.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MarginaEvaluabl_1_1D_15;
	return instance;
}

struct MarginalizedEvaluable_1_1D_15 *Assign_MarginalEvaluabl_1_1D_15(struct MarginalizedEvaluable_1_1D_15 **const left, struct MarginalizedEvaluable_1_1D_15 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MarginalEvaluabl_1_1D_15(*left);
	*left = right;
	return right;
}

void StaticList_25_ctor(struct StaticList_25 *const self, int32_t maximumCount)
{
	struct MarginalizedEvaluable_1_1D_15 *array = NULL;

	assert(maximumCount == ((int32_t)15));
	Object_ctor(&self->base);
	array = New_MarginalizEvaluable_1_1D_15();
	(void)Assign_MarginalEvaluabl_1_1D_15(&self->_items, array);
	(void)Assign_MarginalEvaluabl_1_1D_15(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_25 *StatiListFacto_4_CreateInstan_7(struct StaticListFactory_4 *const self, int32_t capacity)
{
	struct StaticList_25 *result = NULL;
	struct StaticList_25 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_4_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_25();
	StaticList_25_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_25(&result, staticList);
	(void)Assign_StaticList_25(&staticList, NULL);
	return result;
}

static void RemRef_FronRadarObjecMeasuModel(struct FrontRadarObjectMeasuremenModel *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base.base.base)->ReferenceCount--;
	if ((&self->base.base.base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_FrontRadarObjectMeasurModel.CurrentCount--;
		Res_FrontRadarObjectMeasurModel.Next[Res_FrontRadarObjectMeasurModel.CurrentCount] = self;
		Del_FrontRadarObjectMeasurModel(self);
	}
}

struct FrontRadarObjectMeasuremenModel *New_FrontRadarObjectMeasurModel(void)
{
	static struct FrontRadarObjectMeasuremenModel const Defau_FrontRadarObjecMeasuModel = { 1 };
	struct FrontRadarObjectMeasuremenModel *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_FrontRadarObjectMeasurModel.CurrentCount == RC_FrontRadarObjectMeasureModel)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_FrontRadarObjectMeasurModel.Next[Res_FrontRadarObjectMeasurModel.CurrentCount];
	Res_FrontRadarObjectMeasurModel.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_FrontRadarObjectMeasurModel.MaximumCount = (Res_FrontRadarObjectMeasurModel.CurrentCount > Res_FrontRadarObjectMeasurModel.MaximumCount) ? Res_FrontRadarObjectMeasurModel.CurrentCount : Res_FrontRadarObjectMeasurModel.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Defau_FrontRadarObjecMeasuModel;
	return instance;
}

struct FrontRadarObjectMeasuremenModel *Assig_FrontRadarObjecMeasuModel(struct FrontRadarObjectMeasuremenModel **const left, struct FrontRadarObjectMeasuremenModel *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base.base.base)->ReferenceCount++;
	}
	RemRef_FronRadarObjecMeasuModel(*left);
	*left = right;
	return right;
}

struct float64_t_1D_5 *FroRadObjePara_get_NoisMatrDiag(struct FrontRadarObjectParameters *const self)
{
	struct float64_t_1D_5 *result = NULL;

	(void)Assign_float64_t_1D_5(&result, self->_noiseMatrixDiagonal);
	return result;
}

static void RemRef_PositiveDefiniteMatrix_5(struct PositiveDefiniteMatrix_5 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base)->ReferenceCount--;
	if ((&self->base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_PositiveDefiniteMatrix_5.CurrentCount--;
		Res_PositiveDefiniteMatrix_5.Next[Res_PositiveDefiniteMatrix_5.CurrentCount] = self;
		Del_PositiveDefiniteMatrix_5(self);
	}
}

struct PositiveDefiniteMatrix_5 *New_PositiveDefiniteMatrix_5(void)
{
	static struct PositiveDefiniteMatrix_5 const Default_PositivDefiniteMatrix_5 = { 1 };
	struct PositiveDefiniteMatrix_5 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_PositiveDefiniteMatrix_5.CurrentCount == RC_PositiveDefiniteMatrix_5)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_PositiveDefiniteMatrix_5.Next[Res_PositiveDefiniteMatrix_5.CurrentCount];
	Res_PositiveDefiniteMatrix_5.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_PositiveDefiniteMatrix_5.MaximumCount = (Res_PositiveDefiniteMatrix_5.CurrentCount > Res_PositiveDefiniteMatrix_5.MaximumCount) ? Res_PositiveDefiniteMatrix_5.CurrentCount : Res_PositiveDefiniteMatrix_5.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_PositivDefiniteMatrix_5;
	return instance;
}

struct PositiveDefiniteMatrix_5 *Assign_PositiveDefiniteMatrix_5(struct PositiveDefiniteMatrix_5 **const left, struct PositiveDefiniteMatrix_5 *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base)->ReferenceCount++;
	}
	RemRef_PositiveDefiniteMatrix_5(*left);
	*left = right;
	return right;
}

void Matrix_5_ctor(struct Matrix_5 *const self)
{
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace_1 = NULL;

	frontRadarObjectSpace = New_FrontRadarObjectSpace();
	FrontRadarObjectSpace_ctor(frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&self->EmptyRowSpace, frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	frontRadarObjectSpace_1 = New_FrontRadarObjectSpace();
	FrontRadarObjectSpace_ctor(frontRadarObjectSpace_1);
	(void)Assign_FrontRadarObjectSpace(&self->EmptyColumnSpace, frontRadarObjectSpace_1);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_1, NULL);
	Object_ctor(&self->base);
	self->Columns = (&self->EmptyRowSpace->base.base)->Dimensions;
	self->Rows = (&self->EmptyColumnSpace->base.base)->Dimensions;
}

void SquareMatrix_5_ctor(struct SquareMatrix_5 *const self)
{
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;

	frontRadarObjectSpace = New_FrontRadarObjectSpace();
	FrontRadarObjectSpace_ctor(frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&self->EmptySpace, frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	Matrix_5_ctor(&self->base);
	self->Dimensions = (&self->base)->Rows;
}

static void Matrix_5_set_UncheckeMatrixData(struct Matrix_5 *const self, struct MatrixData_2 *value)
{
	(void)Assign_MatrixData_2(&self->_matrix, value);
}

static void Matrix_5_CheckMatrix(struct Matrix_5 *const self)
{
	struct float64_t_1D_25 *dataReference = NULL;
	struct float64_t_1D_25 *array = NULL;
	int32_t i = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);

	array = MatrixData_2_get_DataReference(self->_matrix);
	(void)Assign_float64_t_1D_25(&dataReference, array);
	(void)Assign_float64_t_1D_25(&array, NULL);
	i = ((int32_t)0);
	while (i < ((int32_t)25))
	{
		bool_t boolean = false;

		boolean = Double_IsNaN(dataReference->Elements[i]);
		if (!!boolean)
		{
			num = i / self->Rows;
			num2 = i - (num * self->Rows);
			abort();
		}
		i = i + ((int32_t)1);
	}
	RemRef_float64_t_1D_25(dataReference);
}

struct MatrixData_2 *Matrix_5_get_MatrixData(struct Matrix_5 *const self)
{
	struct MatrixData_2 *result = NULL;

	if (!(self->_matrix != NULL))
	{
		struct MatrixData_2 *matrixData = NULL;

		matrixData = MatrixData_20_Zeros_1(self->Rows, self->Columns);
		(void)Assign_MatrixData_2(&self->_matrix, matrixData);
		(void)Assign_MatrixData_2(&matrixData, NULL);
	}
	(void)Assign_MatrixData_2(&result, self->_matrix);
	return result;
}

static void SquareMatrix_5_CheckMatrix(struct SquareMatrix_5 *const self)
{
	struct MatrixData_2 *matrixData = NULL;
	int32_t int32 = ((int32_t)0);
	struct MatrixData_2 *matrixData_1 = NULL;

	Matrix_5_CheckMatrix(&self->base);
	matrixData = Matrix_5_get_MatrixData(&self->base);
	int32 = matrixData->Rows;
	matrixData_1 = Matrix_5_get_MatrixData(&self->base);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
}

bool_t Matrix_5_get_IsZero(struct Matrix_5 *const self)
{
	bool_t result = false;
	struct MatrixData_2 *matrixData = NULL;
	bool_t boolean = false;

	matrixData = Matrix_5_get_MatrixData(self);
	boolean = MatrixData_2_get_IsZero(matrixData);
	result = boolean;
	(void)Assign_MatrixData_2(&matrixData, NULL);
	return result;
}

static float64_t Matrix_5_UncheckedGet(struct Matrix_5 *const self, int32_t row, int32_t column)
{
	float64_t result = 0.0;
	struct MatrixData_2 *matrixData = NULL;
	float64_t double_ = 0.0;

	matrixData = Matrix_5_get_MatrixData(self);
	double_ = MatrixData_2_get_Item(matrixData, row, column);
	result = double_;
	(void)Assign_MatrixData_2(&matrixData, NULL);
	return result;
}

static struct MatrixData_2 *Matrix_5_get_UncheckeMatrixData(struct Matrix_5 *const self)
{
	struct MatrixData_2 *result = NULL;

	(void)Assign_MatrixData_2(&result, self->_matrix);
	return result;
}

static void PositDefiniMatrix_5_CheckMatrix(struct PositiveDefiniteMatrix_5 *const self)
{
	bool_t boolean = false;
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;

	SquareMatrix_5_CheckMatrix(&self->base);
	boolean = Matrix_5_get_IsZero(&self->base.base);
	if (!!boolean)
	{
		return;
	}
	i = ((int32_t)0);
	while (i < (&self->base.base)->Rows)
	{
		j = ((int32_t)0);
		while (j < i)
		{
			float64_t double_ = 0.0;
			float64_t double__1 = 0.0;
			int32_t int32 = ((int32_t)0);

			double_ = Matrix_5_UncheckedGet(&self->base.base, i, j);
			double__1 = Matrix_5_UncheckedGet(&self->base.base, j, i);
			int32 = FloatCompare_Compare(double_, double__1);
			if (!!(int32 != ((int32_t)0)))
			{
				abort();
			}
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	matrixData = Matrix_5_get_UncheckeMatrixData(&self->base.base);
	matrixData_1 = MatrixMath_Chol(matrixData);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
}

void SquareMatrix_5_ctor_1(struct PositiveDefiniteMatrix_5 *const self, struct float64_t_1D_5 *mainDiagonal)
{
	struct MatrixData_2 *matrixData = NULL;

	SquareMatrix_5_ctor(&self->base);
	matrixData = MatrixData_20_Diag(mainDiagonal);
	Matrix_5_set_UncheckeMatrixData(&self->base.base, matrixData);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	PositDefiniMatrix_5_CheckMatrix(self);
}

void PositiveDefiniteMatrix_5_ctor(struct PositiveDefiniteMatrix_5 *const self, struct float64_t_1D_5 *mainDiagonal)
{
	SquareMatrix_5_ctor_1(self, mainDiagonal);
}

void MeasuremenModel_3_set_Condition(struct MeasurementModel_3 *const self, struct CASpace *value)
{
	(void)Assign_CASpace(&self->Condition, value);
}

static void MeasurementModel_3_ctor(struct MeasurementModel_3 *const self, struct PositiveDefiniteMatrix_5 *measurementNoiseCovariance)
{
	struct CASpace *caSpace = NULL;

	if (!(measurementNoiseCovariance != NULL))
	{
		abort();
	}
	Object_ctor(&self->base);
	caSpace = New_CASpace();
	CASpace_ctor(caSpace);
	MeasuremenModel_3_set_Condition(self, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	(void)Assign_PositiveDefiniteMatrix_5(&self->_measurementNoiseCovariance, measurementNoiseCovariance);
}

static void MeasurementModel_7_ctor(struct MeasurementModel_7 *const self, struct PositiveDefiniteMatrix_5 *measurementNoiseCovariance)
{
	MeasurementModel_3_ctor(&self->base, measurementNoiseCovariance);
}

static void CartMeasuModel_1_set_SensoParam(struct CartesianMeasurementModel_1 *const self, struct FrontRadarObjectParameters *value)
{
	(void)Assign_FrontRadarObjectParamete(&self->SensorParameters, value);
}

struct FrontRadarObjectParameters *CartMeasuModel_1_get_SensoParam(struct CartesianMeasurementModel_1 *const self)
{
	struct FrontRadarObjectParameters *result = NULL;

	(void)Assign_FrontRadarObjectParamete(&result, self->SensorParameters);
	return result;
}

float64_t FrontRadarObjecParam_get_RotatZ(struct FrontRadarObjectParameters *const self)
{
	return self->RotationZ;
}

static void CartesianMeasuremenModel_1_ctor(struct CartesianMeasurementModel_1 *const self, struct FrontRadarObjectParameters *sensorParameters)
{
	struct float64_t_1D_5 *array = NULL;
	struct PositiveDefiniteMatrix_5 *positiveDefiniteMatrix = NULL;
	struct FrontRadarObjectParameters *CS_0_0000 = NULL;
	struct FrontRadarObjectParameters *frontRadarObjectParameters = NULL;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	struct FrontRadarObjectParameters *CS_0_0001 = NULL;
	struct FrontRadarObjectParameters *frontRadarObjectParameters_1 = NULL;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;

	array = FroRadObjePara_get_NoisMatrDiag(sensorParameters);
	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_5();
	PositiveDefiniteMatrix_5_ctor(positiveDefiniteMatrix, array);
	MeasurementModel_7_ctor(&self->base, positiveDefiniteMatrix);
	(void)Assign_float64_t_1D_5(&array, NULL);
	(void)Assign_PositiveDefiniteMatrix_5(&positiveDefiniteMatrix, NULL);
	CartMeasuModel_1_set_SensoParam(self, sensorParameters);
	frontRadarObjectParameters = CartMeasuModel_1_get_SensoParam(self);
	(void)Assign_FrontRadarObjectParamete(&CS_0_0000, frontRadarObjectParameters);
	(void)Assign_FrontRadarObjectParamete(&frontRadarObjectParameters, NULL);
	double_ = FrontRadarObjecParam_get_RotatZ(CS_0_0000);
	double__1 = Math_Cos(-double_);
	self->CosRotZ = double__1;
	frontRadarObjectParameters_1 = CartMeasuModel_1_get_SensoParam(self);
	(void)Assign_FrontRadarObjectParamete(&CS_0_0001, frontRadarObjectParameters_1);
	(void)Assign_FrontRadarObjectParamete(&frontRadarObjectParameters_1, NULL);
	double__2 = FrontRadarObjecParam_get_RotatZ(CS_0_0001);
	double__3 = Math_Sin(-double__2);
	self->SinRotZ = double__3;
	RemRef_FrontRadarObjectParamete(CS_0_0000);
	RemRef_FrontRadarObjectParamete(CS_0_0001);
}

void CartesMeasurModel_1_set_Condit2(struct CartesianMeasurementModel_1 *const self, float64_t value)
{
	self->Condition2 = value;
}

void CarteMeasuModel_1_set_EgoVeloci(struct CartesianMeasurementModel_1 *const self, float64_t value)
{
	CartesMeasurModel_1_set_Condit2(self, value);
}

static void CaMeMoWiVeVeAnAcc_set_EgoYawRat(struct CartMeasModeWithVectVeloAndAcce *const self, float64_t value)
{
	self->EgoYawRate = value;
}

static void CaMeMoWiVecVelAndAcc_set_EgoAcc(struct CartMeasModeWithVectVeloAndAcce *const self, float64_t value)
{
	self->EgoAcceleration = value;
}

static void CarMeaModWitVecVeloAndAcce_ctor(struct CartMeasModeWithVectVeloAndAcce *const self, struct FrontRadarObjectParameters *sensorParameters, float64_t egoVelocity, float64_t egoYawrate, float64_t egoAcceleration)
{
	CartesianMeasuremenModel_1_ctor(&self->base, sensorParameters);
	CarteMeasuModel_1_set_EgoVeloci(&self->base, egoVelocity);
	CaMeMoWiVeVeAnAcc_set_EgoYawRat(self, egoYawrate);
	CaMeMoWiVecVelAndAcc_set_EgoAcc(self, egoAcceleration);
}

void FrontRadarObjecMeasurModel_ctor(struct FrontRadarObjectMeasuremenModel *const self, float64_t egoVelocity, float64_t egoYawRate, float64_t egoAcceleration, struct FrontRadarObjectParameters *sensorParameters)
{
	CarMeaModWitVecVeloAndAcce_ctor(&self->base, sensorParameters, egoVelocity, egoYawRate, egoAcceleration);
}

static void RemRef_FronRadarObjecDetecModel(struct FrontRadarObjectDetectionModel *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base.base)->ReferenceCount--;
	if ((&self->base.base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_FrontRadarObjectDetectModel.CurrentCount--;
		Res_FrontRadarObjectDetectModel.Next[Res_FrontRadarObjectDetectModel.CurrentCount] = self;
		Del_FrontRadarObjectDetectModel(self);
	}
}

struct FrontRadarObjectDetectionModel *New_FrontRadarObjectDetectModel(void)
{
	static struct FrontRadarObjectDetectionModel const Defau_FrontRadarObjecDetecModel = { 1 };
	struct FrontRadarObjectDetectionModel *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_FrontRadarObjectDetectModel.CurrentCount == RC_FrontRadarObjectDetectiModel)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_FrontRadarObjectDetectModel.Next[Res_FrontRadarObjectDetectModel.CurrentCount];
	Res_FrontRadarObjectDetectModel.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_FrontRadarObjectDetectModel.MaximumCount = (Res_FrontRadarObjectDetectModel.CurrentCount > Res_FrontRadarObjectDetectModel.MaximumCount) ? Res_FrontRadarObjectDetectModel.CurrentCount : Res_FrontRadarObjectDetectModel.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Defau_FrontRadarObjecDetecModel;
	return instance;
}

struct FrontRadarObjectDetectionModel *Assig_FrontRadarObjecDetecModel(struct FrontRadarObjectDetectionModel **const left, struct FrontRadarObjectDetectionModel *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base.base)->ReferenceCount++;
	}
	RemRef_FronRadarObjecDetecModel(*left);
	*left = right;
	return right;
}

void DetectionModel_1_set_Condition(struct DetectionModel_1 *const self, struct FrontRadarObjectSpace *value)
{
	(void)Assign_FrontRadarObjectSpace(&self->Condition, value);
}

static void DetectionModel_1_ctor(struct DetectionModel_1 *const self)
{
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;

	Object_ctor(&self->base);
	frontRadarObjectSpace = New_FrontRadarObjectSpace();
	FrontRadarObjectSpace_ctor(frontRadarObjectSpace);
	DetectionModel_1_set_Condition(self, frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
}

void SinglDetecModel_1_set_GateProba(struct SingleDetectionModel_1 *const self, float64_t value)
{
	if (!((value >= 0.0) && (value <= 1.0)))
	{
		abort();
	}
	self->_gateProbability = value;
}

static void SingleDetectionModel_1_ctor(struct SingleDetectionModel_1 *const self, float64_t gateProbability)
{
	DetectionModel_1_ctor(&self->base);
	SinglDetecModel_1_set_GateProba(self, gateProbability);
}

struct Vector2D_1D_10 *FronRadaObjePara_get_FielOfView(struct FrontRadarObjectParameters *const self)
{
	struct Vector2D_1D_10 *result = NULL;

	(void)Assign_Vector2D_1D_10(&result, self->FieldOfView);
	return result;
}

static void RemRef_StaticList_3(struct StaticList_3 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_3.CurrentCount--;
		Res_StaticList_3.Next[Res_StaticList_3.CurrentCount] = self;
		Del_StaticList_3(self);
	}
}

struct StaticList_3 *New_StaticList_3(void)
{
	static struct StaticList_3 const Default_StaticList_3 = { 1 };
	struct StaticList_3 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_3.CurrentCount == RC_StaticList_3)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_3.Next[Res_StaticList_3.CurrentCount];
	Res_StaticList_3.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_3.MaximumCount = (Res_StaticList_3.CurrentCount > Res_StaticList_3.MaximumCount) ? Res_StaticList_3.CurrentCount : Res_StaticList_3.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_3;
	return instance;
}

struct StaticList_3 *Assign_StaticList_3(struct StaticList_3 **const left, struct StaticList_3 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_3(*left);
	*left = right;
	return right;
}

void StaticList_3_ctor(struct StaticList_3 *const self, int32_t maximumCount)
{
	struct Vector2D_1D_10 *array = NULL;

	assert(maximumCount == ((int32_t)10));
	Object_ctor(&self->base);
	array = New_Vector2D_1D_10();
	(void)Assign_Vector2D_1D_10(&self->_items, array);
	(void)Assign_Vector2D_1D_10(&array, NULL);
	self->MaximumCount = maximumCount;
}

float64_t FrontRadarObjecParam_get_PositX(struct FrontRadarObjectParameters *const self)
{
	return self->PositionX;
}

float64_t FrontRadarObjecParam_get_PositY(struct FrontRadarObjectParameters *const self)
{
	return self->PositionY;
}

int32_t StaticList_3_get_Count(struct StaticList_3 *const self)
{
	return self->Count;
}

static void StaticList_3_CheckCount(struct StaticList_3 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_3_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_3_set_Count(struct StaticList_3 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_3_Add(struct StaticList_3 *const self, struct Vector2D value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_3_CheckCount(self);
	int32 = StaticList_3_get_Count(self);
	count = int32;
	self->_items->Elements[count] = value;
	int32_1 = StaticList_3_get_Count(self);
	StaticList_3_set_Count(self, int32_1 + ((int32_t)1));
}

void PolygonDetectionModel_ctor(struct PolygonDetectionModel *const self, struct FrontRadarObjectParameters *parameters, float64_t gateProbability)
{
	struct Vector2D_1D_10 *array = NULL;
	struct StaticList_3 *staticList = NULL;
	struct Vector2D_1D_10 *CS_6_0000 = NULL;
	struct Vector2D_1D_10 *array_1 = NULL;
	int32_t CS_7_0001 = ((int32_t)0);
	struct Vector2D p = { 0 };

	SingleDetectionModel_1_ctor(&self->base, gateProbability);
	(void)Assign_FrontRadarObjectParamete(&self->_parameters, parameters);
	array = FronRadaObjePara_get_FielOfView(parameters);
	staticList = New_StaticList_3();
	StaticList_3_ctor(staticList, ((int32_t)10));
	(void)Assign_StaticList_3(&self->_polygonPointsInVehicleFrame, staticList);
	(void)Assign_Vector2D_1D_10(&array, NULL);
	(void)Assign_StaticList_3(&staticList, NULL);
	array_1 = FronRadaObjePara_get_FielOfView(parameters);
	(void)Assign_Vector2D_1D_10(&CS_6_0000, array_1);
	(void)Assign_Vector2D_1D_10(&array_1, NULL);
	CS_7_0001 = ((int32_t)0);
	while (CS_7_0001 < ((int32_t)10))
	{
		struct StaticList_3 *staticList_1 = NULL;
		float64_t double_ = 0.0;
		float64_t double__1 = 0.0;
		float64_t double__2 = 0.0;
		float64_t double__3 = 0.0;
		float64_t double__4 = 0.0;
		struct Vector2D vector2D = { 0 };

		p = CS_6_0000->Elements[CS_7_0001];
		(void)Assign_StaticList_3(&staticList_1, self->_polygonPointsInVehicleFrame);
		double_ = p.X;
		double__1 = FrontRadarObjecParam_get_PositX(self->_parameters);
		double__2 = double_ + double__1;
		double__3 = p.Y;
		double__4 = FrontRadarObjecParam_get_PositY(self->_parameters);
		Vector2D_ctor(&vector2D, double__2, double__3 + double__4);
		StaticList_3_Add(staticList_1, vector2D);
		(void)Assign_StaticList_3(&staticList_1, NULL);
		CS_7_0001 = CS_7_0001 + ((int32_t)1);
	}
	RemRef_Vector2D_1D_10(CS_6_0000);
}

void FrontRadarObjecDetectModel_ctor(struct FrontRadarObjectDetectionModel *const self, struct FrontRadarObjectParameters *parameters, float64_t gateProbability)
{
	PolygonDetectionModel_ctor(&self->base, parameters, gateProbability);
}

void Matrix_13_ctor(struct Matrix_13 *const self)
{
	struct CASpace *caSpace = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;

	caSpace = New_CASpace();
	CASpace_ctor(caSpace);
	(void)Assign_CASpace(&self->EmptyRowSpace, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	frontRadarObjectSpace = New_FrontRadarObjectSpace();
	FrontRadarObjectSpace_ctor(frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&self->EmptyColumnSpace, frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	Object_ctor(&self->base);
	self->Columns = (&self->EmptyRowSpace->base.base.base)->Dimensions;
	self->Rows = (&self->EmptyColumnSpace->base.base)->Dimensions;
}

static struct CASpace *MeasuremenModel_3_get_Condition(struct MeasurementModel_3 *const self)
{
	struct CASpace *result = NULL;

	(void)Assign_CASpace(&result, self->Condition);
	return result;
}

static void CarMeaModWitVecVeloAndAcce_ccto(void)
{
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
	struct CASpace *caSpace = NULL;

	frontRadarObjectSpace = Space_6_GetIndices_1();
	(void)Assign_FrontRadarObjectSpace(&CarMeaModWitVecVelAndAcc_MeaInd, frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	caSpace = Space_6_GetIndices();
	(void)Assign_CASpace(&CarMeaModWitVecVelAndAcc_StaInd, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
}

float64_t CVComponentsSpace_get_X(struct CVComponentsSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_get_Item(&self->base, ((int32_t)0));
	return double_;
}

struct MatrixData_2 *Matrix_13_get_MatrixData(struct Matrix_13 *const self)
{
	struct MatrixData_2 *result = NULL;

	if (!(self->_matrix != NULL))
	{
		struct MatrixData_2 *matrixData = NULL;

		matrixData = MatrixData_20_Zeros_1(self->Rows, self->Columns);
		(void)Assign_MatrixData_2(&self->_matrix, matrixData);
		(void)Assign_MatrixData_2(&matrixData, NULL);
	}
	(void)Assign_MatrixData_2(&result, self->_matrix);
	return result;
}

static void Matrix_13_MatrixChanged(struct Matrix_13 *const self)
{
	(void)Assign_MatrixData(&self->CachedTranspose, NULL);
}

void Matrix_13_set_Item(struct Matrix_13 *const self, int32_t row, int32_t column, float64_t value)
{
	struct MatrixData_2 *matrixData = NULL;

	if (!((row >= ((int32_t)0)) && (row < self->Rows)))
	{
		abort();
	}
	if (!((column >= ((int32_t)0)) && (column < self->Columns)))
	{
		abort();
	}
	matrixData = Matrix_13_get_MatrixData(self);
	MatrixData_2_set_Item(matrixData, row, column, value);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	Matrix_13_MatrixChanged(self);
}

void Matrix_13_set_Item_1(struct Matrix_13 *const self, float64_t row, float64_t column, float64_t value)
{
	Matrix_13_set_Item(self, (int32_t)row, (int32_t)column, value);
}

float64_t CVComponentsSpace_get_Y(struct CVComponentsSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_get_Item(&self->base, ((int32_t)1));
	return double_;
}

float64_t CVComponentsSpace_get_Vx(struct CVComponentsSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_get_Item(&self->base, ((int32_t)2));
	return double_;
}

static float64_t CaMeMoWiVeVeAnAcc_get_EgoYawRat(struct CartMeasModeWithVectVeloAndAcce *const self)
{
	return self->EgoYawRate;
}

float64_t CVComponentsSpace_get_Vy(struct CVComponentsSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_get_Item(&self->base, ((int32_t)3));
	return double_;
}

float64_t FrontRadarObjectSpace_get_A(struct FrontRadarObjectSpace *const self)
{
	float64_t double_ = 0.0;

	double_ = Space_get_Item(&self->base.base, ((int32_t)4));
	return double_;
}

void CaMeMoWitVecVelAndAcc_FilTraMat(struct CartMeasModeWithVectVeloAndAcce *const self, struct CASpace *predictedStateExpectation, struct Matrix_13 **H)
{
	float64_t r = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	float64_t double__5 = 0.0;
	float64_t sinG = 0.0;
	float64_t double__6 = 0.0;
	float64_t double__7 = 0.0;
	float64_t cosG = 0.0;
	float64_t double__8 = 0.0;
	float64_t double__9 = 0.0;
	struct Matrix_13 *arg_92_0 = NULL;
	struct FrontRadarObjectSpace *CS_0_0000 = NULL;
	float64_t arg_92_1 = 0.0;
	float64_t double__10 = 0.0;
	struct CASpace *CS_0_0001 = NULL;
	struct Matrix_13 *matrix = NULL;
	float64_t double__11 = 0.0;
	float64_t double__12 = 0.0;
	struct Matrix_13 *arg_C8_0 = NULL;
	struct FrontRadarObjectSpace *CS_0_0002 = NULL;
	float64_t arg_C8_1 = 0.0;
	float64_t double__13 = 0.0;
	struct CASpace *CS_0_0003 = NULL;
	struct Matrix_13 *matrix_1 = NULL;
	float64_t double__14 = 0.0;
	float64_t double__15 = 0.0;
	struct Matrix_13 *arg_FD_0 = NULL;
	struct FrontRadarObjectSpace *CS_0_0004 = NULL;
	float64_t arg_FD_1 = 0.0;
	float64_t double__16 = 0.0;
	struct CASpace *CS_0_0005 = NULL;
	struct Matrix_13 *matrix_2 = NULL;
	float64_t double__17 = 0.0;
	float64_t double__18 = 0.0;
	struct Matrix_13 *arg_132_0 = NULL;
	struct FrontRadarObjectSpace *CS_0_0006 = NULL;
	float64_t arg_132_1 = 0.0;
	float64_t double__19 = 0.0;
	struct CASpace *CS_0_0007 = NULL;
	struct Matrix_13 *matrix_3 = NULL;
	float64_t double__20 = 0.0;
	float64_t double__21 = 0.0;
	struct Matrix_13 *arg_17E_0 = NULL;
	struct FrontRadarObjectSpace *CS_0_0008 = NULL;
	float64_t arg_17E_1 = 0.0;
	float64_t double__22 = 0.0;
	struct CASpace *CS_0_0009 = NULL;
	struct Matrix_13 *matrix_4 = NULL;
	float64_t double__23 = 0.0;
	float64_t double__24 = 0.0;
	float64_t double__25 = 0.0;
	float64_t double__26 = 0.0;
	float64_t double__27 = 0.0;
	float64_t double__28 = 0.0;
	struct Matrix_13 *arg_1CA_0 = NULL;
	struct FrontRadarObjectSpace *CS_0_0010 = NULL;
	float64_t arg_1CA_1 = 0.0;
	float64_t double__29 = 0.0;
	struct CASpace *CS_0_0011 = NULL;
	struct Matrix_13 *matrix_5 = NULL;
	float64_t double__30 = 0.0;
	float64_t double__31 = 0.0;
	float64_t double__32 = 0.0;
	float64_t double__33 = 0.0;
	float64_t double__34 = 0.0;
	float64_t double__35 = 0.0;
	struct Matrix_13 *arg_219_0 = NULL;
	struct FrontRadarObjectSpace *CS_0_0012 = NULL;
	float64_t arg_219_1 = 0.0;
	float64_t double__36 = 0.0;
	struct CASpace *CS_0_0013 = NULL;
	struct Matrix_13 *matrix_6 = NULL;
	float64_t double__37 = 0.0;
	float64_t double__38 = 0.0;
	float64_t double__39 = 0.0;
	float64_t double__40 = 0.0;
	struct Matrix_13 *arg_259_0 = NULL;
	struct FrontRadarObjectSpace *CS_0_0014 = NULL;
	float64_t arg_259_1 = 0.0;
	float64_t double__41 = 0.0;
	struct CASpace *CS_0_0015 = NULL;
	struct Matrix_13 *matrix_7 = NULL;
	float64_t double__42 = 0.0;
	float64_t double__43 = 0.0;
	struct Matrix_13 *arg_2A6_0 = NULL;
	struct FrontRadarObjectSpace *CS_0_0016 = NULL;
	float64_t arg_2A6_1 = 0.0;
	float64_t double__44 = 0.0;
	struct CASpace *CS_0_0017 = NULL;
	struct Matrix_13 *matrix_8 = NULL;
	float64_t double__45 = 0.0;
	float64_t double__46 = 0.0;
	float64_t double__47 = 0.0;
	float64_t double__48 = 0.0;
	float64_t double__49 = 0.0;
	float64_t double__50 = 0.0;
	float64_t double__51 = 0.0;
	struct Matrix_13 *arg_2F3_0 = NULL;
	struct FrontRadarObjectSpace *CS_0_0018 = NULL;
	float64_t arg_2F3_1 = 0.0;
	float64_t double__52 = 0.0;
	struct CASpace *CS_0_0019 = NULL;
	struct Matrix_13 *matrix_9 = NULL;
	float64_t double__53 = 0.0;
	float64_t double__54 = 0.0;
	float64_t double__55 = 0.0;
	float64_t double__56 = 0.0;
	float64_t double__57 = 0.0;
	float64_t double__58 = 0.0;
	float64_t double__59 = 0.0;
	struct Matrix_13 *arg_341_0 = NULL;
	struct FrontRadarObjectSpace *CS_0_0020 = NULL;
	float64_t arg_341_1 = 0.0;
	float64_t double__60 = 0.0;
	struct CASpace *CS_0_0021 = NULL;
	struct Matrix_13 *matrix_10 = NULL;
	float64_t double__61 = 0.0;
	float64_t double__62 = 0.0;
	float64_t double__63 = 0.0;
	struct Matrix_13 *arg_381_0 = NULL;
	struct FrontRadarObjectSpace *CS_0_0022 = NULL;
	float64_t arg_381_1 = 0.0;
	float64_t double__64 = 0.0;
	struct CASpace *CS_0_0023 = NULL;
	struct Matrix_13 *matrix_11 = NULL;
	float64_t double__65 = 0.0;
	float64_t double__66 = 0.0;
	struct Matrix_13 *arg_3C1_0 = NULL;
	struct FrontRadarObjectSpace *CS_0_0024 = NULL;
	float64_t arg_3C1_1 = 0.0;
	float64_t double__67 = 0.0;
	struct CASpace *CS_0_0025 = NULL;
	struct Matrix_13 *matrix_12 = NULL;
	float64_t double__68 = 0.0;
	float64_t double__69 = 0.0;
	struct Matrix_13 *arg_410_0 = NULL;
	struct FrontRadarObjectSpace *CS_0_0026 = NULL;
	float64_t arg_410_1 = 0.0;
	float64_t double__70 = 0.0;
	struct CASpace *CS_0_0027 = NULL;
	struct Matrix_13 *matrix_13 = NULL;
	float64_t double__71 = 0.0;
	float64_t double__72 = 0.0;
	float64_t double__73 = 0.0;
	float64_t double__74 = 0.0;

	double_ = CVSpace_get_X(&(*&predictedStateExpectation)->base);
	double__1 = CVSpace_get_X(&(*&predictedStateExpectation)->base);
	double__2 = double_ * double__1;
	double__3 = CVSpace_get_Y(&(*&predictedStateExpectation)->base);
	double__4 = CVSpace_get_Y(&(*&predictedStateExpectation)->base);
	double__5 = Math_Sqrt(double__2 + (double__3 * double__4));
	r = double__5;
	double__6 = CVSpace_get_G(&(*&predictedStateExpectation)->base);
	double__7 = Math_Sin(double__6);
	sinG = double__7;
	double__8 = CVSpace_get_G(&(*&predictedStateExpectation)->base);
	double__9 = Math_Cos(double__8);
	cosG = double__9;
	(void)Assign_Matrix_13(&arg_92_0, *H);
	(void)Assign_FrontRadarObjectSpace(&CS_0_0000, CarMeaModWitVecVelAndAcc_MeaInd);
	double__10 = CVComponentsSpace_get_X(&(*&CS_0_0000)->base);
	arg_92_1 = double__10;
	(void)Assign_CASpace(&CS_0_0001, CarMeaModWitVecVelAndAcc_StaInd);
	(void)Assign_Matrix_13(&matrix, arg_92_0);
	double__11 = arg_92_1;
	double__12 = CVSpace_get_X(&(*&CS_0_0001)->base);
	Matrix_13_set_Item_1(matrix, double__11, double__12, (&self->base)->CosRotZ);
	(void)Assign_Matrix_13(&matrix, NULL);
	(void)Assign_Matrix_13(&arg_C8_0, *H);
	(void)Assign_FrontRadarObjectSpace(&CS_0_0002, CarMeaModWitVecVelAndAcc_MeaInd);
	double__13 = CVComponentsSpace_get_X(&(*&CS_0_0002)->base);
	arg_C8_1 = double__13;
	(void)Assign_CASpace(&CS_0_0003, CarMeaModWitVecVelAndAcc_StaInd);
	(void)Assign_Matrix_13(&matrix_1, arg_C8_0);
	double__14 = arg_C8_1;
	double__15 = CVSpace_get_Y(&(*&CS_0_0003)->base);
	Matrix_13_set_Item_1(matrix_1, double__14, double__15, -(&self->base)->SinRotZ);
	(void)Assign_Matrix_13(&matrix_1, NULL);
	(void)Assign_Matrix_13(&arg_FD_0, *H);
	(void)Assign_FrontRadarObjectSpace(&CS_0_0004, CarMeaModWitVecVelAndAcc_MeaInd);
	double__16 = CVComponentsSpace_get_Y(&(*&CS_0_0004)->base);
	arg_FD_1 = double__16;
	(void)Assign_CASpace(&CS_0_0005, CarMeaModWitVecVelAndAcc_StaInd);
	(void)Assign_Matrix_13(&matrix_2, arg_FD_0);
	double__17 = arg_FD_1;
	double__18 = CVSpace_get_X(&(*&CS_0_0005)->base);
	Matrix_13_set_Item_1(matrix_2, double__17, double__18, (&self->base)->SinRotZ);
	(void)Assign_Matrix_13(&matrix_2, NULL);
	(void)Assign_Matrix_13(&arg_132_0, *H);
	(void)Assign_FrontRadarObjectSpace(&CS_0_0006, CarMeaModWitVecVelAndAcc_MeaInd);
	double__19 = CVComponentsSpace_get_Y(&(*&CS_0_0006)->base);
	arg_132_1 = double__19;
	(void)Assign_CASpace(&CS_0_0007, CarMeaModWitVecVelAndAcc_StaInd);
	(void)Assign_Matrix_13(&matrix_3, arg_132_0);
	double__20 = arg_132_1;
	double__21 = CVSpace_get_Y(&(*&CS_0_0007)->base);
	Matrix_13_set_Item_1(matrix_3, double__20, double__21, (&self->base)->CosRotZ);
	(void)Assign_Matrix_13(&matrix_3, NULL);
	(void)Assign_Matrix_13(&arg_17E_0, *H);
	(void)Assign_FrontRadarObjectSpace(&CS_0_0008, CarMeaModWitVecVelAndAcc_MeaInd);
	double__22 = CVComponentsSpace_get_Vx(&(*&CS_0_0008)->base);
	arg_17E_1 = double__22;
	(void)Assign_CASpace(&CS_0_0009, CarMeaModWitVecVelAndAcc_StaInd);
	(void)Assign_Matrix_13(&matrix_4, arg_17E_0);
	double__23 = arg_17E_1;
	double__24 = CVSpace_get_X(&(*&CS_0_0009)->base);
	double__25 = CVSpace_get_X(&(*&predictedStateExpectation)->base);
	double__26 = double__25 / r;
	double__27 = CaMeMoWiVeVeAnAcc_get_EgoYawRat(self);
	double__28 = double__26 * double__27;
	Matrix_13_set_Item_1(matrix_4, double__23, double__24, double__28 * (&self->base)->SinRotZ);
	(void)Assign_Matrix_13(&matrix_4, NULL);
	(void)Assign_Matrix_13(&arg_1CA_0, *H);
	(void)Assign_FrontRadarObjectSpace(&CS_0_0010, CarMeaModWitVecVelAndAcc_MeaInd);
	double__29 = CVComponentsSpace_get_Vx(&(*&CS_0_0010)->base);
	arg_1CA_1 = double__29;
	(void)Assign_CASpace(&CS_0_0011, CarMeaModWitVecVelAndAcc_StaInd);
	(void)Assign_Matrix_13(&matrix_5, arg_1CA_0);
	double__30 = arg_1CA_1;
	double__31 = CVSpace_get_Y(&(*&CS_0_0011)->base);
	double__32 = CVSpace_get_Y(&(*&predictedStateExpectation)->base);
	double__33 = double__32 / r;
	double__34 = CaMeMoWiVeVeAnAcc_get_EgoYawRat(self);
	double__35 = double__33 * double__34;
	Matrix_13_set_Item_1(matrix_5, double__30, double__31, double__35 * (&self->base)->SinRotZ);
	(void)Assign_Matrix_13(&matrix_5, NULL);
	(void)Assign_Matrix_13(&arg_219_0, *H);
	(void)Assign_FrontRadarObjectSpace(&CS_0_0012, CarMeaModWitVecVelAndAcc_MeaInd);
	double__36 = CVComponentsSpace_get_Vx(&(*&CS_0_0012)->base);
	arg_219_1 = double__36;
	(void)Assign_CASpace(&CS_0_0013, CarMeaModWitVecVelAndAcc_StaInd);
	(void)Assign_Matrix_13(&matrix_6, arg_219_0);
	double__37 = arg_219_1;
	double__38 = CVSpace_get_G(&(*&CS_0_0013)->base);
	double__39 = CVSpace_get_V(&(*&predictedStateExpectation)->base);
	double__40 = -double__39;
	Matrix_13_set_Item_1(matrix_6, double__37, double__38, double__40 * ((sinG * (&self->base)->CosRotZ) + (cosG * (&self->base)->SinRotZ)));
	(void)Assign_Matrix_13(&matrix_6, NULL);
	(void)Assign_Matrix_13(&arg_259_0, *H);
	(void)Assign_FrontRadarObjectSpace(&CS_0_0014, CarMeaModWitVecVelAndAcc_MeaInd);
	double__41 = CVComponentsSpace_get_Vx(&(*&CS_0_0014)->base);
	arg_259_1 = double__41;
	(void)Assign_CASpace(&CS_0_0015, CarMeaModWitVecVelAndAcc_StaInd);
	(void)Assign_Matrix_13(&matrix_7, arg_259_0);
	double__42 = arg_259_1;
	double__43 = CVSpace_get_V(&(*&CS_0_0015)->base);
	Matrix_13_set_Item_1(matrix_7, double__42, double__43, (cosG * (&self->base)->CosRotZ) - (sinG * (&self->base)->SinRotZ));
	(void)Assign_Matrix_13(&matrix_7, NULL);
	(void)Assign_Matrix_13(&arg_2A6_0, *H);
	(void)Assign_FrontRadarObjectSpace(&CS_0_0016, CarMeaModWitVecVelAndAcc_MeaInd);
	double__44 = CVComponentsSpace_get_Vy(&(*&CS_0_0016)->base);
	arg_2A6_1 = double__44;
	(void)Assign_CASpace(&CS_0_0017, CarMeaModWitVecVelAndAcc_StaInd);
	(void)Assign_Matrix_13(&matrix_8, arg_2A6_0);
	double__45 = arg_2A6_1;
	double__46 = CVSpace_get_X(&(*&CS_0_0017)->base);
	double__47 = CVSpace_get_X(&(*&predictedStateExpectation)->base);
	double__48 = -double__47;
	double__49 = double__48 / r;
	double__50 = CaMeMoWiVeVeAnAcc_get_EgoYawRat(self);
	double__51 = double__49 * double__50;
	Matrix_13_set_Item_1(matrix_8, double__45, double__46, double__51 * (&self->base)->CosRotZ);
	(void)Assign_Matrix_13(&matrix_8, NULL);
	(void)Assign_Matrix_13(&arg_2F3_0, *H);
	(void)Assign_FrontRadarObjectSpace(&CS_0_0018, CarMeaModWitVecVelAndAcc_MeaInd);
	double__52 = CVComponentsSpace_get_Vy(&(*&CS_0_0018)->base);
	arg_2F3_1 = double__52;
	(void)Assign_CASpace(&CS_0_0019, CarMeaModWitVecVelAndAcc_StaInd);
	(void)Assign_Matrix_13(&matrix_9, arg_2F3_0);
	double__53 = arg_2F3_1;
	double__54 = CVSpace_get_Y(&(*&CS_0_0019)->base);
	double__55 = CVSpace_get_Y(&(*&predictedStateExpectation)->base);
	double__56 = -double__55;
	double__57 = double__56 / r;
	double__58 = CaMeMoWiVeVeAnAcc_get_EgoYawRat(self);
	double__59 = double__57 * double__58;
	Matrix_13_set_Item_1(matrix_9, double__53, double__54, double__59 * (&self->base)->CosRotZ);
	(void)Assign_Matrix_13(&matrix_9, NULL);
	(void)Assign_Matrix_13(&arg_341_0, *H);
	(void)Assign_FrontRadarObjectSpace(&CS_0_0020, CarMeaModWitVecVelAndAcc_MeaInd);
	double__60 = CVComponentsSpace_get_Vy(&(*&CS_0_0020)->base);
	arg_341_1 = double__60;
	(void)Assign_CASpace(&CS_0_0021, CarMeaModWitVecVelAndAcc_StaInd);
	(void)Assign_Matrix_13(&matrix_10, arg_341_0);
	double__61 = arg_341_1;
	double__62 = CVSpace_get_G(&(*&CS_0_0021)->base);
	double__63 = CVSpace_get_V(&(*&predictedStateExpectation)->base);
	Matrix_13_set_Item_1(matrix_10, double__61, double__62, double__63 * ((cosG * (&self->base)->CosRotZ) - (sinG * (&self->base)->SinRotZ)));
	(void)Assign_Matrix_13(&matrix_10, NULL);
	(void)Assign_Matrix_13(&arg_381_0, *H);
	(void)Assign_FrontRadarObjectSpace(&CS_0_0022, CarMeaModWitVecVelAndAcc_MeaInd);
	double__64 = CVComponentsSpace_get_Vy(&(*&CS_0_0022)->base);
	arg_381_1 = double__64;
	(void)Assign_CASpace(&CS_0_0023, CarMeaModWitVecVelAndAcc_StaInd);
	(void)Assign_Matrix_13(&matrix_11, arg_381_0);
	double__65 = arg_381_1;
	double__66 = CVSpace_get_V(&(*&CS_0_0023)->base);
	Matrix_13_set_Item_1(matrix_11, double__65, double__66, (cosG * (&self->base)->SinRotZ) + (sinG * (&self->base)->CosRotZ));
	(void)Assign_Matrix_13(&matrix_11, NULL);
	(void)Assign_Matrix_13(&arg_3C1_0, *H);
	(void)Assign_FrontRadarObjectSpace(&CS_0_0024, CarMeaModWitVecVelAndAcc_MeaInd);
	double__67 = FrontRadarObjectSpace_get_A(CS_0_0024);
	arg_3C1_1 = double__67;
	(void)Assign_CASpace(&CS_0_0025, CarMeaModWitVecVelAndAcc_StaInd);
	(void)Assign_Matrix_13(&matrix_12, arg_3C1_0);
	double__68 = arg_3C1_1;
	double__69 = CASpace_get_A(CS_0_0025);
	Matrix_13_set_Item_1(matrix_12, double__68, double__69, (cosG * (&self->base)->CosRotZ) - (sinG * (&self->base)->SinRotZ));
	(void)Assign_Matrix_13(&matrix_12, NULL);
	(void)Assign_Matrix_13(&arg_410_0, *H);
	(void)Assign_FrontRadarObjectSpace(&CS_0_0026, CarMeaModWitVecVelAndAcc_MeaInd);
	double__70 = FrontRadarObjectSpace_get_A(CS_0_0026);
	arg_410_1 = double__70;
	(void)Assign_CASpace(&CS_0_0027, CarMeaModWitVecVelAndAcc_StaInd);
	(void)Assign_Matrix_13(&matrix_13, arg_410_0);
	double__71 = arg_410_1;
	double__72 = CVSpace_get_G(&(*&CS_0_0027)->base);
	double__73 = CASpace_get_A(predictedStateExpectation);
	double__74 = -double__73;
	Matrix_13_set_Item_1(matrix_13, double__71, double__72, double__74 * ((sinG * (&self->base)->CosRotZ) + (cosG * (&self->base)->SinRotZ)));
	(void)Assign_Matrix_13(&matrix_13, NULL);
	RemRef_Matrix_13(arg_92_0);
	RemRef_FrontRadarObjectSpace(CS_0_0000);
	RemRef_CASpace(CS_0_0001);
	RemRef_Matrix_13(arg_C8_0);
	RemRef_FrontRadarObjectSpace(CS_0_0002);
	RemRef_CASpace(CS_0_0003);
	RemRef_Matrix_13(arg_FD_0);
	RemRef_FrontRadarObjectSpace(CS_0_0004);
	RemRef_CASpace(CS_0_0005);
	RemRef_Matrix_13(arg_132_0);
	RemRef_FrontRadarObjectSpace(CS_0_0006);
	RemRef_CASpace(CS_0_0007);
	RemRef_Matrix_13(arg_17E_0);
	RemRef_FrontRadarObjectSpace(CS_0_0008);
	RemRef_CASpace(CS_0_0009);
	RemRef_Matrix_13(arg_1CA_0);
	RemRef_FrontRadarObjectSpace(CS_0_0010);
	RemRef_CASpace(CS_0_0011);
	RemRef_Matrix_13(arg_219_0);
	RemRef_FrontRadarObjectSpace(CS_0_0012);
	RemRef_CASpace(CS_0_0013);
	RemRef_Matrix_13(arg_259_0);
	RemRef_FrontRadarObjectSpace(CS_0_0014);
	RemRef_CASpace(CS_0_0015);
	RemRef_Matrix_13(arg_2A6_0);
	RemRef_FrontRadarObjectSpace(CS_0_0016);
	RemRef_CASpace(CS_0_0017);
	RemRef_Matrix_13(arg_2F3_0);
	RemRef_FrontRadarObjectSpace(CS_0_0018);
	RemRef_CASpace(CS_0_0019);
	RemRef_Matrix_13(arg_341_0);
	RemRef_FrontRadarObjectSpace(CS_0_0020);
	RemRef_CASpace(CS_0_0021);
	RemRef_Matrix_13(arg_381_0);
	RemRef_FrontRadarObjectSpace(CS_0_0022);
	RemRef_CASpace(CS_0_0023);
	RemRef_Matrix_13(arg_3C1_0);
	RemRef_FrontRadarObjectSpace(CS_0_0024);
	RemRef_CASpace(CS_0_0025);
	RemRef_Matrix_13(arg_410_0);
	RemRef_FrontRadarObjectSpace(CS_0_0026);
	RemRef_CASpace(CS_0_0027);
}

struct Matrix_13 *MeasurModel_7_get_TransitMatrix(struct CartMeasModeWithVectVeloAndAcce *const self)
{
	struct Matrix_13 *result = NULL;
	struct Matrix_13 *matrix = NULL;
	struct CASpace *caSpace = NULL;
	struct Matrix_13 *result_1 = NULL;

	matrix = New_Matrix_13();
	Matrix_13_ctor(matrix);
	(void)Assign_Matrix_13(&result, matrix);
	(void)Assign_Matrix_13(&matrix, NULL);
	caSpace = MeasuremenModel_3_get_Condition(&self->base.base.base);
	CaMeMoWitVecVelAndAcc_FilTraMat(self, caSpace, &result);
	(void)Assign_CASpace(&caSpace, NULL);
	(void)Assign_Matrix_13(&result_1, result);
	RemRef_Matrix_13(result);
	return result_1;
}

struct PositiveDefiniteMatrix_5 *MeasureModel_3_get_NoiseCovaria(struct MeasurementModel_3 *const self)
{
	struct PositiveDefiniteMatrix_5 *result = NULL;

	(void)Assign_PositiveDefiniteMatrix_5(&result, self->_measurementNoiseCovariance);
	return result;
}

struct PositiveDefiniteMatrix_5 *MeasuremeModel_3_get_Covariance(struct MeasurementModel_3 *const self)
{
	struct PositiveDefiniteMatrix_5 *result = NULL;
	struct PositiveDefiniteMatrix_5 *positiveDefiniteMatrix = NULL;

	positiveDefiniteMatrix = MeasureModel_3_get_NoiseCovaria(self);
	(void)Assign_PositiveDefiniteMatrix_5(&result, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_5(&positiveDefiniteMatrix, NULL);
	return result;
}

void PositiveDefiniteMatrix_5_ctor_1(struct PositiveDefiniteMatrix_5 *const self)
{
	SquareMatrix_5_ctor(&self->base);
}

struct PositiveDefiniteMatrix_5 *PositivDefiniteMatrix_13_Create(struct MatrixData_2 *matrix)
{
	struct PositiveDefiniteMatrix_5 *result = NULL;
	struct PositiveDefiniteMatrix_5 *positiveDefiniteMatrix = NULL;

	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_5();
	PositiveDefiniteMatrix_5_ctor_1(positiveDefiniteMatrix);
	Matrix_5_set_UncheckeMatrixData(&positiveDefiniteMatrix->base.base, matrix);
	(void)Assign_PositiveDefiniteMatrix_5(&result, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_5(&positiveDefiniteMatrix, NULL);
	return result;
}

struct PositiveDefiniteMatrix_5 *PosiDefinMatri_13_CreatAndCorre(struct MatrixData_2 *matrix)
{
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	float64_t num = 0.0;
	float64_t num2 = 0.0;
	float64_t value = 0.0;
	struct PositiveDefiniteMatrix_5 *result = NULL;
	struct PositiveDefiniteMatrix_5 *positiveDefiniteMatrix = NULL;

	i = ((int32_t)0);
	while (i < matrix->Rows)
	{
		float64_t double_ = 0.0;

		double_ = MatrixData_2_get_Item(matrix, i, i);
		if (!(double_ > 0.0))
		{
			MatrixData_2_set_Item(matrix, i, i, 4.94065645841247E-324);
		}
		j = ((int32_t)0);
		while (j < i)
		{
			float64_t double__1 = 0.0;
			float64_t double__2 = 0.0;
			float64_t double__3 = 0.0;
			float64_t double__4 = 0.0;
			float64_t double__5 = 0.0;
			float64_t double__6 = 0.0;

			double__1 = MatrixData_2_get_Item(matrix, i, j);
			double__2 = MatrixData_2_get_Item(matrix, j, i);
			num = (double__1 + double__2) / 2.0;
			double__3 = MatrixData_2_get_Item(matrix, i, i);
			double__4 = MatrixData_2_get_Item(matrix, j, j);
			double__5 = Math_Sqrt(double__3 * double__4);
			num2 = 1.0 * double__5;
			double__6 = Math_Abs(num);
			if (!(double__6 <= num2))
			{
				int32_t int32 = ((int32_t)0);
				float64_t double__7 = 0.0;

				int32 = Math_Sign(num);
				double__7 = (float64_t)int32;
				value = double__7 * num2;
			}
			else
			{
				value = num;
			}
			MatrixData_2_set_Item(matrix, i, j, value);
			MatrixData_2_set_Item(matrix, j, i, value);
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	positiveDefiniteMatrix = PositivDefiniteMatrix_13_Create(matrix);
	(void)Assign_PositiveDefiniteMatrix_5(&result, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_5(&positiveDefiniteMatrix, NULL);
	return result;
}

void CartesianMeasurementModel_1_h(struct CartesianMeasurementModel_1 *const self, struct CASpace *state, struct FrontRadarObjectSpace **predictedMeasurement)
{
	float64_t arg_21_0 = 0.0;
	float64_t double_ = 0.0;
	struct FrontRadarObjectParameters *CS_0_0000 = NULL;
	struct FrontRadarObjectParameters *frontRadarObjectParameters = NULL;
	float64_t x = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t arg_44_0 = 0.0;
	float64_t double__3 = 0.0;
	struct FrontRadarObjectParameters *CS_0_0001 = NULL;
	struct FrontRadarObjectParameters *frontRadarObjectParameters_1 = NULL;
	float64_t y = 0.0;
	float64_t double__4 = 0.0;
	float64_t double__5 = 0.0;

	double_ = CVSpace_get_X(&(*&state)->base);
	arg_21_0 = double_;
	frontRadarObjectParameters = CartMeasuModel_1_get_SensoParam(self);
	(void)Assign_FrontRadarObjectParamete(&CS_0_0000, frontRadarObjectParameters);
	(void)Assign_FrontRadarObjectParamete(&frontRadarObjectParameters, NULL);
	double__1 = arg_21_0;
	double__2 = FrontRadarObjecParam_get_PositX(CS_0_0000);
	x = double__1 - double__2;
	double__3 = CVSpace_get_Y(&(*&state)->base);
	arg_44_0 = double__3;
	frontRadarObjectParameters_1 = CartMeasuModel_1_get_SensoParam(self);
	(void)Assign_FrontRadarObjectParamete(&CS_0_0001, frontRadarObjectParameters_1);
	(void)Assign_FrontRadarObjectParamete(&frontRadarObjectParameters_1, NULL);
	double__4 = arg_44_0;
	double__5 = FrontRadarObjecParam_get_PositY(CS_0_0001);
	y = double__4 - double__5;
	CVComponentsSpace_set_X(&(*predictedMeasurement)->base, (x * self->CosRotZ) - (y * self->SinRotZ));
	CVComponentsSpace_set_Y(&(*predictedMeasurement)->base, (x * self->SinRotZ) + (y * self->CosRotZ));
	RemRef_FrontRadarObjectParamete(CS_0_0000);
	RemRef_FrontRadarObjectParamete(CS_0_0001);
}

static float64_t CartesMeasurModel_1_get_Condit2(struct CartesianMeasurementModel_1 *const self)
{
	return self->Condition2;
}

float64_t CarteMeasuModel_1_get_EgoVeloci(struct CartesianMeasurementModel_1 *const self)
{
	float64_t double_ = 0.0;

	double_ = CartesMeasurModel_1_get_Condit2(self);
	return double_;
}

static float64_t CaMeMoWiVecVelAndAcc_get_EgoAcc(struct CartMeasModeWithVectVeloAndAcce *const self)
{
	return self->EgoAcceleration;
}

void CarMeaModeWithVectVeloAndAcce_h(struct CartMeasModeWithVectVeloAndAcce *const self, struct CASpace *state, struct FrontRadarObjectSpace **predictedMeasurement)
{
	float64_t r = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	float64_t double__5 = 0.0;
	float64_t cosG = 0.0;
	float64_t double__6 = 0.0;
	float64_t double__7 = 0.0;
	float64_t sinG = 0.0;
	float64_t double__8 = 0.0;
	float64_t double__9 = 0.0;
	float64_t vx = 0.0;
	float64_t double__10 = 0.0;
	float64_t double__11 = 0.0;
	float64_t double__12 = 0.0;
	float64_t vy = 0.0;
	float64_t double__13 = 0.0;
	float64_t double__14 = 0.0;
	float64_t double__15 = 0.0;
	float64_t double__16 = 0.0;
	float64_t ax = 0.0;
	float64_t double__17 = 0.0;
	float64_t double__18 = 0.0;
	float64_t double__19 = 0.0;
	float64_t ay = 0.0;
	float64_t double__20 = 0.0;

	CartesianMeasurementModel_1_h(&self->base, state, predictedMeasurement);
	double_ = CVSpace_get_X(&(*&state)->base);
	double__1 = CVSpace_get_X(&(*&state)->base);
	double__2 = double_ * double__1;
	double__3 = CVSpace_get_Y(&(*&state)->base);
	double__4 = CVSpace_get_Y(&(*&state)->base);
	double__5 = Math_Sqrt(double__2 + (double__3 * double__4));
	r = double__5;
	double__6 = CVSpace_get_G(&(*&state)->base);
	double__7 = Math_Cos(double__6);
	cosG = double__7;
	double__8 = CVSpace_get_G(&(*&state)->base);
	double__9 = Math_Sin(double__8);
	sinG = double__9;
	double__10 = CVSpace_get_V(&(*&state)->base);
	double__11 = double__10 * cosG;
	double__12 = CarteMeasuModel_1_get_EgoVeloci(&self->base);
	vx = double__11 - double__12;
	double__13 = CVSpace_get_V(&(*&state)->base);
	double__14 = double__13 * sinG;
	double__15 = r;
	double__16 = CaMeMoWiVeVeAnAcc_get_EgoYawRat(self);
	vy = double__14 - (double__15 * double__16);
	CVComponentsSpace_set_Vx(&(*predictedMeasurement)->base, (vx * (&self->base)->CosRotZ) - (vy * (&self->base)->SinRotZ));
	CVComponentsSpace_set_Vy(&(*predictedMeasurement)->base, (vx * (&self->base)->SinRotZ) + (vy * (&self->base)->CosRotZ));
	double__17 = CASpace_get_A(state);
	double__18 = double__17 * cosG;
	double__19 = CaMeMoWiVecVelAndAcc_get_EgoAcc(self);
	ax = double__18 - double__19;
	double__20 = CASpace_get_A(state);
	ay = double__20 * sinG;
	FrontRadarObjectSpace_set_A(*predictedMeasurement, (ax * (&self->base)->CosRotZ) - (ay * (&self->base)->SinRotZ));
}

struct FrontRadarObjectSpace *MeasuremeModel_3_get_Expectatio(struct CartMeasModeWithVectVeloAndAcce *const self)
{
	struct FrontRadarObjectSpace *result = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
	struct CASpace *caSpace = NULL;
	struct FrontRadarObjectSpace *result_1 = NULL;

	frontRadarObjectSpace = New_FrontRadarObjectSpace();
	FrontRadarObjectSpace_ctor(frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&result, frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	caSpace = MeasuremenModel_3_get_Condition(&self->base.base.base);
	CarMeaModeWithVectVeloAndAcce_h(self, caSpace, &result);
	(void)Assign_CASpace(&caSpace, NULL);
	(void)Assign_FrontRadarObjectSpace(&result_1, result);
	RemRef_FrontRadarObjectSpace(result);
	return result_1;
}

static void Gaussian_11_cctor(void)
{
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;

	frontRadarObjectSpace = New_FrontRadarObjectSpace();
	FrontRadarObjectSpace_ctor(frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&Gaussian_11_EmptySpace, frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
}

static void Gaussian_3_set_Expectation(struct Gaussian_3 *const self, struct FrontRadarObjectSpace *value)
{
	(void)Assign_FrontRadarObjectSpace(&self->Expectation, value);
}

static void Gaussian_3_ResetCachedValues(struct Gaussian_3 *const self)
{
	struct Nullable_2 nullable = { 0 };

	self->NormalizationFactor = nullable;
}

static void Gaussian_3_set_Covariance(struct Gaussian_3 *const self, struct PositiveDefiniteMatrix_5 *value)
{
	Gaussian_3_ResetCachedValues(self);
	(void)Assign_PositiveDefiniteMatrix_5(&self->covariance, value);
}

static void Gaussian_3_ctor(struct Gaussian_3 *const self, bool_t noInitialization)
{
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
	struct PositiveDefiniteMatrix_5 *positiveDefiniteMatrix = NULL;

	Object_ctor(&self->base);
	self->_dimensions = (&Gaussian_11_EmptySpace->base.base)->Dimensions;
	if (!!noInitialization)
	{
		return;
	}
	frontRadarObjectSpace = New_FrontRadarObjectSpace();
	FrontRadarObjectSpace_ctor(frontRadarObjectSpace);
	Gaussian_3_set_Expectation(self, frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_5();
	PositiveDefiniteMatrix_5_ctor_1(positiveDefiniteMatrix);
	Gaussian_3_set_Covariance(self, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_5(&positiveDefiniteMatrix, NULL);
}

struct Gaussian_3 *Gaussian_11_Create(struct FrontRadarObjectSpace *expectation, struct PositiveDefiniteMatrix_5 *covariance)
{
	struct Gaussian_3 *result = NULL;
	struct Gaussian_3 *gaussian = NULL;

	gaussian = New_Gaussian_3();
	Gaussian_3_ctor(gaussian, true);
	Gaussian_3_set_Expectation(gaussian, expectation);
	Gaussian_3_set_Covariance(gaussian, covariance);
	(void)Assign_Gaussian_3(&result, gaussian);
	(void)Assign_Gaussian_3(&gaussian, NULL);
	return result;
}

struct Gaussian_3 *EKF_PredictMeasurement_3(struct Gaussian_5 *predictedState, struct FrontRadarObjectMeasuremenModel *measurementModel, struct Matrix_13 **transitionMatrix)
{
	struct CASpace *caSpace = NULL;
	struct Matrix_13 **matrix = NULL;
	struct Matrix_13 *matrix_1 = NULL;
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	struct MatrixData_2 *matrix_2 = NULL;
	struct MatrixData_2 *matrixData_2 = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix = NULL;
	struct MatrixData_2 *matrixData_3 = NULL;
	struct MatrixData_2 *matrixData_4 = NULL;
	struct PositiveDefiniteMatrix_5 *positiveDefiniteMatrix_1 = NULL;
	struct MatrixData_2 *matrixData_5 = NULL;
	struct MatrixData_2 *matrixData_6 = NULL;
	struct PositiveDefiniteMatrix_5 *covariance = NULL;
	struct PositiveDefiniteMatrix_5 *positiveDefiniteMatrix_2 = NULL;
	struct Gaussian_3 *result = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
	struct Gaussian_3 *gaussian = NULL;

	if (!(__ContrRunti_1_insidContrEvalua > ((int32_t)4)))
	{
		bool_t boolean = false;
		bool_t boolean_1 = false;

		__ContrRunti_1_insidContrEvalua = __ContrRunti_1_insidContrEvalua + ((int32_t)1);
		boolean = Object_2_ReferenceEquals(&predictedState->base, NULL);
		if (!!boolean)
		{
			abort();
		}
		boolean_1 = Object_2_ReferenceEquals(&measurementModel->base.base.base.base.base, NULL);
		if (!!boolean_1)
		{
			abort();
		}
		__ContrRunti_1_insidContrEvalua = __ContrRunti_1_insidContrEvalua - ((int32_t)1);
	}
	caSpace = Gaussian_5_get_Expectation(predictedState);
	MeasuremenModel_3_set_Condition(&(*&measurementModel)->base.base.base.base, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	matrix = transitionMatrix;
	matrix_1 = MeasurModel_7_get_TransitMatrix(&(*&measurementModel)->base);
	(void)Assign_Matrix_13(&*matrix, matrix_1);
	(void)Assign_Matrix_13(&matrix_1, NULL);
	matrixData_1 = Matrix_13_get_MatrixData(*transitionMatrix);
	(void)Assign_MatrixData_2(&matrixData, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	(void)Assign_MatrixData_2(&matrixData_2, matrixData);
	positiveDefiniteMatrix = Gaussian_5_get_Covariance(predictedState);
	matrixData_3 = Matrix_10_get_MatrixData(&positiveDefiniteMatrix->base.base);
	matrixData_4 = MatrixMath_Multiply_18(false, false, true, matrixData_2, matrixData_3, matrixData);
	positiveDefiniteMatrix_1 = MeasuremeModel_3_get_Covariance(&(*&measurementModel)->base.base.base.base);
	matrixData_5 = Matrix_5_get_MatrixData(&positiveDefiniteMatrix_1->base.base);
	matrixData_6 = MatrixMath_Add_3(matrixData_4, matrixData_5);
	(void)Assign_MatrixData_2(&matrix_2, matrixData_6);
	(void)Assign_MatrixData_2(&matrixData_2, NULL);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix, NULL);
	(void)Assign_MatrixData_2(&matrixData_3, NULL);
	(void)Assign_MatrixData_2(&matrixData_4, NULL);
	(void)Assign_PositiveDefiniteMatrix_5(&positiveDefiniteMatrix_1, NULL);
	(void)Assign_MatrixData_2(&matrixData_5, NULL);
	(void)Assign_MatrixData_2(&matrixData_6, NULL);
	positiveDefiniteMatrix_2 = PosiDefinMatri_13_CreatAndCorre(matrix_2);
	(void)Assign_PositiveDefiniteMatrix_5(&covariance, positiveDefiniteMatrix_2);
	(void)Assign_PositiveDefiniteMatrix_5(&positiveDefiniteMatrix_2, NULL);
	frontRadarObjectSpace = MeasuremeModel_3_get_Expectatio(&(*&measurementModel)->base);
	gaussian = Gaussian_11_Create(frontRadarObjectSpace, covariance);
	(void)Assign_Gaussian_3(&result, gaussian);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	(void)Assign_Gaussian_3(&gaussian, NULL);
	RemRef_MatrixData_2(matrixData);
	RemRef_MatrixData_2(matrix_2);
	RemRef_PositiveDefiniteMatrix_5(covariance);
	return result;
}

int32_t StaticList_17_get_Count(struct StaticList_17 *const self)
{
	return self->Count;
}

static void StaticList_17_CheckCount(struct StaticList_17 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_17_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_17_set_Count(struct StaticList_17 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_17_Add(struct StaticList_17 *const self, struct Matrix_13 *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_17_CheckCount(self);
	int32 = StaticList_17_get_Count(self);
	count = int32;
	(void)Assign_Matrix_13(&self->_items->Elements[count], value);
	int32_1 = StaticList_17_get_Count(self);
	StaticList_17_set_Count(self, int32_1 + ((int32_t)1));
}

int32_t StaticList_21_get_Count(struct StaticList_21 *const self)
{
	return self->Count;
}

static void StaticList_21_CheckCount(struct StaticList_21 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_21_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_21_set_Count(struct StaticList_21 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_21_Add(struct StaticList_21 *const self, struct Gaussian_3 *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_21_CheckCount(self);
	int32 = StaticList_21_get_Count(self);
	count = int32;
	(void)Assign_Gaussian_3(&self->_items->Elements[count], value);
	int32_1 = StaticList_21_get_Count(self);
	StaticList_21_set_Count(self, int32_1 + ((int32_t)1));
}

struct PositiveDefiniteMatrix_5 *Gaussian_3_get_Covariance(struct Gaussian_3 *const self)
{
	struct PositiveDefiniteMatrix_5 *result = NULL;

	Gaussian_3_ResetCachedValues(self);
	(void)Assign_PositiveDefiniteMatrix_5(&result, self->covariance);
	return result;
}

static int32_t MatrixData_2_GetIndexTransposed(struct MatrixData_2 *const self, int32_t row, int32_t column)
{
	return (row * self->Columns) + column;
}

static int32_t MatrixData_2_GetIndex(struct MatrixData_2 *const self, int32_t row, int32_t column)
{
	return (column * self->Rows) + row;
}

struct MatrixData_2 *MatrixData_2_get_T(struct MatrixData_2 *const self)
{
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	struct float64_t_1D_25 *dataReference = NULL;
	struct float64_t_1D_25 *array = NULL;
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	struct MatrixData_2 *result = NULL;

	matrixData_1 = New_MatrixData_2();
	MatrixData_2_ctor(matrixData_1, self->Columns, self->Rows);
	(void)Assign_MatrixData_2(&matrixData, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	array = MatrixData_2_get_DataReference(matrixData);
	(void)Assign_float64_t_1D_25(&dataReference, array);
	(void)Assign_float64_t_1D_25(&array, NULL);
	i = ((int32_t)0);
	while (i < self->Rows)
	{
		j = ((int32_t)0);
		while (j < self->Columns)
		{
			struct float64_t_1D_25 *array_1 = NULL;
			int32_t int32 = ((int32_t)0);
			struct float64_t_1D_25 *array_2 = NULL;
			int32_t int32_1 = ((int32_t)0);

			(void)Assign_float64_t_1D_25(&array_1, dataReference);
			int32 = MatrixData_2_GetIndexTransposed(self, i, j);
			(void)Assign_float64_t_1D_25(&array_2, self->_data);
			int32_1 = MatrixData_2_GetIndex(self, i, j);
			array_1->Elements[int32] = array_2->Elements[int32_1];
			(void)Assign_float64_t_1D_25(&array_1, NULL);
			(void)Assign_float64_t_1D_25(&array_2, NULL);
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	(void)Assign_MatrixData_2(&result, matrixData);
	RemRef_MatrixData_2(matrixData);
	RemRef_float64_t_1D_25(dataReference);
	return result;
}

static void RemRef_SquareMatrix_5(struct SquareMatrix_5 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_SquareMatrix_5.CurrentCount--;
		Res_SquareMatrix_5.Next[Res_SquareMatrix_5.CurrentCount] = self;
		Del_SquareMatrix_5(self);
	}
}

struct SquareMatrix_5 *New_SquareMatrix_5(void)
{
	static struct SquareMatrix_5 const Default_SquareMatrix_5 = { 1 };
	struct SquareMatrix_5 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_SquareMatrix_5.CurrentCount == RC_SquareMatrix_5)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_SquareMatrix_5.Next[Res_SquareMatrix_5.CurrentCount];
	Res_SquareMatrix_5.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_SquareMatrix_5.MaximumCount = (Res_SquareMatrix_5.CurrentCount > Res_SquareMatrix_5.MaximumCount) ? Res_SquareMatrix_5.CurrentCount : Res_SquareMatrix_5.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_SquareMatrix_5;
	return instance;
}

struct SquareMatrix_5 *Assign_SquareMatrix_5(struct SquareMatrix_5 **const left, struct SquareMatrix_5 *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_SquareMatrix_5(*left);
	*left = right;
	return right;
}

struct SquareMatrix_5 *SquareMatrix_11_Create(struct MatrixData_2 *matrix)
{
	struct SquareMatrix_5 *result = NULL;
	struct SquareMatrix_5 *squareMatrix = NULL;

	squareMatrix = New_SquareMatrix_5();
	SquareMatrix_5_ctor(squareMatrix);
	Matrix_5_set_UncheckeMatrixData(&squareMatrix->base, matrix);
	(void)Assign_SquareMatrix_5(&result, squareMatrix);
	(void)Assign_SquareMatrix_5(&squareMatrix, NULL);
	return result;
}

struct SquareMatrix_5 *PosiDefinMatri_5_get_CholeDecom(struct PositiveDefiniteMatrix_5 *const self)
{
	struct MatrixData_2 *arg_3D_1 = NULL;
	struct SquareMatrix_5 *result = NULL;
	struct SquareMatrix_5 *squareMatrix = NULL;

	if (!(self->CachedCholeskyDecomposition != NULL))
	{
		bool_t boolean = false;

		boolean = Matrix_5_get_IsZero(&self->base.base);
		if (!boolean)
		{
			struct MatrixData_2 *matrixData = NULL;
			struct MatrixData_2 *matrixData_1 = NULL;
			struct MatrixData_2 *matrixData_2 = NULL;

			matrixData = Matrix_5_get_MatrixData(&self->base.base);
			matrixData_1 = MatrixMath_Chol(matrixData);
			matrixData_2 = MatrixData_2_get_T(matrixData_1);
			(void)Assign_MatrixData_2(&arg_3D_1, matrixData_2);
			(void)Assign_MatrixData_2(&matrixData, NULL);
			(void)Assign_MatrixData_2(&matrixData_1, NULL);
			(void)Assign_MatrixData_2(&matrixData_2, NULL);
		}
		else
		{
			struct MatrixData_2 *matrixData_3 = NULL;

			matrixData_3 = MatrixData_20_Zeros_1((&self->base.base)->Rows, (&self->base.base)->Columns);
			(void)Assign_MatrixData_2(&arg_3D_1, matrixData_3);
			(void)Assign_MatrixData_2(&matrixData_3, NULL);
		}
		(void)Assign_MatrixData_2(&self->CachedCholeskyDecomposition, arg_3D_1);
	}
	squareMatrix = SquareMatrix_11_Create(self->CachedCholeskyDecomposition);
	(void)Assign_SquareMatrix_5(&result, squareMatrix);
	(void)Assign_SquareMatrix_5(&squareMatrix, NULL);
	RemRef_MatrixData_2(arg_3D_1);
	return result;
}

struct FrontRadarObjectSpace *Gaussian_3_get_Expectation(struct Gaussian_3 *const self)
{
	struct FrontRadarObjectSpace *result = NULL;

	(void)Assign_FrontRadarObjectSpace(&result, self->Expectation);
	return result;
}

static void RemRef_MatrixData_19(struct MatrixData_19 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_19.CurrentCount--;
		Res_MatrixData_19.Next[Res_MatrixData_19.CurrentCount] = self;
		Del_MatrixData_19(self);
	}
}

struct MatrixData_19 *New_MatrixData_19(void)
{
	static struct MatrixData_19 const Default_MatrixData_19 = { 1 };
	struct MatrixData_19 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_19.CurrentCount == RC_MatrixData_19)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_19.Next[Res_MatrixData_19.CurrentCount];
	Res_MatrixData_19.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_19.MaximumCount = (Res_MatrixData_19.CurrentCount > Res_MatrixData_19.MaximumCount) ? Res_MatrixData_19.CurrentCount : Res_MatrixData_19.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_19;
	return instance;
}

struct MatrixData_19 *Assign_MatrixData_19(struct MatrixData_19 **const left, struct MatrixData_19 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_19(*left);
	*left = right;
	return right;
}

static void Del_float64_t_1D_250(struct float64_t_1D_250 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_float64_t_1D_250(struct float64_t_1D_250 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_float64_t_1D_250.CurrentCount--;
		Res_float64_t_1D_250.Next[Res_float64_t_1D_250.CurrentCount] = self;
		Del_float64_t_1D_250(self);
	}
}

struct float64_t_1D_250 *New_float64_t_1D_250(void)
{
	static struct float64_t_1D_250 const Default_float64_t_1D_250 = { 1 };
	struct float64_t_1D_250 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_float64_t_1D_250.CurrentCount == RC_float64_t_1D_250)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_float64_t_1D_250.Next[Res_float64_t_1D_250.CurrentCount];
	Res_float64_t_1D_250.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_float64_t_1D_250.MaximumCount = (Res_float64_t_1D_250.CurrentCount > Res_float64_t_1D_250.MaximumCount) ? Res_float64_t_1D_250.CurrentCount : Res_float64_t_1D_250.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_float64_t_1D_250;
	return instance;
}

struct float64_t_1D_250 *Assign_float64_t_1D_250(struct float64_t_1D_250 **const left, struct float64_t_1D_250 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_float64_t_1D_250(*left);
	*left = right;
	return right;
}

void MatrixData_19_ctor(struct MatrixData_19 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_250 *array = NULL;

	assert(rows == ((int32_t)5));
	assert(columns == ((int32_t)50));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_250();
	(void)Assign_float64_t_1D_250(&self->_data, array);
	(void)Assign_float64_t_1D_250(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct float64_t_1D_250 *MatrixData_19_get_DataReference(struct MatrixData_19 *const self)
{
	struct float64_t_1D_250 *result = NULL;

	(void)Assign_float64_t_1D_250(&result, self->_data);
	return result;
}

static struct MatrixData_19 *Tracking_1_CreateRandnMatrix_1(int32_t rows, int32_t columns)
{
	struct MatrixData_19 *obj = NULL;
	struct MatrixData_19 *matrixData = NULL;
	struct float64_t_1D_250 *data = NULL;
	struct float64_t_1D_250 *array = NULL;
	int32_t i = ((int32_t)0);
	struct Random *random = NULL;
	struct Random *random_1 = NULL;
	float64_t u = 0.0;
	float64_t v = 0.0;
	float64_t combined = 0.0;
	float64_t u_1 = 0.0;
	float64_t v_1 = 0.0;
	float64_t combined_1 = 0.0;
	struct MatrixData_19 *result = NULL;

	assert(rows == ((int32_t)5));
	assert(columns == ((int32_t)50));
	matrixData = New_MatrixData_19();
	MatrixData_19_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData_19(&obj, matrixData);
	(void)Assign_MatrixData_19(&matrixData, NULL);
	array = MatrixData_19_get_DataReference(obj);
	(void)Assign_float64_t_1D_250(&data, array);
	(void)Assign_float64_t_1D_250(&array, NULL);
	i = ((int32_t)0);
	random_1 = New_Random();
	Random_ctor_1(random_1);
	(void)Assign_Random(&random, random_1);
	(void)Assign_Random(&random_1, NULL);
	while (i < (((int32_t)250) - ((int32_t)1)))
	{
		float64_t double_ = 0.0;
		float64_t double__1 = 0.0;
		float64_t double__2 = 0.0;

		while (true)
		{
			float64_t double__3 = 0.0;
			float64_t double__4 = 0.0;
			bool_t boolean = false;
			bool_t boolean_1 = false;
			bool_t boolean_2 = false;

			double__3 = Random_NextDouble(random);
			u = (2.0 * double__3) - 1.0;
			double__4 = Random_NextDouble(random);
			v = (2.0 * double__4) - 1.0;
			combined = (u * u) + (v * v);
			boolean_1 = combined >= 1.0;
			if (boolean_1 == false)
			{
				boolean = float64_t_Equals(&combined, 0.0);
				boolean_2 = boolean;
			}
			else
			{
				boolean_2 = true;
			}
			if (!boolean_2)
			{
				break;
			}
		}
		double_ = Math_Log(combined);
		double__1 = -2.0 * double_;
		double__2 = Math_Sqrt(double__1 / combined);
		combined = double__2;
		data->Elements[i] = u * combined;
		data->Elements[i + ((int32_t)1)] = v * combined;
		i = i + ((int32_t)2);
	}
	if (!(i >= ((int32_t)250)))
	{
		float64_t double__5 = 0.0;
		float64_t double__6 = 0.0;
		float64_t double__7 = 0.0;

		while (true)
		{
			float64_t double__8 = 0.0;
			float64_t double__9 = 0.0;
			bool_t boolean_3 = false;
			bool_t boolean_4 = false;
			bool_t boolean_5 = false;

			double__8 = Random_NextDouble(random);
			u_1 = (2.0 * double__8) - 1.0;
			double__9 = Random_NextDouble(random);
			v_1 = (2.0 * double__9) - 1.0;
			combined_1 = (u_1 * u_1) + (v_1 * v_1);
			boolean_4 = combined_1 >= 1.0;
			if (boolean_4 == false)
			{
				boolean_3 = float64_t_Equals(&combined_1, 0.0);
				boolean_5 = boolean_3;
			}
			else
			{
				boolean_5 = true;
			}
			if (!boolean_5)
			{
				break;
			}
		}
		double__5 = Math_Log(combined_1);
		double__6 = -2.0 * double__5;
		double__7 = Math_Sqrt(double__6 / combined_1);
		combined_1 = double__7;
		data->Elements[i] = u_1 * combined_1;
	}
	(void)Assign_MatrixData_19(&result, obj);
	RemRef_MatrixData_19(obj);
	RemRef_float64_t_1D_250(data);
	RemRef_Random(random);
	return result;
}

void LinearAlgebra_MatrixMultiply_21(struct LinearAlgebra *const self, struct float64_t_1D_25 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_250 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_250 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)25) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)250) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)25) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)25) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)250) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)250) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)25) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)250) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_19 *MatrixMath_Multiply_38(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_2 *left, struct MatrixData_19 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_19 *matrixData = NULL;
	struct MatrixData_19 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_25 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_250 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_250 *array_2 = NULL;
	struct MatrixData_19 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == false);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Columns;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_19();
	MatrixData_19_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_19(&matrixData, matrixData_1);
	(void)Assign_MatrixData_19(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_2_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_19_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_19_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_21(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_25(&array, NULL);
	(void)Assign_float64_t_1D_250(&array_1, NULL);
	(void)Assign_float64_t_1D_250(&array_2, NULL);
	(void)Assign_MatrixData_19(&result, matrixData);
	RemRef_MatrixData_19(matrixData);
	return result;
}

struct MatrixData_19 *MatrixMath_Multiply_39(struct MatrixData_2 *left, struct MatrixData_19 *right)
{
	struct MatrixData_19 *result = NULL;
	struct MatrixData_19 *matrixData = NULL;

	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	matrixData = MatrixMath_Multiply_38(false, false, left, right);
	(void)Assign_MatrixData_19(&result, matrixData);
	(void)Assign_MatrixData_19(&matrixData, NULL);
	return result;
}

static void RemRef_StaticList_10(struct StaticList_10 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_10.CurrentCount--;
		Res_StaticList_10.Next[Res_StaticList_10.CurrentCount] = self;
		Del_StaticList_10(self);
	}
}

struct StaticList_10 *New_StaticList_10(void)
{
	static struct StaticList_10 const Default_StaticList_10 = { 1 };
	struct StaticList_10 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_10.CurrentCount == RC_StaticList_10)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_10.Next[Res_StaticList_10.CurrentCount];
	Res_StaticList_10.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_10.MaximumCount = (Res_StaticList_10.CurrentCount > Res_StaticList_10.MaximumCount) ? Res_StaticList_10.CurrentCount : Res_StaticList_10.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_10;
	return instance;
}

struct StaticList_10 *Assign_StaticList_10(struct StaticList_10 **const left, struct StaticList_10 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_10(*left);
	*left = right;
	return right;
}

static void Del_FrontRadarObjectSpace_1D_50(struct FrontRadarObjectSpace_1D_50 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)50);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_FrontRadarObjectSpace(self->Elements[i]);
	}
}

static void RemRef_FronRadaObjecSpace_1D_50(struct FrontRadarObjectSpace_1D_50 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_FrontRadarObjectSpace_1D_50.CurrentCount--;
		Res_FrontRadarObjectSpace_1D_50.Next[Res_FrontRadarObjectSpace_1D_50.CurrentCount] = self;
		Del_FrontRadarObjectSpace_1D_50(self);
	}
}

struct FrontRadarObjectSpace_1D_50 *New_FrontRadarObjectSpace_1D_50(void)
{
	static struct FrontRadarObjectSpace_1D_50 const Defa_FrontRadarObjecSpace_1D_50 = { 1 };
	struct FrontRadarObjectSpace_1D_50 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_FrontRadarObjectSpace_1D_50.CurrentCount == RC_FrontRadarObjectSpace_1D_50)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_FrontRadarObjectSpace_1D_50.Next[Res_FrontRadarObjectSpace_1D_50.CurrentCount];
	Res_FrontRadarObjectSpace_1D_50.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_FrontRadarObjectSpace_1D_50.MaximumCount = (Res_FrontRadarObjectSpace_1D_50.CurrentCount > Res_FrontRadarObjectSpace_1D_50.MaximumCount) ? Res_FrontRadarObjectSpace_1D_50.CurrentCount : Res_FrontRadarObjectSpace_1D_50.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Defa_FrontRadarObjecSpace_1D_50;
	return instance;
}

struct FrontRadarObjectSpace_1D_50 *Assi_FrontRadarObjecSpace_1D_50(struct FrontRadarObjectSpace_1D_50 **const left, struct FrontRadarObjectSpace_1D_50 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_FronRadaObjecSpace_1D_50(*left);
	*left = right;
	return right;
}

void StaticList_10_ctor(struct StaticList_10 *const self, int32_t maximumCount)
{
	struct FrontRadarObjectSpace_1D_50 *array = NULL;

	assert(maximumCount == ((int32_t)50));
	Object_ctor(&self->base);
	array = New_FrontRadarObjectSpace_1D_50();
	(void)Assi_FrontRadarObjecSpace_1D_50(&self->_items, array);
	(void)Assi_FrontRadarObjecSpace_1D_50(&array, NULL);
	self->MaximumCount = maximumCount;
}

int32_t StaticList_10_get_Count(struct StaticList_10 *const self)
{
	return self->Count;
}

static void StaticList_10_CheckCount(struct StaticList_10 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_10_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_10_set_Count(struct StaticList_10 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_10_Add(struct StaticList_10 *const self, struct FrontRadarObjectSpace *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_10_CheckCount(self);
	int32 = StaticList_10_get_Count(self);
	count = int32;
	(void)Assign_FrontRadarObjectSpace(&self->_items->Elements[count], value);
	int32_1 = StaticList_10_get_Count(self);
	StaticList_10_set_Count(self, int32_1 + ((int32_t)1));
}

void StaticList_10_set_Item(struct StaticList_10 *const self, int32_t index, struct FrontRadarObjectSpace *value)
{
	(void)Assign_FrontRadarObjectSpace(&self->_items->Elements[index], value);
}

struct FrontRadarObjectSpace *StaticList_10_get_Item(struct StaticList_10 *const self, int32_t index)
{
	struct FrontRadarObjectSpace *result = NULL;

	(void)Assign_FrontRadarObjectSpace(&result, self->_items->Elements[index]);
	return result;
}

static struct StaticList_10 *Tracking_1_Draw_1(struct Gaussian_3 *state, int32_t count)
{
	struct MatrixData_19 *x = NULL;
	struct PositiveDefiniteMatrix_5 *positiveDefiniteMatrix = NULL;
	struct SquareMatrix_5 *squareMatrix = NULL;
	struct MatrixData_2 *matrixData = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
	int32_t int32 = ((int32_t)0);
	struct MatrixData_19 *matrixData_1 = NULL;
	struct MatrixData_19 *matrixData_2 = NULL;
	struct StaticList_10 *samples = NULL;
	struct StaticList_10 *staticList = NULL;
	int32_t i = ((int32_t)0);
	int32_t writeSampleIndex = ((int32_t)0);
	int32_t writeDimensionIndex = ((int32_t)0);
	int32_t readElementIndex = ((int32_t)0);
	struct FrontRadarObjectSpace *CS_0_0001 = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace_1 = NULL;
	struct float64_t_1D_5 *expectation = NULL;
	struct MatrixData *matrixData_3 = NULL;
	struct float64_t_1D_5 *array = NULL;
	struct float64_t_1D_250 *matrix = NULL;
	struct float64_t_1D_250 *array_1 = NULL;
	struct FrontRadarObjectSpace *CS_0_0002 = NULL;
	struct StaticList_10 *result = NULL;

	assert(count == ((int32_t)50));
	positiveDefiniteMatrix = Gaussian_3_get_Covariance(state);
	squareMatrix = PosiDefinMatri_5_get_CholeDecom(positiveDefiniteMatrix);
	matrixData = Matrix_5_get_MatrixData(&squareMatrix->base);
	frontRadarObjectSpace = Gaussian_3_get_Expectation(state);
	int32 = (&frontRadarObjectSpace->base.base)->Dimensions;
	matrixData_1 = Tracking_1_CreateRandnMatrix_1(int32, count);
	matrixData_2 = MatrixMath_Multiply_39(matrixData, matrixData_1);
	(void)Assign_MatrixData_19(&x, matrixData_2);
	(void)Assign_PositiveDefiniteMatrix_5(&positiveDefiniteMatrix, NULL);
	(void)Assign_SquareMatrix_5(&squareMatrix, NULL);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	(void)Assign_MatrixData_19(&matrixData_1, NULL);
	(void)Assign_MatrixData_19(&matrixData_2, NULL);
	staticList = New_StaticList_10();
	StaticList_10_ctor(staticList, count);
	(void)Assign_StaticList_10(&samples, staticList);
	(void)Assign_StaticList_10(&staticList, NULL);
	i = ((int32_t)0);
	while (i < count)
	{
		StaticList_10_Add(samples, NULL);
		i = i + ((int32_t)1);
	}
	writeSampleIndex = ((int32_t)0);
	writeDimensionIndex = ((int32_t)0);
	readElementIndex = ((int32_t)0);
	frontRadarObjectSpace_1 = Gaussian_3_get_Expectation(state);
	(void)Assign_FrontRadarObjectSpace(&CS_0_0001, frontRadarObjectSpace_1);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_1, NULL);
	matrixData_3 = Space_get_MatrixData(&(*&CS_0_0001)->base.base);
	array = MatrixData_get_DataReference(matrixData_3);
	(void)Assign_float64_t_1D_5(&expectation, array);
	(void)Assign_MatrixData(&matrixData_3, NULL);
	(void)Assign_float64_t_1D_5(&array, NULL);
	array_1 = MatrixData_19_get_DataReference(x);
	(void)Assign_float64_t_1D_250(&matrix, array_1);
	(void)Assign_float64_t_1D_250(&array_1, NULL);
	while (readElementIndex < (x->Rows * x->Columns))
	{
		struct FrontRadarObjectSpace *frontRadarObjectSpace_2 = NULL;
		struct MatrixData *matrixData_4 = NULL;
		struct float64_t_1D_5 *array_2 = NULL;
		int32_t int32_1 = ((int32_t)0);
		struct float64_t_1D_250 *array_3 = NULL;
		float64_t double_ = 0.0;
		int32_t int32_2 = ((int32_t)0);
		struct FrontRadarObjectSpace *frontRadarObjectSpace_3 = NULL;

		if (!(writeDimensionIndex != ((int32_t)0)))
		{
			struct StaticList_10 *staticList_1 = NULL;
			int32_t int32_3 = ((int32_t)0);
			struct FrontRadarObjectSpace *frontRadarObjectSpace_4 = NULL;

			(void)Assign_StaticList_10(&staticList_1, samples);
			int32_3 = writeSampleIndex;
			frontRadarObjectSpace_4 = New_FrontRadarObjectSpace();
			FrontRadarObjectSpace_ctor(frontRadarObjectSpace_4);
			StaticList_10_set_Item(staticList_1, int32_3, frontRadarObjectSpace_4);
			(void)Assign_StaticList_10(&staticList_1, NULL);
			(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_4, NULL);
		}
		frontRadarObjectSpace_2 = StaticList_10_get_Item(samples, writeSampleIndex);
		(void)Assign_FrontRadarObjectSpace(&CS_0_0002, frontRadarObjectSpace_2);
		(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_2, NULL);
		matrixData_4 = Space_get_MatrixData(&(*&CS_0_0002)->base.base);
		array_2 = MatrixData_get_DataReference(matrixData_4);
		int32_1 = writeDimensionIndex;
		(void)Assign_float64_t_1D_250(&array_3, matrix);
		double_ = array_3->Elements[(*&readElementIndex)++];
		array_2->Elements[int32_1] = double_ + expectation->Elements[writeDimensionIndex];
		(void)Assign_MatrixData(&matrixData_4, NULL);
		(void)Assign_float64_t_1D_5(&array_2, NULL);
		(void)Assign_float64_t_1D_250(&array_3, NULL);
		writeDimensionIndex = writeDimensionIndex + ((int32_t)1);
		int32_2 = writeDimensionIndex;
		frontRadarObjectSpace_3 = Gaussian_3_get_Expectation(state);
		if (!((int32_2 % (&frontRadarObjectSpace_3->base.base)->Dimensions) != ((int32_t)0)))
		{
			(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_3, NULL);
			writeDimensionIndex = ((int32_t)0);
			writeSampleIndex = writeSampleIndex + ((int32_t)1);
		}
		else
		{
			(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_3, NULL);
		}
	}
	(void)Assign_StaticList_10(&result, samples);
	RemRef_MatrixData_19(x);
	RemRef_StaticList_10(samples);
	RemRef_FrontRadarObjectSpace(CS_0_0001);
	RemRef_float64_t_1D_5(expectation);
	RemRef_float64_t_1D_250(matrix);
	RemRef_FrontRadarObjectSpace(CS_0_0002);
	return result;
}

static void SampleSet_4_cctor(void)
{
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;

	frontRadarObjectSpace = New_FrontRadarObjectSpace();
	FrontRadarObjectSpace_ctor(frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&SampleSet_4_EmptySample, frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
}

static void RemRef_SampleSet_1(struct SampleSet_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_SampleSet_1.CurrentCount--;
		Res_SampleSet_1.Next[Res_SampleSet_1.CurrentCount] = self;
		Del_SampleSet_1(self);
	}
}

struct SampleSet_1 *New_SampleSet_1(void)
{
	static struct SampleSet_1 const Default_SampleSet_1 = { 1 };
	struct SampleSet_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_SampleSet_1.CurrentCount == RC_SampleSet_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_SampleSet_1.Next[Res_SampleSet_1.CurrentCount];
	Res_SampleSet_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_SampleSet_1.MaximumCount = (Res_SampleSet_1.CurrentCount > Res_SampleSet_1.MaximumCount) ? Res_SampleSet_1.CurrentCount : Res_SampleSet_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_SampleSet_1;
	return instance;
}

struct SampleSet_1 *Assign_SampleSet_1(struct SampleSet_1 **const left, struct SampleSet_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_SampleSet_1(*left);
	*left = right;
	return right;
}

static void RemRef_StaticList_14(struct StaticList_14 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_14.CurrentCount--;
		Res_StaticList_14.Next[Res_StaticList_14.CurrentCount] = self;
		Del_StaticList_14(self);
	}
}

struct StaticList_14 *New_StaticList_14(void)
{
	static struct StaticList_14 const Default_StaticList_14 = { 1 };
	struct StaticList_14 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_14.CurrentCount == RC_StaticList_14)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_14.Next[Res_StaticList_14.CurrentCount];
	Res_StaticList_14.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_14.MaximumCount = (Res_StaticList_14.CurrentCount > Res_StaticList_14.MaximumCount) ? Res_StaticList_14.CurrentCount : Res_StaticList_14.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_14;
	return instance;
}

struct StaticList_14 *Assign_StaticList_14(struct StaticList_14 **const left, struct StaticList_14 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_14(*left);
	*left = right;
	return right;
}

static void RemRef_SampleProbabilityPair_1(struct SampleProbabilityPair_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_SampleProbabilityPair_1.CurrentCount--;
		Res_SampleProbabilityPair_1.Next[Res_SampleProbabilityPair_1.CurrentCount] = self;
		Del_SampleProbabilityPair_1(self);
	}
}

struct SampleProbabilityPair_1 *New_SampleProbabilityPair_1(void)
{
	static struct SampleProbabilityPair_1 const Default_SampleProbabilityPair_1 = { 1 };
	struct SampleProbabilityPair_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_SampleProbabilityPair_1.CurrentCount == RC_SampleProbabilityPair_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_SampleProbabilityPair_1.Next[Res_SampleProbabilityPair_1.CurrentCount];
	Res_SampleProbabilityPair_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_SampleProbabilityPair_1.MaximumCount = (Res_SampleProbabilityPair_1.CurrentCount > Res_SampleProbabilityPair_1.MaximumCount) ? Res_SampleProbabilityPair_1.CurrentCount : Res_SampleProbabilityPair_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_SampleProbabilityPair_1;
	return instance;
}

struct SampleProbabilityPair_1 *Assign_SampleProbabilityPair_1(struct SampleProbabilityPair_1 **const left, struct SampleProbabilityPair_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_SampleProbabilityPair_1(*left);
	*left = right;
	return right;
}

static void Del_SampleProbabiliPair_1_1D_50(struct SampleProbabilityPair_1_1D_50 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)50);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_SampleProbabilityPair_1(self->Elements[i]);
	}
}

static void RemRef_SampleProbabPair_1_1D_50(struct SampleProbabilityPair_1_1D_50 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_SampleProbabiliPair_1_1D_50.CurrentCount--;
		Res_SampleProbabiliPair_1_1D_50.Next[Res_SampleProbabiliPair_1_1D_50.CurrentCount] = self;
		Del_SampleProbabiliPair_1_1D_50(self);
	}
}

struct SampleProbabilityPair_1_1D_50 *New_SampleProbabiliPair_1_1D_50(void)
{
	static struct SampleProbabilityPair_1_1D_50 const Defaul_SampleProbabPair_1_1D_50 = { 1 };
	struct SampleProbabilityPair_1_1D_50 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_SampleProbabiliPair_1_1D_50.CurrentCount == RC_SampleProbabilitPair_1_1D_50)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_SampleProbabiliPair_1_1D_50.Next[Res_SampleProbabiliPair_1_1D_50.CurrentCount];
	Res_SampleProbabiliPair_1_1D_50.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_SampleProbabiliPair_1_1D_50.MaximumCount = (Res_SampleProbabiliPair_1_1D_50.CurrentCount > Res_SampleProbabiliPair_1_1D_50.MaximumCount) ? Res_SampleProbabiliPair_1_1D_50.CurrentCount : Res_SampleProbabiliPair_1_1D_50.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Defaul_SampleProbabPair_1_1D_50;
	return instance;
}

struct SampleProbabilityPair_1_1D_50 *Assign_SampleProbabPair_1_1D_50(struct SampleProbabilityPair_1_1D_50 **const left, struct SampleProbabilityPair_1_1D_50 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_SampleProbabPair_1_1D_50(*left);
	*left = right;
	return right;
}

void StaticList_14_ctor(struct StaticList_14 *const self, int32_t maximumCount)
{
	struct SampleProbabilityPair_1_1D_50 *array = NULL;

	assert(maximumCount == ((int32_t)50));
	Object_ctor(&self->base);
	array = New_SampleProbabiliPair_1_1D_50();
	(void)Assign_SampleProbabPair_1_1D_50(&self->_items, array);
	(void)Assign_SampleProbabPair_1_1D_50(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_14 *StatiListFactor_1_CreateInstan(struct StaticListFactory_1 *const self, int32_t capacity)
{
	struct StaticList_14 *result = NULL;
	struct StaticList_14 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_1_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_14();
	StaticList_14_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_14(&result, staticList);
	(void)Assign_StaticList_14(&staticList, NULL);
	return result;
}

static void SampleSet_1_set_Samples(struct SampleSet_1 *const self, struct StaticList_14 *value)
{
	(void)Assign_StaticList_14(&self->Samples, value);
}

void SampleSet_1_ctor(struct SampleSet_1 *const self, int32_t capacity, struct StaticListFactory_1 *listFactory)
{
	struct UniformRandomGenerator *uniformRandomGenerator = NULL;
	struct StaticListFactory_1 *arg_1F_1 = NULL;
	struct StaticList_14 *staticList = NULL;

	uniformRandomGenerator = New_UniformRandomGenerator();
	UniformRandomGenerator_ctor(uniformRandomGenerator);
	(void)Assign_UniformRandomGenerator(&self->_randomGenerator, uniformRandomGenerator);
	(void)Assign_UniformRandomGenerator(&uniformRandomGenerator, NULL);
	Object_ctor(&self->base);
	(void)Assign_StaticListFactory_1(&arg_1F_1, listFactory);
	(void)Assign_StaticListFactory_1(&self->_listFactory, arg_1F_1);
	staticList = StatiListFactor_1_CreateInstan(self->_listFactory, capacity);
	SampleSet_1_set_Samples(self, staticList);
	(void)Assign_StaticList_14(&staticList, NULL);
	RemRef_StaticListFactory_1(arg_1F_1);
}

void SampleSet_1_ctor_1(struct SampleSet_1 *const self, struct StaticListFactory_1 *listFactory)
{
	SampleSet_1_ctor(self, ((int32_t)0), listFactory);
}

static void RemRef_StaticListEnumerator_6(struct StaticListEnumerator_6 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListEnumerator_6.CurrentCount--;
		Res_StaticListEnumerator_6.Next[Res_StaticListEnumerator_6.CurrentCount] = self;
		Del_StaticListEnumerator_6(self);
	}
}

struct StaticListEnumerator_6 *New_StaticListEnumerator_6(void)
{
	static struct StaticListEnumerator_6 const Default_StaticListEnumerator_6 = { 1 };
	struct StaticListEnumerator_6 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListEnumerator_6.CurrentCount == RC_StaticListEnumerator_6)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListEnumerator_6.Next[Res_StaticListEnumerator_6.CurrentCount];
	Res_StaticListEnumerator_6.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListEnumerator_6.MaximumCount = (Res_StaticListEnumerator_6.CurrentCount > Res_StaticListEnumerator_6.MaximumCount) ? Res_StaticListEnumerator_6.CurrentCount : Res_StaticListEnumerator_6.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListEnumerator_6;
	return instance;
}

struct StaticListEnumerator_6 *Assign_StaticListEnumerator_6(struct StaticListEnumerator_6 **const left, struct StaticListEnumerator_6 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListEnumerator_6(*left);
	*left = right;
	return right;
}

void StaticListEnumerator_6_ctor(struct StaticListEnumerator_6 *const self, struct StaticList_10 *list)
{
	self->_current = ((int32_t)-1);
	Object_ctor(&self->base);
	(void)Assign_StaticList_10(&self->_list, list);
}

struct StaticListEnumerator_6 *StaticList_10_GetEnumerator(struct StaticList_10 *const self)
{
	struct StaticListEnumerator_6 *result = NULL;
	struct StaticListEnumerator_6 *staticListEnumerator = NULL;

	staticListEnumerator = New_StaticListEnumerator_6();
	StaticListEnumerator_6_ctor(staticListEnumerator, self);
	(void)Assign_StaticListEnumerator_6(&result, staticListEnumerator);
	(void)Assign_StaticListEnumerator_6(&staticListEnumerator, NULL);
	return result;
}

bool_t StaticListEnumerator_6_MoveNext(struct StaticListEnumerator_6 *const self)
{
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	self->_current = self->_current + ((int32_t)1);
	int32 = self->_current;
	int32_1 = StaticList_10_get_Count(self->_list);
	return int32 != int32_1;
}

struct FrontRadarObjectSpace *StaticListEnumera_6_get_Current(struct StaticListEnumerator_6 *const self)
{
	struct FrontRadarObjectSpace *result = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;

	frontRadarObjectSpace = StaticList_10_get_Item(self->_list, self->_current);
	(void)Assign_FrontRadarObjectSpace(&result, frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	return result;
}

static struct FrontRadarObjectSpace *Object_MemberwiseClone_3(struct FrontRadarObjectSpace *const self)
{
	struct FrontRadarObjectSpace *result;

	result = New_FrontRadarObjectSpace();
	*result = *self;
	(&result->base.base.base)->ReferenceCount = ((int32_t)1);
	Clone_FrontRadarObjectSpace(result);
	return result;
}

static struct FrontRadarObjectSpace *Space_ShallowCopy_1(struct FrontRadarObjectSpace *const self)
{
	struct FrontRadarObjectSpace *space = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
	struct FrontRadarObjectSpace *result = NULL;

	frontRadarObjectSpace = Object_MemberwiseClone_3(self);
	(void)Assign_FrontRadarObjectSpace(&space, frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	if (!!((&self->base.base)->_vector != NULL))
	{
		struct FrontRadarObjectSpace *frontRadarObjectSpace_1 = NULL;
		struct MatrixData *matrixData = NULL;

		(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_1, space);
		matrixData = MatrixData_get_Copy((&self->base.base)->_vector);
		(void)Assign_MatrixData(&(&frontRadarObjectSpace_1->base.base)->_vector, matrixData);
		(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_1, NULL);
		(void)Assign_MatrixData(&matrixData, NULL);
	}
	if (!!((&self->base.base)->_spaceInformationLock != NULL))
	{
		struct FrontRadarObjectSpace *frontRadarObjectSpace_2 = NULL;
		struct Object *object = NULL;

		(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_2, space);
		object = New_Object();
		Object_ctor(object);
		(void)Assign_Object(&(&frontRadarObjectSpace_2->base.base)->_spaceInformationLock, object);
		(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_2, NULL);
		(void)Assign_Object(&object, NULL);
	}
	(void)Assign_FrontRadarObjectSpace(&result, space);
	RemRef_FrontRadarObjectSpace(space);
	return result;
}

struct FrontRadarObjectSpace *SpaceExtensions_Clone_3(struct FrontRadarObjectSpace *space)
{
	struct FrontRadarObjectSpace *result = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;

	frontRadarObjectSpace = Space_ShallowCopy_1(space);
	(void)Assign_FrontRadarObjectSpace(&result, frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	return result;
}

static struct StaticList_14 *SampleSet_1_get_Samples(struct SampleSet_1 *const self)
{
	struct StaticList_14 *result = NULL;

	(void)Assign_StaticList_14(&result, self->Samples);
	return result;
}

void SampleProbabilPair_1_set_Sample(struct SampleProbabilityPair_1 *const self, struct FrontRadarObjectSpace *value)
{
	(void)Assign_FrontRadarObjectSpace(&self->Sample, value);
}

void SampleProbabiPair_1_set_Probabi(struct SampleProbabilityPair_1 *const self, float64_t value)
{
	self->Probability = value;
}

void SampleProbabilityPair_1_ctor(struct SampleProbabilityPair_1 *const self, struct FrontRadarObjectSpace *sample, float64_t probability)
{
	Object_ctor(&self->base);
	SampleProbabilPair_1_set_Sample(self, sample);
	SampleProbabiPair_1_set_Probabi(self, probability);
}

int32_t StaticList_14_get_Count(struct StaticList_14 *const self)
{
	return self->Count;
}

static void StaticList_14_CheckCount(struct StaticList_14 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_14_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_14_set_Count(struct StaticList_14 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_14_Add(struct StaticList_14 *const self, struct SampleProbabilityPair_1 *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_14_CheckCount(self);
	int32 = StaticList_14_get_Count(self);
	count = int32;
	(void)Assign_SampleProbabilityPair_1(&self->_items->Elements[count], value);
	int32_1 = StaticList_14_get_Count(self);
	StaticList_14_set_Count(self, int32_1 + ((int32_t)1));
}

void SampleSet_1_Add(struct SampleSet_1 *const self, struct FrontRadarObjectSpace *sample, float64_t probability)
{
	struct StaticList_14 *staticList = NULL;
	struct SampleProbabilityPair_1 *sampleProbabilityPair = NULL;

	if (!(probability >= 0.0))
	{
		abort();
	}
	staticList = SampleSet_1_get_Samples(self);
	sampleProbabilityPair = New_SampleProbabilityPair_1();
	SampleProbabilityPair_1_ctor(sampleProbabilityPair, sample, probability);
	StaticList_14_Add(staticList, sampleProbabilityPair);
	(void)Assign_StaticList_14(&staticList, NULL);
	(void)Assign_SampleProbabilityPair_1(&sampleProbabilityPair, NULL);
}

void StaticListEnumerator_6_Dispose(struct StaticListEnumerator_6 *const self)
{
}

static void RemRef_StaticListEnumerator_9(struct StaticListEnumerator_9 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListEnumerator_9.CurrentCount--;
		Res_StaticListEnumerator_9.Next[Res_StaticListEnumerator_9.CurrentCount] = self;
		Del_StaticListEnumerator_9(self);
	}
}

struct StaticListEnumerator_9 *New_StaticListEnumerator_9(void)
{
	static struct StaticListEnumerator_9 const Default_StaticListEnumerator_9 = { 1 };
	struct StaticListEnumerator_9 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListEnumerator_9.CurrentCount == RC_StaticListEnumerator_9)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListEnumerator_9.Next[Res_StaticListEnumerator_9.CurrentCount];
	Res_StaticListEnumerator_9.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListEnumerator_9.MaximumCount = (Res_StaticListEnumerator_9.CurrentCount > Res_StaticListEnumerator_9.MaximumCount) ? Res_StaticListEnumerator_9.CurrentCount : Res_StaticListEnumerator_9.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListEnumerator_9;
	return instance;
}

struct StaticListEnumerator_9 *Assign_StaticListEnumerator_9(struct StaticListEnumerator_9 **const left, struct StaticListEnumerator_9 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListEnumerator_9(*left);
	*left = right;
	return right;
}

void StaticListEnumerator_9_ctor(struct StaticListEnumerator_9 *const self, struct StaticList_14 *list)
{
	self->_current = ((int32_t)-1);
	Object_ctor(&self->base);
	(void)Assign_StaticList_14(&self->_list, list);
}

struct StaticListEnumerator_9 *StaticList_14_GetEnumerator(struct StaticList_14 *const self)
{
	struct StaticListEnumerator_9 *result = NULL;
	struct StaticListEnumerator_9 *staticListEnumerator = NULL;

	staticListEnumerator = New_StaticListEnumerator_9();
	StaticListEnumerator_9_ctor(staticListEnumerator, self);
	(void)Assign_StaticListEnumerator_9(&result, staticListEnumerator);
	(void)Assign_StaticListEnumerator_9(&staticListEnumerator, NULL);
	return result;
}

bool_t StaticListEnumerator_9_MoveNext(struct StaticListEnumerator_9 *const self)
{
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	self->_current = self->_current + ((int32_t)1);
	int32 = self->_current;
	int32_1 = StaticList_14_get_Count(self->_list);
	return int32 != int32_1;
}

struct SampleProbabilityPair_1 *StaticList_14_get_Item(struct StaticList_14 *const self, int32_t index)
{
	struct SampleProbabilityPair_1 *result = NULL;

	(void)Assign_SampleProbabilityPair_1(&result, self->_items->Elements[index]);
	return result;
}

struct SampleProbabilityPair_1 *StaticListEnumera_9_get_Current(struct StaticListEnumerator_9 *const self)
{
	struct SampleProbabilityPair_1 *result = NULL;
	struct SampleProbabilityPair_1 *sampleProbabilityPair = NULL;

	sampleProbabilityPair = StaticList_14_get_Item(self->_list, self->_current);
	(void)Assign_SampleProbabilityPair_1(&result, sampleProbabilityPair);
	(void)Assign_SampleProbabilityPair_1(&sampleProbabilityPair, NULL);
	return result;
}

float64_t SampleProbabiPair_1_get_Probabi(struct SampleProbabilityPair_1 *const self)
{
	return self->Probability;
}

void StaticListEnumerator_9_Dispose(struct StaticListEnumerator_9 *const self)
{
}

int32_t SampleSet_1_get_Count(struct SampleSet_1 *const self)
{
	int32_t result = ((int32_t)0);
	struct StaticList_14 *staticList = NULL;
	int32_t int32 = ((int32_t)0);

	staticList = SampleSet_1_get_Samples(self);
	int32 = StaticList_14_get_Count(staticList);
	result = int32;
	(void)Assign_StaticList_14(&staticList, NULL);
	return result;
}

void SampleSet_1_Normalize(struct SampleSet_1 *const self)
{
	float64_t num = 0.0;
	struct StaticListEnumerator_9 *enumerator = NULL;
	struct StaticList_14 *staticList = NULL;
	struct StaticListEnumerator_9 *staticListEnumerator = NULL;
	struct SampleProbabilityPair_1 *current = NULL;
	bool_t boolean = false;
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	struct SampleProbabilityPair_1 *expr_B3 = NULL;
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	num = 0.0;
	staticList = SampleSet_1_get_Samples(self);
	staticListEnumerator = StaticList_14_GetEnumerator(staticList);
	(void)Assign_StaticListEnumerator_9(&enumerator, staticListEnumerator);
	(void)Assign_StaticList_14(&staticList, NULL);
	(void)Assign_StaticListEnumerator_9(&staticListEnumerator, NULL);
	boolean = StaticListEnumerator_9_MoveNext(enumerator);
	while (boolean)
	{
		struct SampleProbabilityPair_1 *sampleProbabilityPair = NULL;
		float64_t double_ = 0.0;
		float64_t double__1 = 0.0;

		sampleProbabilityPair = StaticListEnumera_9_get_Current(enumerator);
		(void)Assign_SampleProbabilityPair_1(&current, sampleProbabilityPair);
		(void)Assign_SampleProbabilityPair_1(&sampleProbabilityPair, NULL);
		double_ = num;
		double__1 = SampleProbabiPair_1_get_Probabi(current);
		num = double_ + double__1;
		boolean = StaticListEnumerator_9_MoveNext(enumerator);
	}
	if (!!(enumerator != NULL))
	{
		StaticListEnumerator_9_Dispose(enumerator);
	}
	if (!(num != 0.0))
	{
		int32_t int32_2 = ((int32_t)0);
		int32_t int32_3 = ((int32_t)0);

		i = ((int32_t)0);
		int32_2 = i;
		int32_3 = SampleSet_1_get_Count(self);
		while (int32_2 < int32_3)
		{
			struct StaticList_14 *staticList_1 = NULL;
			struct SampleProbabilityPair_1 *sampleProbabilityPair_1 = NULL;
			int32_t int32_4 = ((int32_t)0);

			staticList_1 = SampleSet_1_get_Samples(self);
			sampleProbabilityPair_1 = StaticList_14_get_Item(staticList_1, i);
			int32_4 = SampleSet_1_get_Count(self);
			SampleProbabiPair_1_set_Probabi(sampleProbabilityPair_1, 1.0 / (float64_t)int32_4);
			(void)Assign_StaticList_14(&staticList_1, NULL);
			(void)Assign_SampleProbabilityPair_1(&sampleProbabilityPair_1, NULL);
			i = i + ((int32_t)1);
			int32_2 = i;
			int32_3 = SampleSet_1_get_Count(self);
		}
		RemRef_StaticListEnumerator_9(enumerator);
		RemRef_SampleProbabilityPair_1(current);
		RemRef_SampleProbabilityPair_1(expr_B3);
		return;
	}
	if (!(num != 1.0))
	{
		RemRef_StaticListEnumerator_9(enumerator);
		RemRef_SampleProbabilityPair_1(current);
		RemRef_SampleProbabilityPair_1(expr_B3);
		return;
	}
	j = ((int32_t)0);
	int32 = j;
	int32_1 = SampleSet_1_get_Count(self);
	while (int32 < int32_1)
	{
		struct StaticList_14 *staticList_2 = NULL;
		struct SampleProbabilityPair_1 *sampleProbabilityPair_2 = NULL;
		struct SampleProbabilityPair_1 *sampleProbabilityPair_3 = NULL;
		float64_t double__2 = 0.0;

		staticList_2 = SampleSet_1_get_Samples(self);
		sampleProbabilityPair_2 = StaticList_14_get_Item(staticList_2, j);
		(void)Assign_SampleProbabilityPair_1(&expr_B3, sampleProbabilityPair_2);
		(void)Assign_StaticList_14(&staticList_2, NULL);
		(void)Assign_SampleProbabilityPair_1(&sampleProbabilityPair_2, NULL);
		(void)Assign_SampleProbabilityPair_1(&sampleProbabilityPair_3, expr_B3);
		double__2 = SampleProbabiPair_1_get_Probabi(expr_B3);
		SampleProbabiPair_1_set_Probabi(sampleProbabilityPair_3, double__2 / num);
		(void)Assign_SampleProbabilityPair_1(&sampleProbabilityPair_3, NULL);
		j = j + ((int32_t)1);
		int32 = j;
		int32_1 = SampleSet_1_get_Count(self);
	}
	RemRef_StaticListEnumerator_9(enumerator);
	RemRef_SampleProbabilityPair_1(current);
	RemRef_SampleProbabilityPair_1(expr_B3);
}

void SampleSet_1_ctor_2(struct SampleSet_1 *const self, struct StaticList_10 *samples, struct StaticListFactory_1 *listFactory)
{
	struct StaticListEnumerator_6 *enumerator = NULL;
	struct StaticListEnumerator_6 *staticListEnumerator = NULL;
	struct FrontRadarObjectSpace *current = NULL;
	bool_t boolean = false;

	SampleSet_1_ctor_1(self, listFactory);
	staticListEnumerator = StaticList_10_GetEnumerator(samples);
	(void)Assign_StaticListEnumerator_6(&enumerator, staticListEnumerator);
	(void)Assign_StaticListEnumerator_6(&staticListEnumerator, NULL);
	boolean = StaticListEnumerator_6_MoveNext(enumerator);
	while (boolean)
	{
		struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
		struct FrontRadarObjectSpace *frontRadarObjectSpace_1 = NULL;

		frontRadarObjectSpace = StaticListEnumera_6_get_Current(enumerator);
		(void)Assign_FrontRadarObjectSpace(&current, frontRadarObjectSpace);
		(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
		frontRadarObjectSpace_1 = SpaceExtensions_Clone_3(current);
		SampleSet_1_Add(self, frontRadarObjectSpace_1, 1.0);
		(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_1, NULL);
		boolean = StaticListEnumerator_6_MoveNext(enumerator);
	}
	if (!!(enumerator != NULL))
	{
		StaticListEnumerator_6_Dispose(enumerator);
	}
	SampleSet_1_Normalize(self);
	RemRef_StaticListEnumerator_6(enumerator);
	RemRef_FrontRadarObjectSpace(current);
}

void MarginalizedEvaluable_1_ctor(struct MarginalizedEvaluable_1 *const self, struct FrontRadarObjectDetectionModel *conditionalDistribution, struct SampleSet_1 *condition)
{
	Object_ctor(&self->base);
	(void)Assig_FrontRadarObjecDetecModel(&self->_conditionalDistribution, conditionalDistribution);
	(void)Assign_SampleSet_1(&self->_condition, condition);
}

int32_t StaticList_25_get_Count(struct StaticList_25 *const self)
{
	return self->Count;
}

static void StaticList_25_CheckCount(struct StaticList_25 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_25_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_25_set_Count(struct StaticList_25 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_25_Add(struct StaticList_25 *const self, struct MarginalizedEvaluable_1 *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_25_CheckCount(self);
	int32 = StaticList_25_get_Count(self);
	count = int32;
	(void)Assign_MarginalizedEvaluable_1(&self->_items->Elements[count], value);
	int32_1 = StaticList_25_get_Count(self);
	StaticList_25_set_Count(self, int32_1 + ((int32_t)1));
}

static void RemRef_ProbabilityGate_1(struct ProbabilityGate_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base.base)->ReferenceCount--;
	if ((&self->base.base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_ProbabilityGate_1.CurrentCount--;
		Res_ProbabilityGate_1.Next[Res_ProbabilityGate_1.CurrentCount] = self;
		Del_ProbabilityGate_1(self);
	}
}

struct ProbabilityGate_1 *New_ProbabilityGate_1(void)
{
	static struct ProbabilityGate_1 const Default_ProbabilityGate_1 = { 1 };
	struct ProbabilityGate_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_ProbabilityGate_1.CurrentCount == RC_ProbabilityGate_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_ProbabilityGate_1.Next[Res_ProbabilityGate_1.CurrentCount];
	Res_ProbabilityGate_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_ProbabilityGate_1.MaximumCount = (Res_ProbabilityGate_1.CurrentCount > Res_ProbabilityGate_1.MaximumCount) ? Res_ProbabilityGate_1.CurrentCount : Res_ProbabilityGate_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_ProbabilityGate_1;
	return instance;
}

struct ProbabilityGate_1 *Assign_ProbabilityGate_1(struct ProbabilityGate_1 **const left, struct ProbabilityGate_1 *const right)
{
	if (right != NULL)
	{
		(&right->base.base.base)->ReferenceCount++;
	}
	RemRef_ProbabilityGate_1(*left);
	*left = right;
	return right;
}

static float64_t Gaussia_11_InverseNormalDistrib(float64_t y0)
{
	int32_t num = ((int32_t)0);
	float64_t num2 = 0.0;
	float64_t num3 = 0.0;
	float64_t num4 = 0.0;
	float64_t num5 = 0.0;
	float64_t num6 = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t num7 = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t num8 = 0.0;
	float64_t num9 = 0.0;
	float64_t num10 = 0.0;
	float64_t num11 = 0.0;
	float64_t num12 = 0.0;
	float64_t num13 = 0.0;

	if (!(y0 > 0.0))
	{
		return -1.7976931348623157E+308;
	}
	if (!(y0 < 1.0))
	{
		return 1.7976931348623157E+308;
	}
	num = ((int32_t)1);
	num2 = y0;
	if (!(num2 <= 0.8646647167633873))
	{
		num2 = 1.0 - num2;
		num = ((int32_t)0);
	}
	if (!(num2 <= 0.1353352832366127))
	{
		num2 = num2 - 0.5;
		num3 = num2 * num2;
		num4 = -59.963350101410789;
		num4 = 98.001075418599967 + (num3 * num4);
		num4 = -56.676285746907027 + (num3 * num4);
		num4 = 13.931260938727968 + (num3 * num4);
		num4 = -1.2391658386738125 + (num3 * num4);
		num5 = 1.0;
		num5 = 1.9544885833814176 + (num3 * num5);
		num5 = 4.6762791289888153 + (num3 * num5);
		num5 = 86.360242139089053 + (num3 * num5);
		num5 = -225.46268785411937 + (num3 * num5);
		num5 = 200.26021238006066 + (num3 * num5);
		num5 = -82.037225616833339 + (num3 * num5);
		num5 = 15.90562251262117 + (num3 * num5);
		num5 = -1.1833162112133 + (num3 * num5);
		num6 = num2 + (((num2 * num3) * num4) / num5);
		return num6 * 2.5066282746310007;
	}
	double_ = Math_Log(num2);
	double__1 = Math_Sqrt(-(2.0 * double_));
	num6 = double__1;
	double__2 = num6;
	double__3 = Math_Log(num6);
	num7 = double__2 - (double__3 / num6);
	num8 = 1.0 / num6;
	if (!(num6 >= 8.0))
	{
		num9 = 4.0554489230596245;
		num9 = 31.525109459989388 + (num8 * num9);
		num9 = 57.162819224642128 + (num8 * num9);
		num9 = 44.080507389320083 + (num8 * num9);
		num9 = 14.684956192885803 + (num8 * num9);
		num9 = 2.1866330685079025 + (num8 * num9);
		num9 = -0.14025607917135449 + (num8 * num9);
		num9 = -0.035042462682784818 + (num8 * num9);
		num9 = -0.00085745678515468545 + (num8 * num9);
		num10 = 1.0;
		num10 = 15.779988325646675 + (num8 * num10);
		num10 = 45.390763512887922 + (num8 * num10);
		num10 = 41.3172038254672 + (num8 * num10);
		num10 = 15.04253856929075 + (num8 * num10);
		num10 = 2.5046494620830941 + (num8 * num10);
		num10 = -0.14218292285478781 + (num8 * num10);
		num10 = -0.038080640769157834 + (num8 * num10);
		num10 = -0.00093325948089545755 + (num8 * num10);
		num11 = (num8 * num9) / num10;
	}
	else
	{
		num12 = 3.2377489177694603;
		num12 = 6.9152288906898418 + (num8 * num12);
		num12 = 3.9388102529247444 + (num8 * num12);
		num12 = 1.3330346081580755 + (num8 * num12);
		num12 = 0.20148538954917911 + (num8 * num12);
		num12 = 0.012371663481782003 + (num8 * num12);
		num12 = 0.00030158155350823543 + (num8 * num12);
		num12 = 2.658069746867375E-06 + (num8 * num12);
		num12 = 6.2397453918498331E-09 + (num8 * num12);
		num13 = 1.0;
		num13 = 6.02427039364742 + (num8 * num13);
		num13 = 3.6798356385616087 + (num8 * num13);
		num13 = 1.3770209948908132 + (num8 * num13);
		num13 = 0.21623699359449666 + (num8 * num13);
		num13 = 0.01342040060885432 + (num8 * num13);
		num13 = 0.00032801446468212774 + (num8 * num13);
		num13 = 2.8924786474538064E-06 + (num8 * num13);
		num13 = 6.7901940800998127E-09 + (num8 * num13);
		num11 = (num8 * num12) / num13;
	}
	num6 = num7 - num11;
	if (!!(num != ((int32_t)0)))
	{
		num6 = -num6;
	}
	return num6;
}

static float64_t Gaus_11_LnGammXGreaOrEquaMinu34(float64_t x)
{
	float64_t num = 0.0;
	float64_t num2 = 0.0;
	float64_t num3 = 0.0;
	float64_t num4 = 0.0;
	float64_t num5 = 0.0;
	float64_t num6 = 0.0;
	float64_t num7 = 0.0;
	float64_t num8 = 0.0;

	if (!(x >= 13.0))
	{
		float64_t double_ = 0.0;
		float64_t double__1 = 0.0;

		num = 1.0;
		num2 = 0.0;
		num3 = x;
		while (num3 >= 3.0)
		{
			num2 = num2 - 1.0;
			num3 = x + num2;
			num = num * num3;
		}
		while (num3 < 2.0)
		{
			num = num / num3;
			num2 = num2 + 1.0;
			num3 = x + num2;
		}
		double_ = Math_Abs(num);
		num = double_;
		if (!(num3 != 2.0))
		{
			float64_t double__2 = 0.0;

			double__2 = Math_Log(num);
			return double__2;
		}
		num2 = num2 - 2.0;
		x = x + num2;
		num4 = -1378.2515256912086;
		num4 = -38801.631513463784 + (x * num4);
		num4 = -331612.99273887119 + (x * num4);
		num4 = -1162370.9749276231 + (x * num4);
		num4 = -1721737.0082083966 + (x * num4);
		num4 = -853555.66424576542 + (x * num4);
		num5 = 1.0;
		num5 = -351.81570143652345 + (x * num5);
		num5 = -17064.210665188115 + (x * num5);
		num5 = -220528.59055385445 + (x * num5);
		num5 = -1139334.4436798252 + (x * num5);
		num5 = -2532523.0717758294 + (x * num5);
		num5 = -2018891.4143353277 + (x * num5);
		num2 = (x * num4) / num5;
		double__1 = Math_Log(num);
		return double__1 + num2;
	}
	else
	{
		float64_t double__3 = 0.0;
		float64_t double__4 = 0.0;
		float64_t double__5 = 0.0;

		double__3 = x - 0.5;
		double__4 = Math_Log(x);
		double__5 = double__3 * double__4;
		num6 = (double__5 - x) + 0.91893853320467278;
		if (!(x <= 100000000.0))
		{
			return num6;
		}
		num7 = 1.0 / (x * x);
		if (!(x < 1000.0))
		{
			return num6 + (((((0.00079365079365079376 * num7) - 0.0027777777777777779) * num7) + 0.083333333333333329) / x);
		}
		num8 = 0.00081161416747050838;
		num8 = -0.00059506190428430144 + (num7 * num8);
		num8 = 0.00079365034045771694 + (num7 * num8);
		num8 = -0.0027777777773009969 + (num7 * num8);
		num8 = 0.0833333333333332 + (num7 * num8);
		return num6 + (num8 / x);
	}
}

static float64_t Gaussian_11_LnGamma(float64_t x)
{
	float64_t num = 0.0;
	float64_t num2 = 0.0;
	float64_t double_ = 0.0;
	float64_t num3 = 0.0;
	float64_t double__1 = 0.0;
	float64_t num4 = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	float64_t double__5 = 0.0;

	if (!(x < -34.0))
	{
		float64_t double__6 = 0.0;

		double__6 = Gaus_11_LnGammXGreaOrEquaMinu34(x);
		return double__6;
	}
	num = -x;
	double_ = Gaus_11_LnGammXGreaOrEquaMinu34(num);
	num2 = double_;
	double__1 = Math_Floor(num);
	num3 = double__1;
	num4 = num - num3;
	if (!(num4 <= 0.5))
	{
		num3 = num3 + 1.0;
		num4 = num3 - num;
	}
	double__2 = num;
	double__3 = Math_Sin(3.1415926535897931 * num4);
	num4 = double__2 * double__3;
	double__4 = Math_Log(num4);
	double__5 = 1.1447298858494002 - double__4;
	return double__5 - num2;
}

static float64_t Ga_11_InGamIntXSmaTha1OrSmaThaA(float64_t a, float64_t x)
{
	float64_t num = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	float64_t num2 = 0.0;
	float64_t num3 = 0.0;
	float64_t num4 = 0.0;
	float64_t double__5 = 0.0;

	if (!!((x <= 0.0) | (a <= 0.0)))
	{
		return 0.0;
	}
	double_ = a;
	double__1 = Math_Log(x);
	double__2 = double_ * double__1;
	double__3 = double__2 - x;
	double__4 = Gaussian_11_LnGamma(a);
	num = double__3 - double__4;
	if (!(num >= -709.782712893384))
	{
		return 0.0;
	}
	num2 = a;
	num3 = 1.0;
	num4 = 1.0;
	while (true)
	{
		num2 = num2 + 1.0;
		num3 = (num3 * x) / num2;
		num4 = num4 + num3;
		if (!((num3 / num4) > 1E-15))
		{
			break;
		}
	}
	double__5 = Math_Exp(num);
	num = double__5;
	return (num4 * num) / a;
}

static float64_t Gauss_11_ComplIncompGammaIntegr(float64_t a, float64_t x)
{
	float64_t num = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	float64_t num2 = 0.0;
	float64_t num3 = 0.0;
	float64_t num4 = 0.0;
	float64_t num5 = 0.0;
	float64_t num6 = 0.0;
	float64_t num7 = 0.0;
	float64_t num8 = 0.0;
	float64_t num9 = 0.0;
	float64_t num10 = 0.0;
	float64_t num11 = 0.0;
	float64_t num12 = 0.0;
	float64_t num13 = 0.0;
	float64_t num14 = 0.0;
	float64_t double__5 = 0.0;

	if (!!((x <= 0.0) | (a <= 0.0)))
	{
		return 1.0;
	}
	if (!!((x < 1.0) | (x < a)))
	{
		float64_t double__6 = 0.0;

		double__6 = Ga_11_InGamIntXSmaTha1OrSmaThaA(a, x);
		return 1.0 - double__6;
	}
	double_ = a;
	double__1 = Math_Log(x);
	double__2 = double_ * double__1;
	double__3 = double__2 - x;
	double__4 = Gaussian_11_LnGamma(a);
	num = double__3 - double__4;
	if (!(num >= -709.782712893384))
	{
		return 0.0;
	}
	num2 = 1.0 - a;
	num3 = (x + num2) + 1.0;
	num4 = 0.0;
	num5 = 1.0;
	num6 = x;
	num7 = x + 1.0;
	num8 = num3 * x;
	num9 = num7 / num8;
	while (true)
	{
		float64_t double__7 = 0.0;

		num4 = num4 + 1.0;
		num2 = num2 + 1.0;
		num3 = num3 + 2.0;
		num10 = num2 * num4;
		num11 = (num7 * num3) - (num5 * num10);
		num12 = (num8 * num3) - (num6 * num10);
		if (!(num12 == 0.0))
		{
			float64_t double__8 = 0.0;

			num13 = num11 / num12;
			double__8 = Math_Abs((num9 - num13) / num13);
			num14 = double__8;
			num9 = num13;
		}
		else
		{
			num14 = 1.0;
		}
		num5 = num7;
		num7 = num11;
		num6 = num8;
		num8 = num12;
		double__7 = Math_Abs(num11);
		if (!(double__7 <= 4503599627370496.0))
		{
			num5 = num5 * 2.2204460492503131E-16;
			num7 = num7 * 2.2204460492503131E-16;
			num6 = num6 * 2.2204460492503131E-16;
			num8 = num8 * 2.2204460492503131E-16;
		}
		if (!(num14 > 1E-15))
		{
			break;
		}
	}
	double__5 = Math_Exp(num);
	num = double__5;
	return num9 * num;
}

static float64_t Gaus_11_InveCompIncomGammaInteg(float64_t a, float64_t y0)
{
	float64_t num = 0.0;
	float64_t num2 = 0.0;
	float64_t num3 = 0.0;
	float64_t num4 = 0.0;
	float64_t num5 = 0.0;
	float64_t num6 = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t num7 = 0.0;
	float64_t num8 = 0.0;
	float64_t double__3 = 0.0;
	int32_t i = ((int32_t)0);
	int32_t num9 = ((int32_t)0);

	num = 4503599627370496.0;
	num2 = 0.0;
	num3 = 0.0;
	num4 = 1.0;
	num5 = 1.0 / (9.0 * a);
	double_ = 1.0 - num5;
	double__1 = Gaussia_11_InverseNormalDistrib(y0);
	double__2 = Math_Sqrt(num5);
	num6 = double_ - (double__1 * double__2);
	num7 = ((a * num6) * num6) * num6;
	double__3 = Gaussian_11_LnGamma(a);
	num8 = double__3;
	i = ((int32_t)0);
	while (i < ((int32_t)10))
	{
		float64_t double__4 = 0.0;
		float64_t double__5 = 0.0;
		float64_t double__6 = 0.0;
		float64_t double__7 = 0.0;
		float64_t double__8 = 0.0;
		float64_t double__9 = 0.0;
		float64_t double__10 = 0.0;

		if (!!((num7 > num) | (num7 < num3)))
		{
			num5 = 0.0625;
			break;
		}
		double__4 = Gauss_11_ComplIncompGammaIntegr(a, num7);
		num6 = double__4;
		if (!!((num6 < num2) | (num6 > num4)))
		{
			num5 = 0.0625;
			break;
		}
		if (!(num6 >= y0))
		{
			num = num7;
			num2 = num6;
		}
		else
		{
			num3 = num7;
			num4 = num6;
		}
		double__5 = a - 1.0;
		double__6 = Math_Log(num7);
		double__7 = double__5 * double__6;
		double__8 = double__7 - num7;
		num5 = double__8 - num8;
		if (!(num5 >= -709.782712893384))
		{
			num5 = 0.0625;
			break;
		}
		double__9 = Math_Exp(num5);
		num5 = -double__9;
		num5 = (num6 - y0) / num5;
		double__10 = Math_Abs(num5 / num7);
		if (!(double__10 >= 1E-15))
		{
			return num7;
		}
		num7 = num7 - num5;
		i = i + ((int32_t)1);
	}
	if (!(num != 4503599627370496.0))
	{
		float64_t double__11 = 0.0;

		if (!(num7 > 0.0))
		{
			num7 = 1.0;
		}
		num7 = (1.0 + num5) * num7;
		double__11 = Gauss_11_ComplIncompGammaIntegr(a, num7);
		num6 = double__11;
		if (!(num6 >= y0))
		{
			num = num7;
			num2 = num6;
		}
	}
	num5 = 0.5;
	num9 = ((int32_t)0);
	i = ((int32_t)0);
	while (i < ((int32_t)400))
	{
		float64_t double__12 = 0.0;
		float64_t double__13 = 0.0;
		float64_t double__14 = 0.0;
		bool_t boolean = false;

		num7 = num3 + (num5 * (num - num3));
		double__12 = Gauss_11_ComplIncompGammaIntegr(a, num7);
		num6 = double__12;
		num8 = (num - num3) / (num3 + num);
		double__13 = Math_Abs(num8);
		if (!!(double__13 < 5.0000000000000008E-15))
		{
			break;
		}
		num8 = (num6 - y0) / y0;
		double__14 = Math_Abs(num8);
		boolean = double__14 < 5.0000000000000008E-15;
		if (!!(boolean || (num7 <= 0.0)))
		{
			break;
		}
		if (!(num6 < y0))
		{
			num3 = num7;
			num4 = num6;
			if (!(num9 >= ((int32_t)0)))
			{
				num9 = ((int32_t)0);
				num5 = 0.5;
			}
			else
			{
				if (!(num9 <= ((int32_t)1)))
				{
					num5 = (0.5 * num5) + 0.5;
				}
				else
				{
					num5 = (y0 - num2) / (num4 - num2);
				}
			}
			num9 = num9 + ((int32_t)1);
		}
		else
		{
			num = num7;
			num2 = num6;
			if (!(num9 <= ((int32_t)0)))
			{
				num9 = ((int32_t)0);
				num5 = 0.5;
			}
			else
			{
				if (!(num9 >= ((int32_t)-1)))
				{
					num5 = 0.5 * num5;
				}
				else
				{
					num5 = (y0 - num2) / (num4 - num2);
				}
			}
			num9 = num9 - ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	return num7;
}

float64_t Gaus_11_GetMaximMahalDistaSquar(float64_t gateProbability)
{
	float64_t double_ = 0.0;

	if (!((gateProbability >= 0.0) && (gateProbability <= 1.0)))
	{
		abort();
	}
	double_ = Gaus_11_InveCompIncomGammaInteg(0.5 * (float64_t)(&Gaussian_11_EmptySpace->base.base)->Dimensions, 1.0 - gateProbability);
	return 2.0 * double_;
}

static void RemRef_SquaredMahalanDistance_1(struct SquaredMahalanobisDistance_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_SquaredMahalanobiDistance_1.CurrentCount--;
		Res_SquaredMahalanobiDistance_1.Next[Res_SquaredMahalanobiDistance_1.CurrentCount] = self;
		Del_SquaredMahalanobiDistance_1(self);
	}
}

struct SquaredMahalanobisDistance_1 *New_SquaredMahalanobiDistance_1(void)
{
	static struct SquaredMahalanobisDistance_1 const Default_SquaredMahalanDistanc_1 = { 1 };
	struct SquaredMahalanobisDistance_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_SquaredMahalanobiDistance_1.CurrentCount == RC_SquaredMahalanobisDistance_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_SquaredMahalanobiDistance_1.Next[Res_SquaredMahalanobiDistance_1.CurrentCount];
	Res_SquaredMahalanobiDistance_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_SquaredMahalanobiDistance_1.MaximumCount = (Res_SquaredMahalanobiDistance_1.CurrentCount > Res_SquaredMahalanobiDistance_1.MaximumCount) ? Res_SquaredMahalanobiDistance_1.CurrentCount : Res_SquaredMahalanobiDistance_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_SquaredMahalanDistanc_1;
	return instance;
}

struct SquaredMahalanobisDistance_1 *Assign_SquaredMahalanDistance_1(struct SquaredMahalanobisDistance_1 **const left, struct SquaredMahalanobisDistance_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_SquaredMahalanDistance_1(*left);
	*left = right;
	return right;
}

void SquaredMahalanobDistance_1_ctor(struct SquaredMahalanobisDistance_1 *const self)
{
	Object_ctor(&self->base);
}

static void RemRef_IMetric_1(struct IMetric_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_IMetric_1.CurrentCount--;
		Res_IMetric_1.Next[Res_IMetric_1.CurrentCount] = self;
		Del_IMetric_1(self);
	}
}

struct IMetric_1 *New_IMetric_1(void)
{
	static struct IMetric_1 const Default_IMetric_1 = { 1 };
	struct IMetric_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_IMetric_1.CurrentCount == RC_IMetric_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_IMetric_1.Next[Res_IMetric_1.CurrentCount];
	Res_IMetric_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_IMetric_1.MaximumCount = (Res_IMetric_1.CurrentCount > Res_IMetric_1.MaximumCount) ? Res_IMetric_1.CurrentCount : Res_IMetric_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_IMetric_1;
	return instance;
}

struct IMetric_1 *Assign_IMetric_1(struct IMetric_1 **const left, struct IMetric_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_IMetric_1(*left);
	*left = right;
	return right;
}

static void Gate_1_set_MaximumDistance(struct Gate_1 *const self, float64_t value)
{
	self->MaximumDistance = value;
}

void Gate_1_ctor(struct Gate_1 *const self, struct SquaredMahalanobisDistance_1 *metric, float64_t maximumDistance)
{
	if (!(metric != NULL))
	{
		abort();
	}
	Object_ctor(&self->base);
	(void)Assign_SquaredMahalanDistance_1(&self->_metric, metric);
	Gate_1_set_MaximumDistance(self, maximumDistance);
}

static void GaussianGate_1_set_GateProbabil(struct GaussianGate_1 *const self, float64_t value)
{
	self->GateProbability = value;
}

static void GaussianGate_1_ctor(struct GaussianGate_1 *const self, float64_t maxSquaredMahalanobisDistance, float64_t gateProbability)
{
	struct SquaredMahalanobisDistance_1 *squaredMahalanobisDistance = NULL;

	squaredMahalanobisDistance = New_SquaredMahalanobiDistance_1();
	SquaredMahalanobDistance_1_ctor(squaredMahalanobisDistance);
	Gate_1_ctor(&self->base, squaredMahalanobisDistance, maxSquaredMahalanobisDistance);
	(void)Assign_SquaredMahalanDistance_1(&squaredMahalanobisDistance, NULL);
	if (!(maxSquaredMahalanobisDistance >= 0.0))
	{
		abort();
	}
	if (!((gateProbability >= 0.0) && (gateProbability <= 1.0)))
	{
		abort();
	}
	GaussianGate_1_set_GateProbabil(self, gateProbability);
}

void ProbabilityGate_1_ctor(struct ProbabilityGate_1 *const self, float64_t gateProbability)
{
	float64_t double_ = 0.0;

	double_ = Gaus_11_GetMaximMahalDistaSquar(gateProbability);
	GaussianGate_1_ctor(&self->base, double_, gateProbability);
}

static void RemRef_IEnumerable_3(struct IEnumerable_3 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_IEnumerable_3.CurrentCount--;
		Res_IEnumerable_3.Next[Res_IEnumerable_3.CurrentCount] = self;
		Del_IEnumerable_3(self);
	}
}

struct IEnumerable_3 *New_IEnumerable_3(void)
{
	static struct IEnumerable_3 const Default_IEnumerable_3 = { 1 };
	struct IEnumerable_3 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_IEnumerable_3.CurrentCount == RC_IEnumerable_3)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_IEnumerable_3.Next[Res_IEnumerable_3.CurrentCount];
	Res_IEnumerable_3.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_IEnumerable_3.MaximumCount = (Res_IEnumerable_3.CurrentCount > Res_IEnumerable_3.MaximumCount) ? Res_IEnumerable_3.CurrentCount : Res_IEnumerable_3.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_IEnumerable_3;
	return instance;
}

struct IEnumerable_3 *Assign_IEnumerable_3(struct IEnumerable_3 **const left, struct IEnumerable_3 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_IEnumerable_3(*left);
	*left = right;
	return right;
}

static void RemRef_IEnumerable_4(struct IEnumerable_4 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_IEnumerable_4.CurrentCount--;
		Res_IEnumerable_4.Next[Res_IEnumerable_4.CurrentCount] = self;
		Del_IEnumerable_4(self);
	}
}

struct IEnumerable_4 *New_IEnumerable_4(void)
{
	static struct IEnumerable_4 const Default_IEnumerable_4 = { 1 };
	struct IEnumerable_4 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_IEnumerable_4.CurrentCount == RC_IEnumerable_4)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_IEnumerable_4.Next[Res_IEnumerable_4.CurrentCount];
	Res_IEnumerable_4.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_IEnumerable_4.MaximumCount = (Res_IEnumerable_4.CurrentCount > Res_IEnumerable_4.MaximumCount) ? Res_IEnumerable_4.CurrentCount : Res_IEnumerable_4.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_IEnumerable_4;
	return instance;
}

struct IEnumerable_4 *Assign_IEnumerable_4(struct IEnumerable_4 **const left, struct IEnumerable_4 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_IEnumerable_4(*left);
	*left = right;
	return right;
}

static void RemRef_MeasurementAssociation_1(struct MeasurementAssociation_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_MeasurementAssociation_1.CurrentCount--;
		Res_MeasurementAssociation_1.Next[Res_MeasurementAssociation_1.CurrentCount] = self;
		Del_MeasurementAssociation_1(self);
	}
}

struct MeasurementAssociation_1 *New_MeasurementAssociation_1(void)
{
	static struct MeasurementAssociation_1 const Default_MeasuremenAssociation_1 = { 1 };
	struct MeasurementAssociation_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MeasurementAssociation_1.CurrentCount == RC_MeasurementAssociation_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MeasurementAssociation_1.Next[Res_MeasurementAssociation_1.CurrentCount];
	Res_MeasurementAssociation_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MeasurementAssociation_1.MaximumCount = (Res_MeasurementAssociation_1.CurrentCount > Res_MeasurementAssociation_1.MaximumCount) ? Res_MeasurementAssociation_1.CurrentCount : Res_MeasurementAssociation_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MeasuremenAssociation_1;
	return instance;
}

struct MeasurementAssociation_1 *Assign_MeasurementAssociation_1(struct MeasurementAssociation_1 **const left, struct MeasurementAssociation_1 *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_MeasurementAssociation_1(*left);
	*left = right;
	return right;
}

static void Association_1_set_Objects1(struct Association_1 *const self, struct StaticList_21 *value)
{
	(void)Assign_StaticList_21(&self->Objects1, value);
}

struct StaticList_9 *StatiListFacto_5_CreateInstan_1(struct StaticListFactory_5 *const self, int32_t capacity)
{
	struct StaticList_9 *result = NULL;
	struct StaticList_9 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_5_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_9();
	StaticList_9_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_9(&result, staticList);
	(void)Assign_StaticList_9(&staticList, NULL);
	return result;
}

static void Association_1_set_Objects2(struct Association_1 *const self, struct StaticList_9 *value)
{
	(void)Assign_StaticList_9(&self->Objects2, value);
}

static void RemRef_StaticListEnumerator_13(struct StaticListEnumerator_13 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListEnumerator_13.CurrentCount--;
		Res_StaticListEnumerator_13.Next[Res_StaticListEnumerator_13.CurrentCount] = self;
		Del_StaticListEnumerator_13(self);
	}
}

struct StaticListEnumerator_13 *New_StaticListEnumerator_13(void)
{
	static struct StaticListEnumerator_13 const Default_StaticListEnumerator_13 = { 1 };
	struct StaticListEnumerator_13 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListEnumerator_13.CurrentCount == RC_StaticListEnumerator_13)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListEnumerator_13.Next[Res_StaticListEnumerator_13.CurrentCount];
	Res_StaticListEnumerator_13.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListEnumerator_13.MaximumCount = (Res_StaticListEnumerator_13.CurrentCount > Res_StaticListEnumerator_13.MaximumCount) ? Res_StaticListEnumerator_13.CurrentCount : Res_StaticListEnumerator_13.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListEnumerator_13;
	return instance;
}

struct StaticListEnumerator_13 *Assign_StaticListEnumerator_13(struct StaticListEnumerator_13 **const left, struct StaticListEnumerator_13 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListEnumerator_13(*left);
	*left = right;
	return right;
}

void StaticListEnumerator_13_ctor(struct StaticListEnumerator_13 *const self, struct StaticList_21 *list)
{
	self->_current = ((int32_t)-1);
	Object_ctor(&self->base);
	(void)Assign_StaticList_21(&self->_list, list);
}

struct StaticListEnumerator_13 *StaticList_21_GetEnumerator(struct StaticList_21 *const self)
{
	struct StaticListEnumerator_13 *result = NULL;
	struct StaticListEnumerator_13 *staticListEnumerator = NULL;

	staticListEnumerator = New_StaticListEnumerator_13();
	StaticListEnumerator_13_ctor(staticListEnumerator, self);
	(void)Assign_StaticListEnumerator_13(&result, staticListEnumerator);
	(void)Assign_StaticListEnumerator_13(&staticListEnumerator, NULL);
	return result;
}

bool_t StaticListEnumerato_13_MoveNext(struct StaticListEnumerator_13 *const self)
{
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	self->_current = self->_current + ((int32_t)1);
	int32 = self->_current;
	int32_1 = StaticList_21_get_Count(self->_list);
	return int32 != int32_1;
}

struct Gaussian_3 *StaticList_21_get_Item(struct StaticList_21 *const self, int32_t index)
{
	struct Gaussian_3 *result = NULL;

	(void)Assign_Gaussian_3(&result, self->_items->Elements[index]);
	return result;
}

struct Gaussian_3 *StaticListEnumer_13_get_Current(struct StaticListEnumerator_13 *const self)
{
	struct Gaussian_3 *result = NULL;
	struct Gaussian_3 *gaussian = NULL;

	gaussian = StaticList_21_get_Item(self->_list, self->_current);
	(void)Assign_Gaussian_3(&result, gaussian);
	(void)Assign_Gaussian_3(&gaussian, NULL);
	return result;
}

static struct StaticList_21 *Association_1_get_Objects1(struct Association_1 *const self)
{
	struct StaticList_21 *result = NULL;

	(void)Assign_StaticList_21(&result, self->Objects1);
	return result;
}

void StaticListEnumerator_13_Dispose(struct StaticListEnumerator_13 *const self)
{
}

static void RemRef_StaticListEnumerator_5(struct StaticListEnumerator_5 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListEnumerator_5.CurrentCount--;
		Res_StaticListEnumerator_5.Next[Res_StaticListEnumerator_5.CurrentCount] = self;
		Del_StaticListEnumerator_5(self);
	}
}

struct StaticListEnumerator_5 *New_StaticListEnumerator_5(void)
{
	static struct StaticListEnumerator_5 const Default_StaticListEnumerator_5 = { 1 };
	struct StaticListEnumerator_5 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListEnumerator_5.CurrentCount == RC_StaticListEnumerator_5)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListEnumerator_5.Next[Res_StaticListEnumerator_5.CurrentCount];
	Res_StaticListEnumerator_5.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListEnumerator_5.MaximumCount = (Res_StaticListEnumerator_5.CurrentCount > Res_StaticListEnumerator_5.MaximumCount) ? Res_StaticListEnumerator_5.CurrentCount : Res_StaticListEnumerator_5.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListEnumerator_5;
	return instance;
}

struct StaticListEnumerator_5 *Assign_StaticListEnumerator_5(struct StaticListEnumerator_5 **const left, struct StaticListEnumerator_5 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListEnumerator_5(*left);
	*left = right;
	return right;
}

void StaticListEnumerator_5_ctor(struct StaticListEnumerator_5 *const self, struct StaticList_9 *list)
{
	self->_current = ((int32_t)-1);
	Object_ctor(&self->base);
	(void)Assign_StaticList_9(&self->_list, list);
}

struct StaticListEnumerator_5 *StaticList_9_GetEnumerator(struct StaticList_9 *const self)
{
	struct StaticListEnumerator_5 *result = NULL;
	struct StaticListEnumerator_5 *staticListEnumerator = NULL;

	staticListEnumerator = New_StaticListEnumerator_5();
	StaticListEnumerator_5_ctor(staticListEnumerator, self);
	(void)Assign_StaticListEnumerator_5(&result, staticListEnumerator);
	(void)Assign_StaticListEnumerator_5(&staticListEnumerator, NULL);
	return result;
}

bool_t StaticListEnumerator_5_MoveNext(struct StaticListEnumerator_5 *const self)
{
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	self->_current = self->_current + ((int32_t)1);
	int32 = self->_current;
	int32_1 = StaticList_9_get_Count(self->_list);
	return int32 != int32_1;
}

struct FrontRadarObjectSpace *StaticList_9_get_Item(struct StaticList_9 *const self, int32_t index)
{
	struct FrontRadarObjectSpace *result = NULL;

	(void)Assign_FrontRadarObjectSpace(&result, self->_items->Elements[index]);
	return result;
}

struct FrontRadarObjectSpace *StaticListEnumera_5_get_Current(struct StaticListEnumerator_5 *const self)
{
	struct FrontRadarObjectSpace *result = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;

	frontRadarObjectSpace = StaticList_9_get_Item(self->_list, self->_current);
	(void)Assign_FrontRadarObjectSpace(&result, frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	return result;
}

static struct StaticList_9 *Association_1_get_Objects2(struct Association_1 *const self)
{
	struct StaticList_9 *result = NULL;

	(void)Assign_StaticList_9(&result, self->Objects2);
	return result;
}

void StaticListEnumerator_5_Dispose(struct StaticListEnumerator_5 *const self)
{
}

static void Associati_1_set_AssociatioTable(struct Association_1 *const self, struct AssociationTable *value)
{
	(void)Assign_AssociationTable(&self->AssociationTable, value);
}

static void Association_1_ctor(struct Association_1 *const self, struct StaticList_21 *objects1, struct StaticList_9 *objects2, struct MultipleLocalNearestNeighbor *associationAlgorithm, struct StatiIPDATrackColleFactorProvid *factoryProvider)
{
	struct StatiIPDATrackColleFactorProvid *arg_4E_1 = NULL;
	struct StaticListFactory_4 *staticListFactory = NULL;
	struct StaticList_21 *staticList = NULL;
	struct StaticListFactory_5 *staticListFactory_1 = NULL;
	struct StaticList_9 *staticList_1 = NULL;
	struct StaticListEnumerator_13 *enumerator = NULL;
	struct StaticListEnumerator_13 *staticListEnumerator = NULL;
	struct Gaussian_3 *current = NULL;
	bool_t boolean = false;
	struct StaticListEnumerator_5 *enumerator2 = NULL;
	struct StaticListEnumerator_5 *staticListEnumerator_1 = NULL;
	struct FrontRadarObjectSpace *current2 = NULL;
	bool_t boolean_1 = false;
	struct StaticAssociationTableFactory *staticAssociationTableFactory = NULL;
	struct StaticList_21 *staticList_2 = NULL;
	int32_t int32 = ((int32_t)0);
	struct StaticList_9 *staticList_3 = NULL;
	int32_t int32_1 = ((int32_t)0);
	struct AssociationTable *associationTable = NULL;

	if (!(objects1 != NULL))
	{
		abort();
	}
	if (!(objects2 != NULL))
	{
		abort();
	}
	if (!(associationAlgorithm != NULL))
	{
		abort();
	}
	Object_ctor(&self->base);
	(void)Assi_StatIPDATracCollFactoProvi(&arg_4E_1, factoryProvider);
	(void)Assi_StatIPDATracCollFactoProvi(&self->_factoryProvider, arg_4E_1);
	staticListFactory = StIPDATrCoFacPro_get_Obj1LisFac(self->_factoryProvider);
	staticList = StatiListFacto_4_CreateInstan_5(staticListFactory, ((int32_t)0));
	Association_1_set_Objects1(self, staticList);
	(void)Assign_StaticListFactory_4(&staticListFactory, NULL);
	(void)Assign_StaticList_21(&staticList, NULL);
	staticListFactory_1 = StIPDATrCoFacPro_get_Obj2LisFac(self->_factoryProvider);
	staticList_1 = StatiListFacto_5_CreateInstan_1(staticListFactory_1, ((int32_t)0));
	Association_1_set_Objects2(self, staticList_1);
	(void)Assign_StaticListFactory_5(&staticListFactory_1, NULL);
	(void)Assign_StaticList_9(&staticList_1, NULL);
	staticListEnumerator = StaticList_21_GetEnumerator(objects1);
	(void)Assign_StaticListEnumerator_13(&enumerator, staticListEnumerator);
	(void)Assign_StaticListEnumerator_13(&staticListEnumerator, NULL);
	boolean = StaticListEnumerato_13_MoveNext(enumerator);
	while (boolean)
	{
		struct Gaussian_3 *gaussian = NULL;
		struct StaticList_21 *staticList_4 = NULL;

		gaussian = StaticListEnumer_13_get_Current(enumerator);
		(void)Assign_Gaussian_3(&current, gaussian);
		(void)Assign_Gaussian_3(&gaussian, NULL);
		staticList_4 = Association_1_get_Objects1(self);
		StaticList_21_Add(staticList_4, current);
		(void)Assign_StaticList_21(&staticList_4, NULL);
		boolean = StaticListEnumerato_13_MoveNext(enumerator);
	}
	if (!!(enumerator != NULL))
	{
		StaticListEnumerator_13_Dispose(enumerator);
	}
	staticListEnumerator_1 = StaticList_9_GetEnumerator(objects2);
	(void)Assign_StaticListEnumerator_5(&enumerator2, staticListEnumerator_1);
	(void)Assign_StaticListEnumerator_5(&staticListEnumerator_1, NULL);
	boolean_1 = StaticListEnumerator_5_MoveNext(enumerator2);
	while (boolean_1)
	{
		struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
		struct StaticList_9 *staticList_5 = NULL;

		frontRadarObjectSpace = StaticListEnumera_5_get_Current(enumerator2);
		(void)Assign_FrontRadarObjectSpace(&current2, frontRadarObjectSpace);
		(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
		staticList_5 = Association_1_get_Objects2(self);
		StaticList_9_Add(staticList_5, current2);
		(void)Assign_StaticList_9(&staticList_5, NULL);
		boolean_1 = StaticListEnumerator_5_MoveNext(enumerator2);
	}
	if (!!(enumerator2 != NULL))
	{
		StaticListEnumerator_5_Dispose(enumerator2);
	}
	(void)Assign_MultipLocalNearesNeighbo(&self->_associationAlgorithm, associationAlgorithm);
	staticAssociationTableFactory = StIPDATrColFacPro_get_AssTabFac(self->_factoryProvider);
	staticList_2 = Association_1_get_Objects1(self);
	int32 = StaticList_21_get_Count(staticList_2);
	staticList_3 = Association_1_get_Objects2(self);
	int32_1 = StaticList_9_get_Count(staticList_3);
	associationTable = StatiAssocTableFacto_CreatInsta(staticAssociationTableFactory, int32, int32_1);
	Associati_1_set_AssociatioTable(self, associationTable);
	(void)Assign_StaticAssociTableFactory(&staticAssociationTableFactory, NULL);
	(void)Assign_StaticList_21(&staticList_2, NULL);
	(void)Assign_StaticList_9(&staticList_3, NULL);
	(void)Assign_AssociationTable(&associationTable, NULL);
	RemRef_StatIPDATracCollFactProv(arg_4E_1);
	RemRef_StaticListEnumerator_13(enumerator);
	RemRef_Gaussian_3(current);
	RemRef_StaticListEnumerator_5(enumerator2);
	RemRef_FrontRadarObjectSpace(current2);
}

static struct AssociationTable *Associati_1_get_AssociatioTable(struct Association_1 *const self)
{
	struct AssociationTable *result = NULL;

	(void)Assign_AssociationTable(&result, self->AssociationTable);
	return result;
}

int32_t Association_1_get_Count1(struct Association_1 *const self)
{
	int32_t result = ((int32_t)0);
	struct AssociationTable *associationTable = NULL;
	int32_t int32 = ((int32_t)0);

	associationTable = Associati_1_get_AssociatioTable(self);
	int32 = AssociationTable_get_Rows(associationTable);
	result = int32;
	(void)Assign_AssociationTable(&associationTable, NULL);
	return result;
}

int32_t Association_1_get_Count2(struct Association_1 *const self)
{
	int32_t result = ((int32_t)0);
	struct AssociationTable *associationTable = NULL;
	int32_t int32 = ((int32_t)0);

	associationTable = Associati_1_get_AssociatioTable(self);
	int32 = AssociationTable_get_Columns(associationTable);
	result = int32;
	(void)Assign_AssociationTable(&associationTable, NULL);
	return result;
}

struct float64_t_1D_5 *Space_6_op_Subtraction_4(struct Space *left, struct Space *right)
{
	struct float64_t_1D_5 *result = NULL;
	struct float64_t_1D_5 *array = NULL;

	array = Space_Subtract(left, right);
	(void)Assign_float64_t_1D_5(&result, array);
	(void)Assign_float64_t_1D_5(&array, NULL);
	return result;
}

static void LineaAlgeb_1_SolveUpperTriang(struct float64_t_1D_25 *a, int32_t lda, int32_t rank, struct float64_t_1D_25 *b, int32_t ldb, int32_t rightHandSides, bool_t ignoreDiagonal)
{
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t expr_23_cp_1 = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t expr_41_cp_1 = ((int32_t)0);

	i = ((int32_t)0);
	while (i < rightHandSides)
	{
		j = rank - ((int32_t)1);
		while (j >= ((int32_t)0))
		{
			if (!ignoreDiagonal)
			{
				expr_23_cp_1 = (i * ldb) + j;
				b->Elements[expr_23_cp_1] = b->Elements[expr_23_cp_1] / a->Elements[(j * lda) + j];
			}
			k = ((int32_t)0);
			while (k < j)
			{
				expr_41_cp_1 = (i * ldb) + k;
				b->Elements[expr_41_cp_1] = b->Elements[expr_41_cp_1] - (b->Elements[(i * ldb) + j] * a->Elements[(j * lda) + k]);
				k = k + ((int32_t)1);
			}
			j = j - ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
}

void LinearAlgebra_SolveCholesky_1(struct LinearAlgebra *const self, struct float64_t_1D_25 *a, int32_t rows, struct float64_t_1D_25 *b)
{
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t expr_A6_cp_1 = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t expr_C7_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rows > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)25) % rows) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!!((((int32_t)25) % rows) != ((int32_t)0)))
	{
		abort();
	}
	num = ((int32_t)25) / rows;
	if (!(num == rows))
	{
		abort();
	}
	num2 = ((int32_t)25) / rows;
	i = ((int32_t)0);
	while (i < num2)
	{
		j = ((int32_t)0);
		while (j < num)
		{
			expr_A6_cp_1 = (i * rows) + j;
			b->Elements[expr_A6_cp_1] = b->Elements[expr_A6_cp_1] / a->Elements[(j * rows) + j];
			k = j + ((int32_t)1);
			while (k < num)
			{
				expr_C7_cp_1 = (i * rows) + k;
				b->Elements[expr_C7_cp_1] = b->Elements[expr_C7_cp_1] - (b->Elements[(i * rows) + j] * a->Elements[(k * rows) + j]);
				k = k + ((int32_t)1);
			}
			j = j + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
	LineaAlgeb_1_SolveUpperTriang(a, rows, rows, b, rows, num2, false);
}

struct MatrixData_2 *MatrixMath_LinsolveHermitian_1(struct MatrixData_2 *left, struct MatrixData_2 *right)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	struct MatrixData_2 *copy = NULL;
	struct MatrixData_2 *matrixData = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_25 *array = NULL;
	struct MatrixData_2 *copy2 = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra_1 = NULL;
	struct float64_t_1D_25 *array_1 = NULL;
	int32_t int32 = ((int32_t)0);
	struct float64_t_1D_25 *array_2 = NULL;
	struct MatrixData_2 *result = NULL;

	if (!(left != NULL))
	{
		abort();
	}
	boolean = MatrixData_2_get_IsEmpty(left);
	if (!(right != NULL))
	{
		abort();
	}
	boolean_1 = MatrixData_2_get_IsEmpty(right);
	matrixData = MatrixData_2_get_Copy(left);
	(void)Assign_MatrixData_2(&copy, matrixData);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_2_get_DataReference(copy);
	LinearAlgebra_FactorCholesky(linearAlgebra, array, copy->Rows);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_25(&array, NULL);
	matrixData_1 = MatrixData_2_get_Copy(right);
	(void)Assign_MatrixData_2(&copy2, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra_1, MatrixMath_LinearAlgebra);
	array_1 = MatrixData_2_get_DataReference(copy);
	int32 = copy->Rows;
	array_2 = MatrixData_2_get_DataReference(copy2);
	LinearAlgebra_SolveCholesky_1(linearAlgebra_1, array_1, int32, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra_1, NULL);
	(void)Assign_float64_t_1D_25(&array_1, NULL);
	(void)Assign_float64_t_1D_25(&array_2, NULL);
	(void)Assign_MatrixData_2(&result, copy2);
	RemRef_MatrixData_2(copy);
	RemRef_MatrixData_2(copy2);
	return result;
}

struct PositiveDefiniteMatrix_5 *PositiDefiniMatrix_5_get_Invers(struct PositiveDefiniteMatrix_5 *const self)
{
	struct PositiveDefiniteMatrix_5 *result = NULL;
	struct PositiveDefiniteMatrix_5 *positiveDefiniteMatrix = NULL;

	if (!(self->CachedInverse != NULL))
	{
		struct MatrixData_2 *matrixData = NULL;
		struct MatrixData_2 *matrixData_1 = NULL;
		struct MatrixData_2 *matrixData_2 = NULL;

		matrixData = Matrix_5_get_MatrixData(&self->base.base);
		matrixData_1 = MatrixData_20_Eye((&self->base)->Dimensions, (&self->base)->Dimensions);
		matrixData_2 = MatrixMath_LinsolveHermitian_1(matrixData, matrixData_1);
		(void)Assign_MatrixData_2(&self->CachedInverse, matrixData_2);
		(void)Assign_MatrixData_2(&matrixData, NULL);
		(void)Assign_MatrixData_2(&matrixData_1, NULL);
		(void)Assign_MatrixData_2(&matrixData_2, NULL);
	}
	positiveDefiniteMatrix = PositivDefiniteMatrix_13_Create(self->CachedInverse);
	(void)Assign_PositiveDefiniteMatrix_5(&result, positiveDefiniteMatrix);
	(void)Assign_PositiveDefiniteMatrix_5(&positiveDefiniteMatrix, NULL);
	return result;
}

static void RemRef_MatrixData_1(struct MatrixData_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_MatrixData_1.CurrentCount--;
		Res_MatrixData_1.Next[Res_MatrixData_1.CurrentCount] = self;
		Del_MatrixData_1(self);
	}
}

struct MatrixData_1 *New_MatrixData_1(void)
{
	static struct MatrixData_1 const Default_MatrixData_1 = { 1 };
	struct MatrixData_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_MatrixData_1.CurrentCount == RC_MatrixData_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_MatrixData_1.Next[Res_MatrixData_1.CurrentCount];
	Res_MatrixData_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_MatrixData_1.MaximumCount = (Res_MatrixData_1.CurrentCount > Res_MatrixData_1.MaximumCount) ? Res_MatrixData_1.CurrentCount : Res_MatrixData_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_MatrixData_1;
	return instance;
}

struct MatrixData_1 *Assign_MatrixData_1(struct MatrixData_1 **const left, struct MatrixData_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_MatrixData_1(*left);
	*left = right;
	return right;
}

void MatrixData_1_ctor(struct MatrixData_1 *const self, int32_t rows, int32_t columns)
{
	struct float64_t_1D_5 *array = NULL;

	assert(rows == ((int32_t)1));
	assert(columns == ((int32_t)5));
	Object_ctor(&self->base);
	MatrixData_20_CheckRange(rows, columns);
	array = New_float64_t_1D_5();
	(void)Assign_float64_t_1D_5(&self->_data, array);
	(void)Assign_float64_t_1D_5(&array, NULL);
	self->Rows = rows;
	self->Columns = columns;
}

struct float64_t_1D_5 *MatrixData_1_get_DataReference(struct MatrixData_1 *const self)
{
	struct float64_t_1D_5 *result = NULL;

	(void)Assign_float64_t_1D_5(&result, self->_data);
	return result;
}

void LinearAlgebra_MatrixMultiply_22(struct LinearAlgebra *const self, struct float64_t_1D_5 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_25 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_5 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)5) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)25) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)5) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)5) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)25) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)25) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)5) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)5) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_1 *MatrixMath_Multiply_40(bool_t transposeLeft, bool_t transposeRight, struct MatrixData *left, struct MatrixData_2 *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_1 *matrixData = NULL;
	struct MatrixData_1 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_5 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_25 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_5 *array_2 = NULL;
	struct MatrixData_1 *result = NULL;

	assert(transposeLeft == true);
	assert(transposeRight == false);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Columns;
	rows = arg_145_0;
	arg_15D_0 = right->Columns;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_1();
	MatrixData_1_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_1(&matrixData, matrixData_1);
	(void)Assign_MatrixData_1(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_2_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_1_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_22(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_5(&array, NULL);
	(void)Assign_float64_t_1D_25(&array_1, NULL);
	(void)Assign_float64_t_1D_5(&array_2, NULL);
	(void)Assign_MatrixData_1(&result, matrixData);
	RemRef_MatrixData_1(matrixData);
	return result;
}

void LinearAlgebra_MatrixMultiply_23(struct LinearAlgebra *const self, struct float64_t_1D_5 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_5 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_1 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)5) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)5) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)5) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)5) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)5) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)5) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)5) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)1) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData_3 *MatrixMath_Multiply_41(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_1 *left, struct MatrixData *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData_3 *matrixData = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_5 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_5 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_1 *array_2 = NULL;
	struct MatrixData_3 *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == false);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Columns;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData_3();
	MatrixData_3_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData_3(&matrixData, matrixData_1);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_1_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_3_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_23(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_5(&array, NULL);
	(void)Assign_float64_t_1D_5(&array_1, NULL);
	(void)Assign_float64_t_1D_1(&array_2, NULL);
	(void)Assign_MatrixData_3(&result, matrixData);
	RemRef_MatrixData_3(matrixData);
	return result;
}

struct MatrixData_3 *MatrixMath_Multiply_42(bool_t transposeFirst, bool_t transposeSecond, bool_t transposeThird, struct MatrixData *first, struct MatrixData_2 *second, struct MatrixData *third)
{
	struct MatrixData_1 *left = NULL;
	struct MatrixData_1 *matrixData = NULL;
	struct MatrixData_3 *result = NULL;
	struct MatrixData_3 *matrixData_1 = NULL;

	assert(transposeFirst == true);
	assert(transposeSecond == false);
	assert(transposeThird == false);
	if (!(first != NULL))
	{
		abort();
	}
	if (!(second != NULL))
	{
		abort();
	}
	if (!(third != NULL))
	{
		abort();
	}
	matrixData = MatrixMath_Multiply_40(transposeFirst, transposeSecond, first, second);
	(void)Assign_MatrixData_1(&left, matrixData);
	(void)Assign_MatrixData_1(&matrixData, NULL);
	matrixData_1 = MatrixMath_Multiply_41(false, transposeThird, left, third);
	(void)Assign_MatrixData_3(&result, matrixData_1);
	(void)Assign_MatrixData_3(&matrixData_1, NULL);
	RemRef_MatrixData_1(left);
	return result;
}

float64_t Gaussi_3_GetMahalaDistanSquared(struct Gaussian_3 *const self, struct FrontRadarObjectSpace *sample)
{
	struct MatrixData *matrixData = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace_1 = NULL;
	struct float64_t_1D_5 *array = NULL;
	struct MatrixData *matrixData_1 = NULL;
	float64_t result = 0.0;
	struct MatrixData *matrixData_2 = NULL;
	struct PositiveDefiniteMatrix_5 *positiveDefiniteMatrix = NULL;
	struct PositiveDefiniteMatrix_5 *positiveDefiniteMatrix_1 = NULL;
	struct MatrixData_2 *matrixData_3 = NULL;
	struct MatrixData_3 *matrixData_4 = NULL;
	float64_t double_ = 0.0;

	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, sample);
	frontRadarObjectSpace_1 = Gaussian_3_get_Expectation(self);
	array = Space_6_op_Subtraction_4(&frontRadarObjectSpace->base.base, &frontRadarObjectSpace_1->base.base);
	matrixData_1 = MatrixData_20_Create_2(array);
	(void)Assign_MatrixData(&matrixData, matrixData_1);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_1, NULL);
	(void)Assign_float64_t_1D_5(&array, NULL);
	(void)Assign_MatrixData(&matrixData_1, NULL);
	(void)Assign_MatrixData(&matrixData_2, matrixData);
	positiveDefiniteMatrix = Gaussian_3_get_Covariance(self);
	positiveDefiniteMatrix_1 = PositiDefiniMatrix_5_get_Invers(positiveDefiniteMatrix);
	matrixData_3 = Matrix_5_get_MatrixData(&positiveDefiniteMatrix_1->base.base);
	matrixData_4 = MatrixMath_Multiply_42(true, false, false, matrixData_2, matrixData_3, matrixData);
	double_ = MatrixData_3_get_Item(matrixData_4, ((int32_t)0), ((int32_t)0));
	result = double_;
	(void)Assign_MatrixData(&matrixData_2, NULL);
	(void)Assign_PositiveDefiniteMatrix_5(&positiveDefiniteMatrix, NULL);
	(void)Assign_PositiveDefiniteMatrix_5(&positiveDefiniteMatrix_1, NULL);
	(void)Assign_MatrixData_2(&matrixData_3, NULL);
	(void)Assign_MatrixData_3(&matrixData_4, NULL);
	RemRef_MatrixData(matrixData);
	return result;
}

float64_t SquareMahalaDistanc_1_GetMetric(struct SquaredMahalanobisDistance_1 *const self, struct Gaussian_3 *object1, struct FrontRadarObjectSpace *object2)
{
	float64_t double_ = 0.0;

	if (!(object1 != NULL))
	{
		abort();
	}
	if (!(object2 != NULL))
	{
		abort();
	}
	double_ = Gaussi_3_GetMahalaDistanSquared(object1, object2);
	return double_;
}

float64_t Gate_1_get_MaximumDistance(struct Gate_1 *const self)
{
	return self->MaximumDistance;
}

bool_t Gate_1_IsInside(struct Gate_1 *const self, struct Gaussian_3 *object1, struct FrontRadarObjectSpace *object2)
{
	float64_t metric = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;

	if (!(object1 != NULL))
	{
		abort();
	}
	if (!(object2 != NULL))
	{
		abort();
	}
	double_ = SquareMahalaDistanc_1_GetMetric(self->_metric, object1, object2);
	metric = double_;
	double__1 = metric;
	double__2 = Gate_1_get_MaximumDistance(self);
	return double__1 <= double__2;
}

int32_t Gaussian_3_get_Dimensions(struct Gaussian_3 *const self)
{
	return self->_dimensions;
}

bool_t MatrixData_2_get_IsScalar(struct MatrixData_2 *const self)
{
	return ((int32_t)25) == ((int32_t)1);
}

static void Del_int32_t_1D_5(struct int32_t_1D_5 *const self)
{
	Del_Object(&self->base);
}

static void RemRef_int32_t_1D_5(struct int32_t_1D_5 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_int32_t_1D_5.CurrentCount--;
		Res_int32_t_1D_5.Next[Res_int32_t_1D_5.CurrentCount] = self;
		Del_int32_t_1D_5(self);
	}
}

struct int32_t_1D_5 *New_int32_t_1D_5(void)
{
	static struct int32_t_1D_5 const Default_int32_t_1D_5 = { 1 };
	struct int32_t_1D_5 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_int32_t_1D_5.CurrentCount == RC_int32_t_1D_5)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_int32_t_1D_5.Next[Res_int32_t_1D_5.CurrentCount];
	Res_int32_t_1D_5.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_int32_t_1D_5.MaximumCount = (Res_int32_t_1D_5.CurrentCount > Res_int32_t_1D_5.MaximumCount) ? Res_int32_t_1D_5.CurrentCount : Res_int32_t_1D_5.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_int32_t_1D_5;
	return instance;
}

struct int32_t_1D_5 *Assign_int32_t_1D_5(struct int32_t_1D_5 **const left, struct int32_t_1D_5 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_int32_t_1D_5(*left);
	*left = right;
	return right;
}

void LinearAlgebra_FactorLU_2(struct LinearAlgebra *const self, struct float64_t_1D_25 *a, int32_t rows, struct int32_t_1D_5 *pivotIndices)
{
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	float64_t num4 = 0.0;
	int32_t j = ((int32_t)0);
	float64_t num5 = 0.0;
	int32_t k = ((int32_t)0);
	float64_t num6 = 0.0;
	int32_t l = ((int32_t)0);
	int32_t expr_150_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t expr_187_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rows > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)25) % rows) != ((int32_t)0)))
	{
		abort();
	}
	num = ((int32_t)25) / rows;
	int32 = Math_Min(num, rows);
	num2 = int32;
	if (!(pivotIndices != NULL))
	{
		abort();
	}
	if (!(((int32_t)5) == num2))
	{
		abort();
	}
	i = ((int32_t)0);
	while (i < num2)
	{
		num3 = i;
		num4 = 0.0;
		j = i;
		while (j < num)
		{
			float64_t double_ = 0.0;

			double_ = Math_Abs(a->Elements[(i * rows) + j]);
			num5 = double_;
			if (!(num5 <= num4))
			{
				num4 = num5;
				num3 = j;
			}
			j = j + ((int32_t)1);
		}
		pivotIndices->Elements[i] = num3 + ((int32_t)1);
		if (!!(a->Elements[(i * rows) + num3] == 0.0))
		{
			abort();
		}
		if (!(num3 == i))
		{
			k = ((int32_t)0);
			while (k < num)
			{
				num6 = a->Elements[(k * rows) + num3];
				a->Elements[(k * rows) + num3] = a->Elements[(k * rows) + i];
				a->Elements[(k * rows) + i] = num6;
				k = k + ((int32_t)1);
			}
		}
		if (!(a->Elements[(i * rows) + i] == 1.0))
		{
			l = i + ((int32_t)1);
			while (l < rows)
			{
				expr_150_cp_1 = (i * rows) + l;
				a->Elements[expr_150_cp_1] = a->Elements[expr_150_cp_1] / a->Elements[(i * rows) + i];
				l = l + ((int32_t)1);
			}
		}
		m = i + ((int32_t)1);
		while (m < num)
		{
			n = i + ((int32_t)1);
			while (n < rows)
			{
				expr_187_cp_1 = (m * rows) + n;
				a->Elements[expr_187_cp_1] = a->Elements[expr_187_cp_1] - (a->Elements[(m * rows) + i] * a->Elements[(i * rows) + n]);
				n = n + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		i = i + ((int32_t)1);
	}
}

float64_t MatrixMath_Det_1(struct MatrixData_2 *matrix)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	bool_t boolean_2 = false;
	struct float64_t_1D_25 *array = NULL;
	struct float64_t_1D_25 *array_1 = NULL;
	struct float64_t_1D_25 *array_2 = NULL;
	struct float64_t_1D_25 *array_3 = NULL;
	struct int32_t_1D_5 *array2 = NULL;
	struct int32_t_1D_5 *array_4 = NULL;
	float64_t num = 0.0;
	int32_t i = ((int32_t)0);

	if (!(matrix != NULL))
	{
		abort();
	}
	boolean = MatrixData_2_get_IsEmpty(matrix);
	boolean_1 = MatrixData_2_get_IsScalar(matrix);
	boolean_2 = MatrixData_2_get_IsZero(matrix);
	if (!!boolean_2)
	{
		RemRef_float64_t_1D_25(array);
		RemRef_int32_t_1D_5(array2);
		return 0.0;
	}
	array_1 = MatrixData_2_get_DataReference(matrix);
	array_2 = New_float64_t_1D_25();
	(void)Assign_float64_t_1D_25(&array, array_2);
	(void)Assign_float64_t_1D_25(&array_1, NULL);
	(void)Assign_float64_t_1D_25(&array_2, NULL);
	array_3 = MatrixData_2_get_DataReference(matrix);
	(void)memcpy(&array->Elements, &array_3->Elements, sizeof(float64_t) * ((int32_t)25));
	(void)Assign_float64_t_1D_25(&array_3, NULL);
	array_4 = New_int32_t_1D_5();
	(void)Assign_int32_t_1D_5(&array2, array_4);
	(void)Assign_int32_t_1D_5(&array_4, NULL);
	LinearAlgebra_FactorLU_2(MatrixMath_LinearAlgebra, array, matrix->Rows, array2);
	num = 1.0;
	i = ((int32_t)0);
	while (i < matrix->Rows)
	{
		num = num * array->Elements[(i * matrix->Rows) + i];
		if (!(array2->Elements[i] == (i + ((int32_t)1))))
		{
			num = num * -1.0;
		}
		i = i + ((int32_t)1);
	}
	RemRef_float64_t_1D_25(array);
	RemRef_int32_t_1D_5(array2);
	return num;
}

float64_t SquareMatrix_5_get_Determinant(struct PositiveDefiniteMatrix_5 *const self)
{
	struct PositiveDefiniteMatrix_5 *positiveDefiniteMatrix = NULL;
	bool_t boolean = false;
	struct PositiveDefiniteMatrix_5 *positiveDefiniteMatrix_1 = NULL;
	float64_t double_ = 0.0;

	(void)Assign_PositiveDefiniteMatrix_5(&positiveDefiniteMatrix, self);
	boolean = Nullable_2_get_HasValue(&(&positiveDefiniteMatrix->base)->CachedDeterminant);
	if (!boolean)
	{
		struct MatrixData_2 *matrixData = NULL;
		float64_t double__1 = 0.0;
		struct Nullable_2 nullable = { 0 };

		matrixData = Matrix_5_get_MatrixData(&self->base.base);
		double__1 = MatrixMath_Det_1(matrixData);
		Nullable_2_ctor(&nullable, double__1);
		(&self->base)->CachedDeterminant = nullable;
		(void)Assign_MatrixData_2(&matrixData, NULL);
	}
	(void)Assign_PositiveDefiniteMatrix_5(&positiveDefiniteMatrix_1, self);
	double_ = Nullable_2_get_Value(&(&positiveDefiniteMatrix_1->base)->CachedDeterminant);
	RemRef_PositiveDefiniteMatrix_5(positiveDefiniteMatrix);
	RemRef_PositiveDefiniteMatrix_5(positiveDefiniteMatrix_1);
	return double_;
}

float64_t Gaussian_3_Evaluate(struct Gaussian_3 *const self, float64_t mahalanobisSquared)
{
	struct Gaussian_3 *gaussian = NULL;
	bool_t boolean = false;
	struct Gaussian_3 *gaussian_1 = NULL;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;

	(void)Assign_Gaussian_3(&gaussian, self);
	boolean = Nullable_2_get_HasValue(&gaussian->NormalizationFactor);
	if (!boolean)
	{
		int32_t int32 = ((int32_t)0);
		float64_t double__2 = 0.0;
		struct PositiveDefiniteMatrix_5 *positiveDefiniteMatrix = NULL;
		float64_t double__3 = 0.0;
		float64_t double__4 = 0.0;
		struct Nullable_2 nullable = { 0 };

		int32 = Gaussian_3_get_Dimensions(self);
		double__2 = Math_Pow(6.2831853071795862, (float64_t)int32 / 2.0);
		positiveDefiniteMatrix = Gaussian_3_get_Covariance(self);
		double__3 = SquareMatrix_5_get_Determinant(positiveDefiniteMatrix);
		double__4 = Math_Sqrt(double__3);
		Nullable_2_ctor(&nullable, 1.0 / (double__2 * double__4));
		self->NormalizationFactor = nullable;
		(void)Assign_PositiveDefiniteMatrix_5(&positiveDefiniteMatrix, NULL);
	}
	(void)Assign_Gaussian_3(&gaussian_1, self);
	double_ = Nullable_2_get_Value(&gaussian_1->NormalizationFactor);
	double__1 = Math_Exp(-mahalanobisSquared / 2.0);
	RemRef_Gaussian_3(gaussian);
	RemRef_Gaussian_3(gaussian_1);
	return double_ * double__1;
}

float64_t Gaussian_3_Evaluate_1(struct Gaussian_3 *const self, struct FrontRadarObjectSpace *sample)
{
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;

	double_ = Gaussi_3_GetMahalaDistanSquared(self, sample);
	double__1 = Gaussian_3_Evaluate(self, double_);
	return double__1;
}

static void Associati_1_DetermineAssociatio(struct Association_1 *const self)
{
	struct MultipleLocalNearestNeighbor *multipleLocalNearestNeighbor = NULL;
	struct AssociationTable *associationTable = NULL;
	struct StaticList_5 *staticList = NULL;

	(void)Assign_MultipLocalNearesNeighbo(&multipleLocalNearestNeighbor, self->_associationAlgorithm);
	associationTable = Associati_1_get_AssociatioTable(self);
	staticList = MultiLocalNeareNeighb_GetAssoci(multipleLocalNearestNeighbor, associationTable, &self->_notAssociatedObjects);
	(void)Assign_StaticList_5(&self->_associations, staticList);
	(void)Assign_MultipLocalNearesNeighbo(&multipleLocalNearestNeighbor, NULL);
	(void)Assign_AssociationTable(&associationTable, NULL);
	(void)Assign_StaticList_5(&staticList, NULL);
}

void MeasurementAssociation_1_ctor(struct MeasurementAssociation_1 *const self, struct StaticList_21 *likelihoods, struct StaticList_26 *existences, struct StaticList_9 *measurements, struct MultipleLocalNearestNeighbor *associationAlgorithm, struct ProbabilityGate_1 *gate, struct StatiIPDATrackColleFactorProvid *factoryProvider)
{
	struct StaticListEnumerator_14 *enumerator = NULL;
	struct StaticListEnumerator_14 *staticListEnumerator = NULL;
	int32_t i = ((int32_t)0);
	struct Gaussian_3 *object = NULL;
	int32_t j = ((int32_t)0);
	struct FrontRadarObjectSpace *tMeasurementSpace = NULL;
	float64_t num = 0.0;
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	if (!(likelihoods != NULL))
	{
		abort();
	}
	if (!(existences != NULL))
	{
		abort();
	}
	if (!(measurements != NULL))
	{
		abort();
	}
	if (!(associationAlgorithm != NULL))
	{
		abort();
	}
	Association_1_ctor(&self->base, likelihoods, measurements, associationAlgorithm, factoryProvider);
	staticListEnumerator = StaticList_26_GetEnumerator(existences);
	(void)Assign_StaticListEnumerator_14(&enumerator, staticListEnumerator);
	(void)Assign_StaticListEnumerator_14(&staticListEnumerator, NULL);
	i = ((int32_t)0);
	int32 = i;
	int32_1 = Association_1_get_Count1(&self->base);
	while (int32 < int32_1)
	{
		struct StaticList_21 *staticList = NULL;
		struct Gaussian_3 *gaussian = NULL;
		bool_t boolean = false;
		int32_t int32_2 = ((int32_t)0);
		int32_t int32_3 = ((int32_t)0);

		staticList = Association_1_get_Objects1(&self->base);
		gaussian = StaticList_21_get_Item(staticList, i);
		(void)Assign_Gaussian_3(&object, gaussian);
		(void)Assign_StaticList_21(&staticList, NULL);
		(void)Assign_Gaussian_3(&gaussian, NULL);
		boolean = StaticListEnumerato_14_MoveNext(enumerator);
		if (!boolean)
		{
			abort();
		}
		j = ((int32_t)0);
		int32_2 = j;
		int32_3 = Association_1_get_Count2(&self->base);
		while (int32_2 < int32_3)
		{
			struct StaticList_9 *staticList_1 = NULL;
			struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
			bool_t boolean_1 = false;
			struct ProbabilityGate_1 *probabilityGate = NULL;
			bool_t boolean_2 = false;

			staticList_1 = Association_1_get_Objects2(&self->base);
			frontRadarObjectSpace = StaticList_9_get_Item(staticList_1, j);
			(void)Assign_FrontRadarObjectSpace(&tMeasurementSpace, frontRadarObjectSpace);
			(void)Assign_StaticList_9(&staticList_1, NULL);
			(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
			(void)Assign_ProbabilityGate_1(&probabilityGate, gate);
			if ((probabilityGate != NULL) == true)
			{
				boolean_1 = Gate_1_IsInside(&gate->base.base, object, tMeasurementSpace);
				boolean_2 = !boolean_1;
			}
			else
			{
				boolean_2 = false;
			}
			if (!boolean_2)
			{
				struct Existence *existence = NULL;
				float64_t double_ = 0.0;
				struct AssociationTable *associationTable = NULL;
				int32_t int32_4 = ((int32_t)0);
				int32_t int32_5 = ((int32_t)0);
				float64_t double__1 = 0.0;

				(void)Assign_ProbabilityGate_1(&probabilityGate, NULL);
				existence = StaticListEnumer_14_get_Current(enumerator);
				double_ = TwoPointDistribution_Evaluate(&existence->base, ExistenceSpace_1_Existent);
				num = double_;
				(void)Assign_Existence(&existence, NULL);
				associationTable = Associati_1_get_AssociatioTable(&self->base);
				int32_4 = i;
				int32_5 = j;
				double__1 = Gaussian_3_Evaluate_1(object, tMeasurementSpace);
				AssociationTable_set_Item(associationTable, int32_4, int32_5, double__1 * num);
				(void)Assign_AssociationTable(&associationTable, NULL);
			}
			else
			{
				(void)Assign_ProbabilityGate_1(&probabilityGate, NULL);
			}
			j = j + ((int32_t)1);
			int32_2 = j;
			int32_3 = Association_1_get_Count2(&self->base);
		}
		i = i + ((int32_t)1);
		int32 = i;
		int32_1 = Association_1_get_Count1(&self->base);
	}
	Associati_1_DetermineAssociatio(&self->base);
	RemRef_StaticListEnumerator_14(enumerator);
	RemRef_Gaussian_3(object);
	RemRef_FrontRadarObjectSpace(tMeasurementSpace);
}

struct MeasurementAssociation_1 *MeasuremenAssociation_2_Create(struct StaticList_21 *likelihoodIntegralDistributions, struct StaticList_26 *existences, struct StaticList_9 *measurements, struct MultipleLocalNearestNeighbor *associationAlgorithm, struct ProbabilityGate_1 *gate, struct StatiIPDATrackColleFactorProvid *factoryProvider)
{
	struct MeasurementAssociation_1 *result = NULL;
	struct MeasurementAssociation_1 *measurementAssociation = NULL;

	if (!(likelihoodIntegralDistributions != NULL))
	{
		abort();
	}
	if (!(existences != NULL))
	{
		abort();
	}
	if (!(measurements != NULL))
	{
		abort();
	}
	if (!(associationAlgorithm != NULL))
	{
		abort();
	}
	measurementAssociation = New_MeasurementAssociation_1();
	MeasurementAssociation_1_ctor(measurementAssociation, likelihoodIntegralDistributions, existences, measurements, associationAlgorithm, gate, factoryProvider);
	(void)Assign_MeasurementAssociation_1(&result, measurementAssociation);
	(void)Assign_MeasurementAssociation_1(&measurementAssociation, NULL);
	return result;
}

struct StaticList_9 *Associati_1_GetAssociateObjects(struct Association_1 *const self, int32_t object1Index)
{
	struct StaticList_9 *list = NULL;
	struct StaticListFactory_5 *staticListFactory = NULL;
	struct StaticList_9 *staticList = NULL;
	struct StaticListEnumerator *enumerator = NULL;
	struct StaticList *staticList_1 = NULL;
	struct StaticListEnumerator *staticListEnumerator = NULL;
	int32_t current = ((int32_t)0);
	bool_t boolean = false;
	struct StaticList_9 *result = NULL;

	if (!(__ContrRunti_1_insidContrEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_1_insidContrEvalua = __ContrRunti_1_insidContrEvalua + ((int32_t)1);
		if (!(object1Index >= ((int32_t)0)))
		{
			abort();
		}
		int32 = object1Index;
		int32_1 = Association_1_get_Count1(self);
		if (!(int32 < int32_1))
		{
			abort();
		}
		__ContrRunti_1_insidContrEvalua = __ContrRunti_1_insidContrEvalua - ((int32_t)1);
	}
	staticListFactory = StIPDATrCoFacPro_get_Obj2LisFac(self->_factoryProvider);
	staticList = StatiListFacto_5_CreateInstan_1(staticListFactory, ((int32_t)0));
	(void)Assign_StaticList_9(&list, staticList);
	(void)Assign_StaticListFactory_5(&staticListFactory, NULL);
	(void)Assign_StaticList_9(&staticList, NULL);
	staticList_1 = StaticList_5_get_Item(self->_associations, object1Index);
	staticListEnumerator = StaticList_GetEnumerator(staticList_1);
	(void)Assign_StaticListEnumerator(&enumerator, staticListEnumerator);
	(void)Assign_StaticList(&staticList_1, NULL);
	(void)Assign_StaticListEnumerator(&staticListEnumerator, NULL);
	boolean = StaticListEnumerator_MoveNext(enumerator);
	while (boolean)
	{
		int32_t int32_2 = ((int32_t)0);
		struct StaticList_9 *staticList_2 = NULL;
		struct StaticList_9 *staticList_3 = NULL;
		struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;

		int32_2 = StaticListEnumerato_get_Current(enumerator);
		current = int32_2;
		(void)Assign_StaticList_9(&staticList_2, list);
		staticList_3 = Association_1_get_Objects2(self);
		frontRadarObjectSpace = StaticList_9_get_Item(staticList_3, current);
		StaticList_9_Add(staticList_2, frontRadarObjectSpace);
		(void)Assign_StaticList_9(&staticList_2, NULL);
		(void)Assign_StaticList_9(&staticList_3, NULL);
		(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
		boolean = StaticListEnumerator_MoveNext(enumerator);
	}
	if (!!(enumerator != NULL))
	{
		StaticListEnumerator_Dispose(enumerator);
	}
	(void)Assign_StaticList_9(&result, list);
	RemRef_StaticList_9(list);
	RemRef_StaticListEnumerator(enumerator);
	return result;
}

struct MarginalizedEvaluable_1 *StaticList_25_get_Item(struct StaticList_25 *const self, int32_t index)
{
	struct MarginalizedEvaluable_1 *result = NULL;

	(void)Assign_MarginalizedEvaluable_1(&result, self->_items->Elements[index]);
	return result;
}

float64_t FronRadaObjePara_get_CluttLambd(struct FrontRadarObjectParameters *const self)
{
	return self->ClutterLambda;
}

static void RemRef_IEvaluable_3(struct IEvaluable_3 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_IEvaluable_3.CurrentCount--;
		Res_IEvaluable_3.Next[Res_IEvaluable_3.CurrentCount] = self;
		Del_IEvaluable_3(self);
	}
}

struct IEvaluable_3 *New_IEvaluable_3(void)
{
	static struct IEvaluable_3 const Default_IEvaluable_3 = { 1 };
	struct IEvaluable_3 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_IEvaluable_3.CurrentCount == RC_IEvaluable_3)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_IEvaluable_3.Next[Res_IEvaluable_3.CurrentCount];
	Res_IEvaluable_3.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_IEvaluable_3.MaximumCount = (Res_IEvaluable_3.CurrentCount > Res_IEvaluable_3.MaximumCount) ? Res_IEvaluable_3.CurrentCount : Res_IEvaluable_3.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_IEvaluable_3;
	return instance;
}

struct IEvaluable_3 *Assign_IEvaluable_3(struct IEvaluable_3 **const left, struct IEvaluable_3 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_IEvaluable_3(*left);
	*left = right;
	return right;
}

static void IPDA_4_cctor(void)
{
}

static void RemRef_IPDA_1(struct IPDA_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_IPDA_1.CurrentCount--;
		Res_IPDA_1.Next[Res_IPDA_1.CurrentCount] = self;
		Del_IPDA_1(self);
	}
}

struct IPDA_1 *New_IPDA_1(void)
{
	static struct IPDA_1 const Default_IPDA_1 = { 1 };
	struct IPDA_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_IPDA_1.CurrentCount == RC_IPDA_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_IPDA_1.Next[Res_IPDA_1.CurrentCount];
	Res_IPDA_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_IPDA_1.MaximumCount = (Res_IPDA_1.CurrentCount > Res_IPDA_1.MaximumCount) ? Res_IPDA_1.CurrentCount : Res_IPDA_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_IPDA_1;
	return instance;
}

struct IPDA_1 *Assign_IPDA_1(struct IPDA_1 **const left, struct IPDA_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_IPDA_1(*left);
	*left = right;
	return right;
}

static void IPDA_1_set_Lambda(struct IPDA_1 *const self, float64_t value)
{
	self->Lambda = value;
}

struct StaticListEnumerator_9 *SampleSet_1_GetEnumerator(struct SampleSet_1 *const self)
{
	struct StaticListEnumerator_9 *result = NULL;
	struct StaticList_14 *staticList = NULL;
	struct StaticListEnumerator_9 *staticListEnumerator = NULL;

	staticList = SampleSet_1_get_Samples(self);
	staticListEnumerator = StaticList_14_GetEnumerator(staticList);
	(void)Assign_StaticListEnumerator_9(&result, staticListEnumerator);
	(void)Assign_StaticList_14(&staticList, NULL);
	(void)Assign_StaticListEnumerator_9(&staticListEnumerator, NULL);
	return result;
}

struct FrontRadarObjectSpace *SampleProbabilPair_1_get_Sample(struct SampleProbabilityPair_1 *const self)
{
	struct FrontRadarObjectSpace *result = NULL;

	(void)Assign_FrontRadarObjectSpace(&result, self->Sample);
	return result;
}

static struct FrontRadarObjectSpace *DetectionModel_1_get_Condition(struct DetectionModel_1 *const self)
{
	struct FrontRadarObjectSpace *result = NULL;

	(void)Assign_FrontRadarObjectSpace(&result, self->Condition);
	return result;
}

struct Vector2D StaticList_3_get_Item(struct StaticList_3 *const self, int32_t index)
{
	return self->_items->Elements[index];
}

static float64_t Polygon_IsLeft(struct Vector2D linePoint1, struct Vector2D linePoint2, struct Vector2D testPoint)
{
	return ((linePoint2.X - linePoint1.X) * (testPoint.Y - linePoint1.Y)) - ((testPoint.X - linePoint1.X) * (linePoint2.Y - linePoint1.Y));
}

bool_t Polygon_IsPointWithin(struct Vector2D point, struct StaticList_3 *polygonPoints)
{
	int32_t counter = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	counter = ((int32_t)0);
	i = ((int32_t)0);
	int32 = i;
	int32_1 = StaticList_3_get_Count(polygonPoints);
	while (int32 < (int32_1 - ((int32_t)1)))
	{
		struct Vector2D vector2D = { 0 };
		float64_t double_ = 0.0;

		vector2D = StaticList_3_get_Item(polygonPoints, i);
		double_ = vector2D.Y;
		if (!(double_ > point.Y))
		{
			struct Vector2D vector2D_1 = { 0 };
			struct Vector2D vector2D_2 = { 0 };
			float64_t double__1 = 0.0;
			struct Vector2D vector2D_3 = { 0 };
			float64_t double__2 = 0.0;
			bool_t boolean = false;
			bool_t boolean_1 = false;

			vector2D_3 = StaticList_3_get_Item(polygonPoints, i + ((int32_t)1));
			double__2 = vector2D_3.Y;
			boolean = double__2 <= point.Y;
			if (boolean == false)
			{
				vector2D_1 = StaticList_3_get_Item(polygonPoints, i);
				vector2D_2 = StaticList_3_get_Item(polygonPoints, i + ((int32_t)1));
				double__1 = Polygon_IsLeft(vector2D_1, vector2D_2, point);
				boolean_1 = double__1 <= 0.0;
			}
			else
			{
				boolean_1 = true;
			}
			if (!boolean_1)
			{
				counter = counter + ((int32_t)1);
			}
		}
		else
		{
			struct Vector2D vector2D_4 = { 0 };
			struct Vector2D vector2D_5 = { 0 };
			float64_t double__3 = 0.0;
			struct Vector2D vector2D_6 = { 0 };
			float64_t double__4 = 0.0;
			bool_t boolean_2 = false;
			bool_t boolean_3 = false;

			vector2D_6 = StaticList_3_get_Item(polygonPoints, i + ((int32_t)1));
			double__4 = vector2D_6.Y;
			boolean_2 = double__4 > point.Y;
			if (boolean_2 == false)
			{
				vector2D_4 = StaticList_3_get_Item(polygonPoints, i);
				vector2D_5 = StaticList_3_get_Item(polygonPoints, i + ((int32_t)1));
				double__3 = Polygon_IsLeft(vector2D_4, vector2D_5, point);
				boolean_3 = double__3 >= 0.0;
			}
			else
			{
				boolean_3 = true;
			}
			if (!boolean_3)
			{
				counter = counter - ((int32_t)1);
			}
		}
		i = i + ((int32_t)1);
		int32 = i;
		int32_1 = StaticList_3_get_Count(polygonPoints);
	}
	return counter != ((int32_t)0);
}

float64_t FronRadaObjePara_get_DetecProba(struct FrontRadarObjectParameters *const self)
{
	return self->DetectionProbability;
}

static float64_t PolygDetecModel_GetDetectProbab(struct PolygonDetectionModel *const self, struct FrontRadarObjectSpace *state)
{
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	struct Vector2D vector2D = { 0 };
	bool_t boolean = false;
	struct FrontRadarObjectParameters *CS_0_0000 = NULL;
	float64_t double__2 = 0.0;

	double_ = CVComponentsSpace_get_X(&(*&state)->base);
	double__1 = CVComponentsSpace_get_Y(&(*&state)->base);
	Vector2D_ctor(&vector2D, double_, double__1);
	boolean = Polygon_IsPointWithin(vector2D, self->_polygonPointsInVehicleFrame);
	if (!boolean)
	{
		RemRef_FrontRadarObjectParamete(CS_0_0000);
		return 0.0;
	}
	(void)Assign_FrontRadarObjectParamete(&CS_0_0000, self->_parameters);
	double__2 = FronRadaObjePara_get_DetecProba(CS_0_0000);
	RemRef_FrontRadarObjectParamete(CS_0_0000);
	return double__2;
}

float64_t SinglDetecModel_1_get_GateProba(struct SingleDetectionModel_1 *const self)
{
	return self->_gateProbability;
}

static float64_t SinglDetecModel_1_GetDetecProba(struct PolygonDetectionModel *const self, struct CardinalitySpace *sample, struct FrontRadarObjectSpace *state)
{
	int32_t int32 = ((int32_t)0);

	int32 = CardinalitSpace_get_Cardinality(sample);
	switch (int32)
	{
		case ((int32_t)0):
			{
				float64_t double_ = 0.0;
				float64_t double__1 = 0.0;

				double_ = PolygDetecModel_GetDetectProbab(self, state);
				double__1 = SinglDetecModel_1_get_GateProba(&self->base);
				return 1.0 - (double_ * double__1);
			}
		case ((int32_t)1):
			{
				float64_t double__2 = 0.0;
				float64_t double__3 = 0.0;

				double__2 = PolygDetecModel_GetDetectProbab(self, state);
				double__3 = SinglDetecModel_1_get_GateProba(&self->base);
				return double__2 * double__3;
			}
		default:
			return 0.0;
	}
}

float64_t DetectionModel_1_Evaluate(struct PolygonDetectionModel *const self, struct CardinalitySpace *sample)
{
	float64_t result = 0.0;
	struct CardinalitySpace *cardinalitySpace = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
	float64_t double_ = 0.0;

	(void)Assign_CardinalitySpace(&cardinalitySpace, sample);
	frontRadarObjectSpace = DetectionModel_1_get_Condition(&self->base.base);
	double_ = SinglDetecModel_1_GetDetecProba(self, cardinalitySpace, frontRadarObjectSpace);
	result = double_;
	(void)Assign_CardinalitySpace(&cardinalitySpace, NULL);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	return result;
}

float64_t MarginalizeEvaluable_1_Evaluate(struct MarginalizedEvaluable_1 *const self, struct CardinalitySpace *sample)
{
	float64_t probability = 0.0;
	struct SampleSet_1 *CS_0_0000 = NULL;
	struct StaticListEnumerator_9 *CS_5_0001 = NULL;
	struct StaticListEnumerator_9 *staticListEnumerator = NULL;
	struct SampleProbabilityPair_1 *pair = NULL;
	struct FrontRadarObjectDetectionModel *CS_0_0002 = NULL;
	float64_t arg_61_0 = 0.0;
	struct FrontRadarObjectDetectionModel *CS_0_0003 = NULL;
	bool_t boolean = false;

	probability = 0.0;
	(void)Assign_SampleSet_1(&CS_0_0000, self->_condition);
	staticListEnumerator = SampleSet_1_GetEnumerator(CS_0_0000);
	(void)Assign_StaticListEnumerator_9(&CS_5_0001, staticListEnumerator);
	(void)Assign_StaticListEnumerator_9(&staticListEnumerator, NULL);
	boolean = StaticListEnumerator_9_MoveNext(CS_5_0001);
	while (boolean)
	{
		struct SampleProbabilityPair_1 *sampleProbabilityPair = NULL;
		struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
		float64_t double_ = 0.0;
		float64_t double__1 = 0.0;
		float64_t double__2 = 0.0;

		sampleProbabilityPair = StaticListEnumera_9_get_Current(CS_5_0001);
		(void)Assign_SampleProbabilityPair_1(&pair, sampleProbabilityPair);
		(void)Assign_SampleProbabilityPair_1(&sampleProbabilityPair, NULL);
		(void)Assig_FrontRadarObjecDetecModel(&CS_0_0002, self->_conditionalDistribution);
		frontRadarObjectSpace = SampleProbabilPair_1_get_Sample(pair);
		DetectionModel_1_set_Condition(&(*&CS_0_0002)->base.base.base, frontRadarObjectSpace);
		(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
		arg_61_0 = probability;
		(void)Assig_FrontRadarObjecDetecModel(&CS_0_0003, self->_conditionalDistribution);
		double_ = arg_61_0;
		double__1 = DetectionModel_1_Evaluate(&(*&CS_0_0003)->base, sample);
		double__2 = SampleProbabiPair_1_get_Probabi(pair);
		probability = double_ + (double__1 * double__2);
		boolean = StaticListEnumerator_9_MoveNext(CS_5_0001);
	}
	if (!!(CS_5_0001 != NULL))
	{
		StaticListEnumerator_9_Dispose(CS_5_0001);
	}
	if (!(probability <= 1.0))
	{
		RemRef_SampleSet_1(CS_0_0000);
		RemRef_StaticListEnumerator_9(CS_5_0001);
		RemRef_SampleProbabilityPair_1(pair);
		RemRef_FronRadarObjecDetecModel(CS_0_0002);
		RemRef_FronRadarObjecDetecModel(CS_0_0003);
		return 1.0;
	}
	RemRef_SampleSet_1(CS_0_0000);
	RemRef_StaticListEnumerator_9(CS_5_0001);
	RemRef_SampleProbabilityPair_1(pair);
	RemRef_FronRadarObjecDetecModel(CS_0_0002);
	RemRef_FronRadarObjecDetecModel(CS_0_0003);
	return probability;
}

static void RemRef_StaticList_19(struct StaticList_19 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_19.CurrentCount--;
		Res_StaticList_19.Next[Res_StaticList_19.CurrentCount] = self;
		Del_StaticList_19(self);
	}
}

struct StaticList_19 *New_StaticList_19(void)
{
	static struct StaticList_19 const Default_StaticList_19 = { 1 };
	struct StaticList_19 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_19.CurrentCount == RC_StaticList_19)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_19.Next[Res_StaticList_19.CurrentCount];
	Res_StaticList_19.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_19.MaximumCount = (Res_StaticList_19.CurrentCount > Res_StaticList_19.MaximumCount) ? Res_StaticList_19.CurrentCount : Res_StaticList_19.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_19;
	return instance;
}

struct StaticList_19 *Assign_StaticList_19(struct StaticList_19 **const left, struct StaticList_19 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_19(*left);
	*left = right;
	return right;
}

static void RemRef_TruePositivesHypothesi_1(struct TruePositivesHypothesis_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_TruePositivesHypothesis_1.CurrentCount--;
		Res_TruePositivesHypothesis_1.Next[Res_TruePositivesHypothesis_1.CurrentCount] = self;
		Del_TruePositivesHypothesis_1(self);
	}
}

struct TruePositivesHypothesis_1 *New_TruePositivesHypothesis_1(void)
{
	static struct TruePositivesHypothesis_1 const Default_TruePositiveHypothesi_1 = { 1 };
	struct TruePositivesHypothesis_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_TruePositivesHypothesis_1.CurrentCount == RC_TruePositivesHypothesis_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_TruePositivesHypothesis_1.Next[Res_TruePositivesHypothesis_1.CurrentCount];
	Res_TruePositivesHypothesis_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_TruePositivesHypothesis_1.MaximumCount = (Res_TruePositivesHypothesis_1.CurrentCount > Res_TruePositivesHypothesis_1.MaximumCount) ? Res_TruePositivesHypothesis_1.CurrentCount : Res_TruePositivesHypothesis_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_TruePositiveHypothesi_1;
	return instance;
}

struct TruePositivesHypothesis_1 *Assign_TruePositivesHypothesi_1(struct TruePositivesHypothesis_1 **const left, struct TruePositivesHypothesis_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_TruePositivesHypothesi_1(*left);
	*left = right;
	return right;
}

static void Del_TruePositivHypothes_1_1D_41(struct TruePositivesHypothesis_1_1D_41 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)41);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_TruePositivesHypothesi_1(self->Elements[i]);
	}
}

static void RemRef_TruePositiHypoth_1_1D_41(struct TruePositivesHypothesis_1_1D_41 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_TruePositivHypothes_1_1D_41.CurrentCount--;
		Res_TruePositivHypothes_1_1D_41.Next[Res_TruePositivHypothes_1_1D_41.CurrentCount] = self;
		Del_TruePositivHypothes_1_1D_41(self);
	}
}

struct TruePositivesHypothesis_1_1D_41 *New_TruePositivHypothes_1_1D_41(void)
{
	static struct TruePositivesHypothesis_1_1D_41 const Defaul_TruePositiHypoth_1_1D_41 = { 1 };
	struct TruePositivesHypothesis_1_1D_41 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_TruePositivHypothes_1_1D_41.CurrentCount == RC_TruePositiveHypothes_1_1D_41)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_TruePositivHypothes_1_1D_41.Next[Res_TruePositivHypothes_1_1D_41.CurrentCount];
	Res_TruePositivHypothes_1_1D_41.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_TruePositivHypothes_1_1D_41.MaximumCount = (Res_TruePositivHypothes_1_1D_41.CurrentCount > Res_TruePositivHypothes_1_1D_41.MaximumCount) ? Res_TruePositivHypothes_1_1D_41.CurrentCount : Res_TruePositivHypothes_1_1D_41.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Defaul_TruePositiHypoth_1_1D_41;
	return instance;
}

struct TruePositivesHypothesis_1_1D_41 *Assign_TruePositiHypoth_1_1D_41(struct TruePositivesHypothesis_1_1D_41 **const left, struct TruePositivesHypothesis_1_1D_41 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_TruePositiHypoth_1_1D_41(*left);
	*left = right;
	return right;
}

void StaticList_19_ctor(struct StaticList_19 *const self, int32_t maximumCount)
{
	struct TruePositivesHypothesis_1_1D_41 *array = NULL;

	assert(maximumCount == ((int32_t)41));
	Object_ctor(&self->base);
	array = New_TruePositivHypothes_1_1D_41();
	(void)Assign_TruePositiHypoth_1_1D_41(&self->_items, array);
	(void)Assign_TruePositiHypoth_1_1D_41(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_19 *StatiListFacto_2_CreateInstan_1(struct StaticListFactory_2 *const self, int32_t capacity)
{
	struct StaticList_19 *result = NULL;
	struct StaticList_19 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_2_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_19();
	StaticList_19_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_19(&result, staticList);
	(void)Assign_StaticList_19(&staticList, NULL);
	return result;
}

static void RemRef_StaticList_11(struct StaticList_11 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticList_11.CurrentCount--;
		Res_StaticList_11.Next[Res_StaticList_11.CurrentCount] = self;
		Del_StaticList_11(self);
	}
}

struct StaticList_11 *New_StaticList_11(void)
{
	static struct StaticList_11 const Default_StaticList_11 = { 1 };
	struct StaticList_11 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticList_11.CurrentCount == RC_StaticList_11)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticList_11.Next[Res_StaticList_11.CurrentCount];
	Res_StaticList_11.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticList_11.MaximumCount = (Res_StaticList_11.CurrentCount > Res_StaticList_11.MaximumCount) ? Res_StaticList_11.CurrentCount : Res_StaticList_11.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticList_11;
	return instance;
}

struct StaticList_11 *Assign_StaticList_11(struct StaticList_11 **const left, struct StaticList_11 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticList_11(*left);
	*left = right;
	return right;
}

static void Del_FrontRadarObjectSpace_1D_1(struct FrontRadarObjectSpace_1D_1 *const self)
{
	int32_t i;
	int32_t length = ((int32_t)1);

	Del_Object(&self->base);
	for (i = ((int32_t)0); i < length; i++)
	{
		RemRef_FrontRadarObjectSpace(self->Elements[i]);
	}
}

static void RemRef_FronRadarObjecSpace_1D_1(struct FrontRadarObjectSpace_1D_1 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_FrontRadarObjectSpace_1D_1.CurrentCount--;
		Res_FrontRadarObjectSpace_1D_1.Next[Res_FrontRadarObjectSpace_1D_1.CurrentCount] = self;
		Del_FrontRadarObjectSpace_1D_1(self);
	}
}

struct FrontRadarObjectSpace_1D_1 *New_FrontRadarObjectSpace_1D_1(void)
{
	static struct FrontRadarObjectSpace_1D_1 const Defau_FrontRadarObjecSpace_1D_1 = { 1 };
	struct FrontRadarObjectSpace_1D_1 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_FrontRadarObjectSpace_1D_1.CurrentCount == RC_FrontRadarObjectSpace_1D_1)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_FrontRadarObjectSpace_1D_1.Next[Res_FrontRadarObjectSpace_1D_1.CurrentCount];
	Res_FrontRadarObjectSpace_1D_1.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_FrontRadarObjectSpace_1D_1.MaximumCount = (Res_FrontRadarObjectSpace_1D_1.CurrentCount > Res_FrontRadarObjectSpace_1D_1.MaximumCount) ? Res_FrontRadarObjectSpace_1D_1.CurrentCount : Res_FrontRadarObjectSpace_1D_1.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Defau_FrontRadarObjecSpace_1D_1;
	return instance;
}

struct FrontRadarObjectSpace_1D_1 *Assig_FrontRadarObjecSpace_1D_1(struct FrontRadarObjectSpace_1D_1 **const left, struct FrontRadarObjectSpace_1D_1 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_FronRadarObjecSpace_1D_1(*left);
	*left = right;
	return right;
}

void StaticList_11_ctor(struct StaticList_11 *const self, int32_t maximumCount)
{
	struct FrontRadarObjectSpace_1D_1 *array = NULL;

	assert(maximumCount == ((int32_t)1));
	Object_ctor(&self->base);
	array = New_FrontRadarObjectSpace_1D_1();
	(void)Assig_FrontRadarObjecSpace_1D_1(&self->_items, array);
	(void)Assig_FrontRadarObjecSpace_1D_1(&array, NULL);
	self->MaximumCount = maximumCount;
}

struct StaticList_11 *StatiListFactor_3_CreateInstan(struct StaticListFactory_3 *const self, int32_t capacity)
{
	struct StaticList_11 *result = NULL;
	struct StaticList_11 *staticList = NULL;

	if (!(__ContrRunti_insideContraEvalua > ((int32_t)4)))
	{
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);

		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua + ((int32_t)1);
		if (!(capacity >= ((int32_t)0)))
		{
			abort();
		}
		int32 = capacity;
		int32_1 = StatiListFacto_3_get_MaximCount(self);
		if (!(int32 <= int32_1))
		{
			abort();
		}
		__ContrRunti_insideContraEvalua = __ContrRunti_insideContraEvalua - ((int32_t)1);
	}
	staticList = New_StaticList_11();
	StaticList_11_ctor(staticList, self->_maximumCount);
	(void)Assign_StaticList_11(&result, staticList);
	(void)Assign_StaticList_11(&staticList, NULL);
	return result;
}

static void TruePositiHypothe_1_set_Element(struct TruePositivesHypothesis_1 *const self, struct StaticList_11 *value)
{
	(void)Assign_StaticList_11(&self->Elements, value);
}

static void TruePositivHypothe_1_set_Weight(struct TruePositivesHypothesis_1 *const self, float64_t value)
{
	self->Weight = value;
}

void TruePositivesHypothesis_1_ctor(struct TruePositivesHypothesis_1 *const self, float64_t weight, struct StaticList_11 *elements)
{
	Object_ctor(&self->base);
	TruePositiHypothe_1_set_Element(self, elements);
	TruePositivHypothe_1_set_Weight(self, weight);
}

int32_t StaticList_19_get_Count(struct StaticList_19 *const self)
{
	return self->Count;
}

static void StaticList_19_CheckCount(struct StaticList_19 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_19_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_19_set_Count(struct StaticList_19 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_19_Add(struct StaticList_19 *const self, struct TruePositivesHypothesis_1 *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_19_CheckCount(self);
	int32 = StaticList_19_get_Count(self);
	count = int32;
	(void)Assign_TruePositivesHypothesi_1(&self->_items->Elements[count], value);
	int32_1 = StaticList_19_get_Count(self);
	StaticList_19_set_Count(self, int32_1 + ((int32_t)1));
}

int32_t StaticList_11_get_Count(struct StaticList_11 *const self)
{
	return self->Count;
}

static void StaticList_11_CheckCount(struct StaticList_11 *const self)
{
	int32_t int32 = ((int32_t)0);

	int32 = StaticList_11_get_Count(self);
	if (!(int32 < self->MaximumCount))
	{
		abort();
	}
}

static void StaticList_11_set_Count(struct StaticList_11 *const self, int32_t value)
{
	self->Count = value;
}

void StaticList_11_Add(struct StaticList_11 *const self, struct FrontRadarObjectSpace *value)
{
	int32_t count = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	StaticList_11_CheckCount(self);
	int32 = StaticList_11_get_Count(self);
	count = int32;
	(void)Assign_FrontRadarObjectSpace(&self->_items->Elements[count], value);
	int32_1 = StaticList_11_get_Count(self);
	StaticList_11_set_Count(self, int32_1 + ((int32_t)1));
}

void IPDA_1_ctor(struct IPDA_1 *const self, struct Gaussian_3 *spatialLikelihood, struct Existence *existence, struct MarginalizedEvaluable_1 *truePositiveLikelihood, struct StaticList_9 *elements, float64_t lambda, struct StatiIPDATrackColleFactorProvid *factoryProvider)
{
	struct StatiIPDATrackColleFactorProvid *arg_7A_0 = NULL;
	struct StatiIPDATrackColleFactorProvid *hypothesisListFactoryProvider = NULL;
	float64_t num = 0.0;
	struct MarginalizedEvaluable_1 *marginalizedEvaluable = NULL;
	struct CardinalitySpace *cardinalitySpace = NULL;
	float64_t double_ = 0.0;
	float64_t num2 = 0.0;
	float64_t double__1 = 0.0;
	struct StaticList_1 *list = NULL;
	struct StaticListFactory_5 *staticListFactory = NULL;
	struct StaticList_1 *staticList = NULL;
	struct StaticList_9 *list2 = NULL;
	struct StaticListFactory_5 *staticListFactory_1 = NULL;
	struct StaticList_9 *staticList_1 = NULL;
	float64_t num3 = 0.0;
	struct StaticListEnumerator_5 *enumerator = NULL;
	struct StaticListEnumerator_5 *staticListEnumerator = NULL;
	struct FrontRadarObjectSpace *current = NULL;
	float64_t num4 = 0.0;
	bool_t boolean = false;
	float64_t num5 = 0.0;
	struct MeasurementSetLikelihood *measurementSetLikelihood = NULL;
	float64_t num6 = 0.0;
	struct StaticList_19 *list3 = NULL;
	struct StaticListFactory_2 *staticListFactory_2 = NULL;
	int32_t int32 = ((int32_t)0);
	struct StaticList_19 *staticList_2 = NULL;
	struct StaticList_19 *staticList_3 = NULL;
	float64_t double__2 = 0.0;
	struct StaticListFactory_3 *staticListFactory_3 = NULL;
	struct StaticList_11 *staticList_4 = NULL;
	struct TruePositivesHypothesis_1 *truePositivesHypothesis = NULL;
	int32_t i = ((int32_t)0);
	float64_t weight = 0.0;
	struct StaticList_11 *list4 = NULL;
	int32_t int32_1 = ((int32_t)0);
	int32_t int32_2 = ((int32_t)0);

	if (!(spatialLikelihood != NULL))
	{
		abort();
	}
	if (!(existence != NULL))
	{
		abort();
	}
	if (!(truePositiveLikelihood != NULL))
	{
		abort();
	}
	if (!(elements != NULL))
	{
		abort();
	}
	if (!(lambda > 0.0))
	{
		abort();
	}
	Object_ctor(&self->base);
	(void)Assi_StatIPDATracCollFactoProvi(&arg_7A_0, factoryProvider);
	(void)Assi_StatIPDATracCollFactoProvi(&hypothesisListFactoryProvider, arg_7A_0);
	IPDA_1_set_Lambda(self, lambda);
	(void)Assign_MarginalizedEvaluable_1(&marginalizedEvaluable, truePositiveLikelihood);
	cardinalitySpace = CardinalitySpace_1_op_Implicit(((int32_t)0));
	double_ = MarginalizeEvaluable_1_Evaluate(marginalizedEvaluable, cardinalitySpace);
	num = 1.0 - double_;
	(void)Assign_MarginalizedEvaluable_1(&marginalizedEvaluable, NULL);
	(void)Assign_CardinalitySpace(&cardinalitySpace, NULL);
	double__1 = TwoPointDistribution_Evaluate(&existence->base, ExistenceSpace_1_Existent);
	num2 = double__1;
	staticListFactory = StIPDATrColFacPro_get_MeaLisFac(hypothesisListFactoryProvider);
	staticList = StatiListFacto_5_CreateInstan(staticListFactory, ((int32_t)0));
	(void)Assign_StaticList_1(&list, staticList);
	(void)Assign_StaticListFactory_5(&staticListFactory, NULL);
	(void)Assign_StaticList_1(&staticList, NULL);
	staticListFactory_1 = StIPDATrColFacPro_get_MeaLisFac(hypothesisListFactoryProvider);
	staticList_1 = StatiListFacto_5_CreateInstan_1(staticListFactory_1, ((int32_t)0));
	(void)Assign_StaticList_9(&list2, staticList_1);
	(void)Assign_StaticListFactory_5(&staticListFactory_1, NULL);
	(void)Assign_StaticList_9(&staticList_1, NULL);
	num3 = 0.0;
	staticListEnumerator = StaticList_9_GetEnumerator(elements);
	(void)Assign_StaticListEnumerator_5(&enumerator, staticListEnumerator);
	(void)Assign_StaticListEnumerator_5(&staticListEnumerator, NULL);
	boolean = StaticListEnumerator_5_MoveNext(enumerator);
	while (boolean)
	{
		struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
		float64_t double__3 = 0.0;

		frontRadarObjectSpace = StaticListEnumera_5_get_Current(enumerator);
		(void)Assign_FrontRadarObjectSpace(&current, frontRadarObjectSpace);
		(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
		StaticList_9_Add(list2, current);
		double__3 = Gaussian_3_Evaluate_1(spatialLikelihood, current);
		num4 = double__3;
		StaticList_1_Add(list, num4);
		num3 = num3 + num4;
		boolean = StaticListEnumerator_5_MoveNext(enumerator);
	}
	if (!!(enumerator != NULL))
	{
		StaticListEnumerator_5_Dispose(enumerator);
	}
	num5 = num - ((num3 * num) / lambda);
	measurementSetLikelihood = New_MeasurementSetLikelihood();
	MeasurementSetLikelihood_ctor(measurementSetLikelihood, 1.0 - num5, 1.0);
	(void)Assign_MeasurementSetLikelihood(&self->_elementsLikelihood, measurementSetLikelihood);
	(void)Assign_MeasurementSetLikelihood(&measurementSetLikelihood, NULL);
	num6 = 1.0 - (num5 * num2);
	staticListFactory_2 = StIPDATrColFacPro_get_HypLisFac(hypothesisListFactoryProvider);
	int32 = StaticList_9_get_Count(list2);
	staticList_2 = StatiListFacto_2_CreateInstan_1(staticListFactory_2, int32 + ((int32_t)1));
	(void)Assign_StaticList_19(&list3, staticList_2);
	(void)Assign_StaticListFactory_2(&staticListFactory_2, NULL);
	(void)Assign_StaticList_19(&staticList_2, NULL);
	(void)Assign_StaticList_19(&staticList_3, list3);
	double__2 = (1.0 - (num2 * num)) / num6;
	staticListFactory_3 = StIPDATrCoFaPr_get_TruEleLisFac(hypothesisListFactoryProvider);
	staticList_4 = StatiListFactor_3_CreateInstan(staticListFactory_3, ((int32_t)0));
	truePositivesHypothesis = New_TruePositivesHypothesis_1();
	TruePositivesHypothesis_1_ctor(truePositivesHypothesis, double__2, staticList_4);
	StaticList_19_Add(staticList_3, truePositivesHypothesis);
	(void)Assign_StaticList_19(&staticList_3, NULL);
	(void)Assign_StaticListFactory_3(&staticListFactory_3, NULL);
	(void)Assign_StaticList_11(&staticList_4, NULL);
	(void)Assign_TruePositivesHypothesi_1(&truePositivesHypothesis, NULL);
	i = ((int32_t)0);
	int32_1 = i;
	int32_2 = StaticList_9_get_Count(list2);
	while (int32_1 < int32_2)
	{
		float64_t double__4 = 0.0;
		float64_t double__5 = 0.0;
		float64_t double__6 = 0.0;
		struct StaticListFactory_3 *staticListFactory_4 = NULL;
		struct StaticList_11 *staticList_5 = NULL;
		struct StaticList_11 *staticList_6 = NULL;
		struct FrontRadarObjectSpace *frontRadarObjectSpace_1 = NULL;
		struct StaticList_19 *staticList_7 = NULL;
		struct TruePositivesHypothesis_1 *truePositivesHypothesis_1 = NULL;

		double__4 = StaticList_1_get_Item(list, i);
		double__5 = double__4 * num2;
		double__6 = double__5 * num;
		weight = double__6 / (num6 * lambda);
		staticListFactory_4 = StIPDATrCoFaPr_get_TruEleLisFac(hypothesisListFactoryProvider);
		staticList_5 = StatiListFactor_3_CreateInstan(staticListFactory_4, ((int32_t)1));
		(void)Assign_StaticList_11(&list4, staticList_5);
		(void)Assign_StaticListFactory_3(&staticListFactory_4, NULL);
		(void)Assign_StaticList_11(&staticList_5, NULL);
		(void)Assign_StaticList_11(&staticList_6, list4);
		frontRadarObjectSpace_1 = StaticList_9_get_Item(list2, i);
		StaticList_11_Add(staticList_6, frontRadarObjectSpace_1);
		(void)Assign_StaticList_11(&staticList_6, NULL);
		(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_1, NULL);
		(void)Assign_StaticList_19(&staticList_7, list3);
		truePositivesHypothesis_1 = New_TruePositivesHypothesis_1();
		TruePositivesHypothesis_1_ctor(truePositivesHypothesis_1, weight, list4);
		StaticList_19_Add(staticList_7, truePositivesHypothesis_1);
		(void)Assign_StaticList_19(&staticList_7, NULL);
		(void)Assign_TruePositivesHypothesi_1(&truePositivesHypothesis_1, NULL);
		i = i + ((int32_t)1);
		int32_1 = i;
		int32_2 = StaticList_9_get_Count(list2);
	}
	(void)Assign_StaticList_19(&self->_hypotheses, list3);
	RemRef_StatIPDATracCollFactProv(arg_7A_0);
	RemRef_StatIPDATracCollFactProv(hypothesisListFactoryProvider);
	RemRef_StaticList_1(list);
	RemRef_StaticList_9(list2);
	RemRef_StaticListEnumerator_5(enumerator);
	RemRef_FrontRadarObjectSpace(current);
	RemRef_StaticList_19(list3);
	RemRef_StaticList_11(list4);
}

struct IPDA_1 *IPDA_2_Create_1(struct Gaussian_3 *spatialLikelihood, struct Existence *existence, struct MarginalizedEvaluable_1 *truePositiveLikelihood, struct StaticList_9 *elements, float64_t lambda, struct StatiIPDATrackColleFactorProvid *factoryProvider)
{
	struct IPDA_1 *result = NULL;
	struct IPDA_1 *ipda = NULL;

	if (!(spatialLikelihood != NULL))
	{
		abort();
	}
	if (!(existence != NULL))
	{
		abort();
	}
	if (!(truePositiveLikelihood != NULL))
	{
		abort();
	}
	if (!(elements != NULL))
	{
		abort();
	}
	if (!(lambda > 0.0))
	{
		abort();
	}
	ipda = New_IPDA_1();
	IPDA_1_ctor(ipda, spatialLikelihood, existence, truePositiveLikelihood, elements, lambda, factoryProvider);
	(void)Assign_IPDA_1(&result, ipda);
	(void)Assign_IPDA_1(&ipda, NULL);
	return result;
}

struct StaticList_19 *IPDA_1_GetHypotheses(struct IPDA_1 *const self)
{
	struct StaticList_19 *result = NULL;

	(void)Assign_StaticList_19(&result, self->_hypotheses);
	return result;
}

struct MeasurementSetLikelihood *IPDA_1_GetElementsLikelihood(struct IPDA_1 *const self)
{
	struct MeasurementSetLikelihood *result = NULL;

	(void)Assign_MeasurementSetLikelihood(&result, self->_elementsLikelihood);
	return result;
}

static void RemRef_StaticListEnumerator_11(struct StaticListEnumerator_11 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListEnumerator_11.CurrentCount--;
		Res_StaticListEnumerator_11.Next[Res_StaticListEnumerator_11.CurrentCount] = self;
		Del_StaticListEnumerator_11(self);
	}
}

struct StaticListEnumerator_11 *New_StaticListEnumerator_11(void)
{
	static struct StaticListEnumerator_11 const Default_StaticListEnumerator_11 = { 1 };
	struct StaticListEnumerator_11 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListEnumerator_11.CurrentCount == RC_StaticListEnumerator_11)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListEnumerator_11.Next[Res_StaticListEnumerator_11.CurrentCount];
	Res_StaticListEnumerator_11.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListEnumerator_11.MaximumCount = (Res_StaticListEnumerator_11.CurrentCount > Res_StaticListEnumerator_11.MaximumCount) ? Res_StaticListEnumerator_11.CurrentCount : Res_StaticListEnumerator_11.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListEnumerator_11;
	return instance;
}

struct StaticListEnumerator_11 *Assign_StaticListEnumerator_11(struct StaticListEnumerator_11 **const left, struct StaticListEnumerator_11 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListEnumerator_11(*left);
	*left = right;
	return right;
}

void StaticListEnumerator_11_ctor(struct StaticListEnumerator_11 *const self, struct StaticList_19 *list)
{
	self->_current = ((int32_t)-1);
	Object_ctor(&self->base);
	(void)Assign_StaticList_19(&self->_list, list);
}

struct StaticListEnumerator_11 *StaticList_19_GetEnumerator(struct StaticList_19 *const self)
{
	struct StaticListEnumerator_11 *result = NULL;
	struct StaticListEnumerator_11 *staticListEnumerator = NULL;

	staticListEnumerator = New_StaticListEnumerator_11();
	StaticListEnumerator_11_ctor(staticListEnumerator, self);
	(void)Assign_StaticListEnumerator_11(&result, staticListEnumerator);
	(void)Assign_StaticListEnumerator_11(&staticListEnumerator, NULL);
	return result;
}

bool_t StaticListEnumerato_11_MoveNext(struct StaticListEnumerator_11 *const self)
{
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	self->_current = self->_current + ((int32_t)1);
	int32 = self->_current;
	int32_1 = StaticList_19_get_Count(self->_list);
	return int32 != int32_1;
}

struct TruePositivesHypothesis_1 *StaticList_19_get_Item(struct StaticList_19 *const self, int32_t index)
{
	struct TruePositivesHypothesis_1 *result = NULL;

	(void)Assign_TruePositivesHypothesi_1(&result, self->_items->Elements[index]);
	return result;
}

struct TruePositivesHypothesis_1 *StaticListEnumer_11_get_Current(struct StaticListEnumerator_11 *const self)
{
	struct TruePositivesHypothesis_1 *result = NULL;
	struct TruePositivesHypothesis_1 *truePositivesHypothesis = NULL;

	truePositivesHypothesis = StaticList_19_get_Item(self->_list, self->_current);
	(void)Assign_TruePositivesHypothesi_1(&result, truePositivesHypothesis);
	(void)Assign_TruePositivesHypothesi_1(&truePositivesHypothesis, NULL);
	return result;
}

struct StaticList_11 *TruePositiHypothe_1_get_Element(struct TruePositivesHypothesis_1 *const self)
{
	struct StaticList_11 *result = NULL;

	(void)Assign_StaticList_11(&result, self->Elements);
	return result;
}

static void RemRef_StaticListEnumerator_7(struct StaticListEnumerator_7 *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base)->ReferenceCount--;
	if ((&self->base)->ReferenceCount == ((int32_t)0))
	{
		Res_StaticListEnumerator_7.CurrentCount--;
		Res_StaticListEnumerator_7.Next[Res_StaticListEnumerator_7.CurrentCount] = self;
		Del_StaticListEnumerator_7(self);
	}
}

struct StaticListEnumerator_7 *New_StaticListEnumerator_7(void)
{
	static struct StaticListEnumerator_7 const Default_StaticListEnumerator_7 = { 1 };
	struct StaticListEnumerator_7 *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_StaticListEnumerator_7.CurrentCount == RC_StaticListEnumerator_7)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_StaticListEnumerator_7.Next[Res_StaticListEnumerator_7.CurrentCount];
	Res_StaticListEnumerator_7.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_StaticListEnumerator_7.MaximumCount = (Res_StaticListEnumerator_7.CurrentCount > Res_StaticListEnumerator_7.MaximumCount) ? Res_StaticListEnumerator_7.CurrentCount : Res_StaticListEnumerator_7.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Default_StaticListEnumerator_7;
	return instance;
}

struct StaticListEnumerator_7 *Assign_StaticListEnumerator_7(struct StaticListEnumerator_7 **const left, struct StaticListEnumerator_7 *const right)
{
	if (right != NULL)
	{
		(&right->base)->ReferenceCount++;
	}
	RemRef_StaticListEnumerator_7(*left);
	*left = right;
	return right;
}

void StaticListEnumerator_7_ctor(struct StaticListEnumerator_7 *const self, struct StaticList_11 *list)
{
	self->_current = ((int32_t)-1);
	Object_ctor(&self->base);
	(void)Assign_StaticList_11(&self->_list, list);
}

struct StaticListEnumerator_7 *StaticList_11_GetEnumerator(struct StaticList_11 *const self)
{
	struct StaticListEnumerator_7 *result = NULL;
	struct StaticListEnumerator_7 *staticListEnumerator = NULL;

	staticListEnumerator = New_StaticListEnumerator_7();
	StaticListEnumerator_7_ctor(staticListEnumerator, self);
	(void)Assign_StaticListEnumerator_7(&result, staticListEnumerator);
	(void)Assign_StaticListEnumerator_7(&staticListEnumerator, NULL);
	return result;
}

bool_t StaticListEnumerator_7_MoveNext(struct StaticListEnumerator_7 *const self)
{
	int32_t int32 = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);

	self->_current = self->_current + ((int32_t)1);
	int32 = self->_current;
	int32_1 = StaticList_11_get_Count(self->_list);
	return int32 != int32_1;
}

struct FrontRadarObjectSpace *StaticList_11_get_Item(struct StaticList_11 *const self, int32_t index)
{
	struct FrontRadarObjectSpace *result = NULL;

	(void)Assign_FrontRadarObjectSpace(&result, self->_items->Elements[index]);
	return result;
}

struct FrontRadarObjectSpace *StaticListEnumera_7_get_Current(struct StaticListEnumerator_7 *const self)
{
	struct FrontRadarObjectSpace *result = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;

	frontRadarObjectSpace = StaticList_11_get_Item(self->_list, self->_current);
	(void)Assign_FrontRadarObjectSpace(&result, frontRadarObjectSpace);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	return result;
}

void StaticListEnumerator_7_Dispose(struct StaticListEnumerator_7 *const self)
{
}

struct FrontRadarObjectSpace *Tracki_1_SimplifFirstOrDefault(struct StaticList_11 *source)
{
	struct StaticListEnumerator_7 *enumerator = NULL;
	struct StaticListEnumerator_7 *staticListEnumerator = NULL;
	struct FrontRadarObjectSpace *result = NULL;
	bool_t boolean = false;

	staticListEnumerator = StaticList_11_GetEnumerator(source);
	(void)Assign_StaticListEnumerator_7(&enumerator, staticListEnumerator);
	(void)Assign_StaticListEnumerator_7(&staticListEnumerator, NULL);
	boolean = StaticListEnumerator_7_MoveNext(enumerator);
	if (!!boolean)
	{
		struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;

		frontRadarObjectSpace = StaticListEnumera_7_get_Current(enumerator);
		(void)Assign_FrontRadarObjectSpace(&result, frontRadarObjectSpace);
		(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
		RemRef_StaticListEnumerator_7(enumerator);
		return result;
	}
	StaticListEnumerator_7_Dispose(enumerator);
	(void)Assign_FrontRadarObjectSpace(&result, NULL);
	RemRef_StaticListEnumerator_7(enumerator);
	return result;
}

struct Type *Object_GetType_3(struct FrontRadarObjectSpace *const self)
{
	struct Type *result;

	result = New_Type();
	Object_ctor(&result->base.base);
	result->_id = ((int32_t)775539252);
	return result;
}

bool_t MatrixData_Equals(struct MatrixData *const self, struct MatrixData *other)
{
	bool_t boolean = false;
	bool_t arg_3B_0 = false;
	bool_t flag = false;
	bool_t flag2 = false;
	struct float64_t_1D_5 *array = NULL;
	int32_t int32 = ((int32_t)0);
	struct float64_t_1D_5 *array_1 = NULL;
	bool_t result = false;
	int32_t i = ((int32_t)0);
	int32_t int32_1 = ((int32_t)0);
	struct float64_t_1D_5 *array_2 = NULL;

	if (!(other != NULL))
	{
		return false;
	}
	boolean = Object_2_ReferenceEquals(&self->base, &other->base);
	if (!!boolean)
	{
		return true;
	}
	arg_3B_0 = self->Columns == other->Columns;
	flag = arg_3B_0;
	array = MatrixData_get_DataReference(self);
	int32 = ((int32_t)5);
	array_1 = MatrixData_get_DataReference(other);
	flag2 = int32 == ((int32_t)5);
	(void)Assign_float64_t_1D_5(&array, NULL);
	(void)Assign_float64_t_1D_5(&array_1, NULL);
	result = true;
	i = ((int32_t)0);
	int32_1 = i;
	array_2 = MatrixData_get_DataReference(self);
	while (int32_1 < ((int32_t)5))
	{
		struct float64_t_1D_5 *array_3 = NULL;
		float64_t double_ = 0.0;
		struct float64_t_1D_5 *array_4 = NULL;
		bool_t boolean_1 = false;

		(void)Assign_float64_t_1D_5(&array_2, NULL);
		array_3 = MatrixData_get_DataReference(self);
		double_ = array_3->Elements[i];
		array_4 = MatrixData_get_DataReference(other);
		boolean_1 = float64_t_Equals(&double_, array_4->Elements[i]);
		if (!boolean_1)
		{
			(void)Assign_float64_t_1D_5(&array_3, NULL);
			(void)Assign_float64_t_1D_5(&array_4, NULL);
			result = false;
		}
		else
		{
			(void)Assign_float64_t_1D_5(&array_3, NULL);
			(void)Assign_float64_t_1D_5(&array_4, NULL);
		}
		i = i + ((int32_t)1);
		int32_1 = i;
		array_2 = MatrixData_get_DataReference(self);
	}
	(void)Assign_float64_t_1D_5(&array_2, NULL);
	return result;
	return false;
}

bool_t Space_Equals(struct FrontRadarObjectSpace *const self, struct Space *other)
{
	struct Type *type = NULL;
	struct Type *type_1 = NULL;
	bool_t boolean = false;
	bool_t boolean_1 = false;
	bool_t boolean_2 = false;
	bool_t boolean_3 = false;
	bool_t boolean_4 = false;
	bool_t boolean_5 = false;
	bool_t boolean_6 = false;
	bool_t boolean_7 = false;
	bool_t boolean_8 = false;
	bool_t boolean_9 = false;
	bool_t result = false;
	struct MatrixData *matrixData = NULL;
	struct MatrixData *matrixData_1 = NULL;
	bool_t boolean_10 = false;

	boolean_1 = Object_2_ReferenceEquals(&other->base, NULL);
	boolean_2 = !boolean_1;
	boolean_3 = boolean_2;
	if (boolean_3 == true)
	{
		type = Object_GetType_1(other);
		type_1 = Object_GetType_3(self);
		boolean = Type_1_op_Inequality(type, type_1);
		boolean_4 = !boolean;
	}
	else
	{
		boolean_4 = false;
	}
	if (!boolean_4)
	{
		if (boolean_3 == true)
		{
			(void)Assign_Type(&type, NULL);
			(void)Assign_Type(&type_1, NULL);
		}
		return false;
	}
	else
	{
		if (boolean_3 == true)
		{
			(void)Assign_Type(&type, NULL);
			(void)Assign_Type(&type_1, NULL);
		}
	}
	boolean_5 = Object_2_ReferenceEquals(&other->base, &self->base.base.base);
	if (!!boolean_5)
	{
		return true;
	}
	boolean_7 = Object_2_ReferenceEquals(&(&self->base.base)->_vector->base, NULL);
	boolean_8 = !boolean_7;
	if (boolean_8 == false)
	{
		boolean_6 = Object_2_ReferenceEquals(&other->_vector->base, NULL);
		boolean_9 = !boolean_6;
	}
	else
	{
		boolean_9 = true;
	}
	if (!boolean_9)
	{
		return (&self->base.base)->Dimensions == other->Dimensions;
	}
	matrixData = Space_get_MatrixData(&self->base.base);
	matrixData_1 = Space_get_MatrixData(other);
	boolean_10 = MatrixData_Equals(matrixData, matrixData_1);
	result = boolean_10;
	(void)Assign_MatrixData(&matrixData, NULL);
	(void)Assign_MatrixData(&matrixData_1, NULL);
	return result;
}

bool_t Space_6_op_Equality_2(struct FrontRadarObjectSpace *left, struct Space *right)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;

	boolean = Object_2_ReferenceEquals(&left->base.base.base, NULL);
	if (!!boolean)
	{
		bool_t boolean_2 = false;

		boolean_2 = Object_2_ReferenceEquals(&right->base, NULL);
		return boolean_2;
	}
	boolean_1 = Space_Equals(left, right);
	return boolean_1;
}

float64_t TruePositivHypothe_1_get_Weight(struct TruePositivesHypothesis_1 *const self)
{
	return self->Weight;
}

struct Matrix_13 *StaticList_17_get_Item(struct StaticList_17 *const self, int32_t index)
{
	struct Matrix_13 *result = NULL;

	(void)Assign_Matrix_13(&result, self->_items->Elements[index]);
	return result;
}

void LinearAlgebra_SolveLU_2(struct LinearAlgebra *const self, struct float64_t_1D_25 *a, int32_t rows, struct int32_t_1D_5 *pivotIndices, struct float64_t_1D_25 *b)
{
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t int32 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t j = ((int32_t)0);
	float64_t num5 = 0.0;
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t expr_16A_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rows > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)25) % rows) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!!((((int32_t)25) % rows) != ((int32_t)0)))
	{
		abort();
	}
	num = ((int32_t)25) / rows;
	num2 = ((int32_t)25) / rows;
	int32 = Math_Min(num, rows);
	num3 = int32;
	if (!(pivotIndices != NULL))
	{
		abort();
	}
	if (!(((int32_t)5) == num3))
	{
		abort();
	}
	if (!(num <= rows))
	{
		abort();
	}
	i = ((int32_t)0);
	while (i < num3)
	{
		num4 = pivotIndices->Elements[i] - ((int32_t)1);
		if (!(num4 == i))
		{
			j = ((int32_t)0);
			while (j < num2)
			{
				num5 = b->Elements[(j * rows) + num4];
				b->Elements[(j * rows) + num4] = b->Elements[(j * rows) + i];
				b->Elements[(j * rows) + i] = num5;
				j = j + ((int32_t)1);
			}
		}
		i = i + ((int32_t)1);
	}
	k = ((int32_t)0);
	while (k < num2)
	{
		l = ((int32_t)0);
		while (l < num3)
		{
			m = l + ((int32_t)1);
			while (m < num3)
			{
				expr_16A_cp_1 = (k * rows) + m;
				b->Elements[expr_16A_cp_1] = b->Elements[expr_16A_cp_1] - (b->Elements[(k * rows) + l] * a->Elements[(l * rows) + m]);
				m = m + ((int32_t)1);
			}
			l = l + ((int32_t)1);
		}
		k = k + ((int32_t)1);
	}
	LineaAlgeb_1_SolveUpperTriang(a, rows, num3, b, rows, num2, false);
}

struct MatrixData_2 *MatrixMath_LinsolveSquare_2(struct MatrixData_2 *left, struct MatrixData_2 *right)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t rows = ((int32_t)0);
	struct MatrixData_2 *copy = NULL;
	struct MatrixData_2 *matrixData = NULL;
	struct int32_t_1D_5 *pivotIndices = NULL;
	struct int32_t_1D_5 *array = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_25 *array_1 = NULL;
	struct MatrixData_2 *copy2 = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra_1 = NULL;
	struct float64_t_1D_25 *array_2 = NULL;
	int32_t int32 = ((int32_t)0);
	struct int32_t_1D_5 *array_3 = NULL;
	struct float64_t_1D_25 *array_4 = NULL;
	struct MatrixData_2 *result = NULL;

	if (!(left != NULL))
	{
		abort();
	}
	boolean = MatrixData_2_get_IsEmpty(left);
	if (!(right != NULL))
	{
		abort();
	}
	boolean_1 = MatrixData_2_get_IsEmpty(right);
	rows = left->Rows;
	matrixData = MatrixData_2_get_Copy(left);
	(void)Assign_MatrixData_2(&copy, matrixData);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	array = New_int32_t_1D_5();
	(void)Assign_int32_t_1D_5(&pivotIndices, array);
	(void)Assign_int32_t_1D_5(&array, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array_1 = MatrixData_2_get_DataReference(copy);
	LinearAlgebra_FactorLU_2(linearAlgebra, array_1, rows, pivotIndices);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_25(&array_1, NULL);
	matrixData_1 = MatrixData_2_get_Copy(right);
	(void)Assign_MatrixData_2(&copy2, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra_1, MatrixMath_LinearAlgebra);
	array_2 = MatrixData_2_get_DataReference(copy);
	int32 = copy->Rows;
	(void)Assign_int32_t_1D_5(&array_3, pivotIndices);
	array_4 = MatrixData_2_get_DataReference(copy2);
	LinearAlgebra_SolveLU_2(linearAlgebra_1, array_2, int32, array_3, array_4);
	(void)Assign_LinearAlgebra(&linearAlgebra_1, NULL);
	(void)Assign_float64_t_1D_25(&array_2, NULL);
	(void)Assign_int32_t_1D_5(&array_3, NULL);
	(void)Assign_float64_t_1D_25(&array_4, NULL);
	(void)Assign_MatrixData_2(&result, copy2);
	RemRef_MatrixData_2(copy);
	RemRef_int32_t_1D_5(pivotIndices);
	RemRef_MatrixData_2(copy2);
	return result;
}

struct MatrixData_2 *MatrixMath_Multiply_43(bool_t transposeFirst, bool_t transposeSecond, bool_t transposeThird, struct MatrixData_2 *first, struct MatrixData_2 *second, struct MatrixData_2 *third)
{
	struct MatrixData_2 *left = NULL;
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *result = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;

	assert(transposeFirst == false);
	assert(transposeSecond == true);
	assert(transposeThird == false);
	if (!(first != NULL))
	{
		abort();
	}
	if (!(second != NULL))
	{
		abort();
	}
	if (!(third != NULL))
	{
		abort();
	}
	matrixData = MatrixMath_Multiply_17(transposeFirst, transposeSecond, first, second);
	(void)Assign_MatrixData_2(&left, matrixData);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	matrixData_1 = MatrixMath_Multiply_16(false, transposeThird, left, third);
	(void)Assign_MatrixData_2(&result, matrixData_1);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	RemRef_MatrixData_2(left);
	return result;
}

void LinearAlgebra_MatrixMultiply_24(struct LinearAlgebra *const self, struct float64_t_1D_25 *a, int32_t rowsA, bool_t transposeA, struct float64_t_1D_5 *b, int32_t rowsB, bool_t transposeB, struct float64_t_1D_5 *c)
{
	bool_t boolean = false;
	bool_t boolean_1 = false;
	int32_t arg_D9_0 = ((int32_t)0);
	int32_t num = ((int32_t)0);
	int32_t num2 = ((int32_t)0);
	int32_t arg_F5_0 = ((int32_t)0);
	int32_t num3 = ((int32_t)0);
	int32_t num4 = ((int32_t)0);
	int32_t num5 = ((int32_t)0);
	int32_t num6 = ((int32_t)0);
	int32_t i = ((int32_t)0);
	int32_t j = ((int32_t)0);
	int32_t k = ((int32_t)0);
	int32_t l = ((int32_t)0);
	int32_t expr_1B0_cp_1 = ((int32_t)0);
	int32_t m = ((int32_t)0);
	int32_t n = ((int32_t)0);
	int32_t num7 = ((int32_t)0);
	int32_t num8 = ((int32_t)0);
	int32_t expr_23C_cp_1 = ((int32_t)0);
	int32_t num9 = ((int32_t)0);
	int32_t num10 = ((int32_t)0);
	int32_t num11 = ((int32_t)0);
	int32_t expr_2BE_cp_1 = ((int32_t)0);
	int32_t num12 = ((int32_t)0);
	int32_t num13 = ((int32_t)0);
	int32_t num14 = ((int32_t)0);
	int32_t expr_335_cp_1 = ((int32_t)0);

	if (!(a != NULL))
	{
		abort();
	}
	if (!(rowsA > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)25) % rowsA) != ((int32_t)0)))
	{
		abort();
	}
	if (!(b != NULL))
	{
		abort();
	}
	if (!(rowsB > ((int32_t)0)))
	{
		abort();
	}
	if (!!((((int32_t)5) % rowsB) != ((int32_t)0)))
	{
		abort();
	}
	boolean = Object_2_ReferenceEquals(&a->base, &c->base);
	if (!!boolean)
	{
		abort();
	}
	boolean_1 = Object_2_ReferenceEquals(&b->base, &c->base);
	if (!!boolean_1)
	{
		abort();
	}
	if (!(c != NULL))
	{
		abort();
	}
	if (!transposeA)
	{
		arg_D9_0 = rowsA;
	}
	else
	{
		arg_D9_0 = ((int32_t)25) / rowsA;
	}
	num = arg_D9_0;
	num2 = ((int32_t)25) / num;
	if (!transposeB)
	{
		arg_F5_0 = rowsB;
	}
	else
	{
		arg_F5_0 = ((int32_t)5) / rowsB;
	}
	num3 = arg_F5_0;
	num4 = ((int32_t)5) / num3;
	if (!(num2 == num3))
	{
		abort();
	}
	num5 = ((int32_t)25) / rowsA;
	num6 = num * num4;
	if (!(((int32_t)5) == num6))
	{
		abort();
	}
	if (!transposeA)
	{
		if (!transposeB)
		{
			i = ((int32_t)0);
			while (i < num4)
			{
				j = ((int32_t)0);
				while (j < num)
				{
					c->Elements[(i * num) + j] = a->Elements[j] * b->Elements[i * rowsB];
					j = j + ((int32_t)1);
				}
				k = ((int32_t)1);
				while (k < num5)
				{
					l = ((int32_t)0);
					while (l < num)
					{
						expr_1B0_cp_1 = (i * num) + l;
						c->Elements[expr_1B0_cp_1] = c->Elements[expr_1B0_cp_1] + (a->Elements[(k * rowsA) + l] * b->Elements[(i * rowsB) + k]);
						l = l + ((int32_t)1);
					}
					k = k + ((int32_t)1);
				}
				i = i + ((int32_t)1);
			}
			return;
		}
		m = ((int32_t)0);
		while (m < num4)
		{
			n = ((int32_t)0);
			while (n < num)
			{
				c->Elements[(m * num) + n] = a->Elements[n] * b->Elements[m];
				n = n + ((int32_t)1);
			}
			num7 = ((int32_t)1);
			while (num7 < num5)
			{
				num8 = ((int32_t)0);
				while (num8 < num)
				{
					expr_23C_cp_1 = (m * num) + num8;
					c->Elements[expr_23C_cp_1] = c->Elements[expr_23C_cp_1] + (a->Elements[(num7 * rowsA) + num8] * b->Elements[m + (rowsB * num7)]);
					num8 = num8 + ((int32_t)1);
				}
				num7 = num7 + ((int32_t)1);
			}
			m = m + ((int32_t)1);
		}
		return;
	}
	else
	{
		if (!transposeB)
		{
			num9 = ((int32_t)0);
			while (num9 < num4)
			{
				num10 = ((int32_t)0);
				while (num10 < num)
				{
					c->Elements[(num9 * num) + num10] = a->Elements[rowsA * num10] * b->Elements[num9 * rowsB];
					num11 = ((int32_t)1);
					while (num11 < rowsA)
					{
						expr_2BE_cp_1 = (num9 * num) + num10;
						c->Elements[expr_2BE_cp_1] = c->Elements[expr_2BE_cp_1] + (a->Elements[num11 + (rowsA * num10)] * b->Elements[(num9 * rowsB) + num11]);
						num11 = num11 + ((int32_t)1);
					}
					num10 = num10 + ((int32_t)1);
				}
				num9 = num9 + ((int32_t)1);
			}
			return;
		}
		num12 = ((int32_t)0);
		while (num12 < num4)
		{
			num13 = ((int32_t)0);
			while (num13 < num)
			{
				c->Elements[(num12 * num) + num13] = a->Elements[rowsA * num13] * b->Elements[num12];
				num14 = ((int32_t)1);
				while (num14 < rowsA)
				{
					expr_335_cp_1 = (num12 * num) + num13;
					c->Elements[expr_335_cp_1] = c->Elements[expr_335_cp_1] + (a->Elements[num14 + (rowsA * num13)] * b->Elements[num12 + (rowsB * num14)]);
					num14 = num14 + ((int32_t)1);
				}
				num13 = num13 + ((int32_t)1);
			}
			num12 = num12 + ((int32_t)1);
		}
		return;
	}
}

struct MatrixData *MatrixMath_Multiply_44(bool_t transposeLeft, bool_t transposeRight, struct MatrixData_2 *left, struct MatrixData *right)
{
	int32_t arg_145_0 = ((int32_t)0);
	int32_t rows = ((int32_t)0);
	int32_t arg_15D_0 = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	struct MatrixData *matrixData = NULL;
	struct MatrixData *matrixData_1 = NULL;
	struct LinearAlgebra *linearAlgebra = NULL;
	struct float64_t_1D_25 *array = NULL;
	int32_t int32 = ((int32_t)0);
	bool_t boolean = false;
	struct float64_t_1D_5 *array_1 = NULL;
	int32_t int32_1 = ((int32_t)0);
	bool_t boolean_1 = false;
	struct float64_t_1D_5 *array_2 = NULL;
	struct MatrixData *result = NULL;

	assert(transposeLeft == false);
	assert(transposeRight == false);
	if (!(left != NULL))
	{
		abort();
	}
	if (!(right != NULL))
	{
		abort();
	}
	arg_145_0 = left->Rows;
	rows = arg_145_0;
	arg_15D_0 = right->Columns;
	columns = arg_15D_0;
	matrixData_1 = New_MatrixData();
	MatrixData_ctor(matrixData_1, rows, columns);
	(void)Assign_MatrixData(&matrixData, matrixData_1);
	(void)Assign_MatrixData(&matrixData_1, NULL);
	(void)Assign_LinearAlgebra(&linearAlgebra, MatrixMath_LinearAlgebra);
	array = MatrixData_2_get_DataReference(left);
	int32 = left->Rows;
	boolean = transposeLeft;
	array_1 = MatrixData_get_DataReference(right);
	int32_1 = right->Rows;
	boolean_1 = transposeRight;
	array_2 = MatrixData_get_DataReference(matrixData);
	LinearAlgebra_MatrixMultiply_24(linearAlgebra, array, int32, boolean, array_1, int32_1, boolean_1, array_2);
	(void)Assign_LinearAlgebra(&linearAlgebra, NULL);
	(void)Assign_float64_t_1D_25(&array, NULL);
	(void)Assign_float64_t_1D_5(&array_1, NULL);
	(void)Assign_float64_t_1D_5(&array_2, NULL);
	(void)Assign_MatrixData(&result, matrixData);
	RemRef_MatrixData(matrixData);
	return result;
}

struct Gaussian_5 *EKF_Update_5(struct Gaussian_5 *predictedState, struct Gaussian_3 *predictedMeasurement, struct FrontRadarObjectSpace *measurement, struct Matrix_13 *transitionMatrix)
{
	struct MatrixData_2 *matrixData = NULL;
	struct PositiveDefiniteMatrix_5 *positiveDefiniteMatrix = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	struct MatrixData_2 *matrixData2 = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_1 = NULL;
	struct MatrixData_2 *matrixData_2 = NULL;
	struct MatrixData_2 *matrixData_3 = NULL;
	struct MatrixData_2 *matrixData_4 = NULL;
	struct MatrixData_2 *matrixData_5 = NULL;
	struct MatrixData_2 *matrixData_6 = NULL;
	struct MatrixData_2 *matrixData_7 = NULL;
	struct MatrixData *right = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace_1 = NULL;
	struct float64_t_1D_5 *array = NULL;
	struct MatrixData *matrixData_8 = NULL;
	struct CASpace *expectation = NULL;
	struct CASpace *caSpace = NULL;
	struct MatrixData *vector = NULL;
	struct MatrixData *matrixData_9 = NULL;
	struct MatrixData *matrixData_10 = NULL;
	struct MatrixData *matrixData_11 = NULL;
	struct MatrixData_2 *matrix = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_2 = NULL;
	struct MatrixData_2 *matrixData_12 = NULL;
	struct MatrixData_2 *matrixData_13 = NULL;
	struct MatrixData_2 *matrixData_14 = NULL;
	struct CASpace *expectation2 = NULL;
	struct CASpace *caSpace_1 = NULL;
	struct CASpace *caSpace_2 = NULL;
	struct PositiveDefiniteMatrix_7 *covariance = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_3 = NULL;
	struct Gaussian_5 *result = NULL;
	struct Gaussian_5 *gaussian = NULL;

	positiveDefiniteMatrix = Gaussian_3_get_Covariance(predictedMeasurement);
	matrixData_1 = Matrix_5_get_MatrixData(&positiveDefiniteMatrix->base.base);
	(void)Assign_MatrixData_2(&matrixData, matrixData_1);
	(void)Assign_PositiveDefiniteMatrix_5(&positiveDefiniteMatrix, NULL);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	positiveDefiniteMatrix_1 = Gaussian_5_get_Covariance(predictedState);
	matrixData_2 = Matrix_10_get_MatrixData(&positiveDefiniteMatrix_1->base.base);
	matrixData_3 = Matrix_13_get_MatrixData(transitionMatrix);
	(void)Assign_MatrixData_2(&matrixData_4, matrixData);
	matrixData_5 = MatrixData_20_Eye(matrixData->Rows, matrixData->Columns);
	matrixData_6 = MatrixMath_LinsolveSquare_2(matrixData_4, matrixData_5);
	matrixData_7 = MatrixMath_Multiply_43(false, true, false, matrixData_2, matrixData_3, matrixData_6);
	(void)Assign_MatrixData_2(&matrixData2, matrixData_7);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_1, NULL);
	(void)Assign_MatrixData_2(&matrixData_2, NULL);
	(void)Assign_MatrixData_2(&matrixData_3, NULL);
	(void)Assign_MatrixData_2(&matrixData_4, NULL);
	(void)Assign_MatrixData_2(&matrixData_5, NULL);
	(void)Assign_MatrixData_2(&matrixData_6, NULL);
	(void)Assign_MatrixData_2(&matrixData_7, NULL);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, measurement);
	frontRadarObjectSpace_1 = Gaussian_3_get_Expectation(predictedMeasurement);
	array = Space_6_op_Subtraction_4(&frontRadarObjectSpace->base.base, &frontRadarObjectSpace_1->base.base);
	matrixData_8 = MatrixData_20_Create_2(array);
	(void)Assign_MatrixData(&right, matrixData_8);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_1, NULL);
	(void)Assign_float64_t_1D_5(&array, NULL);
	(void)Assign_MatrixData(&matrixData_8, NULL);
	caSpace = Gaussian_5_get_Expectation(predictedState);
	(void)Assign_CASpace(&expectation, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	matrixData_9 = Space_get_MatrixData(&(*&expectation)->base.base.base);
	matrixData_10 = MatrixMath_Multiply_44(false, false, matrixData2, right);
	matrixData_11 = MatrixMath_Add_5(matrixData_9, matrixData_10);
	(void)Assign_MatrixData(&vector, matrixData_11);
	(void)Assign_MatrixData(&matrixData_9, NULL);
	(void)Assign_MatrixData(&matrixData_10, NULL);
	(void)Assign_MatrixData(&matrixData_11, NULL);
	positiveDefiniteMatrix_2 = Gaussian_5_get_Covariance(predictedState);
	matrixData_12 = Matrix_10_get_MatrixData(&positiveDefiniteMatrix_2->base.base);
	matrixData_13 = MatrixMath_Multiply_18(false, false, true, matrixData2, matrixData, matrixData2);
	matrixData_14 = MatrixMath_Subtract_4(matrixData_12, matrixData_13);
	(void)Assign_MatrixData_2(&matrix, matrixData_14);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_2, NULL);
	(void)Assign_MatrixData_2(&matrixData_12, NULL);
	(void)Assign_MatrixData_2(&matrixData_13, NULL);
	(void)Assign_MatrixData_2(&matrixData_14, NULL);
	caSpace_1 = Space_6_Create_3(vector);
	caSpace_2 = SpaceExtensions_FitToDomain_1(caSpace_1);
	(void)Assign_CASpace(&expectation2, caSpace_2);
	(void)Assign_CASpace(&caSpace_1, NULL);
	(void)Assign_CASpace(&caSpace_2, NULL);
	positiveDefiniteMatrix_3 = PosiDefinMatri_11_CreatAndCorre(matrix);
	(void)Assign_PositiveDefiniteMatrix_7(&covariance, positiveDefiniteMatrix_3);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_3, NULL);
	gaussian = Gaussian_9_Create(expectation2, covariance);
	(void)Assign_Gaussian_5(&result, gaussian);
	(void)Assign_Gaussian_5(&gaussian, NULL);
	RemRef_MatrixData_2(matrixData);
	RemRef_MatrixData_2(matrixData2);
	RemRef_MatrixData(right);
	RemRef_CASpace(expectation);
	RemRef_MatrixData(vector);
	RemRef_MatrixData_2(matrix);
	RemRef_CASpace(expectation2);
	RemRef_PositiveDefiniteMatrix_7(covariance);
	return result;
}

struct Object_1 *FronRadaObjeSpac_get_Ars308Obje(struct FrontRadarObjectSpace *const self)
{
	struct Object_1 *result = NULL;

	(void)Assign_Object_1(&result, self->Ars308Object);
	return result;
}

void StaticListEnumerator_11_Dispose(struct StaticListEnumerator_11 *const self)
{
}

struct StaticList_9 *Associa_1_GetNotAssociatObjects(struct Association_1 *const self)
{
	struct StaticList_9 *list = NULL;
	struct StaticListFactory_5 *staticListFactory = NULL;
	int32_t int32 = ((int32_t)0);
	struct StaticList_9 *staticList = NULL;
	struct StaticListEnumerator *enumerator = NULL;
	struct StaticListEnumerator *staticListEnumerator = NULL;
	int32_t current = ((int32_t)0);
	bool_t boolean = false;
	struct StaticList_9 *result = NULL;

	staticListFactory = StIPDATrCoFacPro_get_Obj2LisFac(self->_factoryProvider);
	int32 = StaticList_get_Count(self->_notAssociatedObjects);
	staticList = StatiListFacto_5_CreateInstan_1(staticListFactory, int32);
	(void)Assign_StaticList_9(&list, staticList);
	(void)Assign_StaticListFactory_5(&staticListFactory, NULL);
	(void)Assign_StaticList_9(&staticList, NULL);
	staticListEnumerator = StaticList_GetEnumerator(self->_notAssociatedObjects);
	(void)Assign_StaticListEnumerator(&enumerator, staticListEnumerator);
	(void)Assign_StaticListEnumerator(&staticListEnumerator, NULL);
	boolean = StaticListEnumerator_MoveNext(enumerator);
	while (boolean)
	{
		int32_t int32_1 = ((int32_t)0);
		struct StaticList_9 *staticList_1 = NULL;
		struct StaticList_9 *staticList_2 = NULL;
		struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;

		int32_1 = StaticListEnumerato_get_Current(enumerator);
		current = int32_1;
		(void)Assign_StaticList_9(&staticList_1, list);
		staticList_2 = Association_1_get_Objects2(self);
		frontRadarObjectSpace = StaticList_9_get_Item(staticList_2, current);
		StaticList_9_Add(staticList_1, frontRadarObjectSpace);
		(void)Assign_StaticList_9(&staticList_1, NULL);
		(void)Assign_StaticList_9(&staticList_2, NULL);
		(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
		boolean = StaticListEnumerator_MoveNext(enumerator);
	}
	if (!!(enumerator != NULL))
	{
		StaticListEnumerator_Dispose(enumerator);
	}
	(void)Assign_StaticList_9(&result, list);
	RemRef_StaticList_9(list);
	RemRef_StaticListEnumerator(enumerator);
	return result;
}

static void RemRef_InvCarMeaModWithVectVelo(struct InveCartMeasModelWithVectoVeloc *const self)
{
	if (self == NULL)
	{
		return;
	}
	(&self->base.base)->ReferenceCount--;
	if ((&self->base.base)->ReferenceCount == ((int32_t)0))
	{
		Res_InvCartMeasModeWithVectVelo.CurrentCount--;
		Res_InvCartMeasModeWithVectVelo.Next[Res_InvCartMeasModeWithVectVelo.CurrentCount] = self;
		Del_InvCartMeasModeWithVectVelo(self);
	}
}

struct InveCartMeasModelWithVectoVeloc *New_InvCartMeasModeWithVectVelo(void)
{
	static struct InveCartMeasModelWithVectoVeloc const Def_InvCartMeasModeWithVectVelo = { 1 };
	struct InveCartMeasModelWithVectoVeloc *instance;
	
	#ifdef DISABLE_MEMORY_PROFILING
	if (Res_InvCartMeasModeWithVectVelo.CurrentCount == RC_InveCartMeasModeWithVectVelo)
	{
		abort();
	}
	#endif /* DISABLE_MEMORY_PROFILING */
	instance = Res_InvCartMeasModeWithVectVelo.Next[Res_InvCartMeasModeWithVectVelo.CurrentCount];
	Res_InvCartMeasModeWithVectVelo.CurrentCount++;
	#ifndef DISABLE_MEMORY_PROFILING
	Res_InvCartMeasModeWithVectVelo.MaximumCount = (Res_InvCartMeasModeWithVectVelo.CurrentCount > Res_InvCartMeasModeWithVectVelo.MaximumCount) ? Res_InvCartMeasModeWithVectVelo.CurrentCount : Res_InvCartMeasModeWithVectVelo.MaximumCount;
	#endif /* DISABLE_MEMORY_PROFILING */
	*instance = Def_InvCartMeasModeWithVectVelo;
	return instance;
}

struct InveCartMeasModelWithVectoVeloc *Ass_InvCartMeasModeWithVectVelo(struct InveCartMeasModelWithVectoVeloc **const left, struct InveCartMeasModelWithVectoVeloc *const right)
{
	if (right != NULL)
	{
		(&right->base.base)->ReferenceCount++;
	}
	RemRef_InvCarMeaModWithVectVelo(*left);
	*left = right;
	return right;
}

static void InveCartMeasMode_set_SensParam(struct InverseCartesianMeasuremeModel *const self, struct FrontRadarObjectParameters *value)
{
	(void)Assign_FrontRadarObjectParamete(&self->SensorParameters, value);
}

struct FrontRadarObjectParameters *InveCartMeasMode_get_SensParam(struct InverseCartesianMeasuremeModel *const self)
{
	struct FrontRadarObjectParameters *result = NULL;

	(void)Assign_FrontRadarObjectParamete(&result, self->SensorParameters);
	return result;
}

void InversCartesiMeasureModel_ctor(struct InverseCartesianMeasuremeModel *const self, struct FrontRadarObjectParameters *sensorParameters)
{
	struct FrontRadarObjectParameters *frontRadarObjectParameters = NULL;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	struct FrontRadarObjectParameters *frontRadarObjectParameters_1 = NULL;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;

	Object_ctor(&self->base);
	InveCartMeasMode_set_SensParam(self, sensorParameters);
	frontRadarObjectParameters = InveCartMeasMode_get_SensParam(self);
	double_ = FrontRadarObjecParam_get_RotatZ(frontRadarObjectParameters);
	double__1 = Math_Cos(double_);
	self->CosRotZ = double__1;
	(void)Assign_FrontRadarObjectParamete(&frontRadarObjectParameters, NULL);
	frontRadarObjectParameters_1 = InveCartMeasMode_get_SensParam(self);
	double__2 = FrontRadarObjecParam_get_RotatZ(frontRadarObjectParameters_1);
	double__3 = Math_Sin(double__2);
	self->SinRotZ = double__3;
	(void)Assign_FrontRadarObjectParamete(&frontRadarObjectParameters_1, NULL);
}

static void InCarMeaModWitVecVel_set_EgoVel(struct InveCartMeasModelWithVectoVeloc *const self, float64_t value)
{
	self->EgoVelocity = value;
}

static void InCaMeMoWitVecVel_set_EgoYawRat(struct InveCartMeasModelWithVectoVeloc *const self, float64_t value)
{
	self->EgoYawRate = value;
}

static void InCarMeaModWitVecVel_set_EgoAcc(struct InveCartMeasModelWithVectoVeloc *const self, float64_t value)
{
	self->EgoAcceleration = value;
}

void InvCarMeasModeWithVectVelo_ctor(struct InveCartMeasModelWithVectoVeloc *const self, struct FrontRadarObjectParameters *sensorParameters, float64_t egoVelocity, float64_t egoYawRate, float64_t egoAcceleration)
{
	InversCartesiMeasureModel_ctor(&self->base, sensorParameters);
	InCarMeaModWitVecVel_set_EgoVel(self, egoVelocity);
	InCaMeMoWitVecVel_set_EgoYawRat(self, egoYawRate);
	InCarMeaModWitVecVel_set_EgoAcc(self, egoAcceleration);
}

void InversCartesMeasurModel_Transf(struct InverseCartesianMeasuremeModel *const self, struct FrontRadarObjectSpace *measurement, struct CASpace **state)
{
	float64_t x = 0.0;
	float64_t double_ = 0.0;
	float64_t y = 0.0;
	float64_t double__1 = 0.0;
	struct CASpace **caSpace = NULL;
	float64_t double__2 = 0.0;
	struct FrontRadarObjectParameters *frontRadarObjectParameters = NULL;
	float64_t double__3 = 0.0;
	struct CASpace **caSpace_1 = NULL;
	float64_t double__4 = 0.0;
	struct FrontRadarObjectParameters *frontRadarObjectParameters_1 = NULL;
	float64_t double__5 = 0.0;

	double_ = CVComponentsSpace_get_X(&(*&measurement)->base);
	x = double_;
	double__1 = CVComponentsSpace_get_Y(&(*&measurement)->base);
	y = double__1;
	caSpace = state;
	double__2 = (x * self->CosRotZ) - (y * self->SinRotZ);
	frontRadarObjectParameters = InveCartMeasMode_get_SensParam(self);
	double__3 = FrontRadarObjecParam_get_PositX(frontRadarObjectParameters);
	CVSpace_set_X(&(*caSpace)->base, double__2 + double__3);
	(void)Assign_FrontRadarObjectParamete(&frontRadarObjectParameters, NULL);
	caSpace_1 = state;
	double__4 = (x * self->SinRotZ) + (y * self->CosRotZ);
	frontRadarObjectParameters_1 = InveCartMeasMode_get_SensParam(self);
	double__5 = FrontRadarObjecParam_get_PositY(frontRadarObjectParameters_1);
	CVSpace_set_Y(&(*caSpace_1)->base, double__4 + double__5);
	(void)Assign_FrontRadarObjectParamete(&frontRadarObjectParameters_1, NULL);
}

static float64_t InCarMeaModWitVecVel_get_EgoVel(struct InveCartMeasModelWithVectoVeloc *const self)
{
	return self->EgoVelocity;
}

static float64_t InCaMeMoWitVecVel_get_EgoYawRat(struct InveCartMeasModelWithVectoVeloc *const self)
{
	return self->EgoYawRate;
}

static float64_t InCarMeaModWitVecVel_get_EgoAcc(struct InveCartMeasModelWithVectoVeloc *const self)
{
	return self->EgoAcceleration;
}

void InvCarMeasModeWithVectVelo_Tran(struct InveCartMeasModelWithVectoVeloc *const self, struct FrontRadarObjectSpace *measurement, struct CASpace **state)
{
	float64_t r = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	float64_t double__5 = 0.0;
	float64_t vx = 0.0;
	float64_t double__6 = 0.0;
	float64_t double__7 = 0.0;
	float64_t double__8 = 0.0;
	float64_t double__9 = 0.0;
	float64_t double__10 = 0.0;
	float64_t vy = 0.0;
	float64_t double__11 = 0.0;
	float64_t double__12 = 0.0;
	float64_t double__13 = 0.0;
	float64_t double__14 = 0.0;
	float64_t double__15 = 0.0;
	float64_t double__16 = 0.0;
	struct CASpace **caSpace = NULL;
	float64_t double__17 = 0.0;
	struct CASpace **caSpace_1 = NULL;
	float64_t double__18 = 0.0;
	struct CASpace **caSpace_2 = NULL;
	float64_t double__19 = 0.0;
	float64_t double__20 = 0.0;
	float64_t double__21 = 0.0;

	InversCartesMeasurModel_Transf(&self->base, measurement, state);
	double_ = CVSpace_get_X(&(*state)->base);
	double__1 = CVSpace_get_X(&(*state)->base);
	double__2 = double_ * double__1;
	double__3 = CVSpace_get_Y(&(*state)->base);
	double__4 = CVSpace_get_Y(&(*state)->base);
	double__5 = Math_Sqrt(double__2 + (double__3 * double__4));
	r = double__5;
	double__6 = CVComponentsSpace_get_Vx(&(*&measurement)->base);
	double__7 = double__6 * (&self->base)->CosRotZ;
	double__8 = CVComponentsSpace_get_Vy(&(*&measurement)->base);
	double__9 = double__7 - (double__8 * (&self->base)->SinRotZ);
	double__10 = InCarMeaModWitVecVel_get_EgoVel(self);
	vx = double__9 + double__10;
	double__11 = CVComponentsSpace_get_Vx(&(*&measurement)->base);
	double__12 = double__11 * (&self->base)->SinRotZ;
	double__13 = CVComponentsSpace_get_Vy(&(*&measurement)->base);
	double__14 = double__12 + (double__13 * (&self->base)->CosRotZ);
	double__15 = r;
	double__16 = InCaMeMoWitVecVel_get_EgoYawRat(self);
	vy = double__14 + (double__15 * double__16);
	caSpace = state;
	double__17 = Math_Sqrt((vx * vx) + (vy * vy));
	CVSpace_set_V(&(*caSpace)->base, double__17);
	caSpace_1 = state;
	double__18 = Math_Atan2(vy, vx);
	CVSpace_set_G(&(*caSpace_1)->base, double__18);
	caSpace_2 = state;
	double__19 = FrontRadarObjectSpace_get_A(measurement);
	double__20 = double__19 * (&self->base)->CosRotZ;
	double__21 = InCarMeaModWitVecVel_get_EgoAcc(self);
	CASpace_set_A(*caSpace_2, double__20 + double__21);
}

void PositiDefinitMatrix_7_set_Item(struct PositiveDefiniteMatrix_7 *const self, float64_t row, float64_t column, float64_t value)
{
	PositivDefinitMatrix_7_set_Item(self, (int32_t)row, (int32_t)column, value);
}

static struct TrackWithMeasurements *Trac_CreaTracFromFronRadarObjec(struct Tracking *const self, struct FrontRadarObjectSpace *measurement, float64_t egoVelocity, float64_t egoYawRate, float64_t egoAcceleration, struct FrontRadarObjectParameters *parameters)
{
	struct InveCartMeasModelWithVectoVeloc *inverseMeasurementModel = NULL;
	struct InveCartMeasModelWithVectoVeloc *inveCartMeasModelWithVectoVeloc = NULL;
	struct CASpace *expectation = NULL;
	struct CASpace *caSpace = NULL;
	int32_t rows = ((int32_t)0);
	int32_t columns = ((int32_t)0);
	float64_t sinRotZ = 0.0;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t cosRotZ = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t x = 0.0;
	float64_t double__4 = 0.0;
	float64_t double__5 = 0.0;
	float64_t double__6 = 0.0;
	float64_t double__7 = 0.0;
	float64_t double__8 = 0.0;
	float64_t y = 0.0;
	float64_t double__9 = 0.0;
	float64_t double__10 = 0.0;
	float64_t double__11 = 0.0;
	float64_t double__12 = 0.0;
	float64_t double__13 = 0.0;
	float64_t r = 0.0;
	float64_t double__14 = 0.0;
	float64_t vx = 0.0;
	float64_t double__15 = 0.0;
	float64_t double__16 = 0.0;
	float64_t double__17 = 0.0;
	float64_t double__18 = 0.0;
	float64_t vy = 0.0;
	float64_t double__19 = 0.0;
	float64_t double__20 = 0.0;
	float64_t double__21 = 0.0;
	float64_t double__22 = 0.0;
	float64_t v = 0.0;
	float64_t double__23 = 0.0;
	float64_t derivativeOfArctan = 0.0;
	struct MatrixData_2 *transitionMatrix = NULL;
	struct MatrixData_2 *matrixData = NULL;
	struct MatrixData_2 *matrixData_1 = NULL;
	float64_t double__24 = 0.0;
	int32_t int32 = ((int32_t)0);
	float64_t double__25 = 0.0;
	int32_t int32_1 = ((int32_t)0);
	struct MatrixData_2 *matrixData_2 = NULL;
	float64_t double__26 = 0.0;
	int32_t int32_2 = ((int32_t)0);
	float64_t double__27 = 0.0;
	int32_t int32_3 = ((int32_t)0);
	struct MatrixData_2 *matrixData_3 = NULL;
	float64_t double__28 = 0.0;
	int32_t int32_4 = ((int32_t)0);
	float64_t double__29 = 0.0;
	int32_t int32_5 = ((int32_t)0);
	struct MatrixData_2 *matrixData_4 = NULL;
	float64_t double__30 = 0.0;
	int32_t int32_6 = ((int32_t)0);
	float64_t double__31 = 0.0;
	int32_t int32_7 = ((int32_t)0);
	struct MatrixData_2 *matrixData_5 = NULL;
	float64_t double__32 = 0.0;
	int32_t int32_8 = ((int32_t)0);
	float64_t double__33 = 0.0;
	int32_t int32_9 = ((int32_t)0);
	struct MatrixData_2 *measurementNoise = NULL;
	struct float64_t_1D_5 *array = NULL;
	struct PositiveDefiniteMatrix_5 *positiveDefiniteMatrix = NULL;
	struct MatrixData_2 *matrixData_6 = NULL;
	struct MatrixData_2 *covariance = NULL;
	struct MatrixData_2 *matrixData_7 = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_1 = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_2 = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_3 = NULL;
	float64_t double__34 = 0.0;
	float64_t double__35 = 0.0;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_4 = NULL;
	float64_t double__36 = 0.0;
	float64_t double__37 = 0.0;
	float64_t double__38 = 0.0;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_5 = NULL;
	float64_t double__39 = 0.0;
	float64_t double__40 = 0.0;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix_6 = NULL;
	float64_t double__41 = 0.0;
	float64_t double__42 = 0.0;
	float64_t double__43 = 0.0;
	struct Gaussian_5 *state = NULL;
	struct Gaussian_5 *gaussian = NULL;
	struct TrackWithMeasurements *result = NULL;
	struct Gaussian_5 *gaussian_1 = NULL;
	struct Existence *existence = NULL;
	uint32_t uInt32 = ((uint32_t)0u);
	uint64_t uInt64 = ((uint64_t)0u);
	struct Object_1 *object = NULL;
	struct TrackWithMeasurements *trackWithMeasurements = NULL;

	inveCartMeasModelWithVectoVeloc = New_InvCartMeasModeWithVectVelo();
	InvCarMeasModeWithVectVelo_ctor(inveCartMeasModelWithVectoVeloc, parameters, egoVelocity, egoYawRate, egoAcceleration);
	(void)Ass_InvCartMeasModeWithVectVelo(&inverseMeasurementModel, inveCartMeasModelWithVectoVeloc);
	(void)Ass_InvCartMeasModeWithVectVelo(&inveCartMeasModelWithVectoVeloc, NULL);
	caSpace = New_CASpace();
	CASpace_ctor(caSpace);
	(void)Assign_CASpace(&expectation, caSpace);
	(void)Assign_CASpace(&caSpace, NULL);
	InvCarMeasModeWithVectVelo_Tran(inverseMeasurementModel, measurement, &expectation);
	rows = (&Tracking_1_StateIndices->base.base.base)->Dimensions;
	columns = (&Tracki_1_FrontRadarObjectIndice->base.base)->Dimensions;
	double_ = FrontRadarObjecParam_get_RotatZ(parameters);
	double__1 = Math_Sin(double_);
	sinRotZ = double__1;
	double__2 = FrontRadarObjecParam_get_RotatZ(parameters);
	double__3 = Math_Cos(double__2);
	cosRotZ = double__3;
	double__4 = CVComponentsSpace_get_X(&measurement->base);
	double__5 = double__4 * cosRotZ;
	double__6 = CVComponentsSpace_get_Y(&measurement->base);
	double__7 = double__5 - (double__6 * sinRotZ);
	double__8 = FrontRadarObjecParam_get_PositX(parameters);
	x = double__7 + double__8;
	double__9 = CVComponentsSpace_get_X(&measurement->base);
	double__10 = double__9 * sinRotZ;
	double__11 = CVComponentsSpace_get_Y(&measurement->base);
	double__12 = double__10 + (double__11 * cosRotZ);
	double__13 = FrontRadarObjecParam_get_PositY(parameters);
	y = double__12 + double__13;
	double__14 = Math_Sqrt((x * x) + (y * y));
	r = double__14;
	double__15 = CVComponentsSpace_get_Vx(&measurement->base);
	double__16 = double__15 * cosRotZ;
	double__17 = CVComponentsSpace_get_Vy(&measurement->base);
	double__18 = double__16 - (double__17 * sinRotZ);
	vx = double__18 + egoVelocity;
	double__19 = CVComponentsSpace_get_Vx(&measurement->base);
	double__20 = double__19 * sinRotZ;
	double__21 = CVComponentsSpace_get_Vy(&measurement->base);
	double__22 = double__20 + (double__21 * cosRotZ);
	vy = double__22 + (r * egoYawRate);
	double__23 = Math_Sqrt((vx * vx) + (vy * vy));
	v = double__23;
	derivativeOfArctan = 1.0 / (1.0 + ((vy * vy) / (vx * vx)));
	matrixData = New_MatrixData_2();
	MatrixData_2_ctor(matrixData, rows, columns);
	(void)Assign_MatrixData_2(&transitionMatrix, matrixData);
	(void)Assign_MatrixData_2(&matrixData, NULL);
	(void)Assign_MatrixData_2(&matrixData_1, transitionMatrix);
	double__24 = CVSpace_get_X(&Tracking_1_StateIndices->base);
	int32 = (int32_t)double__24;
	double__25 = CVComponentsSpace_get_X(&Tracki_1_FrontRadarObjectIndice->base);
	int32_1 = (int32_t)double__25;
	MatrixData_2_set_Item(matrixData_1, int32, int32_1, cosRotZ);
	(void)Assign_MatrixData_2(&matrixData_1, NULL);
	(void)Assign_MatrixData_2(&matrixData_2, transitionMatrix);
	double__26 = CVSpace_get_X(&Tracking_1_StateIndices->base);
	int32_2 = (int32_t)double__26;
	double__27 = CVComponentsSpace_get_Y(&Tracki_1_FrontRadarObjectIndice->base);
	int32_3 = (int32_t)double__27;
	MatrixData_2_set_Item(matrixData_2, int32_2, int32_3, -sinRotZ);
	(void)Assign_MatrixData_2(&matrixData_2, NULL);
	(void)Assign_MatrixData_2(&matrixData_3, transitionMatrix);
	double__28 = CVSpace_get_Y(&Tracking_1_StateIndices->base);
	int32_4 = (int32_t)double__28;
	double__29 = CVComponentsSpace_get_X(&Tracki_1_FrontRadarObjectIndice->base);
	int32_5 = (int32_t)double__29;
	MatrixData_2_set_Item(matrixData_3, int32_4, int32_5, sinRotZ);
	(void)Assign_MatrixData_2(&matrixData_3, NULL);
	(void)Assign_MatrixData_2(&matrixData_4, transitionMatrix);
	double__30 = CVSpace_get_Y(&Tracking_1_StateIndices->base);
	int32_6 = (int32_t)double__30;
	double__31 = CVComponentsSpace_get_Y(&Tracki_1_FrontRadarObjectIndice->base);
	int32_7 = (int32_t)double__31;
	MatrixData_2_set_Item(matrixData_4, int32_6, int32_7, cosRotZ);
	(void)Assign_MatrixData_2(&matrixData_4, NULL);
	if (!(vx <= 1E-07))
	{
		struct MatrixData_2 *matrixData_8 = NULL;
		float64_t double__44 = 0.0;
		int32_t int32_10 = ((int32_t)0);
		float64_t double__45 = 0.0;
		int32_t int32_11 = ((int32_t)0);
		struct MatrixData_2 *matrixData_9 = NULL;
		float64_t double__46 = 0.0;
		int32_t int32_12 = ((int32_t)0);
		float64_t double__47 = 0.0;
		int32_t int32_13 = ((int32_t)0);
		struct MatrixData_2 *matrixData_10 = NULL;
		float64_t double__48 = 0.0;
		int32_t int32_14 = ((int32_t)0);
		float64_t double__49 = 0.0;
		int32_t int32_15 = ((int32_t)0);
		struct MatrixData_2 *matrixData_11 = NULL;
		float64_t double__50 = 0.0;
		int32_t int32_16 = ((int32_t)0);
		float64_t double__51 = 0.0;
		int32_t int32_17 = ((int32_t)0);

		(void)Assign_MatrixData_2(&matrixData_8, transitionMatrix);
		double__44 = CVSpace_get_G(&Tracking_1_StateIndices->base);
		int32_10 = (int32_t)double__44;
		double__45 = CVComponentsSpace_get_X(&Tracki_1_FrontRadarObjectIndice->base);
		int32_11 = (int32_t)double__45;
		MatrixData_2_set_Item(matrixData_8, int32_10, int32_11, (((derivativeOfArctan * egoYawRate) / vx) * ((x * cosRotZ) + (y * sinRotZ))) / r);
		(void)Assign_MatrixData_2(&matrixData_8, NULL);
		(void)Assign_MatrixData_2(&matrixData_9, transitionMatrix);
		double__46 = CVSpace_get_G(&Tracking_1_StateIndices->base);
		int32_12 = (int32_t)double__46;
		double__47 = CVComponentsSpace_get_Y(&Tracki_1_FrontRadarObjectIndice->base);
		int32_13 = (int32_t)double__47;
		MatrixData_2_set_Item(matrixData_9, int32_12, int32_13, (((derivativeOfArctan * egoYawRate) / vx) * ((-x * sinRotZ) + (y * cosRotZ))) / r);
		(void)Assign_MatrixData_2(&matrixData_9, NULL);
		(void)Assign_MatrixData_2(&matrixData_10, transitionMatrix);
		double__48 = CVSpace_get_G(&Tracking_1_StateIndices->base);
		int32_14 = (int32_t)double__48;
		double__49 = CVComponentsSpace_get_Vx(&Tracki_1_FrontRadarObjectIndice->base);
		int32_15 = (int32_t)double__49;
		MatrixData_2_set_Item(matrixData_10, int32_14, int32_15, (derivativeOfArctan * ((sinRotZ * vx) - (vy * cosRotZ))) / (vx * vx));
		(void)Assign_MatrixData_2(&matrixData_10, NULL);
		(void)Assign_MatrixData_2(&matrixData_11, transitionMatrix);
		double__50 = CVSpace_get_G(&Tracking_1_StateIndices->base);
		int32_16 = (int32_t)double__50;
		double__51 = CVComponentsSpace_get_Vy(&Tracki_1_FrontRadarObjectIndice->base);
		int32_17 = (int32_t)double__51;
		MatrixData_2_set_Item(matrixData_11, int32_16, int32_17, (derivativeOfArctan * ((cosRotZ * vx) + (vy * sinRotZ))) / (vx * vx));
		(void)Assign_MatrixData_2(&matrixData_11, NULL);
	}
	if (!(v <= 1E-07))
	{
		struct MatrixData_2 *matrixData_12 = NULL;
		float64_t double__52 = 0.0;
		int32_t int32_18 = ((int32_t)0);
		float64_t double__53 = 0.0;
		int32_t int32_19 = ((int32_t)0);
		struct MatrixData_2 *matrixData_13 = NULL;
		float64_t double__54 = 0.0;
		int32_t int32_20 = ((int32_t)0);
		float64_t double__55 = 0.0;
		int32_t int32_21 = ((int32_t)0);
		struct MatrixData_2 *matrixData_14 = NULL;
		float64_t double__56 = 0.0;
		int32_t int32_22 = ((int32_t)0);
		float64_t double__57 = 0.0;
		int32_t int32_23 = ((int32_t)0);
		struct MatrixData_2 *matrixData_15 = NULL;
		float64_t double__58 = 0.0;
		int32_t int32_24 = ((int32_t)0);
		float64_t double__59 = 0.0;
		int32_t int32_25 = ((int32_t)0);

		(void)Assign_MatrixData_2(&matrixData_12, transitionMatrix);
		double__52 = CVSpace_get_V(&Tracking_1_StateIndices->base);
		int32_18 = (int32_t)double__52;
		double__53 = CVComponentsSpace_get_X(&Tracki_1_FrontRadarObjectIndice->base);
		int32_19 = (int32_t)double__53;
		MatrixData_2_set_Item(matrixData_12, int32_18, int32_19, (((vy / v) * egoYawRate) * ((x * cosRotZ) + (y * sinRotZ))) / r);
		(void)Assign_MatrixData_2(&matrixData_12, NULL);
		(void)Assign_MatrixData_2(&matrixData_13, transitionMatrix);
		double__54 = CVSpace_get_V(&Tracking_1_StateIndices->base);
		int32_20 = (int32_t)double__54;
		double__55 = CVComponentsSpace_get_Y(&Tracki_1_FrontRadarObjectIndice->base);
		int32_21 = (int32_t)double__55;
		MatrixData_2_set_Item(matrixData_13, int32_20, int32_21, (((vy / v) * egoYawRate) * ((-x * sinRotZ) + (y * cosRotZ))) / r);
		(void)Assign_MatrixData_2(&matrixData_13, NULL);
		(void)Assign_MatrixData_2(&matrixData_14, transitionMatrix);
		double__56 = CVSpace_get_V(&Tracking_1_StateIndices->base);
		int32_22 = (int32_t)double__56;
		double__57 = CVComponentsSpace_get_Vx(&Tracki_1_FrontRadarObjectIndice->base);
		int32_23 = (int32_t)double__57;
		MatrixData_2_set_Item(matrixData_14, int32_22, int32_23, (1.0 / v) * ((vx * cosRotZ) + (vy * sinRotZ)));
		(void)Assign_MatrixData_2(&matrixData_14, NULL);
		(void)Assign_MatrixData_2(&matrixData_15, transitionMatrix);
		double__58 = CVSpace_get_V(&Tracking_1_StateIndices->base);
		int32_24 = (int32_t)double__58;
		double__59 = CVComponentsSpace_get_Vy(&Tracki_1_FrontRadarObjectIndice->base);
		int32_25 = (int32_t)double__59;
		MatrixData_2_set_Item(matrixData_15, int32_24, int32_25, (1.0 / v) * ((-vx * sinRotZ) + (vy * cosRotZ)));
		(void)Assign_MatrixData_2(&matrixData_15, NULL);
	}
	(void)Assign_MatrixData_2(&matrixData_5, transitionMatrix);
	double__32 = CASpace_get_A(Tracking_1_StateIndices);
	int32_8 = (int32_t)double__32;
	double__33 = FrontRadarObjectSpace_get_A(Tracki_1_FrontRadarObjectIndice);
	int32_9 = (int32_t)double__33;
	MatrixData_2_set_Item(matrixData_5, int32_8, int32_9, cosRotZ);
	(void)Assign_MatrixData_2(&matrixData_5, NULL);
	array = FroRadObjePara_get_NoisMatrDiag(parameters);
	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_5();
	PositiveDefiniteMatrix_5_ctor(positiveDefiniteMatrix, array);
	matrixData_6 = Matrix_5_get_MatrixData(&positiveDefiniteMatrix->base.base);
	(void)Assign_MatrixData_2(&measurementNoise, matrixData_6);
	(void)Assign_float64_t_1D_5(&array, NULL);
	(void)Assign_PositiveDefiniteMatrix_5(&positiveDefiniteMatrix, NULL);
	(void)Assign_MatrixData_2(&matrixData_6, NULL);
	matrixData_7 = MatrixMath_Multiply_18(false, false, true, transitionMatrix, measurementNoise, transitionMatrix);
	(void)Assign_MatrixData_2(&covariance, matrixData_7);
	(void)Assign_MatrixData_2(&matrixData_7, NULL);
	positiveDefiniteMatrix_2 = PositivDefiniteMatrix_11_Create(covariance);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_1, positiveDefiniteMatrix_2);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_2, NULL);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_3, positiveDefiniteMatrix_1);
	double__34 = CVSpace_get_G(&Tracking_1_StateIndices->base);
	double__35 = CVSpace_get_G(&Tracking_1_StateIndices->base);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_4, positiveDefiniteMatrix_1);
	double__36 = CVSpace_get_G(&Tracking_1_StateIndices->base);
	double__37 = CVSpace_get_G(&Tracking_1_StateIndices->base);
	double__38 = PositiDefinitMatrix_7_get_Item(positiveDefiniteMatrix_4, double__36, double__37);
	PositiDefinitMatrix_7_set_Item(positiveDefiniteMatrix_3, double__34, double__35, double__38 + 0.07);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_3, NULL);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_4, NULL);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_5, positiveDefiniteMatrix_1);
	double__39 = CVSpace_get_V(&Tracking_1_StateIndices->base);
	double__40 = CVSpace_get_V(&Tracking_1_StateIndices->base);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_6, positiveDefiniteMatrix_1);
	double__41 = CVSpace_get_V(&Tracking_1_StateIndices->base);
	double__42 = CVSpace_get_V(&Tracking_1_StateIndices->base);
	double__43 = PositiDefinitMatrix_7_get_Item(positiveDefiniteMatrix_6, double__41, double__42);
	PositiDefinitMatrix_7_set_Item(positiveDefiniteMatrix_5, double__39, double__40, double__43 + 2.0);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_5, NULL);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix_6, NULL);
	gaussian = Gaussian_9_Create(expectation, positiveDefiniteMatrix_1);
	(void)Assign_Gaussian_5(&state, gaussian);
	(void)Assign_Gaussian_5(&gaussian, NULL);
	(void)Assign_Gaussian_5(&gaussian_1, state);
	existence = New_Existence();
	Existence_ctor_1(existence, 0.6);
	uInt32 = IDGenerator_GetNextID();
	uInt64 = (uint64_t)uInt32;
	object = FronRadaObjeSpac_get_Ars308Obje(measurement);
	trackWithMeasurements = New_TrackWithMeasurements();
	TrackWithMeasurements_ctor(trackWithMeasurements, gaussian_1, existence, uInt64, NULL, object);
	(void)Assign_TrackWithMeasurements(&result, trackWithMeasurements);
	(void)Assign_Gaussian_5(&gaussian_1, NULL);
	(void)Assign_Existence(&existence, NULL);
	(void)Assign_Object_1(&object, NULL);
	(void)Assign_TrackWithMeasurements(&trackWithMeasurements, NULL);
	RemRef_InvCarMeaModWithVectVelo(inverseMeasurementModel);
	RemRef_CASpace(expectation);
	RemRef_MatrixData_2(transitionMatrix);
	RemRef_MatrixData_2(measurementNoise);
	RemRef_MatrixData_2(covariance);
	RemRef_PositiveDefiniteMatrix_7(positiveDefiniteMatrix_1);
	RemRef_Gaussian_5(state);
	return result;
}

struct StaticList_27 *Track_ProceFrontRadarObjecDetec(struct Tracking *const self, struct DateTime time_1, struct StaticList_9 *measurements)
{
	struct StaticListFactory_1 *listFactory = NULL;
	struct StaticListFactory_1 *staticListFactory = NULL;
	struct StatiIPDATrackColleFactorProvid *factoryProvider = NULL;
	struct StatiIPDATrackColleFactorProvid *statiIPDATrackColleFactorProvid = NULL;
	struct FrontRadarObjectParameters *parameters = NULL;
	struct FrontRadarObjectParameters *frontRadarObjectParameters = NULL;
	struct StaticList_27 *result = NULL;
	bool_t s__LockTaken8 = false;
	struct Object *CS_2_0001 = NULL;
	struct Object *object = NULL;
	struct Gaussian_4 *egoMotionState = NULL;
	struct Gaussian_4 *gaussian = NULL;
	bool_t boolean = false;
	struct StaticList_27 *CS_1_0000 = NULL;
	struct Tracking *tracking = NULL;
	struct Tracking *tracking_1 = NULL;
	struct StaticList_23 *predictedStates = NULL;
	struct StaticList_21 *predictedMeasurements = NULL;
	struct StaticList_17 *transitionMatrices = NULL;
	struct StaticList_26 *predictedExistences = NULL;
	struct StaticList_25 *measuremenCardinalitLikelihoods = NULL;
	struct CAModel *systemModel = NULL;
	struct Tracking *tracking_2 = NULL;
	struct TimeSpan deltaT = { 0 };
	struct PersistenceModel *persistenceModel = NULL;
	struct FrontRadarObjectMeasuremenModel *measurementModel = NULL;
	struct FrontRadarObjectDetectionModel *detectionModel = NULL;
	struct EgoMotionCompensation *egoMotionCompensation = NULL;
	struct StaticListEnumerator_15 *CS_5_0002 = NULL;
	struct TrackWithMeasurements *track = NULL;
	struct Gaussian_5 *egoMotionCompensatedState = NULL;
	struct Gaussian_5 *predictedState = NULL;
	struct Existence *predictedExistence = NULL;
	struct Matrix_13 *transitionMatrix = NULL;
	struct Gaussian_3 *predictedMeasurement = NULL;
	struct SampleSet_1 *sampledPredictedMeasurement = NULL;
	struct ProbabilityGate_1 *gate = NULL;
	struct MultipleLocalNearestNeighbor *associationAlgorithm = NULL;
	struct MeasurementAssociation_1 *association = NULL;
	struct StaticList_27 *updatedTracks = NULL;
	int32_t index = ((int32_t)0);
	struct TrackWithMeasurements *track_1 = NULL;
	struct StaticList_9 *associatedMeasurements = NULL;
	struct IPDA_1 *hypothesisGenerator = NULL;
	struct StaticList_19 *associationHypotheses = NULL;
	struct GaussianMixture *mixedState = NULL;
	struct MeasurementSetLikelihood *existenConditioElementsLikeliho = NULL;
	struct Object_1 *associatedObject = NULL;
	struct StaticListEnumerator_11 *CS_5_0003 = NULL;
	struct TruePositivesHypothesis_1 *hypothesis = NULL;
	struct FrontRadarObjectSpace *truePositiveMeasurement = NULL;
	struct Gaussian_5 *updatedState = NULL;
	struct TwoPointDistribution *updatedExistence = NULL;
	struct TrackWithMeasurements *updatedTrack = NULL;
	struct StaticListEnumerator_5 *CS_5_0004 = NULL;
	struct FrontRadarObjectSpace *measurement = NULL;
	struct TrackWithMeasurements *trackFromFrontRadarObject = NULL;
	bool_t boolean_1 = false;
	bool_t boolean_2 = false;
	bool_t boolean_3 = false;

	staticListFactory = New_StaticListFactory_1();
	StaticListFactory_1_ctor(staticListFactory, ((int32_t)50));
	(void)Assign_StaticListFactory_1(&listFactory, staticListFactory);
	(void)Assign_StaticListFactory_1(&staticListFactory, NULL);
	statiIPDATrackColleFactorProvid = New_StatIPDATracColleFactoProvi();
	StatIPDATracCollFactoProvi_ctor(statiIPDATrackColleFactorProvid, ((int32_t)15), ((int32_t)40));
	(void)Assi_StatIPDATracCollFactoProvi(&factoryProvider, statiIPDATrackColleFactorProvid);
	(void)Assi_StatIPDATracCollFactoProvi(&statiIPDATrackColleFactorProvid, NULL);
	frontRadarObjectParameters = SensProp_get_FronRadaObjecParam(self->_sensorProperties);
	(void)Assign_FrontRadarObjectParamete(&parameters, frontRadarObjectParameters);
	(void)Assign_FrontRadarObjectParamete(&frontRadarObjectParameters, NULL);
	if (!self->UpdateFromFrontRadarObjects)
	{
		(void)Assign_StaticList_27(&result, NULL);
		RemRef_StaticListFactory_1(listFactory);
		RemRef_StatIPDATracCollFactProv(factoryProvider);
		RemRef_FrontRadarObjectParamete(parameters);
		RemRef_Object(CS_2_0001);
		RemRef_Gaussian_4(egoMotionState);
		RemRef_StaticList_27(CS_1_0000);
		RemRef_Tracking(tracking);
		RemRef_Tracking(tracking_1);
		RemRef_StaticList_23(predictedStates);
		RemRef_StaticList_21(predictedMeasurements);
		RemRef_StaticList_17(transitionMatrices);
		RemRef_StaticList_26(predictedExistences);
		RemRef_StaticList_25(measuremenCardinalitLikelihoods);
		RemRef_CAModel(systemModel);
		RemRef_Tracking(tracking_2);
		RemRef_PersistenceModel(persistenceModel);
		RemRef_FronRadarObjecMeasuModel(measurementModel);
		RemRef_FronRadarObjecDetecModel(detectionModel);
		RemRef_EgoMotionCompensation(egoMotionCompensation);
		RemRef_StaticListEnumerator_15(CS_5_0002);
		RemRef_TrackWithMeasurements(track);
		RemRef_Gaussian_5(egoMotionCompensatedState);
		RemRef_Gaussian_5(predictedState);
		RemRef_Existence(predictedExistence);
		RemRef_Matrix_13(transitionMatrix);
		RemRef_Gaussian_3(predictedMeasurement);
		RemRef_SampleSet_1(sampledPredictedMeasurement);
		RemRef_ProbabilityGate_1(gate);
		RemRef_MultipLocalNearesNeighbo(associationAlgorithm);
		RemRef_MeasurementAssociation_1(association);
		RemRef_StaticList_27(updatedTracks);
		RemRef_TrackWithMeasurements(track_1);
		RemRef_StaticList_9(associatedMeasurements);
		RemRef_IPDA_1(hypothesisGenerator);
		RemRef_StaticList_19(associationHypotheses);
		RemRef_GaussianMixture(mixedState);
		RemRef_MeasurementSetLikelihood(existenConditioElementsLikeliho);
		RemRef_Object_1(associatedObject);
		RemRef_StaticListEnumerator_11(CS_5_0003);
		RemRef_TruePositivesHypothesi_1(hypothesis);
		RemRef_FrontRadarObjectSpace(truePositiveMeasurement);
		RemRef_Gaussian_5(updatedState);
		RemRef_TwoPointDistribution(updatedExistence);
		RemRef_TrackWithMeasurements(updatedTrack);
		RemRef_StaticListEnumerator_5(CS_5_0004);
		RemRef_FrontRadarObjectSpace(measurement);
		RemRef_TrackWithMeasurements(trackFromFrontRadarObject);
		return result;
	}
	s__LockTaken8 = false;
	(void)Assign_Object(&object, Assign_Object(&CS_2_0001, self->_tracksLock));
	s__LockTaken8 = true;
	(void)Assign_Object(&object, NULL);
	gaussian = EgoMotionFilter_PredicXAndReset(self->_egoMotionFilter, time_1);
	(void)Assign_Gaussian_4(&egoMotionState, gaussian);
	(void)Assign_Gaussian_4(&gaussian, NULL);
	boolean_1 = Object_2_ReferenceEquals(&egoMotionState->base, NULL);
	boolean_2 = !boolean_1;
	if (boolean_2 == true)
	{
		boolean = EgoMotionFilter_get_IsStable(self->_egoMotionFilter);
		boolean_3 = boolean;
	}
	else
	{
		boolean_3 = false;
	}
	if (!boolean_3)
	{
		(void)Assign_StaticList_27(&CS_1_0000, NULL);
	}
	else
	{
		bool_t boolean_4 = false;
		struct DateTime dateTime = { 0 };
		struct DateTime dateTime_1 = { 0 };
		bool_t boolean_5 = false;
		struct StaticListFactory_4 *staticListFactory_1 = NULL;
		struct StaticList_23 *staticList = NULL;
		struct StaticListFactory_4 *staticListFactory_2 = NULL;
		struct StaticList_21 *staticList_1 = NULL;
		struct StaticListFactory_4 *staticListFactory_3 = NULL;
		struct StaticList_17 *staticList_2 = NULL;
		struct StaticListFactory_4 *staticListFactory_4 = NULL;
		struct StaticList_26 *staticList_3 = NULL;
		struct StaticListFactory_4 *staticListFactory_5 = NULL;
		struct StaticList_25 *staticList_4 = NULL;
		struct CAModel *caModel = NULL;
		struct DateTime dateTime_2 = { 0 };
		struct DateTime dateTime_3 = { 0 };
		struct TimeSpan timeSpan = { 0 };
		float64_t double_ = 0.0;
		struct PersistenceModel *persistenceModel_1 = NULL;
		struct CTRASpace *ctraSpace = NULL;
		float64_t double__1 = 0.0;
		struct CTRASpace *ctraSpace_1 = NULL;
		float64_t double__2 = 0.0;
		struct CTRASpace *ctraSpace_2 = NULL;
		float64_t double__3 = 0.0;
		struct FrontRadarObjectMeasuremenModel *frontRadarObjectMeasuremenModel = NULL;
		struct FrontRadarObjectParameters *frontRadarObjectParameters_1 = NULL;
		float64_t double__4 = 0.0;
		struct FrontRadarObjectDetectionModel *frontRadarObjectDetectionModel = NULL;
		struct EgoMotionCompensation *egoMotionCompensation_1 = NULL;
		struct StaticListEnumerator_15 *staticListEnumerator = NULL;
		bool_t boolean_6 = false;
		float64_t double__5 = 0.0;
		struct ProbabilityGate_1 *probabilityGate = NULL;
		struct MultipleLocalNearestNeighbor *multipleLocalNearestNeighbor = NULL;
		struct MeasurementAssociation_1 *measurementAssociation = NULL;
		struct StaticListFactory_4 *staticListFactory_6 = NULL;
		struct StaticList_27 *staticList_5 = NULL;
		int32_t int32 = ((int32_t)0);
		int32_t int32_1 = ((int32_t)0);
		struct Nullable_1 nullable = { 0 };

		(void)Assign_Tracking(&tracking, self);
		boolean_4 = Nullable_1_get_HasValue(&tracking->_lastUpdateTime);
		if (!boolean_4)
		{
			struct Nullable_1 nullable_1 = { 0 };

			Nullable_1_ctor(&nullable_1, time_1);
			self->_lastUpdateTime = nullable_1;
		}
		dateTime = time_1;
		(void)Assign_Tracking(&tracking_1, self);
		dateTime_1 = Nullable_1_get_Value(&tracking_1->_lastUpdateTime);
		boolean_5 = DateTime_1_op_LessThan(dateTime, dateTime_1);
		if (!!boolean_5)
		{
			abort();
		}
		staticListFactory_1 = StIPDATrColFacPro_get_TraLisFac(factoryProvider);
		staticList = StaticListFactor_4_CreateInstan(staticListFactory_1, ((int32_t)0));
		(void)Assign_StaticList_23(&predictedStates, staticList);
		(void)Assign_StaticListFactory_4(&staticListFactory_1, NULL);
		(void)Assign_StaticList_23(&staticList, NULL);
		staticListFactory_2 = StIPDATrColFacPro_get_TraLisFac(factoryProvider);
		staticList_1 = StatiListFacto_4_CreateInstan_5(staticListFactory_2, ((int32_t)0));
		(void)Assign_StaticList_21(&predictedMeasurements, staticList_1);
		(void)Assign_StaticListFactory_4(&staticListFactory_2, NULL);
		(void)Assign_StaticList_21(&staticList_1, NULL);
		staticListFactory_3 = StIPDATrColFacPro_get_TraLisFac(factoryProvider);
		staticList_2 = StatiListFacto_4_CreateInstan_6(staticListFactory_3, ((int32_t)0));
		(void)Assign_StaticList_17(&transitionMatrices, staticList_2);
		(void)Assign_StaticListFactory_4(&staticListFactory_3, NULL);
		(void)Assign_StaticList_17(&staticList_2, NULL);
		staticListFactory_4 = StIPDATrColFacPro_get_TraLisFac(factoryProvider);
		staticList_3 = StatiListFacto_4_CreateInstan_1(staticListFactory_4, ((int32_t)0));
		(void)Assign_StaticList_26(&predictedExistences, staticList_3);
		(void)Assign_StaticListFactory_4(&staticListFactory_4, NULL);
		(void)Assign_StaticList_26(&staticList_3, NULL);
		staticListFactory_5 = StIPDATrColFacPro_get_TraLisFac(factoryProvider);
		staticList_4 = StatiListFacto_4_CreateInstan_7(staticListFactory_5, ((int32_t)0));
		(void)Assign_StaticList_25(&measuremenCardinalitLikelihoods, staticList_4);
		(void)Assign_StaticListFactory_4(&staticListFactory_5, NULL);
		(void)Assign_StaticList_25(&staticList_4, NULL);
		caModel = Tracking_GetSystemModel(self);
		(void)Assign_CAModel(&systemModel, caModel);
		(void)Assign_CAModel(&caModel, NULL);
		dateTime_2 = time_1;
		(void)Assign_Tracking(&tracking_2, self);
		dateTime_3 = Nullable_1_get_Value(&tracking_2->_lastUpdateTime);
		timeSpan = DateTime_1_op_Subtraction(dateTime_2, dateTime_3);
		deltaT = timeSpan;
		double_ = Trackin_get_ProcessNoiseExisten(self);
		persistenceModel_1 = New_PersistenceModel();
		PersistenceModel_ctor(persistenceModel_1, double_);
		PersisteModel_set_TimeCondition(persistenceModel_1, deltaT);
		(void)Assign_PersistenceModel(&persistenceModel, persistenceModel_1);
		(void)Assign_PersistenceModel(&persistenceModel_1, NULL);
		ctraSpace = Gaussian_4_get_Expectation(egoMotionState);
		double__1 = CTRASpace_get_V(ctraSpace);
		ctraSpace_1 = Gaussian_4_get_Expectation(egoMotionState);
		double__2 = CTRASpace_get_W(ctraSpace_1);
		ctraSpace_2 = Gaussian_4_get_Expectation(egoMotionState);
		double__3 = CTRASpace_get_A(ctraSpace_2);
		frontRadarObjectMeasuremenModel = New_FrontRadarObjectMeasurModel();
		FrontRadarObjecMeasurModel_ctor(frontRadarObjectMeasuremenModel, double__1, double__2, double__3, parameters);
		(void)Assig_FrontRadarObjecMeasuModel(&measurementModel, frontRadarObjectMeasuremenModel);
		(void)Assign_CTRASpace(&ctraSpace, NULL);
		(void)Assign_CTRASpace(&ctraSpace_1, NULL);
		(void)Assign_CTRASpace(&ctraSpace_2, NULL);
		(void)Assig_FrontRadarObjecMeasuModel(&frontRadarObjectMeasuremenModel, NULL);
		(void)Assign_FrontRadarObjectParamete(&frontRadarObjectParameters_1, parameters);
		double__4 = Tracking_get_GateProbability(self);
		frontRadarObjectDetectionModel = New_FrontRadarObjectDetectModel();
		FrontRadarObjecDetectModel_ctor(frontRadarObjectDetectionModel, frontRadarObjectParameters_1, double__4);
		(void)Assig_FrontRadarObjecDetecModel(&detectionModel, frontRadarObjectDetectionModel);
		(void)Assign_FrontRadarObjectParamete(&frontRadarObjectParameters_1, NULL);
		(void)Assig_FrontRadarObjecDetecModel(&frontRadarObjectDetectionModel, NULL);
		egoMotionCompensation_1 = New_EgoMotionCompensation();
		EgoMotionCompensation_ctor(egoMotionCompensation_1);
		(void)Assign_EgoMotionCompensation(&egoMotionCompensation, egoMotionCompensation_1);
		(void)Assign_EgoMotionCompensation(&egoMotionCompensation_1, NULL);
		staticListEnumerator = StaticList_27_GetEnumerator(self->_tracks);
		(void)Assign_StaticListEnumerator_15(&CS_5_0002, staticListEnumerator);
		(void)Assign_StaticListEnumerator_15(&staticListEnumerator, NULL);
		boolean_6 = StaticListEnumerato_15_MoveNext(CS_5_0002);
		while (boolean_6)
		{
			struct TrackWithMeasurements *trackWithMeasurements = NULL;
			struct Gaussian_5 *gaussian_1 = NULL;
			struct Gaussian_5 *gaussian_2 = NULL;
			struct Existence *existence = NULL;
			struct TwoPointDistribution *twoPointDistribution = NULL;
			struct Existence *existence_1 = NULL;
			struct Gaussian_3 *gaussian_3 = NULL;
			struct StaticList_10 *staticList_6 = NULL;
			struct SampleSet_1 *sampleSet = NULL;
			struct StaticList_25 *staticList_7 = NULL;
			struct MarginalizedEvaluable_1 *marginalizedEvaluable = NULL;

			trackWithMeasurements = StaticListEnumer_15_get_Current(CS_5_0002);
			(void)Assign_TrackWithMeasurements(&track, trackWithMeasurements);
			(void)Assign_TrackWithMeasurements(&trackWithMeasurements, NULL);
			gaussian_1 = CreateExtensions_Marginalize(egoMotionCompensation, &track->base, egoMotionState);
			(void)Assign_Gaussian_5(&egoMotionCompensatedState, gaussian_1);
			(void)Assign_Gaussian_5(&gaussian_1, NULL);
			gaussian_2 = EKF_PredictState_1(deltaT, egoMotionCompensatedState, systemModel);
			(void)Assign_Gaussian_5(&predictedState, gaussian_2);
			(void)Assign_Gaussian_5(&gaussian_2, NULL);
			StaticList_23_Add(predictedStates, predictedState);
			existence = GaussianTrack_get_Existence(&track->base);
			twoPointDistribution = BayesFilter_Predict_1(&existence->base, persistenceModel);
			existence_1 = New_Existence();
			Existence_ctor_2(existence_1, twoPointDistribution);
			(void)Assign_Existence(&predictedExistence, existence_1);
			(void)Assign_Existence(&existence, NULL);
			(void)Assign_TwoPointDistribution(&twoPointDistribution, NULL);
			(void)Assign_Existence(&existence_1, NULL);
			StaticList_26_Add(predictedExistences, predictedExistence);
			gaussian_3 = EKF_PredictMeasurement_3(predictedState, measurementModel, &transitionMatrix);
			(void)Assign_Gaussian_3(&predictedMeasurement, gaussian_3);
			(void)Assign_Gaussian_3(&gaussian_3, NULL);
			StaticList_17_Add(transitionMatrices, transitionMatrix);
			StaticList_21_Add(predictedMeasurements, predictedMeasurement);
			staticList_6 = Tracking_1_Draw_1(predictedMeasurement, ((int32_t)50));
			sampleSet = New_SampleSet_1();
			SampleSet_1_ctor_2(sampleSet, staticList_6, listFactory);
			(void)Assign_SampleSet_1(&sampledPredictedMeasurement, sampleSet);
			(void)Assign_StaticList_10(&staticList_6, NULL);
			(void)Assign_SampleSet_1(&sampleSet, NULL);
			(void)Assign_StaticList_25(&staticList_7, measuremenCardinalitLikelihoods);
			marginalizedEvaluable = New_MarginalizedEvaluable_1();
			MarginalizedEvaluable_1_ctor(marginalizedEvaluable, detectionModel, sampledPredictedMeasurement);
			StaticList_25_Add(staticList_7, marginalizedEvaluable);
			(void)Assign_StaticList_25(&staticList_7, NULL);
			(void)Assign_MarginalizedEvaluable_1(&marginalizedEvaluable, NULL);
			boolean_6 = StaticListEnumerato_15_MoveNext(CS_5_0002);
		}
		if (!!(CS_5_0002 != NULL))
		{
			StaticListEnumerator_15_Dispose(CS_5_0002);
		}
		double__5 = Tracking_get_GateProbability(self);
		probabilityGate = New_ProbabilityGate_1();
		ProbabilityGate_1_ctor(probabilityGate, double__5);
		(void)Assign_ProbabilityGate_1(&gate, probabilityGate);
		(void)Assign_ProbabilityGate_1(&probabilityGate, NULL);
		multipleLocalNearestNeighbor = New_MultiplLocalNearestNeighbor();
		MultiplLocalNearestNeighbo_ctor(multipleLocalNearestNeighbor, factoryProvider);
		(void)Assign_MultipLocalNearesNeighbo(&associationAlgorithm, multipleLocalNearestNeighbor);
		(void)Assign_MultipLocalNearesNeighbo(&multipleLocalNearestNeighbor, NULL);
		measurementAssociation = MeasuremenAssociation_2_Create(predictedMeasurements, predictedExistences, measurements, associationAlgorithm, gate, factoryProvider);
		(void)Assign_MeasurementAssociation_1(&association, measurementAssociation);
		(void)Assign_MeasurementAssociation_1(&measurementAssociation, NULL);
		staticListFactory_6 = StIPDATrColFacPro_get_TraLisFac(factoryProvider);
		staticList_5 = StatiListFacto_4_CreateInstan_4(staticListFactory_6, ((int32_t)0));
		(void)Assign_StaticList_27(&updatedTracks, staticList_5);
		(void)Assign_StaticListFactory_4(&staticListFactory_6, NULL);
		(void)Assign_StaticList_27(&staticList_5, NULL);
		index = ((int32_t)0);
		int32 = index;
		int32_1 = StaticList_27_get_Count(self->_tracks);
		while (int32 < int32_1)
		{
			struct TrackWithMeasurements *trackWithMeasurements_1 = NULL;
			struct StaticList_9 *staticList_8 = NULL;
			struct Gaussian_3 *gaussian_4 = NULL;
			struct Existence *existence_2 = NULL;
			struct MarginalizedEvaluable_1 *marginalizedEvaluable_1 = NULL;
			struct StaticList_9 *staticList_9 = NULL;
			float64_t double__6 = 0.0;
			struct IPDA_1 *ipda = NULL;
			struct StaticList_19 *staticList_10 = NULL;
			int32_t int32_2 = ((int32_t)0);
			struct StaticListFactory_2 *staticListFactory_7 = NULL;
			struct GaussianMixture *gaussianMixture = NULL;
			struct MeasurementSetLikelihood *measurementSetLikelihood = NULL;
			struct StaticListEnumerator_11 *staticListEnumerator_1 = NULL;
			bool_t boolean_7 = false;
			struct Gaussian_5 *gaussian_5 = NULL;
			struct Existence *existence_3 = NULL;
			struct TwoPointDistribution *twoPointDistribution_1 = NULL;
			struct Gaussian_5 *gaussian_6 = NULL;
			struct Existence *existence_4 = NULL;
			uint64_t uInt64 = ((uint64_t)0u);
			struct Obstacle *obstacle = NULL;
			struct TrackWithMeasurements *trackWithMeasurements_2 = NULL;
			bool_t boolean_8 = false;

			trackWithMeasurements_1 = StaticList_27_get_Item(self->_tracks, index);
			(void)Assign_TrackWithMeasurements(&track_1, trackWithMeasurements_1);
			(void)Assign_TrackWithMeasurements(&trackWithMeasurements_1, NULL);
			staticList_8 = Associati_1_GetAssociateObjects(&association->base, index);
			(void)Assign_StaticList_9(&associatedMeasurements, staticList_8);
			(void)Assign_StaticList_9(&staticList_8, NULL);
			gaussian_4 = StaticList_21_get_Item(predictedMeasurements, index);
			existence_2 = StaticList_26_get_Item(predictedExistences, index);
			marginalizedEvaluable_1 = StaticList_25_get_Item(measuremenCardinalitLikelihoods, index);
			(void)Assign_StaticList_9(&staticList_9, associatedMeasurements);
			double__6 = FronRadaObjePara_get_CluttLambd(parameters);
			ipda = IPDA_2_Create_1(gaussian_4, existence_2, marginalizedEvaluable_1, staticList_9, double__6, factoryProvider);
			(void)Assign_IPDA_1(&hypothesisGenerator, ipda);
			(void)Assign_Gaussian_3(&gaussian_4, NULL);
			(void)Assign_Existence(&existence_2, NULL);
			(void)Assign_MarginalizedEvaluable_1(&marginalizedEvaluable_1, NULL);
			(void)Assign_StaticList_9(&staticList_9, NULL);
			(void)Assign_IPDA_1(&ipda, NULL);
			staticList_10 = IPDA_1_GetHypotheses(hypothesisGenerator);
			(void)Assign_StaticList_19(&associationHypotheses, staticList_10);
			(void)Assign_StaticList_19(&staticList_10, NULL);
			int32_2 = StaticList_19_get_Count(associationHypotheses);
			staticListFactory_7 = StIPDATrColFacPro_get_HypLisFac(factoryProvider);
			gaussianMixture = New_GaussianMixture();
			GaussianMixture_ctor(gaussianMixture, int32_2, staticListFactory_7);
			(void)Assign_GaussianMixture(&mixedState, gaussianMixture);
			(void)Assign_StaticListFactory_2(&staticListFactory_7, NULL);
			(void)Assign_GaussianMixture(&gaussianMixture, NULL);
			measurementSetLikelihood = IPDA_1_GetElementsLikelihood(hypothesisGenerator);
			(void)Assign_MeasurementSetLikelihood(&existenConditioElementsLikeliho, measurementSetLikelihood);
			(void)Assign_MeasurementSetLikelihood(&measurementSetLikelihood, NULL);
			(void)Assign_Object_1(&associatedObject, NULL);
			staticListEnumerator_1 = StaticList_19_GetEnumerator(associationHypotheses);
			(void)Assign_StaticListEnumerator_11(&CS_5_0003, staticListEnumerator_1);
			(void)Assign_StaticListEnumerator_11(&staticListEnumerator_1, NULL);
			boolean_7 = StaticListEnumerato_11_MoveNext(CS_5_0003);
			while (boolean_7)
			{
				struct TruePositivesHypothesis_1 *truePositivesHypothesis = NULL;
				struct StaticList_11 *staticList_11 = NULL;
				struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
				bool_t boolean_9 = false;

				truePositivesHypothesis = StaticListEnumer_11_get_Current(CS_5_0003);
				(void)Assign_TruePositivesHypothesi_1(&hypothesis, truePositivesHypothesis);
				(void)Assign_TruePositivesHypothesi_1(&truePositivesHypothesis, NULL);
				staticList_11 = TruePositiHypothe_1_get_Element(hypothesis);
				frontRadarObjectSpace = Tracki_1_SimplifFirstOrDefault(staticList_11);
				(void)Assign_FrontRadarObjectSpace(&truePositiveMeasurement, frontRadarObjectSpace);
				(void)Assign_StaticList_11(&staticList_11, NULL);
				(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
				boolean_9 = Space_6_op_Equality_2(truePositiveMeasurement, NULL);
				if (!!boolean_9)
				{
					struct GaussianMixture *gaussianMixture_1 = NULL;
					struct Gaussian_5 *gaussian_7 = NULL;
					float64_t double__7 = 0.0;

					(void)Assign_GaussianMixture(&gaussianMixture_1, mixedState);
					gaussian_7 = StaticList_23_get_Item(predictedStates, index);
					double__7 = TruePositivHypothe_1_get_Weight(hypothesis);
					GaussianMixture_Add(gaussianMixture_1, gaussian_7, double__7);
					(void)Assign_GaussianMixture(&gaussianMixture_1, NULL);
					(void)Assign_Gaussian_5(&gaussian_7, NULL);
				}
				else
				{
					struct GaussianMixture *gaussianMixture_2 = NULL;
					struct Gaussian_5 *gaussian_8 = NULL;
					struct Gaussian_3 *gaussian_9 = NULL;
					struct FrontRadarObjectSpace *frontRadarObjectSpace_1 = NULL;
					struct Matrix_13 *matrix = NULL;
					struct Gaussian_5 *gaussian_10 = NULL;
					float64_t double__8 = 0.0;
					struct Object_1 *object_1 = NULL;

					(void)Assign_GaussianMixture(&gaussianMixture_2, mixedState);
					gaussian_8 = StaticList_23_get_Item(predictedStates, index);
					gaussian_9 = StaticList_21_get_Item(predictedMeasurements, index);
					(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_1, truePositiveMeasurement);
					matrix = StaticList_17_get_Item(transitionMatrices, index);
					gaussian_10 = EKF_Update_5(gaussian_8, gaussian_9, frontRadarObjectSpace_1, matrix);
					double__8 = TruePositivHypothe_1_get_Weight(hypothesis);
					GaussianMixture_Add(gaussianMixture_2, gaussian_10, double__8);
					(void)Assign_GaussianMixture(&gaussianMixture_2, NULL);
					(void)Assign_Gaussian_5(&gaussian_8, NULL);
					(void)Assign_Gaussian_3(&gaussian_9, NULL);
					(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_1, NULL);
					(void)Assign_Matrix_13(&matrix, NULL);
					(void)Assign_Gaussian_5(&gaussian_10, NULL);
					object_1 = FronRadaObjeSpac_get_Ars308Obje(truePositiveMeasurement);
					(void)Assign_Object_1(&associatedObject, object_1);
					(void)Assign_Object_1(&object_1, NULL);
				}
				boolean_7 = StaticListEnumerato_11_MoveNext(CS_5_0003);
			}
			if (!!(CS_5_0003 != NULL))
			{
				StaticListEnumerator_11_Dispose(CS_5_0003);
			}
			gaussian_5 = GaussianMixture_ToGaussian(mixedState);
			(void)Assign_Gaussian_5(&updatedState, gaussian_5);
			(void)Assign_Gaussian_5(&gaussian_5, NULL);
			existence_3 = StaticList_26_get_Item(predictedExistences, index);
			twoPointDistribution_1 = BayesFilter_Update_1(&existence_3->base, existenConditioElementsLikeliho);
			(void)Assign_TwoPointDistribution(&updatedExistence, twoPointDistribution_1);
			(void)Assign_Existence(&existence_3, NULL);
			(void)Assign_TwoPointDistribution(&twoPointDistribution_1, NULL);
			(void)Assign_Gaussian_5(&gaussian_6, updatedState);
			existence_4 = New_Existence();
			Existence_ctor_2(existence_4, updatedExistence);
			uInt64 = GaussianTrack_get_ID(&track_1->base);
			obstacle = TrackWithMeasureme_get_Obstacle(track_1);
			trackWithMeasurements_2 = New_TrackWithMeasurements();
			TrackWithMeasurements_ctor(trackWithMeasurements_2, gaussian_6, existence_4, uInt64, obstacle, associatedObject);
			(void)Assign_TrackWithMeasurements(&updatedTrack, trackWithMeasurements_2);
			(void)Assign_Gaussian_5(&gaussian_6, NULL);
			(void)Assign_Existence(&existence_4, NULL);
			(void)Assign_Obstacle(&obstacle, NULL);
			(void)Assign_TrackWithMeasurements(&trackWithMeasurements_2, NULL);
			boolean_8 = Tracking_KeepTrack(self, updatedTrack);
			if (!!boolean_8)
			{
				StaticList_27_Add(updatedTracks, updatedTrack);
			}
			index = index + ((int32_t)1);
			int32 = index;
			int32_1 = StaticList_27_get_Count(self->_tracks);
		}
		if (!!self->InitializeFromFrontRadarObjects)
		{
			struct StaticList_9 *staticList_12 = NULL;
			struct StaticListEnumerator_5 *staticListEnumerator_2 = NULL;
			bool_t boolean_10 = false;

			staticList_12 = Associa_1_GetNotAssociatObjects(&association->base);
			staticListEnumerator_2 = StaticList_9_GetEnumerator(staticList_12);
			(void)Assign_StaticListEnumerator_5(&CS_5_0004, staticListEnumerator_2);
			(void)Assign_StaticList_9(&staticList_12, NULL);
			(void)Assign_StaticListEnumerator_5(&staticListEnumerator_2, NULL);
			boolean_10 = StaticListEnumerator_5_MoveNext(CS_5_0004);
			while (boolean_10)
			{
				struct FrontRadarObjectSpace *frontRadarObjectSpace_2 = NULL;
				struct FrontRadarObjectSpace *frontRadarObjectSpace_3 = NULL;
				struct CTRASpace *ctraSpace_3 = NULL;
				float64_t double__9 = 0.0;
				struct CTRASpace *ctraSpace_4 = NULL;
				float64_t double__10 = 0.0;
				struct CTRASpace *ctraSpace_5 = NULL;
				float64_t double__11 = 0.0;
				struct TrackWithMeasurements *trackWithMeasurements_3 = NULL;

				frontRadarObjectSpace_2 = StaticListEnumera_5_get_Current(CS_5_0004);
				(void)Assign_FrontRadarObjectSpace(&measurement, frontRadarObjectSpace_2);
				(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_2, NULL);
				(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_3, measurement);
				ctraSpace_3 = Gaussian_4_get_Expectation(egoMotionState);
				double__9 = CTRASpace_get_V(ctraSpace_3);
				ctraSpace_4 = Gaussian_4_get_Expectation(egoMotionState);
				double__10 = CTRASpace_get_W(ctraSpace_4);
				ctraSpace_5 = Gaussian_4_get_Expectation(egoMotionState);
				double__11 = CTRASpace_get_A(ctraSpace_5);
				trackWithMeasurements_3 = Trac_CreaTracFromFronRadarObjec(self, frontRadarObjectSpace_3, double__9, double__10, double__11, parameters);
				(void)Assign_TrackWithMeasurements(&trackFromFrontRadarObject, trackWithMeasurements_3);
				(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace_3, NULL);
				(void)Assign_CTRASpace(&ctraSpace_3, NULL);
				(void)Assign_CTRASpace(&ctraSpace_4, NULL);
				(void)Assign_CTRASpace(&ctraSpace_5, NULL);
				(void)Assign_TrackWithMeasurements(&trackWithMeasurements_3, NULL);
				StaticList_27_Add(updatedTracks, trackFromFrontRadarObject);
				boolean_10 = StaticListEnumerator_5_MoveNext(CS_5_0004);
			}
			if (!!(CS_5_0004 != NULL))
			{
				StaticListEnumerator_5_Dispose(CS_5_0004);
			}
		}
		Tracking_NormalizeVelocity(self, &updatedTracks);
		(void)Assign_StaticList_27(&self->_tracks, updatedTracks);
		Nullable_1_ctor(&nullable, time_1);
		self->_lastUpdateTime = nullable;
		(void)Assign_StaticList_27(&CS_1_0000, self->_tracks);
	}
	(void)Assign_StaticList_27(&result, CS_1_0000);
	RemRef_StaticListFactory_1(listFactory);
	RemRef_StatIPDATracCollFactProv(factoryProvider);
	RemRef_FrontRadarObjectParamete(parameters);
	RemRef_Object(CS_2_0001);
	RemRef_Gaussian_4(egoMotionState);
	RemRef_StaticList_27(CS_1_0000);
	RemRef_Tracking(tracking);
	RemRef_Tracking(tracking_1);
	RemRef_StaticList_23(predictedStates);
	RemRef_StaticList_21(predictedMeasurements);
	RemRef_StaticList_17(transitionMatrices);
	RemRef_StaticList_26(predictedExistences);
	RemRef_StaticList_25(measuremenCardinalitLikelihoods);
	RemRef_CAModel(systemModel);
	RemRef_Tracking(tracking_2);
	RemRef_PersistenceModel(persistenceModel);
	RemRef_FronRadarObjecMeasuModel(measurementModel);
	RemRef_FronRadarObjecDetecModel(detectionModel);
	RemRef_EgoMotionCompensation(egoMotionCompensation);
	RemRef_StaticListEnumerator_15(CS_5_0002);
	RemRef_TrackWithMeasurements(track);
	RemRef_Gaussian_5(egoMotionCompensatedState);
	RemRef_Gaussian_5(predictedState);
	RemRef_Existence(predictedExistence);
	RemRef_Matrix_13(transitionMatrix);
	RemRef_Gaussian_3(predictedMeasurement);
	RemRef_SampleSet_1(sampledPredictedMeasurement);
	RemRef_ProbabilityGate_1(gate);
	RemRef_MultipLocalNearesNeighbo(associationAlgorithm);
	RemRef_MeasurementAssociation_1(association);
	RemRef_StaticList_27(updatedTracks);
	RemRef_TrackWithMeasurements(track_1);
	RemRef_StaticList_9(associatedMeasurements);
	RemRef_IPDA_1(hypothesisGenerator);
	RemRef_StaticList_19(associationHypotheses);
	RemRef_GaussianMixture(mixedState);
	RemRef_MeasurementSetLikelihood(existenConditioElementsLikeliho);
	RemRef_Object_1(associatedObject);
	RemRef_StaticListEnumerator_11(CS_5_0003);
	RemRef_TruePositivesHypothesi_1(hypothesis);
	RemRef_FrontRadarObjectSpace(truePositiveMeasurement);
	RemRef_Gaussian_5(updatedState);
	RemRef_TwoPointDistribution(updatedExistence);
	RemRef_TrackWithMeasurements(updatedTrack);
	RemRef_StaticListEnumerator_5(CS_5_0004);
	RemRef_FrontRadarObjectSpace(measurement);
	RemRef_TrackWithMeasurements(trackFromFrontRadarObject);
	return result;
}

void CodeGenerationHelper_EntryPoint(void)
{
	struct DateTime time_1 = { 0 };
	struct StaticList_27 *staticList = NULL;
	struct CASpace *caSpace = NULL;
	struct float64_t_1D_5 *array = NULL;
	struct PositiveDefiniteMatrix_7 *positiveDefiniteMatrix = NULL;
	struct Gaussian_5 *gaussian = NULL;
	struct Existence *existence = NULL;
	struct TrackWithMeasurements *trackWithMeasurements = NULL;
	struct StaticList_12 *g__initLocal0 = NULL;
	struct StaticList_12 *staticList_1 = NULL;
	struct StaticList_12 *staticList_2 = NULL;
	struct RadarSpace *radarSpace = NULL;
	struct StaticList_4 *obstacles = NULL;
	struct StaticList_4 *staticList_3 = NULL;
	struct Obstacle *obstacle = NULL;
	struct StaticList_6 *mobilEyeSpaces = NULL;
	struct StaticList_6 *staticList_4 = NULL;
	struct MobilEyeSpace *mobilEyeSpace = NULL;
	struct Object_1 *obj = NULL;
	struct Object_1 *object = NULL;
	struct StaticList_9 *objectSpaces = NULL;
	struct StaticList_9 *staticList_5 = NULL;
	struct FrontRadarObjectSpace *frontRadarObjectSpace = NULL;
	float64_t double_ = 0.0;
	float64_t double__1 = 0.0;
	float64_t double__2 = 0.0;
	float64_t double__3 = 0.0;
	float64_t double__4 = 0.0;
	struct Measure_2 *velocity = NULL;
	struct Measure_2 *measure = NULL;
	struct Measure_3 *yawRate = NULL;
	struct Measure_3 *measure_1 = NULL;
	struct Tracking *tracking = NULL;
	struct Tracking *tracking_1 = NULL;
	struct StaticList_27 *staticList_6 = NULL;
	struct StaticList_27 *staticList_7 = NULL;
	struct StaticList_27 *staticList_8 = NULL;

	DateTime_ctor_1(&time_1, ((int32_t)2016), ((int32_t)1), ((int32_t)14));
	staticList = New_StaticList_27();
	StaticList_27_ctor(staticList, ((int32_t)15));
	(void)Assign_StaticList_27(&staticList, NULL);
	caSpace = New_CASpace();
	CASpace_ctor(caSpace);
	array = New_float64_t_1D_5();
	array->Elements[((int32_t)0)] = 1.0;
	array->Elements[((int32_t)1)] = 1.0;
	array->Elements[((int32_t)2)] = 1.0;
	array->Elements[((int32_t)3)] = 1.0;
	array->Elements[((int32_t)4)] = 1.0;
	positiveDefiniteMatrix = New_PositiveDefiniteMatrix_7();
	PositiveDefiniteMatrix_7_ctor(positiveDefiniteMatrix, array);
	gaussian = New_Gaussian_5();
	Gaussian_5_ctor(gaussian, caSpace, positiveDefiniteMatrix);
	existence = New_Existence();
	Existence_ctor_1(existence, 1.0);
	trackWithMeasurements = New_TrackWithMeasurements();
	TrackWithMeasurements_ctor(trackWithMeasurements, gaussian, existence, ((uint64_t)1u), NULL, NULL);
	(void)Assign_CASpace(&caSpace, NULL);
	(void)Assign_float64_t_1D_5(&array, NULL);
	(void)Assign_PositiveDefiniteMatrix_7(&positiveDefiniteMatrix, NULL);
	(void)Assign_Gaussian_5(&gaussian, NULL);
	(void)Assign_Existence(&existence, NULL);
	(void)Assign_TrackWithMeasurements(&trackWithMeasurements, NULL);
	staticList_1 = New_StaticList_12();
	StaticList_12_ctor(staticList_1, ((int32_t)15));
	(void)Assign_StaticList_12(&g__initLocal0, staticList_1);
	(void)Assign_StaticList_12(&staticList_1, NULL);
	(void)Assign_StaticList_12(&staticList_2, g__initLocal0);
	radarSpace = New_RadarSpace();
	RadarSpace_ctor(radarSpace);
	StaticList_12_Add(staticList_2, radarSpace);
	(void)Assign_StaticList_12(&staticList_2, NULL);
	(void)Assign_RadarSpace(&radarSpace, NULL);
	staticList_3 = New_StaticList_4();
	StaticList_4_ctor(staticList_3, ((int32_t)40));
	obstacle = New_Obstacle();
	Obstacle_ctor(obstacle, ((uint32_t)1u), ((int32_t)1), 1.0, 1.0, 1.0, 1.0, ObstacleType_Bicycle, ObstacleStatus_Moving, 1.0, 1.0, 1.0, 1.0, 1.0, true);
	StaticList_4_Add(staticList_3, obstacle);
	(void)Assign_StaticList_4(&obstacles, staticList_3);
	(void)Assign_StaticList_4(&staticList_3, NULL);
	(void)Assign_Obstacle(&obstacle, NULL);
	staticList_4 = New_StaticList_6();
	StaticList_6_ctor(staticList_4, ((int32_t)40));
	mobilEyeSpace = New_MobilEyeSpace();
	MobilEyeSpace_ctor(mobilEyeSpace);
	StaticList_6_Add(staticList_4, mobilEyeSpace);
	(void)Assign_StaticList_6(&mobilEyeSpaces, staticList_4);
	(void)Assign_StaticList_6(&staticList_4, NULL);
	(void)Assign_MobilEyeSpace(&mobilEyeSpace, NULL);
	object = New_Object_1();
	Object_1_ctor_1(object, ((uint32_t)1u), ((uint32_t)2u), 3.0, 4.0, 5.0, 6.0, ((int32_t)7), 8.0, 9.0, 10.0, ((int32_t)11), 12.0, 13.0, 14.0);
	(void)Assign_Object_1(&obj, object);
	(void)Assign_Object_1(&object, NULL);
	staticList_5 = New_StaticList_9();
	StaticList_9_ctor(staticList_5, ((int32_t)40));
	frontRadarObjectSpace = New_FrontRadarObjectSpace();
	FrontRadarObjectSpace_ctor(frontRadarObjectSpace);
	double_ = Object_1_get_LongitudiDisplacem(obj);
	CVComponentsSpace_set_X(&frontRadarObjectSpace->base, double_);
	double__1 = Object_1_get_LateralDisplacemen(obj);
	CVComponentsSpace_set_Y(&frontRadarObjectSpace->base, double__1);
	double__2 = Object_1_get_RelatiLongitVeloci(obj);
	CVComponentsSpace_set_Vx(&frontRadarObjectSpace->base, double__2);
	double__3 = Object_1_get_LateralSpeed(obj);
	CVComponentsSpace_set_Vy(&frontRadarObjectSpace->base, double__3);
	double__4 = Object_1_get_AcceleratLongitudi(obj);
	FrontRadarObjectSpace_set_A(frontRadarObjectSpace, double__4);
	FronRadaObjeSpac_set_Ars308Obje(frontRadarObjectSpace, obj);
	StaticList_9_Add(staticList_5, frontRadarObjectSpace);
	(void)Assign_StaticList_9(&objectSpaces, staticList_5);
	(void)Assign_StaticList_9(&staticList_5, NULL);
	(void)Assign_FrontRadarObjectSpace(&frontRadarObjectSpace, NULL);
	measure = New_Measure_2();
	Measure_2_ctor(measure, 1.0);
	(void)Assign_Measure_2(&velocity, measure);
	(void)Assign_Measure_2(&measure, NULL);
	measure_1 = New_Measure_3();
	Measure_3_ctor(measure_1, 2.0);
	(void)Assign_Measure_3(&yawRate, measure_1);
	(void)Assign_Measure_3(&measure_1, NULL);
	tracking_1 = New_Tracking();
	Tracking_ctor_1(tracking_1);
	(void)Assign_Tracking(&tracking, tracking_1);
	(void)Assign_Tracking(&tracking_1, NULL);
	Tracking_Initialize(tracking);
	staticList_6 = Tracking_GetTracks(tracking);
	(void)Assign_StaticList_27(&staticList_6, NULL);
	Tracking_ProcessVelocity(tracking, time_1, velocity);
	Tracking_ProcessYawRate(tracking, time_1, yawRate);
	staticList_7 = Trackin_ProcessMobilEyeDetectio(tracking, time_1, mobilEyeSpaces, obstacles);
	(void)Assign_StaticList_27(&staticList_7, NULL);
	staticList_8 = Track_ProceFrontRadarObjecDetec(tracking, time_1, objectSpaces);
	(void)Assign_StaticList_27(&staticList_8, NULL);
	RemRef_StaticList_12(g__initLocal0);
	RemRef_StaticList_4(obstacles);
	RemRef_StaticList_6(mobilEyeSpaces);
	RemRef_Object_1(obj);
	RemRef_StaticList_9(objectSpaces);
	RemRef_Measure_2(velocity);
	RemRef_Measure_3(yawRate);
	RemRef_Tracking(tracking);
}

static void Clone_CASpace(struct CASpace *const self)
{
	Clone_CVSpace(&self->base);
}

static void Clone_CVSpace(struct CVSpace *const self)
{
	Clone_AngularSpace(&self->base);
}

static void Clone_AngularSpace(struct AngularSpace *const self)
{
	Clone_Space(&self->base);
	if (self->AngularDimensionsIndices != NULL)
	{
		(&self->AngularDimensionsIndices->base)->ReferenceCount++;
	}
}

static void Clone_Space(struct Space *const self)
{
	Clone_Object(&self->base);
	if (self->_vector != NULL)
	{
		(&self->_vector->base)->ReferenceCount++;
	}
	if (self->_spaceInformationLock != NULL)
	{
		self->_spaceInformationLock->ReferenceCount++;
	}
}

static void Clone_Object(struct Object *const self)
{
}

static void Clone_CTRASpace(struct CTRASpace *const self)
{
	Clone_AngularSpace_2(&self->base);
}

static void Clone_AngularSpace_2(struct AngularSpace_2 *const self)
{
	Clone_Space_5(&self->base);
	if (self->AngularDimensionsIndices != NULL)
	{
		(&self->AngularDimensionsIndices->base)->ReferenceCount++;
	}
}

static void Clone_Space_5(struct Space_5 *const self)
{
	Clone_Object(&self->base);
	if (self->_vector != NULL)
	{
		(&self->_vector->base)->ReferenceCount++;
	}
	if (self->_spaceInformationLock != NULL)
	{
		self->_spaceInformationLock->ReferenceCount++;
	}
}

static void Clone_MobilEyeSpace(struct MobilEyeSpace *const self)
{
	Clone_Space_3(&self->base);
}

static void Clone_Space_3(struct Space_3 *const self)
{
	Clone_Object(&self->base);
	if (self->_vector != NULL)
	{
		(&self->_vector->base)->ReferenceCount++;
	}
	if (self->_spaceInformationLock != NULL)
	{
		self->_spaceInformationLock->ReferenceCount++;
	}
}

static void Clone_FrontRadarObjectSpace(struct FrontRadarObjectSpace *const self)
{
	Clone_CVComponentsSpace(&self->base);
	if (self->Ars308Object != NULL)
	{
		(&self->Ars308Object->base)->ReferenceCount++;
	}
}

static void Clone_CVComponentsSpace(struct CVComponentsSpace *const self)
{
	Clone_Space(&self->base);
}

static void Del_Object(struct Object *const self)
{
}

static void Del_StaticList_27(struct StaticList_27 *const self)
{
	Del_Object(&self->base);
	RemRef_TrackWithMeasureme_1D_15(self->_items);
}

static void Del_TrackWithMeasurements(struct TrackWithMeasurements *const self)
{
	Del_GaussianTrack(&self->base);
	RemRef_Obstacle(self->Obstacle);
	RemRef_Object_1(self->ARS308Object);
}

static void Del_GaussianTrack(struct GaussianTrack *const self)
{
	Del_Object(&self->base);
	RemRef_Gaussian_5(self->State);
	RemRef_Existence(self->Existence);
}

static void Del_CASpace(struct CASpace *const self)
{
	Del_CVSpace(&self->base);
}

static void Del_CVSpace(struct CVSpace *const self)
{
	Del_AngularSpace(&self->base);
}

static void Del_AngularSpace(struct AngularSpace *const self)
{
	Del_Space(&self->base);
	RemRef_int32_t_1D_1(self->AngularDimensionsIndices);
}

static void Del_Space(struct Space *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData(self->_vector);
	RemRef_Object(self->_spaceInformationLock);
}

static void Del_MatrixData(struct MatrixData *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_5(self->_data);
}

static void Del_PositiveDefiniteMatrix_7(struct PositiveDefiniteMatrix_7 *const self)
{
	Del_SquareMatrix_7(&self->base);
	RemRef_MatrixData(self->CachedInverse);
	RemRef_MatrixData(self->CachedCholeskyDecomposition);
}

static void Del_SquareMatrix_7(struct SquareMatrix_7 *const self)
{
	Del_Matrix_10(&self->base);
	RemRef_CASpace(self->EmptySpace);
}

static void Del_Matrix_10(struct Matrix_10 *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_2(self->_matrix);
	RemRef_CASpace(self->EmptyRowSpace);
	RemRef_CASpace(self->EmptyColumnSpace);
	RemRef_MatrixData(self->CachedTranspose);
}

static void Del_MatrixData_2(struct MatrixData_2 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_25(self->_data);
}

static void Del_LinearAlgebra(struct LinearAlgebra *const self)
{
	Del_Object(&self->base);
}

static void Del_Gaussian_5(struct Gaussian_5 *const self)
{
	Del_Object(&self->base);
	RemRef_PositiveDefiniteMatrix_7(self->covariance);
	RemRef_CASpace(self->Expectation);
}

static void Del_Existence(struct Existence *const self)
{
	Del_TwoPointDistribution(&self->base);
}

static void Del_TwoPointDistribution(struct TwoPointDistribution *const self)
{
	Del_SampleSet_2(&self->base);
	RemRef_ExistenceSpace(self->SuccessSample);
	RemRef_ExistenceSpace(self->FailureSample);
}

static void Del_SampleSet_2(struct SampleSet_2 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticListFactory(self->_listFactory);
	RemRef_UniformRandomGenerator(self->_randomGenerator);
	RemRef_StaticList_15(self->Samples);
}

static void Del_ExistenceSpace(struct ExistenceSpace *const self)
{
	Del_FiniteSpace(&self->base);
}

static void Del_FiniteSpace(struct FiniteSpace *const self)
{
	Del_Space_1(&self->base);
}

static void Del_Space_1(struct Space_1 *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_3(self->_vector);
	RemRef_Object(self->_spaceInformationLock);
}

static void Del_MatrixData_3(struct MatrixData_3 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_1(self->_data);
}

static void Del_StaticListFactory(struct StaticListFactory *const self)
{
	Del_Object(&self->base);
}

static void Del_UniformRandomGenerator(struct UniformRandomGenerator *const self)
{
	Del_Object(&self->base);
	RemRef_Random(self->_random);
}

static void Del_Random(struct Random *const self)
{
	Del_Object(&self->base);
	RemRef_int32_t_1D_56(self->SeedArray);
}

static void Del_StaticList_15(struct StaticList_15 *const self)
{
	Del_Object(&self->base);
	RemRef_SampleProbabiPair_2_1D_2(self->_items);
}

static void Del_SampleProbabilityPair_2(struct SampleProbabilityPair_2 *const self)
{
	Del_Object(&self->base);
	RemRef_ExistenceSpace(self->Sample);
}

static void Del_Obstacle(struct Obstacle *const self)
{
	Del_Object(&self->base);
}

static void Del_Object_1(struct Object_1 *const self)
{
	Del_Object(&self->base);
}

static void Del_StaticList_12(struct StaticList_12 *const self)
{
	Del_Object(&self->base);
	RemRef_RadarSpace_1D_15(self->_items);
}

static void Del_RadarSpace(struct RadarSpace *const self)
{
	Del_AngularSpace_1(&self->base);
}

static void Del_AngularSpace_1(struct AngularSpace_1 *const self)
{
	Del_Space_2(&self->base);
	RemRef_int32_t_1D_1(self->AngularDimensionsIndices);
}

static void Del_Space_2(struct Space_2 *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_4(self->_vector);
	RemRef_Object(self->_spaceInformationLock);
}

static void Del_MatrixData_4(struct MatrixData_4 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_3(self->_data);
}

static void Del_StaticList_4(struct StaticList_4 *const self)
{
	Del_Object(&self->base);
	RemRef_Obstacle_1D_40(self->_items);
}

static void Del_StaticList_6(struct StaticList_6 *const self)
{
	Del_Object(&self->base);
	RemRef_MobilEyeSpace_1D_40(self->_items);
}

static void Del_MobilEyeSpace(struct MobilEyeSpace *const self)
{
	Del_Space_3(&self->base);
}

static void Del_Space_3(struct Space_3 *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_5(self->_vector);
	RemRef_Object(self->_spaceInformationLock);
}

static void Del_MatrixData_5(struct MatrixData_5 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_4(self->_data);
}

static void Del_StaticList_9(struct StaticList_9 *const self)
{
	Del_Object(&self->base);
	RemRef_FronRadaObjecSpace_1D_40(self->_items);
}

static void Del_FrontRadarObjectSpace(struct FrontRadarObjectSpace *const self)
{
	Del_CVComponentsSpace(&self->base);
	RemRef_Object_1(self->Ars308Object);
}

static void Del_CVComponentsSpace(struct CVComponentsSpace *const self)
{
	Del_Space(&self->base);
}

static void Del_Measure_2(struct Measure_2 *const self)
{
	Del_Measure(&self->base);
}

static void Del_Measure(struct Measure *const self)
{
	Del_Object(&self->base);
}

static void Del_Measure_3(struct Measure_3 *const self)
{
	Del_Measure_1(&self->base);
}

static void Del_Measure_1(struct Measure_1 *const self)
{
	Del_Object(&self->base);
}

static void Del_Tracking(struct Tracking *const self)
{
	Del_Object(&self->base);
	RemRef_EgoMotionFilter(self->_egoMotionFilter);
	RemRef_MatrixData_2(self->_velocityNormalization);
	RemRef_StaticList_27(self->_tracks);
	RemRef_Object(self->_tracksLock);
	RemRef_SensorProperties(self->_sensorProperties);
}

static void Del_SensorProperties(struct SensorProperties *const self)
{
	Del_Object(&self->base);
	RemRef_FrontRadarNearParameters(self->_frontRadarNearParameters);
	RemRef_FrontRadarFarParameters(self->_frontRadarFarParameters);
	RemRef_MobilEyeParameters(self->_mobilEyeParameters);
	RemRef_FrontRadarObjectParamete(self->_frontRadarObjectParameters);
}

static void Del_FrontRadarNearParameters(struct FrontRadarNearParameters *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_3(self->_noiseMatrixDiagonal);
}

static void Del_FrontRadarFarParameters(struct FrontRadarFarParameters *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_3(self->_noiseMatrixDiagonal);
}

static void Del_MobilEyeParameters(struct MobilEyeParameters *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_4(self->_noiseMatrixDiagonal);
}

static void Del_FrontRadarObjectParameters(struct FrontRadarObjectParameters *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_5(self->_noiseMatrixDiagonal);
	RemRef_Vector2D_1D_10(self->FieldOfView);
}

static void Del_EgoMotionFilter(struct EgoMotionFilter *const self)
{
	Del_Object(&self->base);
	RemRef_CTRAModel(self->_systemModel);
	RemRef_VelocityMeasurementModel(self->_velocityMeasurementModel);
	RemRef_YawRateMeasurementModel(self->_yawRateMeasurementModel);
	RemRef_Gaussian_4(self->_state);
	RemRef_Object(self->_stateLock);
}

static void Del_PositiveDefiniteMatrix_4(struct PositiveDefiniteMatrix_4 *const self)
{
	Del_SquareMatrix_4(&self->base);
}

static void Del_SquareMatrix_4(struct SquareMatrix_4 *const self)
{
	Del_Matrix_4(&self->base);
	RemRef_CTRAErrorSpace(self->EmptySpace);
}

static void Del_Matrix_4(struct Matrix_4 *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_6(self->_matrix);
	RemRef_CTRAErrorSpace(self->EmptyRowSpace);
	RemRef_CTRAErrorSpace(self->EmptyColumnSpace);
}

static void Del_CTRAErrorSpace(struct CTRAErrorSpace *const self)
{
	Del_Space_4(&self->base);
}

static void Del_Space_4(struct Space_4 *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_8(self->_vector);
	RemRef_Object(self->_spaceInformationLock);
}

static void Del_MatrixData_8(struct MatrixData_8 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_2(self->_data);
}

static void Del_MatrixData_6(struct MatrixData_6 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_4(self->_data);
}

static void Del_CTRASpace(struct CTRASpace *const self)
{
	Del_AngularSpace_2(&self->base);
}

static void Del_AngularSpace_2(struct AngularSpace_2 *const self)
{
	Del_Space_5(&self->base);
	RemRef_int32_t_1D_1(self->AngularDimensionsIndices);
}

static void Del_Space_5(struct Space_5 *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_9(self->_vector);
	RemRef_Object(self->_spaceInformationLock);
}

static void Del_MatrixData_9(struct MatrixData_9 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_6(self->_data);
}

static void Del_CTRAModel(struct CTRAModel *const self)
{
	Del_SystemModel_5(&self->base);
}

static void Del_SystemModel_5(struct SystemModel_5 *const self)
{
	Del_SystemModel_3(&self->base);
}

static void Del_SystemModel_3(struct SystemModel_3 *const self)
{
	Del_SystemModel_1(&self->base);
}

static void Del_SystemModel_1(struct SystemModel_1 *const self)
{
	Del_Object(&self->base);
	RemRef_PositiveDefiniteMatrix_4(self->_processNoiseCovariance);
	RemRef_CTRASpace(self->Condition);
	RemRef_CTRAErrorSpace(self->Condition2);
}

static void Del_PositiveDefiniteMatrix(struct PositiveDefiniteMatrix *const self)
{
	Del_SquareMatrix(&self->base);
}

static void Del_SquareMatrix(struct SquareMatrix *const self)
{
	Del_Matrix(&self->base);
	RemRef_VelocitySpace(self->EmptySpace);
}

static void Del_Matrix(struct Matrix *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_3(self->_matrix);
	RemRef_VelocitySpace(self->EmptyRowSpace);
	RemRef_VelocitySpace(self->EmptyColumnSpace);
}

static void Del_VelocitySpace(struct VelocitySpace *const self)
{
	Del_Space_1(&self->base);
}

static void Del_VelocityMeasurementModel(struct VelocityMeasurementModel *const self)
{
	Del_MeasurementModel_8(&self->base);
}

static void Del_MeasurementModel_8(struct MeasurementModel_8 *const self)
{
	Del_MeasurementModel_4(&self->base);
}

static void Del_MeasurementModel_4(struct MeasurementModel_4 *const self)
{
	Del_MeasurementModel(&self->base);
}

static void Del_MeasurementModel(struct MeasurementModel *const self)
{
	Del_Object(&self->base);
	RemRef_PositiveDefiniteMatrix(self->_measurementNoiseCovariance);
	RemRef_CTRASpace(self->Condition);
}

static void Del_PositiveDefiniteMatrix_1(struct PositiveDefiniteMatrix_1 *const self)
{
	Del_SquareMatrix_1(&self->base);
}

static void Del_SquareMatrix_1(struct SquareMatrix_1 *const self)
{
	Del_Matrix_1(&self->base);
	RemRef_YawRateSpace(self->EmptySpace);
}

static void Del_Matrix_1(struct Matrix_1 *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_3(self->_matrix);
	RemRef_YawRateSpace(self->EmptyRowSpace);
	RemRef_YawRateSpace(self->EmptyColumnSpace);
}

static void Del_YawRateSpace(struct YawRateSpace *const self)
{
	Del_Space_1(&self->base);
}

static void Del_YawRateMeasurementModel(struct YawRateMeasurementModel *const self)
{
	Del_MeasurementModel_5(&self->base);
}

static void Del_MeasurementModel_5(struct MeasurementModel_5 *const self)
{
	Del_MeasurementModel_1(&self->base);
}

static void Del_MeasurementModel_1(struct MeasurementModel_1 *const self)
{
	Del_Object(&self->base);
	RemRef_PositiveDefiniteMatrix_1(self->_measurementNoiseCovariance);
	RemRef_CTRASpace(self->Condition);
}

static void Del_Gaussian_4(struct Gaussian_4 *const self)
{
	Del_Object(&self->base);
	RemRef_PositiveDefiniteMatrix_6(self->covariance);
	RemRef_CTRASpace(self->Expectation);
}

static void Del_PositiveDefiniteMatrix_6(struct PositiveDefiniteMatrix_6 *const self)
{
	Del_SquareMatrix_6(&self->base);
	RemRef_MatrixData(self->CachedInverse);
	RemRef_MatrixData(self->CachedCholeskyDecomposition);
}

static void Del_SquareMatrix_6(struct SquareMatrix_6 *const self)
{
	Del_Matrix_6(&self->base);
	RemRef_CTRASpace(self->EmptySpace);
}

static void Del_Matrix_6(struct Matrix_6 *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_11(self->_matrix);
	RemRef_CTRASpace(self->EmptyRowSpace);
	RemRef_CTRASpace(self->EmptyColumnSpace);
	RemRef_MatrixData(self->CachedTranspose);
}

static void Del_MatrixData_11(struct MatrixData_11 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_36(self->_data);
}

static void Del_StaticListEnumerator_15(struct StaticListEnumerator_15 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_27(self->_list);
}

static void Del_Matrix_7(struct Matrix_7 *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_12(self->_matrix);
	RemRef_CTRAErrorSpace(self->EmptyRowSpace);
	RemRef_CTRASpace(self->EmptyColumnSpace);
	RemRef_MatrixData(self->CachedTranspose);
}

static void Del_MatrixData_12(struct MatrixData_12 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_12(self->_data);
}

static void Del_Matrix_8(struct Matrix_8 *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_10(self->_matrix);
	RemRef_CTRASpace(self->EmptyRowSpace);
	RemRef_VelocitySpace(self->EmptyColumnSpace);
	RemRef_MatrixData(self->CachedTranspose);
}

static void Del_MatrixData_10(struct MatrixData_10 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_6(self->_data);
}

static void Del_Gaussian(struct Gaussian *const self)
{
	Del_Object(&self->base);
	RemRef_PositiveDefiniteMatrix(self->covariance);
	RemRef_VelocitySpace(self->Expectation);
}

static void Del_Matrix_9(struct Matrix_9 *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_10(self->_matrix);
	RemRef_CTRASpace(self->EmptyRowSpace);
	RemRef_YawRateSpace(self->EmptyColumnSpace);
	RemRef_MatrixData(self->CachedTranspose);
}

static void Del_Gaussian_1(struct Gaussian_1 *const self)
{
	Del_Object(&self->base);
	RemRef_PositiveDefiniteMatrix_1(self->covariance);
	RemRef_YawRateSpace(self->Expectation);
}

static void Del_StaticListFactory_1(struct StaticListFactory_1 *const self)
{
	Del_Object(&self->base);
}

static void Del_StatIPDATracColleFactoProvi(struct StatiIPDATrackColleFactorProvid *const self)
{
	Del_Object(&self->base);
	RemRef_StaticListFactory_2(self->_hypothesisListFactory);
	RemRef_StaticAssociTableFactory(self->_associationTableFactory);
	RemRef_StaticListFactory_4(self->_trackListFactory);
	RemRef_StaticListFactory_5(self->_measurementListFactory);
	RemRef_StaticListFactory_3(self->_trueElementsListFactory);
}

static void Del_StaticListFactory_2(struct StaticListFactory_2 *const self)
{
	Del_Object(&self->base);
}

static void Del_StaticListFactory_3(struct StaticListFactory_3 *const self)
{
	Del_Object(&self->base);
}

static void Del_StaticAssociatiTableFactory(struct StaticAssociationTableFactory *const self)
{
	Del_Object(&self->base);
}

static void Del_StaticListFactory_4(struct StaticListFactory_4 *const self)
{
	Del_Object(&self->base);
}

static void Del_StaticListFactory_5(struct StaticListFactory_5 *const self)
{
	Del_Object(&self->base);
}

static void Del_StaticList_23(struct StaticList_23 *const self)
{
	Del_Object(&self->base);
	RemRef_Gaussian_5_1D_15(self->_items);
}

static void Del_StaticList_20(struct StaticList_20 *const self)
{
	Del_Object(&self->base);
	RemRef_Gaussian_2_1D_15(self->_items);
}

static void Del_Gaussian_2(struct Gaussian_2 *const self)
{
	Del_Object(&self->base);
	RemRef_PositiveDefiniteMatrix_3(self->covariance);
	RemRef_MobilEyeSpace(self->Expectation);
}

static void Del_StaticList_16(struct StaticList_16 *const self)
{
	Del_Object(&self->base);
	RemRef_Matrix_11_1D_15(self->_items);
}

static void Del_Matrix_11(struct Matrix_11 *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_16(self->_matrix);
	RemRef_CASpace(self->EmptyRowSpace);
	RemRef_MobilEyeSpace(self->EmptyColumnSpace);
	RemRef_MatrixData(self->CachedTranspose);
}

static void Del_StaticList_26(struct StaticList_26 *const self)
{
	Del_Object(&self->base);
	RemRef_Existence_1D_15(self->_items);
}

static void Del_StaticList_22(struct StaticList_22 *const self)
{
	Del_Object(&self->base);
	RemRef_MarginaliEvaluable_1D_15(self->_items);
}

static void Del_MarginalizedEvaluable(struct MarginalizedEvaluable *const self)
{
	Del_Object(&self->base);
	RemRef_MobilEyeDetectionModel(self->_conditionalDistribution);
	RemRef_SampleSet(self->_condition);
}

static void Del_PositiveDefiniteMatrix_2(struct PositiveDefiniteMatrix_2 *const self)
{
	Del_SquareMatrix_2(&self->base);
}

static void Del_SquareMatrix_2(struct SquareMatrix_2 *const self)
{
	Del_Matrix_2(&self->base);
	RemRef_CAErrorSpace(self->EmptySpace);
}

static void Del_Matrix_2(struct Matrix_2 *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_13(self->_matrix);
	RemRef_CAErrorSpace(self->EmptyRowSpace);
	RemRef_CAErrorSpace(self->EmptyColumnSpace);
}

static void Del_CAErrorSpace(struct CAErrorSpace *const self)
{
	Del_Space_2(&self->base);
}

static void Del_MatrixData_13(struct MatrixData_13 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_9(self->_data);
}

static void Del_CAModel(struct CAModel *const self)
{
	Del_SystemModel_4(&self->base);
}

static void Del_SystemModel_4(struct SystemModel_4 *const self)
{
	Del_SystemModel_2(&self->base);
}

static void Del_SystemModel_2(struct SystemModel_2 *const self)
{
	Del_SystemModel(&self->base);
}

static void Del_SystemModel(struct SystemModel *const self)
{
	Del_Object(&self->base);
	RemRef_PositiveDefiniteMatrix_2(self->_processNoiseCovariance);
	RemRef_CASpace(self->Condition);
	RemRef_CAErrorSpace(self->Condition2);
}

static void Del_PersistenceModel(struct PersistenceModel *const self)
{
	Del_Object(&self->base);
	RemRef_ExistenceSpace(self->Condition);
}

static void Del_MobilEyeDetectionModel(struct MobilEyeDetectionModel *const self)
{
	Del_SingleDetectionModel(&self->base);
	RemRef_MobilEyeParameters(self->_parameters);
}

static void Del_SingleDetectionModel(struct SingleDetectionModel *const self)
{
	Del_DetectionModel(&self->base);
}

static void Del_DetectionModel(struct DetectionModel *const self)
{
	Del_Object(&self->base);
	RemRef_MobilEyeSpace(self->Condition);
}

static void Del_EgoMotionCompensation(struct EgoMotionCompensation *const self)
{
	Del_Object(&self->base);
	RemRef_CASpace(self->Condition);
	RemRef_CTRASpace(self->Condition2);
}

static void Del_Matrix_12(struct Matrix_12 *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_14(self->_matrix);
	RemRef_CAErrorSpace(self->EmptyRowSpace);
	RemRef_CASpace(self->EmptyColumnSpace);
	RemRef_MatrixData(self->CachedTranspose);
}

static void Del_MatrixData_14(struct MatrixData_14 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_15(self->_data);
}

static void Del_Type(struct Type *const self)
{
	Del_MemberInfo(&self->base);
}

static void Del_MemberInfo(struct MemberInfo *const self)
{
	Del_Object(&self->base);
}

static void Del_MobilEyeMeasurementModel(struct MobilEyeMeasurementModel *const self)
{
	Del_CartesianMeasurementModel(&self->base);
	RemRef_MobilEyeSpace(self->_measurementIndices);
}

static void Del_CartesianMeasurementModel(struct CartesianMeasurementModel *const self)
{
	Del_MeasurementModel_6(&self->base);
	RemRef_MobilEyeParameters(self->SensorParameters);
}

static void Del_MeasurementModel_6(struct MeasurementModel_6 *const self)
{
	Del_MeasurementModel_2(&self->base);
}

static void Del_MeasurementModel_2(struct MeasurementModel_2 *const self)
{
	Del_Object(&self->base);
	RemRef_PositiveDefiniteMatrix_3(self->_measurementNoiseCovariance);
	RemRef_CASpace(self->Condition);
}

static void Del_PositiveDefiniteMatrix_3(struct PositiveDefiniteMatrix_3 *const self)
{
	Del_SquareMatrix_3(&self->base);
	RemRef_MatrixData_15(self->CachedInverse);
	RemRef_MatrixData_15(self->CachedCholeskyDecomposition);
}

static void Del_SquareMatrix_3(struct SquareMatrix_3 *const self)
{
	Del_Matrix_3(&self->base);
	RemRef_MobilEyeSpace(self->EmptySpace);
}

static void Del_Matrix_3(struct Matrix_3 *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_15(self->_matrix);
	RemRef_MobilEyeSpace(self->EmptyRowSpace);
	RemRef_MobilEyeSpace(self->EmptyColumnSpace);
	RemRef_MatrixData(self->CachedTranspose);
}

static void Del_MatrixData_15(struct MatrixData_15 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_16(self->_data);
}

static void Del_MatrixData_16(struct MatrixData_16 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_20(self->_data);
}

static void Del_MatrixData_18(struct MatrixData_18 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_200(self->_data);
}

static void Del_StaticList_7(struct StaticList_7 *const self)
{
	Del_Object(&self->base);
	RemRef_MobilEyeSpace_1D_50(self->_items);
}

static void Del_SampleSet(struct SampleSet *const self)
{
	Del_Object(&self->base);
	RemRef_StaticListFactory_1(self->_listFactory);
	RemRef_UniformRandomGenerator(self->_randomGenerator);
	RemRef_StaticList_13(self->Samples);
}

static void Del_StaticList_13(struct StaticList_13 *const self)
{
	Del_Object(&self->base);
	RemRef_SampleProbabilPair_1D_50(self->_items);
}

static void Del_SampleProbabilityPair(struct SampleProbabilityPair *const self)
{
	Del_Object(&self->base);
	RemRef_MobilEyeSpace(self->Sample);
}

static void Del_StaticListEnumerator_3(struct StaticListEnumerator_3 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_7(self->_list);
}

static void Del_StaticListEnumerator_8(struct StaticListEnumerator_8 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_13(self->_list);
}

static void Del_ProbabilityGate(struct ProbabilityGate *const self)
{
	Del_GaussianGate(&self->base);
}

static void Del_GaussianGate(struct GaussianGate *const self)
{
	Del_Gate(&self->base);
}

static void Del_Gate(struct Gate *const self)
{
	Del_Object(&self->base);
	RemRef_SquaredMahalanobDistance(self->_metric);
}

static void Del_SquaredMahalanobisDistance(struct SquaredMahalanobisDistance *const self)
{
	Del_Object(&self->base);
}

static void Del_IMetric(struct IMetric *const self)
{
	Del_Object(&self->base);
}

static void Del_MultiplLocalNearestNeighbor(struct MultipleLocalNearestNeighbor *const self)
{
	Del_Object(&self->base);
	RemRef_StatIPDATracCollFactProv(self->_factoryProvider);
}

static void Del_IEnumerable(struct IEnumerable *const self)
{
	Del_Object(&self->base);
}

static void Del_IEnumerable_1(struct IEnumerable_1 *const self)
{
	Del_Object(&self->base);
}

static void Del_IEnumerable_2(struct IEnumerable_2 *const self)
{
	Del_Object(&self->base);
}

static void Del_IAssociationAlgorithm(struct IAssociationAlgorithm *const self)
{
	Del_Object(&self->base);
}

static void Del_MeasurementAssociation(struct MeasurementAssociation *const self)
{
	Del_Association(&self->base);
}

static void Del_Association(struct Association *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_5(self->_associations);
	RemRef_StaticList(self->_notAssociatedObjects);
	RemRef_MultipLocalNearesNeighbo(self->_associationAlgorithm);
	RemRef_StatIPDATracCollFactProv(self->_factoryProvider);
	RemRef_AssociationTable(self->AssociationTable);
	RemRef_StaticList_20(self->Objects1);
	RemRef_StaticList_6(self->Objects2);
}

static void Del_StaticListEnumerator_12(struct StaticListEnumerator_12 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_20(self->_list);
}

static void Del_StaticListEnumerator_2(struct StaticListEnumerator_2 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_6(self->_list);
}

static void Del_AssociationTable(struct AssociationTable *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_2D_15_40(self->_items);
}

static void Del_StaticListEnumerator_14(struct StaticListEnumerator_14 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_26(self->_list);
}

static void Del_MatrixData_7(struct MatrixData_7 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_4(self->_data);
}

static void Del_StaticList(struct StaticList *const self)
{
	Del_Object(&self->base);
	RemRef_int32_t_1D_40(self->_items);
}

static void Del_IAssociationTable(struct IAssociationTable *const self)
{
	Del_Object(&self->base);
}

static void Del_StaticList_5(struct StaticList_5 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_1D_15(self->_items);
}

static void Del_StaticListEnumerator(struct StaticListEnumerator *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList(self->_list);
}

static void Del_IEvaluable(struct IEvaluable *const self)
{
	Del_Object(&self->base);
}

static void Del_IEvaluable_1(struct IEvaluable_1 *const self)
{
	Del_Object(&self->base);
}

static void Del_IEvaluable_2(struct IEvaluable_2 *const self)
{
	Del_Object(&self->base);
}

static void Del_IPDA(struct IPDA *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_18(self->_hypotheses);
	RemRef_MeasurementSetLikelihood(self->_elementsLikelihood);
}

static void Del_CardinalitySpace(struct CardinalitySpace *const self)
{
	Del_Space_1(&self->base);
}

static void Del_StaticList_1(struct StaticList_1 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_40(self->_items);
}

static void Del_MeasurementSetLikelihood(struct MeasurementSetLikelihood *const self)
{
	Del_Object(&self->base);
	RemRef_ExistenceSpace(self->Condition);
}

static void Del_StaticList_18(struct StaticList_18 *const self)
{
	Del_Object(&self->base);
	RemRef_TruePositivHypothe_1D_41(self->_items);
}

static void Del_TruePositivesHypothesis(struct TruePositivesHypothesis *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_8(self->Elements);
}

static void Del_StaticList_8(struct StaticList_8 *const self)
{
	Del_Object(&self->base);
	RemRef_MobilEyeSpace_1D_1(self->_items);
}

static void Del_GaussianMixture(struct GaussianMixture *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_24(self->_gaussians);
	RemRef_StaticList_2(self->_weights);
}

static void Del_IListFactory(struct IListFactory *const self)
{
	Del_Object(&self->base);
}

static void Del_StaticList_24(struct StaticList_24 *const self)
{
	Del_Object(&self->base);
	RemRef_Gaussian_5_1D_41(self->_items);
}

static void Del_StaticList_2(struct StaticList_2 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_41(self->_items);
}

static void Del_StaticListEnumerator_10(struct StaticListEnumerator_10 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_18(self->_list);
}

static void Del_StaticListEnumerator_4(struct StaticListEnumerator_4 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_8(self->_list);
}

static void Del_MatrixData_17(struct MatrixData_17 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_20(self->_data);
}

static void Del_StaticListEnumerator_1(struct StaticListEnumerator_1 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_2(self->_list);
}

static void Del_InverseMobilEyeMeasureModel(struct InverseMobilEyeMeasurementModel *const self)
{
	Del_InverseCartesiMeasuremModel(&self->base);
}

static void Del_InverseCartesiMeasuremModel(struct InverseCartesianMeasuremenModel *const self)
{
	Del_Object(&self->base);
	RemRef_MobilEyeParameters(self->SensorParameters);
}

static void Del_StaticList_21(struct StaticList_21 *const self)
{
	Del_Object(&self->base);
	RemRef_Gaussian_3_1D_15(self->_items);
}

static void Del_Gaussian_3(struct Gaussian_3 *const self)
{
	Del_Object(&self->base);
	RemRef_PositiveDefiniteMatrix_5(self->covariance);
	RemRef_FrontRadarObjectSpace(self->Expectation);
}

static void Del_StaticList_17(struct StaticList_17 *const self)
{
	Del_Object(&self->base);
	RemRef_Matrix_13_1D_15(self->_items);
}

static void Del_Matrix_13(struct Matrix_13 *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_2(self->_matrix);
	RemRef_CASpace(self->EmptyRowSpace);
	RemRef_FrontRadarObjectSpace(self->EmptyColumnSpace);
	RemRef_MatrixData(self->CachedTranspose);
}

static void Del_StaticList_25(struct StaticList_25 *const self)
{
	Del_Object(&self->base);
	RemRef_MarginalEvaluabl_1_1D_15(self->_items);
}

static void Del_MarginalizedEvaluable_1(struct MarginalizedEvaluable_1 *const self)
{
	Del_Object(&self->base);
	RemRef_FronRadarObjecDetecModel(self->_conditionalDistribution);
	RemRef_SampleSet_1(self->_condition);
}

static void Del_FrontRadarObjectMeasurModel(struct FrontRadarObjectMeasuremenModel *const self)
{
	Del_CarMeaModWitVectVeloAndAcce(&self->base);
}

static void Del_CarMeaModWitVectVeloAndAcce(struct CartMeasModeWithVectVeloAndAcce *const self)
{
	Del_CartesianMeasurementModel_1(&self->base);
}

static void Del_CartesianMeasurementModel_1(struct CartesianMeasurementModel_1 *const self)
{
	Del_MeasurementModel_7(&self->base);
	RemRef_FrontRadarObjectParamete(self->SensorParameters);
}

static void Del_MeasurementModel_7(struct MeasurementModel_7 *const self)
{
	Del_MeasurementModel_3(&self->base);
}

static void Del_MeasurementModel_3(struct MeasurementModel_3 *const self)
{
	Del_Object(&self->base);
	RemRef_PositiveDefiniteMatrix_5(self->_measurementNoiseCovariance);
	RemRef_CASpace(self->Condition);
}

static void Del_PositiveDefiniteMatrix_5(struct PositiveDefiniteMatrix_5 *const self)
{
	Del_SquareMatrix_5(&self->base);
	RemRef_MatrixData_2(self->CachedInverse);
	RemRef_MatrixData_2(self->CachedCholeskyDecomposition);
}

static void Del_SquareMatrix_5(struct SquareMatrix_5 *const self)
{
	Del_Matrix_5(&self->base);
	RemRef_FrontRadarObjectSpace(self->EmptySpace);
}

static void Del_Matrix_5(struct Matrix_5 *const self)
{
	Del_Object(&self->base);
	RemRef_MatrixData_2(self->_matrix);
	RemRef_FrontRadarObjectSpace(self->EmptyRowSpace);
	RemRef_FrontRadarObjectSpace(self->EmptyColumnSpace);
}

static void Del_FrontRadarObjectDetectModel(struct FrontRadarObjectDetectionModel *const self)
{
	Del_PolygonDetectionModel(&self->base);
}

static void Del_PolygonDetectionModel(struct PolygonDetectionModel *const self)
{
	Del_SingleDetectionModel_1(&self->base);
	RemRef_FrontRadarObjectParamete(self->_parameters);
	RemRef_StaticList_3(self->_polygonPointsInVehicleFrame);
}

static void Del_SingleDetectionModel_1(struct SingleDetectionModel_1 *const self)
{
	Del_DetectionModel_1(&self->base);
}

static void Del_DetectionModel_1(struct DetectionModel_1 *const self)
{
	Del_Object(&self->base);
	RemRef_FrontRadarObjectSpace(self->Condition);
}

static void Del_StaticList_3(struct StaticList_3 *const self)
{
	Del_Object(&self->base);
	RemRef_Vector2D_1D_10(self->_items);
}

static void Del_MatrixData_19(struct MatrixData_19 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_250(self->_data);
}

static void Del_StaticList_10(struct StaticList_10 *const self)
{
	Del_Object(&self->base);
	RemRef_FronRadaObjecSpace_1D_50(self->_items);
}

static void Del_SampleSet_1(struct SampleSet_1 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticListFactory_1(self->_listFactory);
	RemRef_UniformRandomGenerator(self->_randomGenerator);
	RemRef_StaticList_14(self->Samples);
}

static void Del_StaticList_14(struct StaticList_14 *const self)
{
	Del_Object(&self->base);
	RemRef_SampleProbabPair_1_1D_50(self->_items);
}

static void Del_SampleProbabilityPair_1(struct SampleProbabilityPair_1 *const self)
{
	Del_Object(&self->base);
	RemRef_FrontRadarObjectSpace(self->Sample);
}

static void Del_StaticListEnumerator_6(struct StaticListEnumerator_6 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_10(self->_list);
}

static void Del_StaticListEnumerator_9(struct StaticListEnumerator_9 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_14(self->_list);
}

static void Del_ProbabilityGate_1(struct ProbabilityGate_1 *const self)
{
	Del_GaussianGate_1(&self->base);
}

static void Del_GaussianGate_1(struct GaussianGate_1 *const self)
{
	Del_Gate_1(&self->base);
}

static void Del_Gate_1(struct Gate_1 *const self)
{
	Del_Object(&self->base);
	RemRef_SquaredMahalanDistance_1(self->_metric);
}

static void Del_SquaredMahalanobiDistance_1(struct SquaredMahalanobisDistance_1 *const self)
{
	Del_Object(&self->base);
}

static void Del_IMetric_1(struct IMetric_1 *const self)
{
	Del_Object(&self->base);
}

static void Del_IEnumerable_3(struct IEnumerable_3 *const self)
{
	Del_Object(&self->base);
}

static void Del_IEnumerable_4(struct IEnumerable_4 *const self)
{
	Del_Object(&self->base);
}

static void Del_MeasurementAssociation_1(struct MeasurementAssociation_1 *const self)
{
	Del_Association_1(&self->base);
}

static void Del_Association_1(struct Association_1 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_5(self->_associations);
	RemRef_StaticList(self->_notAssociatedObjects);
	RemRef_MultipLocalNearesNeighbo(self->_associationAlgorithm);
	RemRef_StatIPDATracCollFactProv(self->_factoryProvider);
	RemRef_AssociationTable(self->AssociationTable);
	RemRef_StaticList_21(self->Objects1);
	RemRef_StaticList_9(self->Objects2);
}

static void Del_StaticListEnumerator_13(struct StaticListEnumerator_13 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_21(self->_list);
}

static void Del_StaticListEnumerator_5(struct StaticListEnumerator_5 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_9(self->_list);
}

static void Del_MatrixData_1(struct MatrixData_1 *const self)
{
	Del_Object(&self->base);
	RemRef_float64_t_1D_5(self->_data);
}

static void Del_IEvaluable_3(struct IEvaluable_3 *const self)
{
	Del_Object(&self->base);
}

static void Del_IPDA_1(struct IPDA_1 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_19(self->_hypotheses);
	RemRef_MeasurementSetLikelihood(self->_elementsLikelihood);
}

static void Del_StaticList_19(struct StaticList_19 *const self)
{
	Del_Object(&self->base);
	RemRef_TruePositiHypoth_1_1D_41(self->_items);
}

static void Del_TruePositivesHypothesis_1(struct TruePositivesHypothesis_1 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_11(self->Elements);
}

static void Del_StaticList_11(struct StaticList_11 *const self)
{
	Del_Object(&self->base);
	RemRef_FronRadarObjecSpace_1D_1(self->_items);
}

static void Del_StaticListEnumerator_11(struct StaticListEnumerator_11 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_19(self->_list);
}

static void Del_StaticListEnumerator_7(struct StaticListEnumerator_7 *const self)
{
	Del_Object(&self->base);
	RemRef_StaticList_11(self->_list);
}

static void Del_InvCartMeasModeWithVectVelo(struct InveCartMeasModelWithVectoVeloc *const self)
{
	Del_InverseCartesiMeasureModel(&self->base);
}

static void Del_InverseCartesiMeasureModel(struct InverseCartesianMeasuremeModel *const self)
{
	Del_Object(&self->base);
	RemRef_FrontRadarObjectParamete(self->SensorParameters);
}

void Bootstrap(void)
{
	int32_t i;

	{
		for (i = 0; i < RC_int32_t_1D_13; i++)
		{
			Res_int32_t_1D_13.Next[i] = &Res_int32_t_1D_13.Elements[i];
		}
		for (i = 0; i < RC_StaticList_27; i++)
		{
			Res_StaticList_27.Next[i] = &Res_StaticList_27.Elements[i];
		}
		for (i = 0; i < RC_TrackWithMeasurements; i++)
		{
			Res_TrackWithMeasurements.Next[i] = &Res_TrackWithMeasurements.Elements[i];
		}
		for (i = 0; i < RC_TrackWithMeasurements_1D_15; i++)
		{
			Res_TrackWithMeasurements_1D_15.Next[i] = &Res_TrackWithMeasurements_1D_15.Elements[i];
		}
		for (i = 0; i < RC_CASpace; i++)
		{
			Res_CASpace.Next[i] = &Res_CASpace.Elements[i];
		}
		for (i = 0; i < RC_int32_t_1D_0; i++)
		{
			Res_int32_t_1D_0.Next[i] = &Res_int32_t_1D_0.Elements[i];
		}
		for (i = 0; i < RC_int32_t_1D_1; i++)
		{
			Res_int32_t_1D_1.Next[i] = &Res_int32_t_1D_1.Elements[i];
		}
		for (i = 0; i < RC_Object; i++)
		{
			Res_Object.Next[i] = &Res_Object.Elements[i];
		}
		for (i = 0; i < RC_float64_t_1D_0; i++)
		{
			Res_float64_t_1D_0.Next[i] = &Res_float64_t_1D_0.Elements[i];
		}
		for (i = 0; i < RC_MatrixData; i++)
		{
			Res_MatrixData.Next[i] = &Res_MatrixData.Elements[i];
		}
		for (i = 0; i < RC_float64_t_1D_5; i++)
		{
			Res_float64_t_1D_5.Next[i] = &Res_float64_t_1D_5.Elements[i];
		}
		for (i = 0; i < RC_PositiveDefiniteMatrix_7; i++)
		{
			Res_PositiveDefiniteMatrix_7.Next[i] = &Res_PositiveDefiniteMatrix_7.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_2; i++)
		{
			Res_MatrixData_2.Next[i] = &Res_MatrixData_2.Elements[i];
		}
		for (i = 0; i < RC_float64_t_1D_25; i++)
		{
			Res_float64_t_1D_25.Next[i] = &Res_float64_t_1D_25.Elements[i];
		}
		for (i = 0; i < RC_LinearAlgebra; i++)
		{
			Res_LinearAlgebra.Next[i] = &Res_LinearAlgebra.Elements[i];
		}
		for (i = 0; i < RC_Gaussian_5; i++)
		{
			Res_Gaussian_5.Next[i] = &Res_Gaussian_5.Elements[i];
		}
		for (i = 0; i < RC_Existence; i++)
		{
			Res_Existence.Next[i] = &Res_Existence.Elements[i];
		}
		for (i = 0; i < RC_ExistenceSpace; i++)
		{
			Res_ExistenceSpace.Next[i] = &Res_ExistenceSpace.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_3; i++)
		{
			Res_MatrixData_3.Next[i] = &Res_MatrixData_3.Elements[i];
		}
		for (i = 0; i < RC_float64_t_1D_1; i++)
		{
			Res_float64_t_1D_1.Next[i] = &Res_float64_t_1D_1.Elements[i];
		}
		for (i = 0; i < RC_StaticListFactory; i++)
		{
			Res_StaticListFactory.Next[i] = &Res_StaticListFactory.Elements[i];
		}
		for (i = 0; i < RC_UniformRandomGenerator; i++)
		{
			Res_UniformRandomGenerator.Next[i] = &Res_UniformRandomGenerator.Elements[i];
		}
		for (i = 0; i < RC_Random; i++)
		{
			Res_Random.Next[i] = &Res_Random.Elements[i];
		}
		for (i = 0; i < RC_int32_t_1D_56; i++)
		{
			Res_int32_t_1D_56.Next[i] = &Res_int32_t_1D_56.Elements[i];
		}
		for (i = 0; i < RC_StaticList_15; i++)
		{
			Res_StaticList_15.Next[i] = &Res_StaticList_15.Elements[i];
		}
		for (i = 0; i < RC_SampleProbabilityPair_2; i++)
		{
			Res_SampleProbabilityPair_2.Next[i] = &Res_SampleProbabilityPair_2.Elements[i];
		}
		for (i = 0; i < RC_SampleProbabilityPair_2_1D_2; i++)
		{
			Res_SampleProbabilitPair_2_1D_2.Next[i] = &Res_SampleProbabilitPair_2_1D_2.Elements[i];
		}
		for (i = 0; i < RC_Obstacle; i++)
		{
			Res_Obstacle.Next[i] = &Res_Obstacle.Elements[i];
		}
		for (i = 0; i < RC_Object_1; i++)
		{
			Res_Object_1.Next[i] = &Res_Object_1.Elements[i];
		}
		for (i = 0; i < RC_StaticList_12; i++)
		{
			Res_StaticList_12.Next[i] = &Res_StaticList_12.Elements[i];
		}
		for (i = 0; i < RC_float64_t_1D_3; i++)
		{
			Res_float64_t_1D_3.Next[i] = &Res_float64_t_1D_3.Elements[i];
		}
		for (i = 0; i < RC_RadarSpace_1D_15; i++)
		{
			Res_RadarSpace_1D_15.Next[i] = &Res_RadarSpace_1D_15.Elements[i];
		}
		for (i = 0; i < RC_RadarSpace; i++)
		{
			Res_RadarSpace.Next[i] = &Res_RadarSpace.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_4; i++)
		{
			Res_MatrixData_4.Next[i] = &Res_MatrixData_4.Elements[i];
		}
		for (i = 0; i < RC_StaticList_4; i++)
		{
			Res_StaticList_4.Next[i] = &Res_StaticList_4.Elements[i];
		}
		for (i = 0; i < RC_Obstacle_1D_40; i++)
		{
			Res_Obstacle_1D_40.Next[i] = &Res_Obstacle_1D_40.Elements[i];
		}
		for (i = 0; i < RC_StaticList_6; i++)
		{
			Res_StaticList_6.Next[i] = &Res_StaticList_6.Elements[i];
		}
		for (i = 0; i < RC_float64_t_1D_4; i++)
		{
			Res_float64_t_1D_4.Next[i] = &Res_float64_t_1D_4.Elements[i];
		}
		for (i = 0; i < RC_MobilEyeSpace_1D_40; i++)
		{
			Res_MobilEyeSpace_1D_40.Next[i] = &Res_MobilEyeSpace_1D_40.Elements[i];
		}
		for (i = 0; i < RC_MobilEyeSpace; i++)
		{
			Res_MobilEyeSpace.Next[i] = &Res_MobilEyeSpace.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_5; i++)
		{
			Res_MatrixData_5.Next[i] = &Res_MatrixData_5.Elements[i];
		}
		for (i = 0; i < RC_StaticList_9; i++)
		{
			Res_StaticList_9.Next[i] = &Res_StaticList_9.Elements[i];
		}
		for (i = 0; i < RC_FrontRadarObjectSpace; i++)
		{
			Res_FrontRadarObjectSpace.Next[i] = &Res_FrontRadarObjectSpace.Elements[i];
		}
		for (i = 0; i < RC_FrontRadarObjectSpace_1D_40; i++)
		{
			Res_FrontRadarObjectSpace_1D_40.Next[i] = &Res_FrontRadarObjectSpace_1D_40.Elements[i];
		}
		for (i = 0; i < RC_Measure_2; i++)
		{
			Res_Measure_2.Next[i] = &Res_Measure_2.Elements[i];
		}
		for (i = 0; i < RC_Measure_3; i++)
		{
			Res_Measure_3.Next[i] = &Res_Measure_3.Elements[i];
		}
		for (i = 0; i < RC_Tracking; i++)
		{
			Res_Tracking.Next[i] = &Res_Tracking.Elements[i];
		}
		for (i = 0; i < RC_SensorProperties; i++)
		{
			Res_SensorProperties.Next[i] = &Res_SensorProperties.Elements[i];
		}
		for (i = 0; i < RC_FrontRadarNearParameters; i++)
		{
			Res_FrontRadarNearParameters.Next[i] = &Res_FrontRadarNearParameters.Elements[i];
		}
		for (i = 0; i < RC_FrontRadarFarParameters; i++)
		{
			Res_FrontRadarFarParameters.Next[i] = &Res_FrontRadarFarParameters.Elements[i];
		}
		for (i = 0; i < RC_MobilEyeParameters; i++)
		{
			Res_MobilEyeParameters.Next[i] = &Res_MobilEyeParameters.Elements[i];
		}
		for (i = 0; i < RC_Vector2D_1D_10; i++)
		{
			Res_Vector2D_1D_10.Next[i] = &Res_Vector2D_1D_10.Elements[i];
		}
		for (i = 0; i < RC_FrontRadarObjectParameters; i++)
		{
			Res_FrontRadarObjectParameters.Next[i] = &Res_FrontRadarObjectParameters.Elements[i];
		}
		for (i = 0; i < RC_EgoMotionFilter; i++)
		{
			Res_EgoMotionFilter.Next[i] = &Res_EgoMotionFilter.Elements[i];
		}
		for (i = 0; i < RC_float64_t_1D_2; i++)
		{
			Res_float64_t_1D_2.Next[i] = &Res_float64_t_1D_2.Elements[i];
		}
		for (i = 0; i < RC_PositiveDefiniteMatrix_4; i++)
		{
			Res_PositiveDefiniteMatrix_4.Next[i] = &Res_PositiveDefiniteMatrix_4.Elements[i];
		}
		for (i = 0; i < RC_CTRAErrorSpace; i++)
		{
			Res_CTRAErrorSpace.Next[i] = &Res_CTRAErrorSpace.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_8; i++)
		{
			Res_MatrixData_8.Next[i] = &Res_MatrixData_8.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_6; i++)
		{
			Res_MatrixData_6.Next[i] = &Res_MatrixData_6.Elements[i];
		}
		for (i = 0; i < RC_CTRASpace; i++)
		{
			Res_CTRASpace.Next[i] = &Res_CTRASpace.Elements[i];
		}
	}
	{
		for (i = 0; i < RC_MatrixData_9; i++)
		{
			Res_MatrixData_9.Next[i] = &Res_MatrixData_9.Elements[i];
		}
		for (i = 0; i < RC_float64_t_1D_6; i++)
		{
			Res_float64_t_1D_6.Next[i] = &Res_float64_t_1D_6.Elements[i];
		}
		for (i = 0; i < RC_CTRAModel; i++)
		{
			Res_CTRAModel.Next[i] = &Res_CTRAModel.Elements[i];
		}
		for (i = 0; i < RC_PositiveDefiniteMatrix; i++)
		{
			Res_PositiveDefiniteMatrix.Next[i] = &Res_PositiveDefiniteMatrix.Elements[i];
		}
		for (i = 0; i < RC_VelocitySpace; i++)
		{
			Res_VelocitySpace.Next[i] = &Res_VelocitySpace.Elements[i];
		}
		for (i = 0; i < RC_VelocityMeasurementModel; i++)
		{
			Res_VelocityMeasurementModel.Next[i] = &Res_VelocityMeasurementModel.Elements[i];
		}
		for (i = 0; i < RC_PositiveDefiniteMatrix_1; i++)
		{
			Res_PositiveDefiniteMatrix_1.Next[i] = &Res_PositiveDefiniteMatrix_1.Elements[i];
		}
		for (i = 0; i < RC_YawRateSpace; i++)
		{
			Res_YawRateSpace.Next[i] = &Res_YawRateSpace.Elements[i];
		}
		for (i = 0; i < RC_YawRateMeasurementModel; i++)
		{
			Res_YawRateMeasurementModel.Next[i] = &Res_YawRateMeasurementModel.Elements[i];
		}
		for (i = 0; i < RC_Gaussian_4; i++)
		{
			Res_Gaussian_4.Next[i] = &Res_Gaussian_4.Elements[i];
		}
		for (i = 0; i < RC_PositiveDefiniteMatrix_6; i++)
		{
			Res_PositiveDefiniteMatrix_6.Next[i] = &Res_PositiveDefiniteMatrix_6.Elements[i];
		}
		for (i = 0; i < RC_float64_t_1D_36; i++)
		{
			Res_float64_t_1D_36.Next[i] = &Res_float64_t_1D_36.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_11; i++)
		{
			Res_MatrixData_11.Next[i] = &Res_MatrixData_11.Elements[i];
		}
		for (i = 0; i < RC_StaticListEnumerator_15; i++)
		{
			Res_StaticListEnumerator_15.Next[i] = &Res_StaticListEnumerator_15.Elements[i];
		}
		for (i = 0; i < RC_SquareMatrix_6; i++)
		{
			Res_SquareMatrix_6.Next[i] = &Res_SquareMatrix_6.Elements[i];
		}
		for (i = 0; i < RC_Matrix_7; i++)
		{
			Res_Matrix_7.Next[i] = &Res_Matrix_7.Elements[i];
		}
		for (i = 0; i < RC_float64_t_1D_12; i++)
		{
			Res_float64_t_1D_12.Next[i] = &Res_float64_t_1D_12.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_12; i++)
		{
			Res_MatrixData_12.Next[i] = &Res_MatrixData_12.Elements[i];
		}
		for (i = 0; i < RC_Matrix_8; i++)
		{
			Res_Matrix_8.Next[i] = &Res_Matrix_8.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_10; i++)
		{
			Res_MatrixData_10.Next[i] = &Res_MatrixData_10.Elements[i];
		}
		for (i = 0; i < RC_Gaussian; i++)
		{
			Res_Gaussian.Next[i] = &Res_Gaussian.Elements[i];
		}
		for (i = 0; i < RC_Matrix_9; i++)
		{
			Res_Matrix_9.Next[i] = &Res_Matrix_9.Elements[i];
		}
		for (i = 0; i < RC_Gaussian_1; i++)
		{
			Res_Gaussian_1.Next[i] = &Res_Gaussian_1.Elements[i];
		}
		for (i = 0; i < RC_StaticListFactory_1; i++)
		{
			Res_StaticListFactory_1.Next[i] = &Res_StaticListFactory_1.Elements[i];
		}
		for (i = 0; i < RC_StatIPDATrackColleFactoProvi; i++)
		{
			Res_StatIPDATracColleFactoProvi.Next[i] = &Res_StatIPDATracColleFactoProvi.Elements[i];
		}
		for (i = 0; i < RC_StaticListFactory_2; i++)
		{
			Res_StaticListFactory_2.Next[i] = &Res_StaticListFactory_2.Elements[i];
		}
		for (i = 0; i < RC_StaticListFactory_3; i++)
		{
			Res_StaticListFactory_3.Next[i] = &Res_StaticListFactory_3.Elements[i];
		}
		for (i = 0; i < RC_StaticAssociatioTableFactory; i++)
		{
			Res_StaticAssociatiTableFactory.Next[i] = &Res_StaticAssociatiTableFactory.Elements[i];
		}
		for (i = 0; i < RC_StaticListFactory_4; i++)
		{
			Res_StaticListFactory_4.Next[i] = &Res_StaticListFactory_4.Elements[i];
		}
		for (i = 0; i < RC_StaticListFactory_5; i++)
		{
			Res_StaticListFactory_5.Next[i] = &Res_StaticListFactory_5.Elements[i];
		}
		for (i = 0; i < RC_StaticList_23; i++)
		{
			Res_StaticList_23.Next[i] = &Res_StaticList_23.Elements[i];
		}
		for (i = 0; i < RC_Gaussian_5_1D_15; i++)
		{
			Res_Gaussian_5_1D_15.Next[i] = &Res_Gaussian_5_1D_15.Elements[i];
		}
		for (i = 0; i < RC_StaticList_20; i++)
		{
			Res_StaticList_20.Next[i] = &Res_StaticList_20.Elements[i];
		}
		for (i = 0; i < RC_Gaussian_2; i++)
		{
			Res_Gaussian_2.Next[i] = &Res_Gaussian_2.Elements[i];
		}
		for (i = 0; i < RC_Gaussian_2_1D_15; i++)
		{
			Res_Gaussian_2_1D_15.Next[i] = &Res_Gaussian_2_1D_15.Elements[i];
		}
		for (i = 0; i < RC_StaticList_16; i++)
		{
			Res_StaticList_16.Next[i] = &Res_StaticList_16.Elements[i];
		}
		for (i = 0; i < RC_Matrix_11; i++)
		{
			Res_Matrix_11.Next[i] = &Res_Matrix_11.Elements[i];
		}
		for (i = 0; i < RC_Matrix_11_1D_15; i++)
		{
			Res_Matrix_11_1D_15.Next[i] = &Res_Matrix_11_1D_15.Elements[i];
		}
		for (i = 0; i < RC_StaticList_26; i++)
		{
			Res_StaticList_26.Next[i] = &Res_StaticList_26.Elements[i];
		}
		for (i = 0; i < RC_Existence_1D_15; i++)
		{
			Res_Existence_1D_15.Next[i] = &Res_Existence_1D_15.Elements[i];
		}
		for (i = 0; i < RC_StaticList_22; i++)
		{
			Res_StaticList_22.Next[i] = &Res_StaticList_22.Elements[i];
		}
		for (i = 0; i < RC_MarginalizedEvaluable; i++)
		{
			Res_MarginalizedEvaluable.Next[i] = &Res_MarginalizedEvaluable.Elements[i];
		}
		for (i = 0; i < RC_MarginalizedEvaluable_1D_15; i++)
		{
			Res_MarginalizedEvaluable_1D_15.Next[i] = &Res_MarginalizedEvaluable_1D_15.Elements[i];
		}
		for (i = 0; i < RC_PositiveDefiniteMatrix_2; i++)
		{
			Res_PositiveDefiniteMatrix_2.Next[i] = &Res_PositiveDefiniteMatrix_2.Elements[i];
		}
		for (i = 0; i < RC_CAErrorSpace; i++)
		{
			Res_CAErrorSpace.Next[i] = &Res_CAErrorSpace.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_13; i++)
		{
			Res_MatrixData_13.Next[i] = &Res_MatrixData_13.Elements[i];
		}
		for (i = 0; i < RC_float64_t_1D_9; i++)
		{
			Res_float64_t_1D_9.Next[i] = &Res_float64_t_1D_9.Elements[i];
		}
		for (i = 0; i < RC_CAModel; i++)
		{
			Res_CAModel.Next[i] = &Res_CAModel.Elements[i];
		}
		for (i = 0; i < RC_PersistenceModel; i++)
		{
			Res_PersistenceModel.Next[i] = &Res_PersistenceModel.Elements[i];
		}
		for (i = 0; i < RC_MobilEyeDetectionModel; i++)
		{
			Res_MobilEyeDetectionModel.Next[i] = &Res_MobilEyeDetectionModel.Elements[i];
		}
		for (i = 0; i < RC_EgoMotionCompensation; i++)
		{
			Res_EgoMotionCompensation.Next[i] = &Res_EgoMotionCompensation.Elements[i];
		}
		for (i = 0; i < RC_SquareMatrix_7; i++)
		{
			Res_SquareMatrix_7.Next[i] = &Res_SquareMatrix_7.Elements[i];
		}
		for (i = 0; i < RC_Matrix_12; i++)
		{
			Res_Matrix_12.Next[i] = &Res_Matrix_12.Elements[i];
		}
		for (i = 0; i < RC_float64_t_1D_15; i++)
		{
			Res_float64_t_1D_15.Next[i] = &Res_float64_t_1D_15.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_14; i++)
		{
			Res_MatrixData_14.Next[i] = &Res_MatrixData_14.Elements[i];
		}
		for (i = 0; i < RC_TwoPointDistribution; i++)
		{
			Res_TwoPointDistribution.Next[i] = &Res_TwoPointDistribution.Elements[i];
		}
		for (i = 0; i < RC_Type; i++)
		{
			Res_Type.Next[i] = &Res_Type.Elements[i];
		}
		for (i = 0; i < RC_MobilEyeMeasurementModel; i++)
		{
			Res_MobilEyeMeasurementModel.Next[i] = &Res_MobilEyeMeasurementModel.Elements[i];
		}
		for (i = 0; i < RC_PositiveDefiniteMatrix_3; i++)
		{
			Res_PositiveDefiniteMatrix_3.Next[i] = &Res_PositiveDefiniteMatrix_3.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_15; i++)
		{
			Res_MatrixData_15.Next[i] = &Res_MatrixData_15.Elements[i];
		}
	}
	{
		for (i = 0; i < RC_float64_t_1D_16; i++)
		{
			Res_float64_t_1D_16.Next[i] = &Res_float64_t_1D_16.Elements[i];
		}
		for (i = 0; i < RC_float64_t_1D_20; i++)
		{
			Res_float64_t_1D_20.Next[i] = &Res_float64_t_1D_20.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_16; i++)
		{
			Res_MatrixData_16.Next[i] = &Res_MatrixData_16.Elements[i];
		}
		for (i = 0; i < RC_SquareMatrix_3; i++)
		{
			Res_SquareMatrix_3.Next[i] = &Res_SquareMatrix_3.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_18; i++)
		{
			Res_MatrixData_18.Next[i] = &Res_MatrixData_18.Elements[i];
		}
		for (i = 0; i < RC_float64_t_1D_200; i++)
		{
			Res_float64_t_1D_200.Next[i] = &Res_float64_t_1D_200.Elements[i];
		}
		for (i = 0; i < RC_StaticList_7; i++)
		{
			Res_StaticList_7.Next[i] = &Res_StaticList_7.Elements[i];
		}
		for (i = 0; i < RC_MobilEyeSpace_1D_50; i++)
		{
			Res_MobilEyeSpace_1D_50.Next[i] = &Res_MobilEyeSpace_1D_50.Elements[i];
		}
		for (i = 0; i < RC_SampleSet; i++)
		{
			Res_SampleSet.Next[i] = &Res_SampleSet.Elements[i];
		}
		for (i = 0; i < RC_StaticList_13; i++)
		{
			Res_StaticList_13.Next[i] = &Res_StaticList_13.Elements[i];
		}
		for (i = 0; i < RC_SampleProbabilityPair; i++)
		{
			Res_SampleProbabilityPair.Next[i] = &Res_SampleProbabilityPair.Elements[i];
		}
		for (i = 0; i < RC_SampleProbabilityPair_1D_50; i++)
		{
			Res_SampleProbabilityPair_1D_50.Next[i] = &Res_SampleProbabilityPair_1D_50.Elements[i];
		}
		for (i = 0; i < RC_StaticListEnumerator_3; i++)
		{
			Res_StaticListEnumerator_3.Next[i] = &Res_StaticListEnumerator_3.Elements[i];
		}
		for (i = 0; i < RC_StaticListEnumerator_8; i++)
		{
			Res_StaticListEnumerator_8.Next[i] = &Res_StaticListEnumerator_8.Elements[i];
		}
		for (i = 0; i < RC_ProbabilityGate; i++)
		{
			Res_ProbabilityGate.Next[i] = &Res_ProbabilityGate.Elements[i];
		}
		for (i = 0; i < RC_SquaredMahalanobisDistance; i++)
		{
			Res_SquaredMahalanobisDistance.Next[i] = &Res_SquaredMahalanobisDistance.Elements[i];
		}
		for (i = 0; i < RC_IMetric; i++)
		{
			Res_IMetric.Next[i] = &Res_IMetric.Elements[i];
		}
		for (i = 0; i < RC_MultipleLocalNearestNeighbor; i++)
		{
			Res_MultiplLocalNearestNeighbor.Next[i] = &Res_MultiplLocalNearestNeighbor.Elements[i];
		}
		for (i = 0; i < RC_IEnumerable; i++)
		{
			Res_IEnumerable.Next[i] = &Res_IEnumerable.Elements[i];
		}
		for (i = 0; i < RC_IEnumerable_1; i++)
		{
			Res_IEnumerable_1.Next[i] = &Res_IEnumerable_1.Elements[i];
		}
		for (i = 0; i < RC_IEnumerable_2; i++)
		{
			Res_IEnumerable_2.Next[i] = &Res_IEnumerable_2.Elements[i];
		}
		for (i = 0; i < RC_IAssociationAlgorithm; i++)
		{
			Res_IAssociationAlgorithm.Next[i] = &Res_IAssociationAlgorithm.Elements[i];
		}
		for (i = 0; i < RC_MeasurementAssociation; i++)
		{
			Res_MeasurementAssociation.Next[i] = &Res_MeasurementAssociation.Elements[i];
		}
		for (i = 0; i < RC_StaticListEnumerator_12; i++)
		{
			Res_StaticListEnumerator_12.Next[i] = &Res_StaticListEnumerator_12.Elements[i];
		}
		for (i = 0; i < RC_StaticListEnumerator_2; i++)
		{
			Res_StaticListEnumerator_2.Next[i] = &Res_StaticListEnumerator_2.Elements[i];
		}
		for (i = 0; i < RC_AssociationTable; i++)
		{
			Res_AssociationTable.Next[i] = &Res_AssociationTable.Elements[i];
		}
		for (i = 0; i < RC_float64_t_2D_15_40; i++)
		{
			Res_float64_t_2D_15_40.Next[i] = &Res_float64_t_2D_15_40.Elements[i];
		}
		for (i = 0; i < RC_StaticListEnumerator_14; i++)
		{
			Res_StaticListEnumerator_14.Next[i] = &Res_StaticListEnumerator_14.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_7; i++)
		{
			Res_MatrixData_7.Next[i] = &Res_MatrixData_7.Elements[i];
		}
		for (i = 0; i < RC_int32_t_1D_4; i++)
		{
			Res_int32_t_1D_4.Next[i] = &Res_int32_t_1D_4.Elements[i];
		}
		for (i = 0; i < RC_int32_t_1D_40; i++)
		{
			Res_int32_t_1D_40.Next[i] = &Res_int32_t_1D_40.Elements[i];
		}
		for (i = 0; i < RC_IAssociationTable; i++)
		{
			Res_IAssociationTable.Next[i] = &Res_IAssociationTable.Elements[i];
		}
		for (i = 0; i < RC_StaticList_5; i++)
		{
			Res_StaticList_5.Next[i] = &Res_StaticList_5.Elements[i];
		}
		for (i = 0; i < RC_StaticList_1D_15; i++)
		{
			Res_StaticList_1D_15.Next[i] = &Res_StaticList_1D_15.Elements[i];
		}
		for (i = 0; i < RC_StaticList; i++)
		{
			Res_StaticList.Next[i] = &Res_StaticList.Elements[i];
		}
		for (i = 0; i < RC_StaticListEnumerator; i++)
		{
			Res_StaticListEnumerator.Next[i] = &Res_StaticListEnumerator.Elements[i];
		}
		for (i = 0; i < RC_IEvaluable; i++)
		{
			Res_IEvaluable.Next[i] = &Res_IEvaluable.Elements[i];
		}
		for (i = 0; i < RC_IEvaluable_1; i++)
		{
			Res_IEvaluable_1.Next[i] = &Res_IEvaluable_1.Elements[i];
		}
		for (i = 0; i < RC_IEvaluable_2; i++)
		{
			Res_IEvaluable_2.Next[i] = &Res_IEvaluable_2.Elements[i];
		}
		for (i = 0; i < RC_IPDA; i++)
		{
			Res_IPDA.Next[i] = &Res_IPDA.Elements[i];
		}
		for (i = 0; i < RC_CardinalitySpace; i++)
		{
			Res_CardinalitySpace.Next[i] = &Res_CardinalitySpace.Elements[i];
		}
		for (i = 0; i < RC_StaticList_1; i++)
		{
			Res_StaticList_1.Next[i] = &Res_StaticList_1.Elements[i];
		}
		for (i = 0; i < RC_float64_t_1D_40; i++)
		{
			Res_float64_t_1D_40.Next[i] = &Res_float64_t_1D_40.Elements[i];
		}
		for (i = 0; i < RC_MeasurementSetLikelihood; i++)
		{
			Res_MeasurementSetLikelihood.Next[i] = &Res_MeasurementSetLikelihood.Elements[i];
		}
		for (i = 0; i < RC_StaticList_18; i++)
		{
			Res_StaticList_18.Next[i] = &Res_StaticList_18.Elements[i];
		}
		for (i = 0; i < RC_TruePositivesHypothesis; i++)
		{
			Res_TruePositivesHypothesis.Next[i] = &Res_TruePositivesHypothesis.Elements[i];
		}
		for (i = 0; i < RC_TruePositivesHypothesi_1D_41; i++)
		{
			Res_TruePositiveHypothesi_1D_41.Next[i] = &Res_TruePositiveHypothesi_1D_41.Elements[i];
		}
		for (i = 0; i < RC_StaticList_8; i++)
		{
			Res_StaticList_8.Next[i] = &Res_StaticList_8.Elements[i];
		}
		for (i = 0; i < RC_MobilEyeSpace_1D_1; i++)
		{
			Res_MobilEyeSpace_1D_1.Next[i] = &Res_MobilEyeSpace_1D_1.Elements[i];
		}
		for (i = 0; i < RC_GaussianMixture; i++)
		{
			Res_GaussianMixture.Next[i] = &Res_GaussianMixture.Elements[i];
		}
		for (i = 0; i < RC_IListFactory; i++)
		{
			Res_IListFactory.Next[i] = &Res_IListFactory.Elements[i];
		}
		for (i = 0; i < RC_StaticList_24; i++)
		{
			Res_StaticList_24.Next[i] = &Res_StaticList_24.Elements[i];
		}
		for (i = 0; i < RC_Gaussian_5_1D_41; i++)
		{
			Res_Gaussian_5_1D_41.Next[i] = &Res_Gaussian_5_1D_41.Elements[i];
		}
		for (i = 0; i < RC_StaticList_2; i++)
		{
			Res_StaticList_2.Next[i] = &Res_StaticList_2.Elements[i];
		}
		for (i = 0; i < RC_float64_t_1D_41; i++)
		{
			Res_float64_t_1D_41.Next[i] = &Res_float64_t_1D_41.Elements[i];
		}
		for (i = 0; i < RC_StaticListEnumerator_10; i++)
		{
			Res_StaticListEnumerator_10.Next[i] = &Res_StaticListEnumerator_10.Elements[i];
		}
		for (i = 0; i < RC_StaticListEnumerator_4; i++)
		{
			Res_StaticListEnumerator_4.Next[i] = &Res_StaticListEnumerator_4.Elements[i];
		}
		for (i = 0; i < RC_Space; i++)
		{
			Res_Space.Next[i] = &Res_Space.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_17; i++)
		{
			Res_MatrixData_17.Next[i] = &Res_MatrixData_17.Elements[i];
		}
		for (i = 0; i < RC_StaticListEnumerator_1; i++)
		{
			Res_StaticListEnumerator_1.Next[i] = &Res_StaticListEnumerator_1.Elements[i];
		}
	}
	{
		for (i = 0; i < RC_InverseMobilEyeMeasuremModel; i++)
		{
			Res_InverseMobilEyeMeasureModel.Next[i] = &Res_InverseMobilEyeMeasureModel.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_2_1D_1; i++)
		{
			Res_MatrixData_2_1D_1.Next[i] = &Res_MatrixData_2_1D_1.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_1D_0; i++)
		{
			Res_MatrixData_1D_0.Next[i] = &Res_MatrixData_1D_0.Elements[i];
		}
		for (i = 0; i < RC_StaticList_21; i++)
		{
			Res_StaticList_21.Next[i] = &Res_StaticList_21.Elements[i];
		}
		for (i = 0; i < RC_Gaussian_3; i++)
		{
			Res_Gaussian_3.Next[i] = &Res_Gaussian_3.Elements[i];
		}
		for (i = 0; i < RC_Gaussian_3_1D_15; i++)
		{
			Res_Gaussian_3_1D_15.Next[i] = &Res_Gaussian_3_1D_15.Elements[i];
		}
		for (i = 0; i < RC_StaticList_17; i++)
		{
			Res_StaticList_17.Next[i] = &Res_StaticList_17.Elements[i];
		}
		for (i = 0; i < RC_Matrix_13; i++)
		{
			Res_Matrix_13.Next[i] = &Res_Matrix_13.Elements[i];
		}
		for (i = 0; i < RC_Matrix_13_1D_15; i++)
		{
			Res_Matrix_13_1D_15.Next[i] = &Res_Matrix_13_1D_15.Elements[i];
		}
		for (i = 0; i < RC_StaticList_25; i++)
		{
			Res_StaticList_25.Next[i] = &Res_StaticList_25.Elements[i];
		}
		for (i = 0; i < RC_MarginalizedEvaluable_1; i++)
		{
			Res_MarginalizedEvaluable_1.Next[i] = &Res_MarginalizedEvaluable_1.Elements[i];
		}
		for (i = 0; i < RC_MarginalizeEvaluable_1_1D_15; i++)
		{
			Res_MarginalizEvaluable_1_1D_15.Next[i] = &Res_MarginalizEvaluable_1_1D_15.Elements[i];
		}
		for (i = 0; i < RC_FrontRadarObjectMeasureModel; i++)
		{
			Res_FrontRadarObjectMeasurModel.Next[i] = &Res_FrontRadarObjectMeasurModel.Elements[i];
		}
		for (i = 0; i < RC_PositiveDefiniteMatrix_5; i++)
		{
			Res_PositiveDefiniteMatrix_5.Next[i] = &Res_PositiveDefiniteMatrix_5.Elements[i];
		}
		for (i = 0; i < RC_FrontRadarObjectDetectiModel; i++)
		{
			Res_FrontRadarObjectDetectModel.Next[i] = &Res_FrontRadarObjectDetectModel.Elements[i];
		}
		for (i = 0; i < RC_StaticList_3; i++)
		{
			Res_StaticList_3.Next[i] = &Res_StaticList_3.Elements[i];
		}
		for (i = 0; i < RC_SquareMatrix_5; i++)
		{
			Res_SquareMatrix_5.Next[i] = &Res_SquareMatrix_5.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_19; i++)
		{
			Res_MatrixData_19.Next[i] = &Res_MatrixData_19.Elements[i];
		}
		for (i = 0; i < RC_float64_t_1D_250; i++)
		{
			Res_float64_t_1D_250.Next[i] = &Res_float64_t_1D_250.Elements[i];
		}
		for (i = 0; i < RC_StaticList_10; i++)
		{
			Res_StaticList_10.Next[i] = &Res_StaticList_10.Elements[i];
		}
		for (i = 0; i < RC_FrontRadarObjectSpace_1D_50; i++)
		{
			Res_FrontRadarObjectSpace_1D_50.Next[i] = &Res_FrontRadarObjectSpace_1D_50.Elements[i];
		}
		for (i = 0; i < RC_SampleSet_1; i++)
		{
			Res_SampleSet_1.Next[i] = &Res_SampleSet_1.Elements[i];
		}
		for (i = 0; i < RC_StaticList_14; i++)
		{
			Res_StaticList_14.Next[i] = &Res_StaticList_14.Elements[i];
		}
		for (i = 0; i < RC_SampleProbabilityPair_1; i++)
		{
			Res_SampleProbabilityPair_1.Next[i] = &Res_SampleProbabilityPair_1.Elements[i];
		}
		for (i = 0; i < RC_SampleProbabilitPair_1_1D_50; i++)
		{
			Res_SampleProbabiliPair_1_1D_50.Next[i] = &Res_SampleProbabiliPair_1_1D_50.Elements[i];
		}
		for (i = 0; i < RC_StaticListEnumerator_6; i++)
		{
			Res_StaticListEnumerator_6.Next[i] = &Res_StaticListEnumerator_6.Elements[i];
		}
		for (i = 0; i < RC_StaticListEnumerator_9; i++)
		{
			Res_StaticListEnumerator_9.Next[i] = &Res_StaticListEnumerator_9.Elements[i];
		}
		for (i = 0; i < RC_ProbabilityGate_1; i++)
		{
			Res_ProbabilityGate_1.Next[i] = &Res_ProbabilityGate_1.Elements[i];
		}
		for (i = 0; i < RC_SquaredMahalanobisDistance_1; i++)
		{
			Res_SquaredMahalanobiDistance_1.Next[i] = &Res_SquaredMahalanobiDistance_1.Elements[i];
		}
		for (i = 0; i < RC_IMetric_1; i++)
		{
			Res_IMetric_1.Next[i] = &Res_IMetric_1.Elements[i];
		}
		for (i = 0; i < RC_IEnumerable_3; i++)
		{
			Res_IEnumerable_3.Next[i] = &Res_IEnumerable_3.Elements[i];
		}
		for (i = 0; i < RC_IEnumerable_4; i++)
		{
			Res_IEnumerable_4.Next[i] = &Res_IEnumerable_4.Elements[i];
		}
		for (i = 0; i < RC_MeasurementAssociation_1; i++)
		{
			Res_MeasurementAssociation_1.Next[i] = &Res_MeasurementAssociation_1.Elements[i];
		}
		for (i = 0; i < RC_StaticListEnumerator_13; i++)
		{
			Res_StaticListEnumerator_13.Next[i] = &Res_StaticListEnumerator_13.Elements[i];
		}
		for (i = 0; i < RC_StaticListEnumerator_5; i++)
		{
			Res_StaticListEnumerator_5.Next[i] = &Res_StaticListEnumerator_5.Elements[i];
		}
		for (i = 0; i < RC_MatrixData_1; i++)
		{
			Res_MatrixData_1.Next[i] = &Res_MatrixData_1.Elements[i];
		}
		for (i = 0; i < RC_int32_t_1D_5; i++)
		{
			Res_int32_t_1D_5.Next[i] = &Res_int32_t_1D_5.Elements[i];
		}
		for (i = 0; i < RC_IEvaluable_3; i++)
		{
			Res_IEvaluable_3.Next[i] = &Res_IEvaluable_3.Elements[i];
		}
		for (i = 0; i < RC_IPDA_1; i++)
		{
			Res_IPDA_1.Next[i] = &Res_IPDA_1.Elements[i];
		}
		for (i = 0; i < RC_StaticList_19; i++)
		{
			Res_StaticList_19.Next[i] = &Res_StaticList_19.Elements[i];
		}
		for (i = 0; i < RC_TruePositivesHypothesis_1; i++)
		{
			Res_TruePositivesHypothesis_1.Next[i] = &Res_TruePositivesHypothesis_1.Elements[i];
		}
		for (i = 0; i < RC_TruePositiveHypothes_1_1D_41; i++)
		{
			Res_TruePositivHypothes_1_1D_41.Next[i] = &Res_TruePositivHypothes_1_1D_41.Elements[i];
		}
		for (i = 0; i < RC_StaticList_11; i++)
		{
			Res_StaticList_11.Next[i] = &Res_StaticList_11.Elements[i];
		}
		for (i = 0; i < RC_FrontRadarObjectSpace_1D_1; i++)
		{
			Res_FrontRadarObjectSpace_1D_1.Next[i] = &Res_FrontRadarObjectSpace_1D_1.Elements[i];
		}
		for (i = 0; i < RC_StaticListEnumerator_11; i++)
		{
			Res_StaticListEnumerator_11.Next[i] = &Res_StaticListEnumerator_11.Elements[i];
		}
		for (i = 0; i < RC_StaticListEnumerator_7; i++)
		{
			Res_StaticListEnumerator_7.Next[i] = &Res_StaticListEnumerator_7.Elements[i];
		}
		for (i = 0; i < RC_InveCartMeasModeWithVectVelo; i++)
		{
			Res_InvCartMeasModeWithVectVelo.Next[i] = &Res_InvCartMeasModeWithVectVelo.Elements[i];
		}
	}
	DateTime_1_cctor();
	MatrixData_20_cctor();
	MatrixMath_cctor();
	Gaussian_9_cctor();
	ExistenceSpace_1_cctor();
	TrackWithMeasurements_1_cctor();
	Tracking_1_cctor();
	CTRAModel_1_cctor();
	TimeSpan_1_cctor();
	VelocityMeasuremenModel_1_cctor();
	YawRateMeasurementModel_1_cctor();
	Gaussian_6_cctor();
	Gaussian_7_cctor();
	Gaussian_8_cctor();
	CAModel_1_cctor();
	TwoPointDistribution_1_cctor();
	MobilEyeMeasuremenModel_1_cctor();
	Gaussian_10_cctor();
	SampleSet_3_cctor();
	MultipLocalNearesNeighb_1_cctor();
	IPDA_3_cctor();
	GaussianMixture_1_cctor();
	CarMeaModWitVecVeloAndAcce_ccto();
	Gaussian_11_cctor();
	SampleSet_4_cctor();
	IPDA_4_cctor();
}

void WriteProfile(void)
{
	#ifndef DISABLE_MEMORY_PROFILING
	FILE *fp;
	fp = fopen("resourceProfile.h","w");
	if (fp == NULL)
	{
		abort();
	}
	(void)fprintf(fp, "#define GC__27941_05_47_820_c1244a649f2\n");
	(void)fprintf(fp, "#define ResourceCount_SafetyFactor 1.1f\n");
	(void)fprintf(fp, "#define RC_int32_t_1D_13 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_int32_t_1D_13.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_27 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_27.MaximumCount);
	(void)fprintf(fp, "#define RC_TrackWithMeasurements ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_TrackWithMeasurements.MaximumCount);
	(void)fprintf(fp, "#define RC_TrackWithMeasurements_1D_15 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_TrackWithMeasurements_1D_15.MaximumCount);
	(void)fprintf(fp, "#define RC_CASpace ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_CASpace.MaximumCount);
	(void)fprintf(fp, "#define RC_int32_t_1D_0 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_int32_t_1D_0.MaximumCount);
	(void)fprintf(fp, "#define RC_int32_t_1D_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_int32_t_1D_1.MaximumCount);
	(void)fprintf(fp, "#define RC_Object ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Object.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_1D_0 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_1D_0.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_1D_5 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_1D_5.MaximumCount);
	(void)fprintf(fp, "#define RC_PositiveDefiniteMatrix_7 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_PositiveDefiniteMatrix_7.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_2 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_2.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_1D_25 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_1D_25.MaximumCount);
	(void)fprintf(fp, "#define RC_LinearAlgebra ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_LinearAlgebra.MaximumCount);
	(void)fprintf(fp, "#define RC_Gaussian_5 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Gaussian_5.MaximumCount);
	(void)fprintf(fp, "#define RC_Existence ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Existence.MaximumCount);
	(void)fprintf(fp, "#define RC_ExistenceSpace ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_ExistenceSpace.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_3 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_3.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_1D_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_1D_1.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListFactory ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListFactory.MaximumCount);
	(void)fprintf(fp, "#define RC_UniformRandomGenerator ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_UniformRandomGenerator.MaximumCount);
	(void)fprintf(fp, "#define RC_Random ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Random.MaximumCount);
	(void)fprintf(fp, "#define RC_int32_t_1D_56 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_int32_t_1D_56.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_15 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_15.MaximumCount);
	(void)fprintf(fp, "#define RC_SampleProbabilityPair_2 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_SampleProbabilityPair_2.MaximumCount);
	(void)fprintf(fp, "#define RC_SampleProbabilityPair_2_1D_2 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_SampleProbabilitPair_2_1D_2.MaximumCount);
	(void)fprintf(fp, "#define RC_Obstacle ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Obstacle.MaximumCount);
	(void)fprintf(fp, "#define RC_Object_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Object_1.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_12 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_12.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_1D_3 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_1D_3.MaximumCount);
	(void)fprintf(fp, "#define RC_RadarSpace_1D_15 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_RadarSpace_1D_15.MaximumCount);
	(void)fprintf(fp, "#define RC_RadarSpace ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_RadarSpace.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_4 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_4.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_4 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_4.MaximumCount);
	(void)fprintf(fp, "#define RC_Obstacle_1D_40 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Obstacle_1D_40.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_6 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_6.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_1D_4 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_1D_4.MaximumCount);
	(void)fprintf(fp, "#define RC_MobilEyeSpace_1D_40 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MobilEyeSpace_1D_40.MaximumCount);
	(void)fprintf(fp, "#define RC_MobilEyeSpace ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MobilEyeSpace.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_5 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_5.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_9 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_9.MaximumCount);
	(void)fprintf(fp, "#define RC_FrontRadarObjectSpace ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_FrontRadarObjectSpace.MaximumCount);
	(void)fprintf(fp, "#define RC_FrontRadarObjectSpace_1D_40 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_FrontRadarObjectSpace_1D_40.MaximumCount);
	(void)fprintf(fp, "#define RC_Measure_2 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Measure_2.MaximumCount);
	(void)fprintf(fp, "#define RC_Measure_3 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Measure_3.MaximumCount);
	(void)fprintf(fp, "#define RC_Tracking ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Tracking.MaximumCount);
	(void)fprintf(fp, "#define RC_SensorProperties ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_SensorProperties.MaximumCount);
	(void)fprintf(fp, "#define RC_FrontRadarNearParameters ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_FrontRadarNearParameters.MaximumCount);
	(void)fprintf(fp, "#define RC_FrontRadarFarParameters ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_FrontRadarFarParameters.MaximumCount);
	(void)fprintf(fp, "#define RC_MobilEyeParameters ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MobilEyeParameters.MaximumCount);
	(void)fprintf(fp, "#define RC_Vector2D_1D_10 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Vector2D_1D_10.MaximumCount);
	(void)fprintf(fp, "#define RC_FrontRadarObjectParameters ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_FrontRadarObjectParameters.MaximumCount);
	(void)fprintf(fp, "#define RC_EgoMotionFilter ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_EgoMotionFilter.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_1D_2 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_1D_2.MaximumCount);
	(void)fprintf(fp, "#define RC_PositiveDefiniteMatrix_4 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_PositiveDefiniteMatrix_4.MaximumCount);
	(void)fprintf(fp, "#define RC_CTRAErrorSpace ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_CTRAErrorSpace.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_8 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_8.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_6 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_6.MaximumCount);
	(void)fprintf(fp, "#define RC_CTRASpace ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_CTRASpace.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_9 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_9.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_1D_6 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_1D_6.MaximumCount);
	(void)fprintf(fp, "#define RC_CTRAModel ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_CTRAModel.MaximumCount);
	(void)fprintf(fp, "#define RC_PositiveDefiniteMatrix ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_PositiveDefiniteMatrix.MaximumCount);
	(void)fprintf(fp, "#define RC_VelocitySpace ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_VelocitySpace.MaximumCount);
	(void)fprintf(fp, "#define RC_VelocityMeasurementModel ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_VelocityMeasurementModel.MaximumCount);
	(void)fprintf(fp, "#define RC_PositiveDefiniteMatrix_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_PositiveDefiniteMatrix_1.MaximumCount);
	(void)fprintf(fp, "#define RC_YawRateSpace ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_YawRateSpace.MaximumCount);
	(void)fprintf(fp, "#define RC_YawRateMeasurementModel ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_YawRateMeasurementModel.MaximumCount);
	(void)fprintf(fp, "#define RC_Gaussian_4 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Gaussian_4.MaximumCount);
	(void)fprintf(fp, "#define RC_PositiveDefiniteMatrix_6 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_PositiveDefiniteMatrix_6.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_1D_36 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_1D_36.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_11 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_11.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListEnumerator_15 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListEnumerator_15.MaximumCount);
	(void)fprintf(fp, "#define RC_SquareMatrix_6 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_SquareMatrix_6.MaximumCount);
	(void)fprintf(fp, "#define RC_Matrix_7 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Matrix_7.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_1D_12 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_1D_12.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_12 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_12.MaximumCount);
	(void)fprintf(fp, "#define RC_Matrix_8 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Matrix_8.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_10 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_10.MaximumCount);
	(void)fprintf(fp, "#define RC_Gaussian ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Gaussian.MaximumCount);
	(void)fprintf(fp, "#define RC_Matrix_9 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Matrix_9.MaximumCount);
	(void)fprintf(fp, "#define RC_Gaussian_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Gaussian_1.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListFactory_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListFactory_1.MaximumCount);
	(void)fprintf(fp, "#define RC_StatIPDATrackColleFactoProvi ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StatIPDATracColleFactoProvi.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListFactory_2 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListFactory_2.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListFactory_3 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListFactory_3.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticAssociatioTableFactory ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticAssociatiTableFactory.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListFactory_4 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListFactory_4.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListFactory_5 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListFactory_5.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_23 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_23.MaximumCount);
	(void)fprintf(fp, "#define RC_Gaussian_5_1D_15 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Gaussian_5_1D_15.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_20 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_20.MaximumCount);
	(void)fprintf(fp, "#define RC_Gaussian_2 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Gaussian_2.MaximumCount);
	(void)fprintf(fp, "#define RC_Gaussian_2_1D_15 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Gaussian_2_1D_15.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_16 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_16.MaximumCount);
	(void)fprintf(fp, "#define RC_Matrix_11 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Matrix_11.MaximumCount);
	(void)fprintf(fp, "#define RC_Matrix_11_1D_15 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Matrix_11_1D_15.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_26 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_26.MaximumCount);
	(void)fprintf(fp, "#define RC_Existence_1D_15 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Existence_1D_15.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_22 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_22.MaximumCount);
	(void)fprintf(fp, "#define RC_MarginalizedEvaluable ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MarginalizedEvaluable.MaximumCount);
	(void)fprintf(fp, "#define RC_MarginalizedEvaluable_1D_15 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MarginalizedEvaluable_1D_15.MaximumCount);
	(void)fprintf(fp, "#define RC_PositiveDefiniteMatrix_2 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_PositiveDefiniteMatrix_2.MaximumCount);
	(void)fprintf(fp, "#define RC_CAErrorSpace ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_CAErrorSpace.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_13 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_13.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_1D_9 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_1D_9.MaximumCount);
	(void)fprintf(fp, "#define RC_CAModel ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_CAModel.MaximumCount);
	(void)fprintf(fp, "#define RC_PersistenceModel ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_PersistenceModel.MaximumCount);
	(void)fprintf(fp, "#define RC_MobilEyeDetectionModel ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MobilEyeDetectionModel.MaximumCount);
	(void)fprintf(fp, "#define RC_EgoMotionCompensation ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_EgoMotionCompensation.MaximumCount);
	(void)fprintf(fp, "#define RC_SquareMatrix_7 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_SquareMatrix_7.MaximumCount);
	(void)fprintf(fp, "#define RC_Matrix_12 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Matrix_12.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_1D_15 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_1D_15.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_14 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_14.MaximumCount);
	(void)fprintf(fp, "#define RC_TwoPointDistribution ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_TwoPointDistribution.MaximumCount);
	(void)fprintf(fp, "#define RC_Type ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Type.MaximumCount);
	(void)fprintf(fp, "#define RC_MobilEyeMeasurementModel ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MobilEyeMeasurementModel.MaximumCount);
	(void)fprintf(fp, "#define RC_PositiveDefiniteMatrix_3 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_PositiveDefiniteMatrix_3.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_15 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_15.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_1D_16 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_1D_16.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_1D_20 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_1D_20.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_16 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_16.MaximumCount);
	(void)fprintf(fp, "#define RC_SquareMatrix_3 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_SquareMatrix_3.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_18 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_18.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_1D_200 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_1D_200.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_7 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_7.MaximumCount);
	(void)fprintf(fp, "#define RC_MobilEyeSpace_1D_50 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MobilEyeSpace_1D_50.MaximumCount);
	(void)fprintf(fp, "#define RC_SampleSet ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_SampleSet.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_13 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_13.MaximumCount);
	(void)fprintf(fp, "#define RC_SampleProbabilityPair ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_SampleProbabilityPair.MaximumCount);
	(void)fprintf(fp, "#define RC_SampleProbabilityPair_1D_50 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_SampleProbabilityPair_1D_50.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListEnumerator_3 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListEnumerator_3.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListEnumerator_8 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListEnumerator_8.MaximumCount);
	(void)fprintf(fp, "#define RC_ProbabilityGate ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_ProbabilityGate.MaximumCount);
	(void)fprintf(fp, "#define RC_SquaredMahalanobisDistance ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_SquaredMahalanobisDistance.MaximumCount);
	(void)fprintf(fp, "#define RC_IMetric ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_IMetric.MaximumCount);
	(void)fprintf(fp, "#define RC_MultipleLocalNearestNeighbor ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MultiplLocalNearestNeighbor.MaximumCount);
	(void)fprintf(fp, "#define RC_IEnumerable ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_IEnumerable.MaximumCount);
	(void)fprintf(fp, "#define RC_IEnumerable_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_IEnumerable_1.MaximumCount);
	(void)fprintf(fp, "#define RC_IEnumerable_2 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_IEnumerable_2.MaximumCount);
	(void)fprintf(fp, "#define RC_IAssociationAlgorithm ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_IAssociationAlgorithm.MaximumCount);
	(void)fprintf(fp, "#define RC_MeasurementAssociation ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MeasurementAssociation.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListEnumerator_12 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListEnumerator_12.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListEnumerator_2 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListEnumerator_2.MaximumCount);
	(void)fprintf(fp, "#define RC_AssociationTable ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_AssociationTable.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_2D_15_40 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_2D_15_40.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListEnumerator_14 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListEnumerator_14.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_7 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_7.MaximumCount);
	(void)fprintf(fp, "#define RC_int32_t_1D_4 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_int32_t_1D_4.MaximumCount);
	(void)fprintf(fp, "#define RC_int32_t_1D_40 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_int32_t_1D_40.MaximumCount);
	(void)fprintf(fp, "#define RC_IAssociationTable ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_IAssociationTable.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_5 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_5.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_1D_15 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_1D_15.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListEnumerator ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListEnumerator.MaximumCount);
	(void)fprintf(fp, "#define RC_IEvaluable ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_IEvaluable.MaximumCount);
	(void)fprintf(fp, "#define RC_IEvaluable_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_IEvaluable_1.MaximumCount);
	(void)fprintf(fp, "#define RC_IEvaluable_2 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_IEvaluable_2.MaximumCount);
	(void)fprintf(fp, "#define RC_IPDA ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_IPDA.MaximumCount);
	(void)fprintf(fp, "#define RC_CardinalitySpace ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_CardinalitySpace.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_1.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_1D_40 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_1D_40.MaximumCount);
	(void)fprintf(fp, "#define RC_MeasurementSetLikelihood ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MeasurementSetLikelihood.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_18 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_18.MaximumCount);
	(void)fprintf(fp, "#define RC_TruePositivesHypothesis ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_TruePositivesHypothesis.MaximumCount);
	(void)fprintf(fp, "#define RC_TruePositivesHypothesi_1D_41 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_TruePositiveHypothesi_1D_41.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_8 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_8.MaximumCount);
	(void)fprintf(fp, "#define RC_MobilEyeSpace_1D_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MobilEyeSpace_1D_1.MaximumCount);
	(void)fprintf(fp, "#define RC_GaussianMixture ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_GaussianMixture.MaximumCount);
	(void)fprintf(fp, "#define RC_IListFactory ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_IListFactory.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_24 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_24.MaximumCount);
	(void)fprintf(fp, "#define RC_Gaussian_5_1D_41 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Gaussian_5_1D_41.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_2 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_2.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_1D_41 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_1D_41.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListEnumerator_10 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListEnumerator_10.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListEnumerator_4 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListEnumerator_4.MaximumCount);
	(void)fprintf(fp, "#define RC_Space ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Space.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_17 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_17.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListEnumerator_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListEnumerator_1.MaximumCount);
	(void)fprintf(fp, "#define RC_InverseMobilEyeMeasuremModel ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_InverseMobilEyeMeasureModel.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_2_1D_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_2_1D_1.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_1D_0 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_1D_0.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_21 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_21.MaximumCount);
	(void)fprintf(fp, "#define RC_Gaussian_3 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Gaussian_3.MaximumCount);
	(void)fprintf(fp, "#define RC_Gaussian_3_1D_15 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Gaussian_3_1D_15.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_17 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_17.MaximumCount);
	(void)fprintf(fp, "#define RC_Matrix_13 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Matrix_13.MaximumCount);
	(void)fprintf(fp, "#define RC_Matrix_13_1D_15 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_Matrix_13_1D_15.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_25 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_25.MaximumCount);
	(void)fprintf(fp, "#define RC_MarginalizedEvaluable_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MarginalizedEvaluable_1.MaximumCount);
	(void)fprintf(fp, "#define RC_MarginalizeEvaluable_1_1D_15 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MarginalizEvaluable_1_1D_15.MaximumCount);
	(void)fprintf(fp, "#define RC_FrontRadarObjectMeasureModel ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_FrontRadarObjectMeasurModel.MaximumCount);
	(void)fprintf(fp, "#define RC_PositiveDefiniteMatrix_5 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_PositiveDefiniteMatrix_5.MaximumCount);
	(void)fprintf(fp, "#define RC_FrontRadarObjectDetectiModel ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_FrontRadarObjectDetectModel.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_3 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_3.MaximumCount);
	(void)fprintf(fp, "#define RC_SquareMatrix_5 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_SquareMatrix_5.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_19 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_19.MaximumCount);
	(void)fprintf(fp, "#define RC_float64_t_1D_250 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_float64_t_1D_250.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_10 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_10.MaximumCount);
	(void)fprintf(fp, "#define RC_FrontRadarObjectSpace_1D_50 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_FrontRadarObjectSpace_1D_50.MaximumCount);
	(void)fprintf(fp, "#define RC_SampleSet_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_SampleSet_1.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_14 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_14.MaximumCount);
	(void)fprintf(fp, "#define RC_SampleProbabilityPair_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_SampleProbabilityPair_1.MaximumCount);
	(void)fprintf(fp, "#define RC_SampleProbabilitPair_1_1D_50 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_SampleProbabiliPair_1_1D_50.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListEnumerator_6 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListEnumerator_6.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListEnumerator_9 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListEnumerator_9.MaximumCount);
	(void)fprintf(fp, "#define RC_ProbabilityGate_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_ProbabilityGate_1.MaximumCount);
	(void)fprintf(fp, "#define RC_SquaredMahalanobisDistance_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_SquaredMahalanobiDistance_1.MaximumCount);
	(void)fprintf(fp, "#define RC_IMetric_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_IMetric_1.MaximumCount);
	(void)fprintf(fp, "#define RC_IEnumerable_3 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_IEnumerable_3.MaximumCount);
	(void)fprintf(fp, "#define RC_IEnumerable_4 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_IEnumerable_4.MaximumCount);
	(void)fprintf(fp, "#define RC_MeasurementAssociation_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MeasurementAssociation_1.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListEnumerator_13 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListEnumerator_13.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListEnumerator_5 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListEnumerator_5.MaximumCount);
	(void)fprintf(fp, "#define RC_MatrixData_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_MatrixData_1.MaximumCount);
	(void)fprintf(fp, "#define RC_int32_t_1D_5 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_int32_t_1D_5.MaximumCount);
	(void)fprintf(fp, "#define RC_IEvaluable_3 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_IEvaluable_3.MaximumCount);
	(void)fprintf(fp, "#define RC_IPDA_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_IPDA_1.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_19 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_19.MaximumCount);
	(void)fprintf(fp, "#define RC_TruePositivesHypothesis_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_TruePositivesHypothesis_1.MaximumCount);
	(void)fprintf(fp, "#define RC_TruePositiveHypothes_1_1D_41 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_TruePositivHypothes_1_1D_41.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticList_11 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticList_11.MaximumCount);
	(void)fprintf(fp, "#define RC_FrontRadarObjectSpace_1D_1 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_FrontRadarObjectSpace_1D_1.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListEnumerator_11 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListEnumerator_11.MaximumCount);
	(void)fprintf(fp, "#define RC_StaticListEnumerator_7 ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_StaticListEnumerator_7.MaximumCount);
	(void)fprintf(fp, "#define RC_InveCartMeasModeWithVectVelo ((int32_t)(%d * ResourceCount_SafetyFactor) + 1)\n", Res_InvCartMeasModeWithVectVelo.MaximumCount);
	(void)fclose(fp);
	#endif /* DISABLE_MEMORY_PROFILING */
}

